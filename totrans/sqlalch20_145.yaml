- en: What’s New in SQLAlchemy 1.0?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_10.html](https://docs.sqlalchemy.org/en/20/changelog/migration_10.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 0.9, undergoing maintenance
    releases as of May, 2014, and SQLAlchemy version 1.0, released in April, 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'Document last updated: June 9, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.0, and also documents
    changes which affect users migrating their applications from the 0.9 series of
    SQLAlchemy to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New Session Bulk INSERT/UPDATE API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new series of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    methods which provide hooks directly into the unit of work’s facility for emitting
    INSERT and UPDATE statements has been created. When used correctly, this expert-oriented
    system can allow ORM-mappings to be used to generate bulk insert and update statements
    batched into executemany groups, allowing the statements to proceed at speeds
    that rival direct use of the Core.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bulk Operations](../orm/persistence_techniques.html#bulk-operations) - introduction
    and full documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
  prefs: []
  type: TYPE_NORMAL
- en: New Performance Example Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inspired by the benchmarking done for the [Bulk Operations](../orm/persistence_techniques.html#bulk-operations)
    feature as well as for the [How can I profile a SQLAlchemy powered application?](../faq/performance.html#faq-how-to-profile)
    section of the FAQ, a new example section has been added which features several
    scripts designed to illustrate the relative performance profile of various Core
    and ORM techniques. The scripts are organized into use cases, and are packaged
    under a single console interface such that any combination of demonstrations can
    be run, dumping out timings, Python profile results and/or RunSnake profile displays.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](../orm/examples.html#examples-performance)'
  prefs: []
  type: TYPE_NORMAL
- en: “Baked” Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The “baked” query feature is an unusual new approach which allows for straightforward
    construction an invocation of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects using caching, which upon successive calls features
    vastly reduced Python function call overhead (over 75%). By specifying a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as a series of lambdas which are only invoked once,
    a query as a pre-compiled unit begins to be feasible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Baked Queries](../orm/extensions/baked.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improvements to declarative mixins, `@declared_attr` and related features'
  prefs: []
  type: TYPE_NORMAL
- en: The declarative system in conjunction with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") has been overhauled to support new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function decorated with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is now called only **after** any mixin-based column
    copies are generated. This means the function can call upon mixin-established
    columns and will receive a reference to the correct [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Above, `SomeClass.foobar_prop` will be invoked against `SomeClass`, and `SomeClass.foobar`
    will be the final [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object that is to be mapped to `SomeClass`, as opposed to the non-copied object
    present directly on `HasFooBar`, even though the columns aren’t mapped yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") function now **memoizes** the value that’s returned
    on a per-class basis, so that repeated calls to the same attribute will return
    the same value. We can alter the example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Previously, `SomeClass` would be mapped with one particular copy of the `foobar`
    column, but the `foobar_prop` by calling upon `foobar` a second time would produce
    a different column. The value of `SomeClass.foobar` is now memoized during declarative
    setup time, so that even before the attribute is mapped by the mapper, the interim
    column value will remain consistent no matter how many times the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is called upon.
  prefs: []
  type: TYPE_NORMAL
- en: The two behaviors above should help considerably with declarative definition
    of many types of mapper properties that derive from other attributes, where the
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    function is called upon from other [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions locally present before the class is
    actually mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a pretty slim edge case where one wishes to build a declarative mixin that
    establishes distinct columns per subclass, a new modifier [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") is added. With this modifier, the decorated
    function will be invoked individually for each class in the mapped inheritance
    hierarchy. While this is already the behavior for special attributes such as `__table_args__`
    and `__mapper_args__`, for columns and other properties the behavior by default
    assumes that attribute is affixed to the base class only, and just inherited from
    subclasses. With [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading"), individual behaviors can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using _orm.declared_attr() to generate table-specific inheriting columns](../orm/declarative_mixins.html#mixin-inheritance-columns)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") class has been reworked so
    that a relationship or other mapper property can be set up inline on the abstract
    base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The above mapping will set up a table `cca` with both an `id` and a `something_id`
    column, and `Concrete` will also have a relationship `something`. The new feature
    is that `Abstract` will also have an independently configured relationship `something`
    that builds against the polymorphic union of the base.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM full object fetches 25% faster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mechanics of the `loading.py` module as well as the identity map have undergone
    several passes of inlining, refactoring, and pruning, so that a raw load of rows
    now populates ORM-based objects around 25% faster. Assuming a 1M row table, a
    script like the following illustrates the type of load that’s improved the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds for
    1.0\. The [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") call is always a good idea when batching huge
    numbers of rows, as it prevents the Python interpreter from having to allocate
    a huge amount of memory for all objects and their instrumentation at once. Without
    the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per"), the above script on the MacBookPro is 31 seconds
    on 0.9 and 26 seconds on 1.0, the extra time spent setting up very large memory
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '### New KeyedTuple implementation dramatically faster'
  prefs: []
  type: TYPE_NORMAL
- en: 'We took a look into the `KeyedTuple` implementation in the hopes of improving
    queries like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KeyedTuple` class is used rather than Python’s `collections.namedtuple()`,
    because the latter has a very complex type-creation routine that benchmarks much
    slower than `KeyedTuple`. However, when fetching hundreds of thousands of rows,
    `collections.namedtuple()` quickly overtakes `KeyedTuple` which becomes dramatically
    slower as instance invocation goes up. What to do? A new type that hedges between
    the approaches of both. Benching all three types for “size” (number of rows returned)
    and “num” (number of distinct queries), the new “lightweight keyed tuple” either
    outperforms both, or lags very slightly behind the faster object, based on which
    scenario. In the “sweet spot”, where we are both creating a good number of new
    types as well as fetching a good number of rows, the lightweight object totally
    smokes both namedtuple and KeyedTuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)  ### Significant Improvements
    in Structural Memory Use'
  prefs: []
  type: TYPE_NORMAL
- en: Structural memory use has been improved via much more significant use of `__slots__`
    for many internal objects. This optimization is particularly geared towards the
    base memory size of large applications that have lots of tables and columns, and
    reduces memory size for a variety of high-volume objects including event listening
    internals, comparator objects and parts of the ORM attribute and loader strategy
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bench that makes use of heapy measure the startup size of Nova illustrates
    a difference of about 3.7 fewer megs, or 46%, taken up by SQLAlchemy’s objects,
    associated dictionaries, as well as weakrefs, within a basic import of “nova.db.sqlalchemy.models”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]  ### UPDATE statements are now batched with executemany() in a flush'
  prefs: []
  type: TYPE_NORMAL
- en: 'UPDATE statements can now be batched within an ORM flush into more performant
    executemany() call, similarly to how INSERT statements can be batched; this will
    be invoked within flush based on the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: two or more UPDATE statements in sequence involve the identical set of columns
    to be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement has no embedded SQL expressions in the SET clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The mapping does not use a `mapper.version_id_col`, or the backend dialect
    supports a “sane” rowcount for an executemany() operation; most DBAPIs support
    this correctly now.  ### Session.get_bind() handles a wider variety of inheritance
    scenarios'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method is invoked whenever a query or unit
    of work flush process seeks to locate the database engine that corresponds to
    a particular class. The method has been improved to handle a variety of inheritance-oriented
    scenarios, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding to a Mixin or Abstract Class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binding to inherited concrete subclasses individually based on table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)  ### Session.get_bind()
    will receive the Mapper in all relevant Query cases'
  prefs: []
  type: TYPE_NORMAL
- en: A series of issues were repaired where the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") would not receive the primary [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), even though this mapper was readily available (the primary
    mapper is the single mapper, or alternatively the first mapper, that is associated
    with a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, when passed to [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind"), is typically used by sessions that make use
    of the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") parameter to associate mappers with a series of engines
    (although in this use case, things frequently “worked” in most cases anyway as
    the bind would be located via the mapped table object), or more specifically implement
    a user-defined [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method that provides some pattern of selecting
    engines based on mappers, such as horizontal sharding or a so-called “routing”
    session that routes queries to different backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'These scenarios include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete"), both for the UPDATE/DELETE statement as well as
    for the SELECT used by the “fetch” strategy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Queries against individual columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SQL functions and other expressions against indirect mappings such as [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)  ### .info dictionary improvements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InspectionAttr.info` collection is now available on every kind of object
    that one would retrieve from the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") collection. This includes [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") and [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy"). However, as these objects
    are class-bound descriptors, they must be accessed **separately** from the class
    to which they are attached in order to get at the attribute. Below this is illustrated
    using the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is also available as a constructor argument for all [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects (e.g. [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") etc.) as well as remaining ORM constructs
    such as [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym "sqlalchemy.orm.synonym").
  prefs: []
  type: TYPE_NORMAL
- en: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)  ### ColumnProperty constructs
    work a lot better with aliases, order_by'
  prefs: []
  type: TYPE_NORMAL
- en: A variety of issues regarding [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") have been fixed, most specifically with regards
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct as well as the “order by label” logic introduced in 0.9 (see [Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple scenario that included “A.b” twice would fail to render correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This would order by the wrong column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'New output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There were also many scenarios where the “order by” logic would fail to order
    by label, for example if the mapping were “polymorphic”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The order_by would fail to use the label, as it would be anonymized due to
    the polymorphic loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the order by label tracks the anonymized label, this now works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Included in these fixes are a variety of heisenbugs that could corrupt the state
    of an `aliased()` construct such that the labeling logic would again fail; these
    have also been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") methods now accept any SQL expression,
    in addition to integer values, as arguments. The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object also passes through any expression to the underlying
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object. Typically this is used to allow a bound parameter to be passed, which
    can be substituted with a value later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Dialects which don’t support non-integer LIMIT or OFFSET expressions may continue
    to not support this behavior; third party dialects may also need modification
    in order to take advantage of the new behavior. A dialect which currently uses
    the `._limit` or `._offset` attributes will continue to function for those cases
    where the limit/offset was specified as a simple integer value. However, when
    a SQL expression is specified, these two attributes will instead raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") on access. A third-party dialect which wishes to
    support the new feature should now call upon the `._limit_clause` and `._offset_clause`
    attributes to receive the full SQL expression, rather than the integer value.  ###
    The `use_alter` flag on `ForeignKeyConstraint` is (usually) no longer needed'
  prefs: []
  type: TYPE_NORMAL
- en: The [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will now make use of a system that
    automatically renders an ALTER statement for foreign key constraints that are
    involved in mutually-dependent cycles between tables, without the need to specify
    [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint"). Additionally, the foreign key constraints
    no longer need to have a name in order to be created via ALTER; only the DROP
    operation requires a name. In the case of a DROP, the feature will ensure that
    only constraints which have explicit names are actually included as ALTER statements.
    In the case of an unresolvable cycle within a DROP, the system emits a succinct
    and clear error message now if the DROP cannot proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") flags remain in place, and continue to have the
    same effect of establishing those constraints for which ALTER is required during
    a CREATE/DROP scenario.
  prefs: []
  type: TYPE_NORMAL
- en: As of version 1.0.1, special logic takes over in the case of SQLite, which does
    not support ALTER, in the case that during a DROP, the given tables have an unresolvable
    cycle; in this case a warning is emitted, and the tables are dropped with **no**
    ordering, which is usually fine on SQLite unless constraints are enabled. To resolve
    the warning and proceed with at least a partial ordering on a SQLite database,
    particularly one where constraints are enabled, re-apply “use_alter” flags to
    those [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which should be explicitly omitted
    from the sort.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - full description of the new behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)  ### ResultProxy “auto
    close” is now a “soft” close'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many releases, the `ResultProxy` object has always been automatically closed
    out at the point at which all result rows have been fetched. This was to allow
    usage of the object without the need to call upon `ResultProxy.close()` explicitly;
    as all DBAPI resources had been freed, the object was safe to discard. However,
    the object maintained a strict “closed” behavior, which meant that any subsequent
    calls to `ResultProxy.fetchone()`, `ResultProxy.fetchmany()` or `ResultProxy.fetchall()`
    would now raise a [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is inconsistent vs. what pep-249 states, which is that you can
    call upon the fetch methods repeatedly even after results are exhausted. It also
    interferes with behavior for some implementations of result proxy, such as the
    `BufferedColumnResultProxy` used by the cx_oracle dialect for certain datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, the “closed” state of the `ResultProxy` has been broken into
    two states; a “soft close” which does the majority of what “close” does, in that
    it releases the DBAPI cursor and in the case of a “close with result” object will
    also release the connection, and a “closed” state which is everything included
    by “soft close” as well as establishing the fetch methods as “closed”. The `ResultProxy.close()`
    method is now never called implicitly, only the `ResultProxy._soft_close()` method
    which is non-public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
  prefs: []
  type: TYPE_NORMAL
- en: CHECK Constraints now support the `%(column_0_name)s` token in naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `%(column_0_name)s` will derive from the first column found in the expression
    of a [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The combination of naming conventions with the constraint produced by a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") such as [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") will also now make use of all CHECK constraint conventions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Naming CHECK Constraints](../core/constraints.html#naming-check-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Naming for Boolean, Enum, and other schema types](../core/constraints.html#naming-schematypes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Constraints referring to unattached Columns can auto-attach to the Table
    when their referred columns are attached'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since at least version 0.8, a [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") has had the ability to “auto-attach” itself to
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    based on being passed table-attached columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to assist with some cases that tend to come up with declarative, this
    same auto-attachment logic can now function even if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are not yet associated with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"); additional events are established such that when those
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are associated, the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is also added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The above feature was a late add as of version 1.0.0b3\. A fix as of version
    1.0.4 for [#3411](https://www.sqlalchemy.org/trac/ticket/3411) ensures that this
    logic does not occur if the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") refers to a mixture of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and string column names; as we do not yet
    have tracking for the addition of names to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Above, the attachment event for column “a” to table “t” will fire off before
    column “b” is attached (as “a” is stated in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor before “b”), and the constraint will fail
    to locate “b” if it were to attempt an attachment. For consistency, if the constraint
    refers to any string names, the autoattach-on-column-attach logic is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original auto-attach logic of course remains in place, if the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") already contains all the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects at the time the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)  ###
    INSERT FROM SELECT now includes Python and SQL-expression defaults'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now includes Python and SQL-expression
    defaults if otherwise unspecified; the limitation where non-server column defaults
    aren’t included in an INSERT FROM SELECT is now lifted and these expressions are
    rendered as constants into the SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature can be disabled using [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select").  ### Column server defaults now
    render literal values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “literal binds” compiler flag is switched on when a [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause"), set up by [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") is present as a SQL expression to be compiled. This
    allows literals embedded in SQL to render correctly, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the literal values `"foo", "bar", "baz"` would render as bound parameters,
    which are useless in DDL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)  ### UniqueConstraint
    is now part of the Table reflection process'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object populated using `autoload=True` will now include [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constructs as well as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") constructs. This logic has a few caveats for PostgreSQL
    and MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  prefs: []
  type: TYPE_NORMAL
- en: New systems to safely emit parameterized warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, there has been a restriction that warning messages could not
    refer to data elements, such that a particular function might emit an infinite
    number of unique warnings. The key place this occurs is in the `Unicode type received
    non-unicode bind param value` warning. Placing the data value in this message
    would mean that the Python `__warningregistry__` for that module, or in some cases
    the Python-global `warnings.onceregistry`, would grow unbounded, as in most warning
    scenarios, one of these two collections is populated with every distinct warning
    message.
  prefs: []
  type: TYPE_NORMAL
- en: The change here is that by using a special `string` type that purposely changes
    how the string is hashed, we can control that a large number of parameterized
    messages are hashed only on a small set of possible hash values, such that a warning
    such as `Unicode type received non-unicode bind param value` can be tailored to
    be emitted only a specific number of times; beyond that, the Python warnings registry
    will begin recording them as duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the following test script will show only ten warnings being
    emitted for ten of the parameter sets, out of a total of 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the warning here is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### query.update() now resolves string names into mapped attribute names'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") states that the given `values` dictionary is “a
    dictionary with attributes names as keys”, implying that these are mapped attribute
    names. Unfortunately, the function was designed more in mind to receive attributes
    and SQL expressions and not as much strings; when strings were passed, these strings
    would be passed through straight to the core update statement without any resolution
    as far as how these names are represented on the mapped class, meaning the name
    would have to match that of a table column exactly, not how an attribute of that
    name was mapped onto the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string names are now resolved as attribute names in earnest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the column `user_name` is mapped as `name`. Previously, a call to [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") that was passed strings would have to have been
    called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The given string is now resolved against the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It is typically preferable to use the attribute directly, to avoid any ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The change also indicates that synonyms and hybrid attributes can be referred
    to by string name as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)  ### Warnings emitted
    when comparing objects with None values to relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'This change is new as of 1.0.1\. Some users are performing queries that are
    essentially of this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is not currently supported in SQLAlchemy. For all versions, it
    emits SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note above, there is a comparison `WHERE ? = address.user_id` where the bound
    value `?` is receiving `None`, or `NULL` in SQL. **This will always return False
    in SQL**. The comparison here would in theory generate SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'But right now, **it does not**. Applications which are relying upon the fact
    that “NULL = NULL” produces False in all cases run the risk that someday, SQLAlchemy
    might fix this issue to generate “IS NULL”, and the queries will then produce
    different results. Therefore with this kind of operation, you will see a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that this pattern was broken in most cases for release 1.0.0 including
    all of the betas; a value like `SYMBOL('NEVER_SET')` would be generated. This
    issue has been fixed, but as a result of identifying this pattern, the warning
    is now there so that we can more safely repair this broken behavior (now captured
    in [#3373](https://www.sqlalchemy.org/trac/ticket/3373)) in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)  ### A “negated contains
    or equals” relationship comparison will use the current value of attributes, not
    the database value'
  prefs: []
  type: TYPE_NORMAL
- en: This change is new as of 1.0.1; while we would have preferred for this to be
    in 1.0.0, it only became apparent as a result of [#3371](https://www.sqlalchemy.org/trac/ticket/3371).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Given `A`, with primary key of 7, but which we changed to be 10 without flushing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A query against a many-to-one relationship with this object as the target will
    use the value 10 in the bound parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before this change, the negation of this criteria would **not** use
    10, it would use 7, unless the object were flushed first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces (in 0.9 and all versions prior to 1.0.1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For a transient object, it would produce a broken query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This inconsistency has been repaired, and in all queries the current attribute
    value, in this example `10`, will now be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)  ### Changes to attribute
    events and other operations regarding attributes that have no pre-existing value'
  prefs: []
  type: TYPE_NORMAL
- en: In this change, the default return value of `None` when accessing an object
    is now returned dynamically on each access, rather than implicitly setting the
    attribute’s state with a special “set” operation when it is first accessed. The
    visible result of this change is that `obj.__dict__` is not implicitly modified
    on get, and there are also some minor behavioral changes for [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") and related functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an object with no state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It has always been SQLAlchemy’s behavior such that if we access a scalar or
    many-to-one attribute that was never set, it is returned as `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This value of `None` is in fact now part of the state of `obj`, and is not
    unlike as though we had set the attribute explicitly, e.g. `obj.someattr = None`.
    However, the “set on get” here would behave differently as far as history and
    events. It would not emit any attribute event, and additionally if we view history,
    we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, it’s as though the attribute were always `None` and were never changed.
    This is explicitly different from if we had set the attribute first instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The above means that the behavior of our “set” operation can be corrupted by
    the fact that the value was accessed via “get” earlier. In 1.0, this inconsistency
    has been resolved, by no longer actually setting anything when the default “getter”
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The reason the above behavior hasn’t had much impact is because the INSERT statement
    in relational databases considers a missing value to be the same as NULL in most
    cases. Whether SQLAlchemy received a history event for a particular attribute
    set to None or not would usually not matter; as the difference between sending
    None/NULL or not wouldn’t have an impact. However, as [#3060](https://www.sqlalchemy.org/trac/ticket/3060)
    (described here in [Priority of attribute changes on relationship-bound attributes
    vs. FK-bound may appear to change](#migration-3060)) illustrates, there are some
    seldom edge cases where we do in fact want to positively have `None` set. Also,
    allowing the attribute event here means it’s now possible to create “default value”
    functions for ORM mapped attributes.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this change, the generation of the implicit “None” is now disabled
    for other situations where this used to occur; this includes when an attribute
    set operation on a many-to-one is received; previously, the “old” value would
    be “None” if it had been not set otherwise; it now will send the value `NEVER_SET`,
    which is a value that may be sent to an attribute listener now. This symbol may
    also be received when calling on mapper utility functions such as [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance"); if the primary key attributes
    have no setting at all, whereas the value would be `None` before, it will now
    be the `NEVER_SET` symbol, and no change to the object’s state occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)  ### Priority of attribute
    changes on relationship-bound attributes vs. FK-bound may appear to change'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side effect of [#3060](https://www.sqlalchemy.org/trac/ticket/3060), setting
    a relationship-bound attribute to `None` is now a tracked history event which
    refers to the intention of persisting `None` to that attribute. As it has always
    been the case that setting a relationship-bound attribute will trump direct assignment
    to the foreign key attributes, a change in behavior can be seen here when assigning
    None. Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the relationship-bound attribute takes precedence over the FK-bound
    attribute in all cases, whether or not the value we assign is a reference to an
    `A` object or is `None`. In 0.9, the behavior is inconsistent and only takes effect
    if a value is assigned; the None is not considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)  ### session.expunge()
    will fully detach an object that’s been deleted'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") had a bug that caused an inconsistency in behavior
    regarding deleted objects. The [`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") function as well as the [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") attribute would still report object as
    belonging to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    subsequent to the expunge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is normal for `u1 not in sess` to be True while `inspect(u1).session`
    still refers to the session, while the transaction is ongoing subsequent to the
    delete operation and [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") has not been called; the full detachment normally
    completes once the transaction is committed. This issue would also impact functions
    that rely on [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") such as [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)  ### Joined/Subquery eager
    loading explicitly disallowed with yield_per'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") method easier to use, an exception is raised
    if any subquery eager loaders, or joined eager loaders that would use collections,
    are to take effect when yield_per is used, as these are currently not compatible
    with yield-per (subquery loading could be in theory, however). When this error
    is raised, the [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option can be sent with an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'or use [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option has the advantage that additional many-to-one
    joined loader options can still be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]  ### Changes and fixes in handling of duplicate join targets'
  prefs: []
  type: TYPE_NORMAL
- en: Changes here encompass bugs where an unexpected and inconsistent behavior would
    occur in some scenarios when joining to an entity twice, or to multiple single-table
    entities against the same table, without using a relationship-based ON clause,
    as well as when joining multiple times to the same target relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A query that joins to `A.bs` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The query deduplicates the redundant `A.bs` because it is attempting to support
    a case like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the `A.bs` is part of a “path”. As part of [#3367](https://www.sqlalchemy.org/trac/ticket/3367),
    arriving at the same endpoint twice without it being part of a larger path will
    now emit a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The bigger change involves when joining to an entity without using a relationship-bound
    path. If we join to `B` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.9, this would render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is problematic since the aliasing is implicit and in the case of different
    ON clauses can lead to unpredictable results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1.0, no automatic aliasing is applied and we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This will raise an error from the database. While it might be nice if the “duplicate
    join target” acted identically if we joined both from redundant relationships
    vs. redundant non-relationship based targets, for now we are only changing the
    behavior in the more serious case where implicit aliasing would have occurred
    previously, and only emitting a warning in the relationship case. Ultimately,
    joining to the same thing twice without any aliasing to disambiguate should raise
    an error in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change also has an impact on single-table inheritance targets. Using a
    mapping as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The two queries at the bottom are equivalent, and should both render the identical
    SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The above SQL is invalid, as it renders “a” within the FROM list twice. However,
    the implicit aliasing bug would occur with the second query only and render this
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the second join to “a” is aliased. While this seems convenient,
    it’s not how single-inheritance queries work in general and is misleading and
    inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The net effect is that applications which were relying on this bug will now
    have an error raised by the database. The solution is to use the expected form.
    When referring to multiple subclasses of a single-inheritance entity in a query,
    you must manually use aliases to disambiguate the table, as all the subclasses
    normally refer to the same table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
  prefs: []
  type: TYPE_NORMAL
- en: Deferred Columns No Longer Implicitly Undefer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mapped attributes marked as deferred without explicit undeferral will now remain
    “deferred” even if their column is otherwise present in the result set in some
    way. This is a performance enhancement in that an ORM load no longer spends time
    searching for each deferred column when the result set is obtained. However, for
    an application that has been relying upon this, an explicit [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or similar option should now be used, in order to prevent
    a SELECT from being emitted when the attribute is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '### Deprecated ORM Event Hooks Removed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following ORM event hooks, some of which have been deprecated since 0.5,
    have been removed: `translate_row`, `populate_instance`, `append_result`, `create_instance`.
    The use cases for these hooks originated in the very early 0.1 / 0.2 series of
    SQLAlchemy and have long since been unnecessary. In particular, the hooks were
    largely unusable as the behavioral contracts within these events was strongly
    linked to the surrounding internals, such as how an instance needs to be created
    and initialized as well as how columns are located within an ORM-generated row.
    The removal of these hooks greatly simplifies the mechanics of ORM object loading.  ###
    API Change for new Bundle feature when custom row loaders are used'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    object of 0.9 has a small change in API, when the `create_row_processor()` method
    is overridden on a custom class. Previously, the sample code looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The unused `result` member is now removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)  ###
    Right inner join nesting now the default for joinedload with innerjoin=True'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") as well as [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") is now to use “nested” inner joins, that is, right-nested,
    as the default behavior when an inner join joined eager load is chained to an
    outer join eager load. In order to get the old behavior of chaining all joined
    eager loads as outer join when an outer join is present, use `innerjoin="unnested"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As introduced in [Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    from version 0.9, the behavior of `innerjoin="nested"` is that an inner join eager
    load chained to an outer join eager load will use a right-nested join. `"nested"`
    is now implied when using `innerjoin=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new default, this will render the FROM clause in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: That is, using a right-nested join for the INNER join so that the full result
    of `users` can be returned. The use of an INNER join is more efficient than using
    an OUTER join, and allows the [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") optimization parameter to take effect in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the older behavior, use `innerjoin="unnested"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This will avoid right-nested joins and chain the joins together using all OUTER
    joins despite the innerjoin directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As noted in the 0.9 notes, the only database backend that has difficulty with
    right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-nested join
    into a subquery as a join target on SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    - description of the feature as introduced in 0.9.4.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)  ### Subqueries no longer
    applied to uselist=False joined eager loads'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a joined eager load like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy considers the relationship `A.b` to be a “one to many, loaded as
    a single value”, which is essentially a “one to one” relationship. However, joined
    eager loading has always treated the above as a situation where the main query
    needs to be inside a subquery, as would normally be needed for a collection of
    B objects where the main query has a LIMIT applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since the relationship of the inner query to the outer one is that
    at most only one row is shared in the case of `uselist=False` (in the same way
    as a many-to-one), the “subquery” used with LIMIT + joined eager loading is now
    dropped in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the case that the LEFT OUTER JOIN returns more than one row, the ORM has
    always emitted a warning here and ignored additional results for `uselist=False`,
    so the results in that error situation should not change.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
  prefs: []
  type: TYPE_NORMAL
- en: query.update() / query.delete() raises if used with join(), select_from(), from_self()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9, 2015)
    when the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods are invoked against a query which has also
    called upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), [`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin"), [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") or `Query.from_self()`. These are unsupported
    use cases which silently fail in the 0.9 series up until 0.9.10 where it emits
    a warning. In 1.0, these cases raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
  prefs: []
  type: TYPE_NORMAL
- en: query.update() with `synchronize_session='evaluate'` raises on multi-table update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “evaluator” for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") won’t work with multi-table updates, and needs
    to be set to `synchronize_session=False` or `synchronize_session='fetch'` when
    multiple tables are present. The new behavior is that an explicit exception is
    now raised, with a message to change the synchronize setting. This is upgraded
    from a warning emitted as of 0.9.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
  prefs: []
  type: TYPE_NORMAL
- en: Resurrect Event has been Removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “resurrect” ORM event has been removed entirely. This event ceased to have
    any function since version 0.8 removed the older “mutable” system from the unit
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: '### Change to single-table-inheritance criteria when using from_self(), count()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a single-table inheritance mapping, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Query.from_self()` or [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") against a subclass would produce a subquery, but
    then add the “WHERE” criteria for subtypes to the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue with this is that if the inner query does not specify all columns,
    then we can’t add the WHERE clause on the outside (it actually tries, and produces
    a bad query). This decision apparently goes way back to 0.6.5 with the note “may
    need to make more adjustments to this”. Well, those adjustments have arrived!
    So now the above query will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'So that queries that don’t include “type” will still work!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)  ### single-table-inheritance
    criteria added to all ON clauses unconditionally'
  prefs: []
  type: TYPE_NORMAL
- en: 'When joining to a single-table inheritance subclass target, the ORM always
    adds the “single table criteria” when joining on a relationship. Given a mapping
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s been the behavior for quite some time that a JOIN on the relationship
    will render a “single inheritance” clause for the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Above, because we joined to a subclass `FooWidget`, [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") knew to add the `AND widget.type IN ('foo')` criteria
    to the ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change here is that the `AND widget.type IN()` criteria is now appended
    to *any* ON clause, not just those generated from a relationship, including one
    that is explicitly stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the “implicit” join when no ON clause of any kind is stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the ON clause for these would not include the single-inheritance
    criteria. Applications that are already adding this criteria to work around this
    will want to remove its explicit use, though it should continue to work fine if
    the criteria happens to be rendered twice in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Changes and fixes in handling of duplicate join targets](#bug-3233)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Warnings emitted when coercing full SQL fragments into text()'
  prefs: []
  type: TYPE_NORMAL
- en: Since SQLAlchemy’s inception, there has always been an emphasis on not getting
    in the way of the usage of plain text. The Core and ORM expression systems were
    intended to allow any number of points at which the user can just use plain text
    SQL expressions, not just in the sense that you can send a full SQL string to
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), but that you can send strings with SQL
    expressions into many functions, such as [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where"), [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that by “SQL expressions” we mean a **full fragment of a SQL string**,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'and we are **not talking about string arguments**, that is, the normal behavior
    of passing string values that become parameterized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The Core tutorial has long featured an example of the use of this technique,
    using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct where virtually all components of
    it are specified as straight strings. However, despite this long-standing behavior
    and example, users are apparently surprised that this behavior exists, and when
    asking around the community, I was unable to find any user that was in fact *not*
    surprised that you can send a full string into a method like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter").
  prefs: []
  type: TYPE_NORMAL
- en: 'So the change here is to encourage the user to qualify textual strings when
    composing SQL that is partially or fully composed from textual fragments. When
    composing a select as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement is built up normally, with all the same coercions as before.
    However, one will see the following warnings emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'These warnings attempt to show exactly where the issue is by displaying the
    parameters as well as where the string was received. The warnings make use of
    the [Session.get_bind() handles a wider variety of inheritance scenarios](#feature-3178)
    so that parameterized warnings can be emitted safely without running out of memory,
    and as always, if one wishes the warnings to be exceptions, the [Python Warnings
    Filter](https://docs.python.org/2/library/warnings.html) should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the above warnings, our statement works just fine, but to get rid of
    the warnings we would rewrite our statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'and as the warnings suggest, we can give our statement more specificity about
    the text if we use [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") and [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Where note also that [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") and [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") can now be imported from “sqlalchemy” without
    the “sql” part.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior here applies to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") as well as to key methods on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") and [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having").
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY and GROUP BY are special cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The output does what we say, but again it warns us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)  ### Python-side defaults
    invoked for each row individually when using a multivalued insert'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Python-side column defaults when using the multi-valued version
    of [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") were essentially not implemented, and
    would only work “by accident” in specific situations, when the dialect in use
    was using a non-positional (e.g. named) style of bound parameter, and when it
    was not necessary that a Python-side callable be invoked for each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature has been overhauled so that it works more similarly to that of
    an “executemany” style of invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example will invoke `next(counter)` for each row individually as
    would be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, a positional dialect would fail as a bind would not be generated
    for additional positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And with a “named” dialect, the same value for “id” would be re-used in each
    row (hence this change is backwards-incompatible with a system that relied on
    this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The system will also refuse to invoke a “server side” default as inline-rendered
    SQL, since it cannot be guaranteed that a server side default is compatible with
    this. If the VALUES clause renders for a specific column, then a Python-side value
    is required; if an omitted value only refers to a server-side default, an exception
    is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'will raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the value “d1” would be copied into that of the third row (but
    again, only with named format!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)  ### Event listeners can
    not be added or removed from within that event’s runner'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of an event listener from inside that same event itself would modify
    the elements of a list during iteration, which would cause still-attached event
    listeners to silently fail to fire. To prevent this while still maintaining performance,
    the lists have been replaced with `collections.deque()`, which does not allow
    any additions or removals during iteration, and instead raises `RuntimeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)  ### The INSERT…FROM SELECT
    construct now implies `inline=True`'
  prefs: []
  type: TYPE_NORMAL
- en: Using [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now implies `inline=True` on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"). This helps to fix a bug where an INSERT…FROM
    SELECT construct would inadvertently be compiled as “implicit returning” on supporting
    backends, which would cause breakage in the case of an INSERT that inserts zero
    rows (as implicit returning expects a row), as well as arbitrary return data in
    the case of an INSERT that inserts multiple rows (e.g. only the first row of many).
    A similar change is also applied to an INSERT..VALUES with multiple parameter
    sets; implicit RETURNING will no longer emit for this statement either. As both
    of these constructs deal with variable numbers of rows, the `ResultProxy.inserted_primary_key`
    accessor does not apply. Previously, there was a documentation note that one may
    prefer `inline=True` with INSERT..FROM SELECT as some databases don’t support
    returning and therefore can’t do “implicit” returning, but there’s no reason an
    INSERT…FROM SELECT needs implicit returning in any case. Regular explicit [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") should be used to return variable
    numbers of result rows if inserted data is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)  ### `autoload_with` now
    implies `autoload=True`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can be set up for reflection by passing [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)  ### DBAPI exception wrapping
    and handle_error() event improvements'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s wrapping of DBAPI exceptions was not taking place in the case where
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object was invalidated, and then tried to reconnect and encountered an error;
    this has been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the recently added `ConnectionEvents.handle_error()` event is
    now invoked for errors that occur upon initial connect, upon reconnect, and when
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    is used given a custom connection function via [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") object has a new datamember [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") that will always refer to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in use, in those cases when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object is not available (e.g. on initial connect).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)  ### ForeignKeyConstraint.columns
    is now a ColumnCollection'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") was previously a plain list
    containing either strings or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, depending on how the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") was constructed and whether it was associated
    with a table. The collection is now a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), and is only initialized after the
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). A new accessor [`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys") is added to unconditionally
    return string keys for the local set of columns regardless of how the object was
    constructed or its current state.  ### MetaData.sorted_tables accessor is “deterministic”'
  prefs: []
  type: TYPE_NORMAL
- en: The sorting of tables resulting from the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor is “deterministic”; the ordering
    should be the same in all cases regardless of Python hashing. This is done by
    first sorting the tables by name before passing them to the topological algorithm,
    which maintains that ordering as it iterates.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change does **not** yet apply to the ordering applied when emitting
    [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)  ### null(), false() and
    true() constants are no longer singletons'
  prefs: []
  type: TYPE_NORMAL
- en: 'These three constants were changed to return a “singleton” value in 0.9; unfortunately,
    that would lead to a query like the following to not render as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: rendering only `SELECT NULL AS anon_1`, because the two [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constructs would come out as the same `NULL`
    object, and SQLAlchemy’s Core model is based on object identity in order to determine
    lexical significance. The change in 0.9 had no importance other than the desire
    to save on object overhead; in general, an unnamed construct needs to stay lexically
    unique so that it gets labeled uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)  ### SQLite/Oracle have
    distinct methods for temporary table/view name reporting'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") methods in the case of
    SQLite/Oracle would also return the names of temporary tables and views, which
    is not provided by any other dialect (in the case of MySQL at least it is not
    even possible). This logic has been moved out to two new methods [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") and [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names").
  prefs: []
  type: TYPE_NORMAL
- en: Note that reflection of a specific named temporary table or temporary view,
    either by `Table('name', autoload=True)` or via methods like [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") continues to function for
    most if not all dialects. For SQLite specifically, there is a bug fix for UNIQUE
    constraint reflection from temp tables as well, which is [#3203](https://www.sqlalchemy.org/trac/ticket/3203).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Overhaul of ENUM type create/drop rules'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") have been made more strict with regards
    to creating and dropping of the TYPE.
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **without** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will be created *and* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This means that if a second table also has an enum named ‘myenum’, the above
    DROP operation will now fail. In order to accommodate the use case of a common
    shared enumerated type, the behavior of a metadata-associated enumeration has
    been enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **with** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will *not* be created *or* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"),
    with the exception of [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") called with the `checkfirst=True` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
  prefs: []
  type: TYPE_NORMAL
- en: New PostgreSQL Table options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS, and
    INHERITS, when rendering DDL via the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Table Options](../dialects/postgresql.html#postgresql-table-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New get_enums() method with PostgreSQL Dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    method returns a [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") object in the case of PostgreSQL,
    which includes a new [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") method that returns
    information on all available `ENUM` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")  ### PostgreSQL Dialect
    reflects Materialized Views, Foreign Tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the `Table` construct with `autoload=True` will now match a name that exists
    in the database as a materialized view or foreign table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") will return plain and
    materialized view names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") does **not** change
    for PostgreSQL, it continues to return only the names of plain tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new method [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") is
    added which will return the names of tables that are specifically marked as “foreign”
    in the PostgreSQL schema tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change to reflection involves adding `'m'` and `'f'` to the list of qualifiers
    we use when querying `pg_class.relkind`, but this change is new in 1.0.0 to avoid
    any backwards-incompatible surprises for those running 0.9 in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)  ### PostgreSQL `has_table()`
    now works for temporary tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple fix such that “has table” for temporary tables now works,
    so that code like the following may proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The very unlikely case that this behavior will cause a non-failing application
    to behave differently, is because PostgreSQL allows a non-temporary table to silently
    overwrite a temporary table. So code like the following will now act completely
    differently, no longer creating the real table following the temporary table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)  ### PostgreSQL FILTER
    keyword'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard FILTER keyword for aggregate functions is now supported by
    PostgreSQL as of 9.4\. SQLAlchemy allows this using [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
  prefs: []
  type: TYPE_NORMAL
- en: PG8000 dialect supports client side encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") parameter is now honored by the pg8000 dialect, using
    on connect handler which emits `SET CLIENT_ENCODING` matching the selected encoding.
  prefs: []
  type: TYPE_NORMAL
- en: PG8000 native JSONB support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for PG8000 versions greater than 1.10.1 has been added, where JSONB
    is supported natively.
  prefs: []
  type: TYPE_NORMAL
- en: Support for psycopg2cffi Dialect on PyPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for the pypy psycopg2cffi dialect is added.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### MySQL TIMESTAMP Type now renders NULL / NOT NULL in all cases'
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL dialect has always worked around MySQL’s implicit NOT NULL default
    associated with TIMESTAMP columns by emitting NULL for such a type, if the column
    is set up with `nullable=True`. However, MySQL 5.6.6 and above features a new
    flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which repairs MySQL’s non-standard behavior to make it behave like any other type;
    to accommodate this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all
    TIMESTAMP columns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)  ### MySQL SET Type Overhauled
    to support empty sets, unicode, blank value handling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    type historically not included a system of handling blank sets and empty values
    separately; as different drivers had different behaviors for treatment of empty
    strings and empty-string-set representations, the SET type tried only to hedge
    between these behaviors, opting to treat the empty set as `set([''])` as is still
    the current behavior for the MySQL-Connector-Python DBAPI. Part of the rationale
    here was that it was otherwise impossible to actually store a blank string within
    a MySQL SET, as the driver gives us back strings with no way to discern between
    `set([''])` and `set()`. It was left to the user to determine if `set([''])` actually
    meant “empty set” or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new behavior moves the use case for the blank string, which is an unusual
    case that isn’t even documented in MySQL’s documentation, into a special case,
    and the default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") is now:'
  prefs: []
  type: TYPE_NORMAL
- en: to treat the empty string `''` as returned by MySQL-python into the empty set
    `set()`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to convert the single-blank value set `set([''])` returned by MySQL-Connector-Python
    into the empty set `set()`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle the case of a set type that actually wishes includes the blank value
    `''` in its list of possible values, a new feature (required in this use case)
    is implemented whereby the set value is persisted and loaded as a bitwise integer
    value; the flag [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") is added in order to enable this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag allows the set to be persisted and retrieved
    with no ambiguity of values. Theoretically this flag can be turned on in all cases,
    as long as the given list of values to the type matches the ordering exactly as
    declared in the database; it only makes the SQL echo output a bit more unusual.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") otherwise remains the same, roundtripping values
    using strings. The string-based behavior now supports unicode fully including
    MySQL-python with use_unicode=0.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL internal “no such table” exceptions not passed to event handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MySQL dialect will now disable `ConnectionEvents.handle_error()` events
    from firing for those statements which it uses internally to detect if a table
    exists or not. This is achieved using an execution option `skip_user_error_events`
    that disables the handle error event for the scope of that execution. In this
    way, user code that rewrites exceptions doesn’t need to worry about the MySQL
    dialect or other dialects that occasionally need to catch SQLAlchemy specific
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Changed the default value of `raise_on_warnings` for MySQL-Connector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changed the default value of “raise_on_warnings” to False for MySQL-Connector.
    This was set at True for some reason. The “buffered” flag unfortunately must stay
    at True as MySQLconnector does not allow a cursor to be closed unless all results
    are fully fetched.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
  prefs: []
  type: TYPE_NORMAL
- en: '### MySQL boolean symbols “true”, “false” work again'
  prefs: []
  type: TYPE_NORMAL
- en: 0.9’s overhaul of the IS/IS NOT operators as well as boolean types in [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    disallowed the MySQL dialect from making use of the “true” and “false” symbols
    in the context of “IS” / “IS NOT”. Apparently, even though MySQL has no “boolean”
    type, it supports IS / IS NOT when the special “true” and “false” symbols are
    used, even though these are otherwise synonymous with “1” and “0” (and IS/IS NOT
    don’t work with the numerics).
  prefs: []
  type: TYPE_NORMAL
- en: So the change here is that the MySQL dialect remains “non native boolean”, but
    the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    symbols again produce the keywords “true” and “false”, so that an expression like
    `column.is_(true())` again works on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)  ### The match() operator
    now returns an agnostic MatchType compatible with MySQL’s floating point return
    value'
  prefs: []
  type: TYPE_NORMAL
- en: The return type of a [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") expression is now a new type
    called [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType").
    This is a subclass of [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), that can be intercepted by the dialect in order to
    produce a different result type at SQL execution time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code like the following will now function correctly and return floating points
    on MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)  ### Drizzle Dialect is
    now an External Dialect'
  prefs: []
  type: TYPE_NORMAL
- en: The dialect for [Drizzle](https://www.drizzle.org/) is now an external dialect,
    available at [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle).
    This dialect was added to SQLAlchemy right before SQLAlchemy was able to accommodate
    third party dialects well; going forward, all databases that aren’t within the
    “ubiquitous use” category are third party dialects. The dialect’s implementation
    hasn’t changed and is still based on the MySQL + MySQLdb dialects within SQLAlchemy.
    The dialect is as of yet unreleased and in “attic” status; however it passes the
    majority of tests and is generally in decent working order, if someone wants to
    pick up on polishing it.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect and
    reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both with
    and without names. Previously, foreign key names were ignored and unnamed unique
    constraints were skipped. In particular this will help with Alembic’s new SQLite
    migration features.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, for both foreign keys and unique constraints, the result of
    PRAGMA foreign_keys, index_list, and index_info is combined with regular expression
    parsing of the CREATE TABLE statement overall to form a complete picture of the
    names of constraints, as well as differentiating UNIQUE constraints that were
    created as UNIQUE vs. unnamed INDEXes.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### PyODBC driver name is required with hostname-based SQL Server connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. with
    an explicit hostname, now requires a driver name - SQLAlchemy will no longer attempt
    to guess a default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy’s previously hardcoded default of “SQL Server” is obsolete on Windows,
    and SQLAlchemy cannot be tasked with guessing the best driver based on operation
    system/driver detection. Using a DSN is always preferred when using ODBC to avoid
    this issue entirely.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, VARBINARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rendering of the [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") types has been changed for SQL Server 2012 and
    greater, with options to control the behavior completely, based on deprecation
    guidelines from Microsoft. See [Large Text/Binary Type Deprecation](../dialects/mssql.html#mssql-large-type-deprecation)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Improved support for CTEs in Oracle'
  prefs: []
  type: TYPE_NORMAL
- en: 'CTE support has been fixed up for Oracle, and there is also a new feature `CTE.with_suffixes()`
    that can assist with Oracle’s special directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
  prefs: []
  type: TYPE_NORMAL
- en: New Oracle Keywords for DDL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keywords such as COMPRESS, ON COMMIT, BITMAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Table Options](../dialects/oracle.html#oracle-table-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Specific Index Options](../dialects/oracle.html#oracle-index-options)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.0, and also documents
    changes which affect users migrating their applications from the 0.9 series of
    SQLAlchemy to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New Session Bulk INSERT/UPDATE API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new series of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    methods which provide hooks directly into the unit of work’s facility for emitting
    INSERT and UPDATE statements has been created. When used correctly, this expert-oriented
    system can allow ORM-mappings to be used to generate bulk insert and update statements
    batched into executemany groups, allowing the statements to proceed at speeds
    that rival direct use of the Core.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bulk Operations](../orm/persistence_techniques.html#bulk-operations) - introduction
    and full documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
  prefs: []
  type: TYPE_NORMAL
- en: New Performance Example Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inspired by the benchmarking done for the [Bulk Operations](../orm/persistence_techniques.html#bulk-operations)
    feature as well as for the [How can I profile a SQLAlchemy powered application?](../faq/performance.html#faq-how-to-profile)
    section of the FAQ, a new example section has been added which features several
    scripts designed to illustrate the relative performance profile of various Core
    and ORM techniques. The scripts are organized into use cases, and are packaged
    under a single console interface such that any combination of demonstrations can
    be run, dumping out timings, Python profile results and/or RunSnake profile displays.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](../orm/examples.html#examples-performance)'
  prefs: []
  type: TYPE_NORMAL
- en: “Baked” Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The “baked” query feature is an unusual new approach which allows for straightforward
    construction an invocation of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects using caching, which upon successive calls features
    vastly reduced Python function call overhead (over 75%). By specifying a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as a series of lambdas which are only invoked once,
    a query as a pre-compiled unit begins to be feasible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Baked Queries](../orm/extensions/baked.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improvements to declarative mixins, `@declared_attr` and related features'
  prefs: []
  type: TYPE_NORMAL
- en: The declarative system in conjunction with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") has been overhauled to support new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function decorated with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is now called only **after** any mixin-based column
    copies are generated. This means the function can call upon mixin-established
    columns and will receive a reference to the correct [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Above, `SomeClass.foobar_prop` will be invoked against `SomeClass`, and `SomeClass.foobar`
    will be the final [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object that is to be mapped to `SomeClass`, as opposed to the non-copied object
    present directly on `HasFooBar`, even though the columns aren’t mapped yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") function now **memoizes** the value that’s returned
    on a per-class basis, so that repeated calls to the same attribute will return
    the same value. We can alter the example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Previously, `SomeClass` would be mapped with one particular copy of the `foobar`
    column, but the `foobar_prop` by calling upon `foobar` a second time would produce
    a different column. The value of `SomeClass.foobar` is now memoized during declarative
    setup time, so that even before the attribute is mapped by the mapper, the interim
    column value will remain consistent no matter how many times the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is called upon.
  prefs: []
  type: TYPE_NORMAL
- en: The two behaviors above should help considerably with declarative definition
    of many types of mapper properties that derive from other attributes, where the
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    function is called upon from other [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions locally present before the class is
    actually mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a pretty slim edge case where one wishes to build a declarative mixin that
    establishes distinct columns per subclass, a new modifier [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") is added. With this modifier, the decorated
    function will be invoked individually for each class in the mapped inheritance
    hierarchy. While this is already the behavior for special attributes such as `__table_args__`
    and `__mapper_args__`, for columns and other properties the behavior by default
    assumes that attribute is affixed to the base class only, and just inherited from
    subclasses. With [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading"), individual behaviors can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using _orm.declared_attr() to generate table-specific inheriting columns](../orm/declarative_mixins.html#mixin-inheritance-columns)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") class has been reworked so
    that a relationship or other mapper property can be set up inline on the abstract
    base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The above mapping will set up a table `cca` with both an `id` and a `something_id`
    column, and `Concrete` will also have a relationship `something`. The new feature
    is that `Abstract` will also have an independently configured relationship `something`
    that builds against the polymorphic union of the base.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM full object fetches 25% faster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mechanics of the `loading.py` module as well as the identity map have undergone
    several passes of inlining, refactoring, and pruning, so that a raw load of rows
    now populates ORM-based objects around 25% faster. Assuming a 1M row table, a
    script like the following illustrates the type of load that’s improved the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds for
    1.0\. The [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") call is always a good idea when batching huge
    numbers of rows, as it prevents the Python interpreter from having to allocate
    a huge amount of memory for all objects and their instrumentation at once. Without
    the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per"), the above script on the MacBookPro is 31 seconds
    on 0.9 and 26 seconds on 1.0, the extra time spent setting up very large memory
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '### New KeyedTuple implementation dramatically faster'
  prefs: []
  type: TYPE_NORMAL
- en: 'We took a look into the `KeyedTuple` implementation in the hopes of improving
    queries like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KeyedTuple` class is used rather than Python’s `collections.namedtuple()`,
    because the latter has a very complex type-creation routine that benchmarks much
    slower than `KeyedTuple`. However, when fetching hundreds of thousands of rows,
    `collections.namedtuple()` quickly overtakes `KeyedTuple` which becomes dramatically
    slower as instance invocation goes up. What to do? A new type that hedges between
    the approaches of both. Benching all three types for “size” (number of rows returned)
    and “num” (number of distinct queries), the new “lightweight keyed tuple” either
    outperforms both, or lags very slightly behind the faster object, based on which
    scenario. In the “sweet spot”, where we are both creating a good number of new
    types as well as fetching a good number of rows, the lightweight object totally
    smokes both namedtuple and KeyedTuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)  ### Significant Improvements
    in Structural Memory Use'
  prefs: []
  type: TYPE_NORMAL
- en: Structural memory use has been improved via much more significant use of `__slots__`
    for many internal objects. This optimization is particularly geared towards the
    base memory size of large applications that have lots of tables and columns, and
    reduces memory size for a variety of high-volume objects including event listening
    internals, comparator objects and parts of the ORM attribute and loader strategy
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bench that makes use of heapy measure the startup size of Nova illustrates
    a difference of about 3.7 fewer megs, or 46%, taken up by SQLAlchemy’s objects,
    associated dictionaries, as well as weakrefs, within a basic import of “nova.db.sqlalchemy.models”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]  ### UPDATE statements are now batched with executemany() in a flush'
  prefs: []
  type: TYPE_NORMAL
- en: 'UPDATE statements can now be batched within an ORM flush into more performant
    executemany() call, similarly to how INSERT statements can be batched; this will
    be invoked within flush based on the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: two or more UPDATE statements in sequence involve the identical set of columns
    to be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement has no embedded SQL expressions in the SET clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The mapping does not use a `mapper.version_id_col`, or the backend dialect
    supports a “sane” rowcount for an executemany() operation; most DBAPIs support
    this correctly now.  ### Session.get_bind() handles a wider variety of inheritance
    scenarios'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method is invoked whenever a query or unit
    of work flush process seeks to locate the database engine that corresponds to
    a particular class. The method has been improved to handle a variety of inheritance-oriented
    scenarios, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding to a Mixin or Abstract Class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binding to inherited concrete subclasses individually based on table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)  ### Session.get_bind()
    will receive the Mapper in all relevant Query cases'
  prefs: []
  type: TYPE_NORMAL
- en: A series of issues were repaired where the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") would not receive the primary [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), even though this mapper was readily available (the primary
    mapper is the single mapper, or alternatively the first mapper, that is associated
    with a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, when passed to [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind"), is typically used by sessions that make use
    of the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") parameter to associate mappers with a series of engines
    (although in this use case, things frequently “worked” in most cases anyway as
    the bind would be located via the mapped table object), or more specifically implement
    a user-defined [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method that provides some pattern of selecting
    engines based on mappers, such as horizontal sharding or a so-called “routing”
    session that routes queries to different backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'These scenarios include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete"), both for the UPDATE/DELETE statement as well as
    for the SELECT used by the “fetch” strategy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Queries against individual columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SQL functions and other expressions against indirect mappings such as [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)  ### .info dictionary improvements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InspectionAttr.info` collection is now available on every kind of object
    that one would retrieve from the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") collection. This includes [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") and [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy"). However, as these objects
    are class-bound descriptors, they must be accessed **separately** from the class
    to which they are attached in order to get at the attribute. Below this is illustrated
    using the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: It is also available as a constructor argument for all [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects (e.g. [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") etc.) as well as remaining ORM constructs
    such as [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym "sqlalchemy.orm.synonym").
  prefs: []
  type: TYPE_NORMAL
- en: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)  ### ColumnProperty constructs
    work a lot better with aliases, order_by'
  prefs: []
  type: TYPE_NORMAL
- en: A variety of issues regarding [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") have been fixed, most specifically with regards
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct as well as the “order by label” logic introduced in 0.9 (see [Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple scenario that included “A.b” twice would fail to render correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'This would order by the wrong column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'New output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'There were also many scenarios where the “order by” logic would fail to order
    by label, for example if the mapping were “polymorphic”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The order_by would fail to use the label, as it would be anonymized due to
    the polymorphic loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the order by label tracks the anonymized label, this now works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Included in these fixes are a variety of heisenbugs that could corrupt the state
    of an `aliased()` construct such that the labeling logic would again fail; these
    have also been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
  prefs: []
  type: TYPE_NORMAL
- en: New Session Bulk INSERT/UPDATE API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new series of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    methods which provide hooks directly into the unit of work’s facility for emitting
    INSERT and UPDATE statements has been created. When used correctly, this expert-oriented
    system can allow ORM-mappings to be used to generate bulk insert and update statements
    batched into executemany groups, allowing the statements to proceed at speeds
    that rival direct use of the Core.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Bulk Operations](../orm/persistence_techniques.html#bulk-operations) - introduction
    and full documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
  prefs: []
  type: TYPE_NORMAL
- en: New Performance Example Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inspired by the benchmarking done for the [Bulk Operations](../orm/persistence_techniques.html#bulk-operations)
    feature as well as for the [How can I profile a SQLAlchemy powered application?](../faq/performance.html#faq-how-to-profile)
    section of the FAQ, a new example section has been added which features several
    scripts designed to illustrate the relative performance profile of various Core
    and ORM techniques. The scripts are organized into use cases, and are packaged
    under a single console interface such that any combination of demonstrations can
    be run, dumping out timings, Python profile results and/or RunSnake profile displays.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](../orm/examples.html#examples-performance)'
  prefs: []
  type: TYPE_NORMAL
- en: “Baked” Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The “baked” query feature is an unusual new approach which allows for straightforward
    construction an invocation of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects using caching, which upon successive calls features
    vastly reduced Python function call overhead (over 75%). By specifying a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as a series of lambdas which are only invoked once,
    a query as a pre-compiled unit begins to be feasible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Baked Queries](../orm/extensions/baked.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improvements to declarative mixins, `@declared_attr` and related features'
  prefs: []
  type: TYPE_NORMAL
- en: The declarative system in conjunction with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") has been overhauled to support new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function decorated with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is now called only **after** any mixin-based column
    copies are generated. This means the function can call upon mixin-established
    columns and will receive a reference to the correct [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Above, `SomeClass.foobar_prop` will be invoked against `SomeClass`, and `SomeClass.foobar`
    will be the final [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object that is to be mapped to `SomeClass`, as opposed to the non-copied object
    present directly on `HasFooBar`, even though the columns aren’t mapped yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") function now **memoizes** the value that’s returned
    on a per-class basis, so that repeated calls to the same attribute will return
    the same value. We can alter the example to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Previously, `SomeClass` would be mapped with one particular copy of the `foobar`
    column, but the `foobar_prop` by calling upon `foobar` a second time would produce
    a different column. The value of `SomeClass.foobar` is now memoized during declarative
    setup time, so that even before the attribute is mapped by the mapper, the interim
    column value will remain consistent no matter how many times the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is called upon.
  prefs: []
  type: TYPE_NORMAL
- en: The two behaviors above should help considerably with declarative definition
    of many types of mapper properties that derive from other attributes, where the
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    function is called upon from other [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions locally present before the class is
    actually mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a pretty slim edge case where one wishes to build a declarative mixin that
    establishes distinct columns per subclass, a new modifier [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") is added. With this modifier, the decorated
    function will be invoked individually for each class in the mapped inheritance
    hierarchy. While this is already the behavior for special attributes such as `__table_args__`
    and `__mapper_args__`, for columns and other properties the behavior by default
    assumes that attribute is affixed to the base class only, and just inherited from
    subclasses. With [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading"), individual behaviors can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using _orm.declared_attr() to generate table-specific inheriting columns](../orm/declarative_mixins.html#mixin-inheritance-columns)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") class has been reworked so
    that a relationship or other mapper property can be set up inline on the abstract
    base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The above mapping will set up a table `cca` with both an `id` and a `something_id`
    column, and `Concrete` will also have a relationship `something`. The new feature
    is that `Abstract` will also have an independently configured relationship `something`
    that builds against the polymorphic union of the base.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM full object fetches 25% faster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mechanics of the `loading.py` module as well as the identity map have undergone
    several passes of inlining, refactoring, and pruning, so that a raw load of rows
    now populates ORM-based objects around 25% faster. Assuming a 1M row table, a
    script like the following illustrates the type of load that’s improved the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds for
    1.0\. The [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") call is always a good idea when batching huge
    numbers of rows, as it prevents the Python interpreter from having to allocate
    a huge amount of memory for all objects and their instrumentation at once. Without
    the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per"), the above script on the MacBookPro is 31 seconds
    on 0.9 and 26 seconds on 1.0, the extra time spent setting up very large memory
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '### New KeyedTuple implementation dramatically faster'
  prefs: []
  type: TYPE_NORMAL
- en: 'We took a look into the `KeyedTuple` implementation in the hopes of improving
    queries like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The `KeyedTuple` class is used rather than Python’s `collections.namedtuple()`,
    because the latter has a very complex type-creation routine that benchmarks much
    slower than `KeyedTuple`. However, when fetching hundreds of thousands of rows,
    `collections.namedtuple()` quickly overtakes `KeyedTuple` which becomes dramatically
    slower as instance invocation goes up. What to do? A new type that hedges between
    the approaches of both. Benching all three types for “size” (number of rows returned)
    and “num” (number of distinct queries), the new “lightweight keyed tuple” either
    outperforms both, or lags very slightly behind the faster object, based on which
    scenario. In the “sweet spot”, where we are both creating a good number of new
    types as well as fetching a good number of rows, the lightweight object totally
    smokes both namedtuple and KeyedTuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Significant Improvements in Structural Memory Use'
  prefs: []
  type: TYPE_NORMAL
- en: Structural memory use has been improved via much more significant use of `__slots__`
    for many internal objects. This optimization is particularly geared towards the
    base memory size of large applications that have lots of tables and columns, and
    reduces memory size for a variety of high-volume objects including event listening
    internals, comparator objects and parts of the ORM attribute and loader strategy
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bench that makes use of heapy measure the startup size of Nova illustrates
    a difference of about 3.7 fewer megs, or 46%, taken up by SQLAlchemy’s objects,
    associated dictionaries, as well as weakrefs, within a basic import of “nova.db.sqlalchemy.models”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '### UPDATE statements are now batched with executemany() in a flush'
  prefs: []
  type: TYPE_NORMAL
- en: 'UPDATE statements can now be batched within an ORM flush into more performant
    executemany() call, similarly to how INSERT statements can be batched; this will
    be invoked within flush based on the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: two or more UPDATE statements in sequence involve the identical set of columns
    to be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement has no embedded SQL expressions in the SET clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mapping does not use a `mapper.version_id_col`, or the backend dialect supports
    a “sane” rowcount for an executemany() operation; most DBAPIs support this correctly
    now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Session.get_bind() handles a wider variety of inheritance scenarios'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method is invoked whenever a query or unit
    of work flush process seeks to locate the database engine that corresponds to
    a particular class. The method has been improved to handle a variety of inheritance-oriented
    scenarios, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding to a Mixin or Abstract Class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binding to inherited concrete subclasses individually based on table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Session.get_bind() will receive the Mapper in all relevant Query cases'
  prefs: []
  type: TYPE_NORMAL
- en: A series of issues were repaired where the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") would not receive the primary [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), even though this mapper was readily available (the primary
    mapper is the single mapper, or alternatively the first mapper, that is associated
    with a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, when passed to [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind"), is typically used by sessions that make use
    of the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") parameter to associate mappers with a series of engines
    (although in this use case, things frequently “worked” in most cases anyway as
    the bind would be located via the mapped table object), or more specifically implement
    a user-defined [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method that provides some pattern of selecting
    engines based on mappers, such as horizontal sharding or a so-called “routing”
    session that routes queries to different backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'These scenarios include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete"), both for the UPDATE/DELETE statement as well as
    for the SELECT used by the “fetch” strategy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Queries against individual columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SQL functions and other expressions against indirect mappings such as [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)'
  prefs: []
  type: TYPE_NORMAL
- en: '### .info dictionary improvements'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InspectionAttr.info` collection is now available on every kind of object
    that one would retrieve from the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") collection. This includes [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") and [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy"). However, as these objects
    are class-bound descriptors, they must be accessed **separately** from the class
    to which they are attached in order to get at the attribute. Below this is illustrated
    using the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: It is also available as a constructor argument for all [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects (e.g. [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") etc.) as well as remaining ORM constructs
    such as [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym "sqlalchemy.orm.synonym").
  prefs: []
  type: TYPE_NORMAL
- en: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ColumnProperty constructs work a lot better with aliases, order_by'
  prefs: []
  type: TYPE_NORMAL
- en: A variety of issues regarding [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") have been fixed, most specifically with regards
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct as well as the “order by label” logic introduced in 0.9 (see [Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple scenario that included “A.b” twice would fail to render correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'This would order by the wrong column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'New output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'There were also many scenarios where the “order by” logic would fail to order
    by label, for example if the mapping were “polymorphic”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'The order_by would fail to use the label, as it would be anonymized due to
    the polymorphic loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the order by label tracks the anonymized label, this now works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Included in these fixes are a variety of heisenbugs that could corrupt the state
    of an `aliased()` construct such that the labeling logic would again fail; these
    have also been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") methods now accept any SQL expression,
    in addition to integer values, as arguments. The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object also passes through any expression to the underlying
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object. Typically this is used to allow a bound parameter to be passed, which
    can be substituted with a value later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Dialects which don’t support non-integer LIMIT or OFFSET expressions may continue
    to not support this behavior; third party dialects may also need modification
    in order to take advantage of the new behavior. A dialect which currently uses
    the `._limit` or `._offset` attributes will continue to function for those cases
    where the limit/offset was specified as a simple integer value. However, when
    a SQL expression is specified, these two attributes will instead raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") on access. A third-party dialect which wishes to
    support the new feature should now call upon the `._limit_clause` and `._offset_clause`
    attributes to receive the full SQL expression, rather than the integer value.  ###
    The `use_alter` flag on `ForeignKeyConstraint` is (usually) no longer needed'
  prefs: []
  type: TYPE_NORMAL
- en: The [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will now make use of a system that
    automatically renders an ALTER statement for foreign key constraints that are
    involved in mutually-dependent cycles between tables, without the need to specify
    [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint"). Additionally, the foreign key constraints
    no longer need to have a name in order to be created via ALTER; only the DROP
    operation requires a name. In the case of a DROP, the feature will ensure that
    only constraints which have explicit names are actually included as ALTER statements.
    In the case of an unresolvable cycle within a DROP, the system emits a succinct
    and clear error message now if the DROP cannot proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") flags remain in place, and continue to have the
    same effect of establishing those constraints for which ALTER is required during
    a CREATE/DROP scenario.
  prefs: []
  type: TYPE_NORMAL
- en: As of version 1.0.1, special logic takes over in the case of SQLite, which does
    not support ALTER, in the case that during a DROP, the given tables have an unresolvable
    cycle; in this case a warning is emitted, and the tables are dropped with **no**
    ordering, which is usually fine on SQLite unless constraints are enabled. To resolve
    the warning and proceed with at least a partial ordering on a SQLite database,
    particularly one where constraints are enabled, re-apply “use_alter” flags to
    those [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which should be explicitly omitted
    from the sort.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - full description of the new behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)  ### ResultProxy “auto
    close” is now a “soft” close'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many releases, the `ResultProxy` object has always been automatically closed
    out at the point at which all result rows have been fetched. This was to allow
    usage of the object without the need to call upon `ResultProxy.close()` explicitly;
    as all DBAPI resources had been freed, the object was safe to discard. However,
    the object maintained a strict “closed” behavior, which meant that any subsequent
    calls to `ResultProxy.fetchone()`, `ResultProxy.fetchmany()` or `ResultProxy.fetchall()`
    would now raise a [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is inconsistent vs. what pep-249 states, which is that you can
    call upon the fetch methods repeatedly even after results are exhausted. It also
    interferes with behavior for some implementations of result proxy, such as the
    `BufferedColumnResultProxy` used by the cx_oracle dialect for certain datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, the “closed” state of the `ResultProxy` has been broken into
    two states; a “soft close” which does the majority of what “close” does, in that
    it releases the DBAPI cursor and in the case of a “close with result” object will
    also release the connection, and a “closed” state which is everything included
    by “soft close” as well as establishing the fetch methods as “closed”. The `ResultProxy.close()`
    method is now never called implicitly, only the `ResultProxy._soft_close()` method
    which is non-public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
  prefs: []
  type: TYPE_NORMAL
- en: CHECK Constraints now support the `%(column_0_name)s` token in naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `%(column_0_name)s` will derive from the first column found in the expression
    of a [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The combination of naming conventions with the constraint produced by a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") such as [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") will also now make use of all CHECK constraint conventions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Naming CHECK Constraints](../core/constraints.html#naming-check-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Naming for Boolean, Enum, and other schema types](../core/constraints.html#naming-schematypes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Constraints referring to unattached Columns can auto-attach to the Table
    when their referred columns are attached'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since at least version 0.8, a [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") has had the ability to “auto-attach” itself to
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    based on being passed table-attached columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to assist with some cases that tend to come up with declarative, this
    same auto-attachment logic can now function even if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are not yet associated with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"); additional events are established such that when those
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are associated, the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is also added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The above feature was a late add as of version 1.0.0b3\. A fix as of version
    1.0.4 for [#3411](https://www.sqlalchemy.org/trac/ticket/3411) ensures that this
    logic does not occur if the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") refers to a mixture of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and string column names; as we do not yet
    have tracking for the addition of names to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Above, the attachment event for column “a” to table “t” will fire off before
    column “b” is attached (as “a” is stated in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor before “b”), and the constraint will fail
    to locate “b” if it were to attempt an attachment. For consistency, if the constraint
    refers to any string names, the autoattach-on-column-attach logic is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original auto-attach logic of course remains in place, if the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") already contains all the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects at the time the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)  ###
    INSERT FROM SELECT now includes Python and SQL-expression defaults'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now includes Python and SQL-expression
    defaults if otherwise unspecified; the limitation where non-server column defaults
    aren’t included in an INSERT FROM SELECT is now lifted and these expressions are
    rendered as constants into the SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature can be disabled using [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select").  ### Column server defaults now
    render literal values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “literal binds” compiler flag is switched on when a [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause"), set up by [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") is present as a SQL expression to be compiled. This
    allows literals embedded in SQL to render correctly, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Now renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the literal values `"foo", "bar", "baz"` would render as bound parameters,
    which are useless in DDL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)  ### UniqueConstraint
    is now part of the Table reflection process'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object populated using `autoload=True` will now include [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constructs as well as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") constructs. This logic has a few caveats for PostgreSQL
    and MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  prefs: []
  type: TYPE_NORMAL
- en: New systems to safely emit parameterized warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, there has been a restriction that warning messages could not
    refer to data elements, such that a particular function might emit an infinite
    number of unique warnings. The key place this occurs is in the `Unicode type received
    non-unicode bind param value` warning. Placing the data value in this message
    would mean that the Python `__warningregistry__` for that module, or in some cases
    the Python-global `warnings.onceregistry`, would grow unbounded, as in most warning
    scenarios, one of these two collections is populated with every distinct warning
    message.
  prefs: []
  type: TYPE_NORMAL
- en: The change here is that by using a special `string` type that purposely changes
    how the string is hashed, we can control that a large number of parameterized
    messages are hashed only on a small set of possible hash values, such that a warning
    such as `Unicode type received non-unicode bind param value` can be tailored to
    be emitted only a specific number of times; beyond that, the Python warnings registry
    will begin recording them as duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the following test script will show only ten warnings being
    emitted for ten of the parameter sets, out of a total of 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the warning here is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") methods now accept any SQL expression,
    in addition to integer values, as arguments. The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object also passes through any expression to the underlying
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object. Typically this is used to allow a bound parameter to be passed, which
    can be substituted with a value later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Dialects which don’t support non-integer LIMIT or OFFSET expressions may continue
    to not support this behavior; third party dialects may also need modification
    in order to take advantage of the new behavior. A dialect which currently uses
    the `._limit` or `._offset` attributes will continue to function for those cases
    where the limit/offset was specified as a simple integer value. However, when
    a SQL expression is specified, these two attributes will instead raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") on access. A third-party dialect which wishes to
    support the new feature should now call upon the `._limit_clause` and `._offset_clause`
    attributes to receive the full SQL expression, rather than the integer value.
  prefs: []
  type: TYPE_NORMAL
- en: '### The `use_alter` flag on `ForeignKeyConstraint` is (usually) no longer needed'
  prefs: []
  type: TYPE_NORMAL
- en: The [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will now make use of a system that
    automatically renders an ALTER statement for foreign key constraints that are
    involved in mutually-dependent cycles between tables, without the need to specify
    [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint"). Additionally, the foreign key constraints
    no longer need to have a name in order to be created via ALTER; only the DROP
    operation requires a name. In the case of a DROP, the feature will ensure that
    only constraints which have explicit names are actually included as ALTER statements.
    In the case of an unresolvable cycle within a DROP, the system emits a succinct
    and clear error message now if the DROP cannot proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") flags remain in place, and continue to have the
    same effect of establishing those constraints for which ALTER is required during
    a CREATE/DROP scenario.
  prefs: []
  type: TYPE_NORMAL
- en: As of version 1.0.1, special logic takes over in the case of SQLite, which does
    not support ALTER, in the case that during a DROP, the given tables have an unresolvable
    cycle; in this case a warning is emitted, and the tables are dropped with **no**
    ordering, which is usually fine on SQLite unless constraints are enabled. To resolve
    the warning and proceed with at least a partial ordering on a SQLite database,
    particularly one where constraints are enabled, re-apply “use_alter” flags to
    those [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which should be explicitly omitted
    from the sort.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - full description of the new behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ResultProxy “auto close” is now a “soft” close'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many releases, the `ResultProxy` object has always been automatically closed
    out at the point at which all result rows have been fetched. This was to allow
    usage of the object without the need to call upon `ResultProxy.close()` explicitly;
    as all DBAPI resources had been freed, the object was safe to discard. However,
    the object maintained a strict “closed” behavior, which meant that any subsequent
    calls to `ResultProxy.fetchone()`, `ResultProxy.fetchmany()` or `ResultProxy.fetchall()`
    would now raise a [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is inconsistent vs. what pep-249 states, which is that you can
    call upon the fetch methods repeatedly even after results are exhausted. It also
    interferes with behavior for some implementations of result proxy, such as the
    `BufferedColumnResultProxy` used by the cx_oracle dialect for certain datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, the “closed” state of the `ResultProxy` has been broken into
    two states; a “soft close” which does the majority of what “close” does, in that
    it releases the DBAPI cursor and in the case of a “close with result” object will
    also release the connection, and a “closed” state which is everything included
    by “soft close” as well as establishing the fetch methods as “closed”. The `ResultProxy.close()`
    method is now never called implicitly, only the `ResultProxy._soft_close()` method
    which is non-public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
  prefs: []
  type: TYPE_NORMAL
- en: CHECK Constraints now support the `%(column_0_name)s` token in naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `%(column_0_name)s` will derive from the first column found in the expression
    of a [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: The combination of naming conventions with the constraint produced by a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") such as [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") will also now make use of all CHECK constraint conventions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Naming CHECK Constraints](../core/constraints.html#naming-check-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Naming for Boolean, Enum, and other schema types](../core/constraints.html#naming-schematypes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Constraints referring to unattached Columns can auto-attach to the Table
    when their referred columns are attached'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since at least version 0.8, a [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") has had the ability to “auto-attach” itself to
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    based on being passed table-attached columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to assist with some cases that tend to come up with declarative, this
    same auto-attachment logic can now function even if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are not yet associated with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"); additional events are established such that when those
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are associated, the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is also added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The above feature was a late add as of version 1.0.0b3\. A fix as of version
    1.0.4 for [#3411](https://www.sqlalchemy.org/trac/ticket/3411) ensures that this
    logic does not occur if the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") refers to a mixture of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and string column names; as we do not yet
    have tracking for the addition of names to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Above, the attachment event for column “a” to table “t” will fire off before
    column “b” is attached (as “a” is stated in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor before “b”), and the constraint will fail
    to locate “b” if it were to attempt an attachment. For consistency, if the constraint
    refers to any string names, the autoattach-on-column-attach logic is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original auto-attach logic of course remains in place, if the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") already contains all the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects at the time the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)'
  prefs: []
  type: TYPE_NORMAL
- en: '### INSERT FROM SELECT now includes Python and SQL-expression defaults'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now includes Python and SQL-expression
    defaults if otherwise unspecified; the limitation where non-server column defaults
    aren’t included in an INSERT FROM SELECT is now lifted and these expressions are
    rendered as constants into the SELECT statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The feature can be disabled using [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select").
  prefs: []
  type: TYPE_NORMAL
- en: '### Column server defaults now render literal values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “literal binds” compiler flag is switched on when a [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause"), set up by [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") is present as a SQL expression to be compiled. This
    allows literals embedded in SQL to render correctly, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Now renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the literal values `"foo", "bar", "baz"` would render as bound parameters,
    which are useless in DDL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)'
  prefs: []
  type: TYPE_NORMAL
- en: '### UniqueConstraint is now part of the Table reflection process'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object populated using `autoload=True` will now include [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constructs as well as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") constructs. This logic has a few caveats for PostgreSQL
    and MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  prefs: []
  type: TYPE_NORMAL
- en: New systems to safely emit parameterized warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, there has been a restriction that warning messages could not
    refer to data elements, such that a particular function might emit an infinite
    number of unique warnings. The key place this occurs is in the `Unicode type received
    non-unicode bind param value` warning. Placing the data value in this message
    would mean that the Python `__warningregistry__` for that module, or in some cases
    the Python-global `warnings.onceregistry`, would grow unbounded, as in most warning
    scenarios, one of these two collections is populated with every distinct warning
    message.
  prefs: []
  type: TYPE_NORMAL
- en: The change here is that by using a special `string` type that purposely changes
    how the string is hashed, we can control that a large number of parameterized
    messages are hashed only on a small set of possible hash values, such that a warning
    such as `Unicode type received non-unicode bind param value` can be tailored to
    be emitted only a specific number of times; beyond that, the Python warnings registry
    will begin recording them as duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the following test script will show only ten warnings being
    emitted for ten of the parameter sets, out of a total of 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the warning here is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### query.update() now resolves string names into mapped attribute names'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") states that the given `values` dictionary is “a
    dictionary with attributes names as keys”, implying that these are mapped attribute
    names. Unfortunately, the function was designed more in mind to receive attributes
    and SQL expressions and not as much strings; when strings were passed, these strings
    would be passed through straight to the core update statement without any resolution
    as far as how these names are represented on the mapped class, meaning the name
    would have to match that of a table column exactly, not how an attribute of that
    name was mapped onto the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string names are now resolved as attribute names in earnest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the column `user_name` is mapped as `name`. Previously, a call to [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") that was passed strings would have to have been
    called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The given string is now resolved against the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'It is typically preferable to use the attribute directly, to avoid any ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The change also indicates that synonyms and hybrid attributes can be referred
    to by string name as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)  ### Warnings emitted
    when comparing objects with None values to relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'This change is new as of 1.0.1\. Some users are performing queries that are
    essentially of this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is not currently supported in SQLAlchemy. For all versions, it
    emits SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Note above, there is a comparison `WHERE ? = address.user_id` where the bound
    value `?` is receiving `None`, or `NULL` in SQL. **This will always return False
    in SQL**. The comparison here would in theory generate SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'But right now, **it does not**. Applications which are relying upon the fact
    that “NULL = NULL” produces False in all cases run the risk that someday, SQLAlchemy
    might fix this issue to generate “IS NULL”, and the queries will then produce
    different results. Therefore with this kind of operation, you will see a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Note that this pattern was broken in most cases for release 1.0.0 including
    all of the betas; a value like `SYMBOL('NEVER_SET')` would be generated. This
    issue has been fixed, but as a result of identifying this pattern, the warning
    is now there so that we can more safely repair this broken behavior (now captured
    in [#3373](https://www.sqlalchemy.org/trac/ticket/3373)) in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)  ### A “negated contains
    or equals” relationship comparison will use the current value of attributes, not
    the database value'
  prefs: []
  type: TYPE_NORMAL
- en: This change is new as of 1.0.1; while we would have preferred for this to be
    in 1.0.0, it only became apparent as a result of [#3371](https://www.sqlalchemy.org/trac/ticket/3371).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Given `A`, with primary key of 7, but which we changed to be 10 without flushing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'A query against a many-to-one relationship with this object as the target will
    use the value 10 in the bound parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before this change, the negation of this criteria would **not** use
    10, it would use 7, unless the object were flushed first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces (in 0.9 and all versions prior to 1.0.1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'For a transient object, it would produce a broken query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: This inconsistency has been repaired, and in all queries the current attribute
    value, in this example `10`, will now be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)  ### Changes to attribute
    events and other operations regarding attributes that have no pre-existing value'
  prefs: []
  type: TYPE_NORMAL
- en: In this change, the default return value of `None` when accessing an object
    is now returned dynamically on each access, rather than implicitly setting the
    attribute’s state with a special “set” operation when it is first accessed. The
    visible result of this change is that `obj.__dict__` is not implicitly modified
    on get, and there are also some minor behavioral changes for [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") and related functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an object with no state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'It has always been SQLAlchemy’s behavior such that if we access a scalar or
    many-to-one attribute that was never set, it is returned as `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'This value of `None` is in fact now part of the state of `obj`, and is not
    unlike as though we had set the attribute explicitly, e.g. `obj.someattr = None`.
    However, the “set on get” here would behave differently as far as history and
    events. It would not emit any attribute event, and additionally if we view history,
    we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, it’s as though the attribute were always `None` and were never changed.
    This is explicitly different from if we had set the attribute first instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The above means that the behavior of our “set” operation can be corrupted by
    the fact that the value was accessed via “get” earlier. In 1.0, this inconsistency
    has been resolved, by no longer actually setting anything when the default “getter”
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: The reason the above behavior hasn’t had much impact is because the INSERT statement
    in relational databases considers a missing value to be the same as NULL in most
    cases. Whether SQLAlchemy received a history event for a particular attribute
    set to None or not would usually not matter; as the difference between sending
    None/NULL or not wouldn’t have an impact. However, as [#3060](https://www.sqlalchemy.org/trac/ticket/3060)
    (described here in [Priority of attribute changes on relationship-bound attributes
    vs. FK-bound may appear to change](#migration-3060)) illustrates, there are some
    seldom edge cases where we do in fact want to positively have `None` set. Also,
    allowing the attribute event here means it’s now possible to create “default value”
    functions for ORM mapped attributes.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this change, the generation of the implicit “None” is now disabled
    for other situations where this used to occur; this includes when an attribute
    set operation on a many-to-one is received; previously, the “old” value would
    be “None” if it had been not set otherwise; it now will send the value `NEVER_SET`,
    which is a value that may be sent to an attribute listener now. This symbol may
    also be received when calling on mapper utility functions such as [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance"); if the primary key attributes
    have no setting at all, whereas the value would be `None` before, it will now
    be the `NEVER_SET` symbol, and no change to the object’s state occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)  ### Priority of attribute
    changes on relationship-bound attributes vs. FK-bound may appear to change'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side effect of [#3060](https://www.sqlalchemy.org/trac/ticket/3060), setting
    a relationship-bound attribute to `None` is now a tracked history event which
    refers to the intention of persisting `None` to that attribute. As it has always
    been the case that setting a relationship-bound attribute will trump direct assignment
    to the foreign key attributes, a change in behavior can be seen here when assigning
    None. Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the relationship-bound attribute takes precedence over the FK-bound
    attribute in all cases, whether or not the value we assign is a reference to an
    `A` object or is `None`. In 0.9, the behavior is inconsistent and only takes effect
    if a value is assigned; the None is not considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)  ### session.expunge()
    will fully detach an object that’s been deleted'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") had a bug that caused an inconsistency in behavior
    regarding deleted objects. The [`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") function as well as the [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") attribute would still report object as
    belonging to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    subsequent to the expunge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is normal for `u1 not in sess` to be True while `inspect(u1).session`
    still refers to the session, while the transaction is ongoing subsequent to the
    delete operation and [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") has not been called; the full detachment normally
    completes once the transaction is committed. This issue would also impact functions
    that rely on [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") such as [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)  ### Joined/Subquery eager
    loading explicitly disallowed with yield_per'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") method easier to use, an exception is raised
    if any subquery eager loaders, or joined eager loaders that would use collections,
    are to take effect when yield_per is used, as these are currently not compatible
    with yield-per (subquery loading could be in theory, however). When this error
    is raised, the [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option can be sent with an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'or use [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option has the advantage that additional many-to-one
    joined loader options can still be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]  ### Changes and fixes in handling of duplicate join targets'
  prefs: []
  type: TYPE_NORMAL
- en: Changes here encompass bugs where an unexpected and inconsistent behavior would
    occur in some scenarios when joining to an entity twice, or to multiple single-table
    entities against the same table, without using a relationship-based ON clause,
    as well as when joining multiple times to the same target relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'A query that joins to `A.bs` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'The query deduplicates the redundant `A.bs` because it is attempting to support
    a case like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the `A.bs` is part of a “path”. As part of [#3367](https://www.sqlalchemy.org/trac/ticket/3367),
    arriving at the same endpoint twice without it being part of a larger path will
    now emit a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The bigger change involves when joining to an entity without using a relationship-bound
    path. If we join to `B` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.9, this would render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: This is problematic since the aliasing is implicit and in the case of different
    ON clauses can lead to unpredictable results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1.0, no automatic aliasing is applied and we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: This will raise an error from the database. While it might be nice if the “duplicate
    join target” acted identically if we joined both from redundant relationships
    vs. redundant non-relationship based targets, for now we are only changing the
    behavior in the more serious case where implicit aliasing would have occurred
    previously, and only emitting a warning in the relationship case. Ultimately,
    joining to the same thing twice without any aliasing to disambiguate should raise
    an error in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change also has an impact on single-table inheritance targets. Using a
    mapping as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'The two queries at the bottom are equivalent, and should both render the identical
    SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'The above SQL is invalid, as it renders “a” within the FROM list twice. However,
    the implicit aliasing bug would occur with the second query only and render this
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the second join to “a” is aliased. While this seems convenient,
    it’s not how single-inheritance queries work in general and is misleading and
    inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The net effect is that applications which were relying on this bug will now
    have an error raised by the database. The solution is to use the expected form.
    When referring to multiple subclasses of a single-inheritance entity in a query,
    you must manually use aliases to disambiguate the table, as all the subclasses
    normally refer to the same table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
  prefs: []
  type: TYPE_NORMAL
- en: Deferred Columns No Longer Implicitly Undefer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mapped attributes marked as deferred without explicit undeferral will now remain
    “deferred” even if their column is otherwise present in the result set in some
    way. This is a performance enhancement in that an ORM load no longer spends time
    searching for each deferred column when the result set is obtained. However, for
    an application that has been relying upon this, an explicit [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or similar option should now be used, in order to prevent
    a SELECT from being emitted when the attribute is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '### Deprecated ORM Event Hooks Removed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following ORM event hooks, some of which have been deprecated since 0.5,
    have been removed: `translate_row`, `populate_instance`, `append_result`, `create_instance`.
    The use cases for these hooks originated in the very early 0.1 / 0.2 series of
    SQLAlchemy and have long since been unnecessary. In particular, the hooks were
    largely unusable as the behavioral contracts within these events was strongly
    linked to the surrounding internals, such as how an instance needs to be created
    and initialized as well as how columns are located within an ORM-generated row.
    The removal of these hooks greatly simplifies the mechanics of ORM object loading.  ###
    API Change for new Bundle feature when custom row loaders are used'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    object of 0.9 has a small change in API, when the `create_row_processor()` method
    is overridden on a custom class. Previously, the sample code looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'The unused `result` member is now removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)  ###
    Right inner join nesting now the default for joinedload with innerjoin=True'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") as well as [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") is now to use “nested” inner joins, that is, right-nested,
    as the default behavior when an inner join joined eager load is chained to an
    outer join eager load. In order to get the old behavior of chaining all joined
    eager loads as outer join when an outer join is present, use `innerjoin="unnested"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As introduced in [Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    from version 0.9, the behavior of `innerjoin="nested"` is that an inner join eager
    load chained to an outer join eager load will use a right-nested join. `"nested"`
    is now implied when using `innerjoin=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new default, this will render the FROM clause in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: That is, using a right-nested join for the INNER join so that the full result
    of `users` can be returned. The use of an INNER join is more efficient than using
    an OUTER join, and allows the [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") optimization parameter to take effect in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the older behavior, use `innerjoin="unnested"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'This will avoid right-nested joins and chain the joins together using all OUTER
    joins despite the innerjoin directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: As noted in the 0.9 notes, the only database backend that has difficulty with
    right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-nested join
    into a subquery as a join target on SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    - description of the feature as introduced in 0.9.4.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)  ### Subqueries no longer
    applied to uselist=False joined eager loads'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a joined eager load like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy considers the relationship `A.b` to be a “one to many, loaded as
    a single value”, which is essentially a “one to one” relationship. However, joined
    eager loading has always treated the above as a situation where the main query
    needs to be inside a subquery, as would normally be needed for a collection of
    B objects where the main query has a LIMIT applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since the relationship of the inner query to the outer one is that
    at most only one row is shared in the case of `uselist=False` (in the same way
    as a many-to-one), the “subquery” used with LIMIT + joined eager loading is now
    dropped in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: In the case that the LEFT OUTER JOIN returns more than one row, the ORM has
    always emitted a warning here and ignored additional results for `uselist=False`,
    so the results in that error situation should not change.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
  prefs: []
  type: TYPE_NORMAL
- en: query.update() / query.delete() raises if used with join(), select_from(), from_self()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9, 2015)
    when the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods are invoked against a query which has also
    called upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), [`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin"), [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") or `Query.from_self()`. These are unsupported
    use cases which silently fail in the 0.9 series up until 0.9.10 where it emits
    a warning. In 1.0, these cases raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
  prefs: []
  type: TYPE_NORMAL
- en: query.update() with `synchronize_session='evaluate'` raises on multi-table update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “evaluator” for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") won’t work with multi-table updates, and needs
    to be set to `synchronize_session=False` or `synchronize_session='fetch'` when
    multiple tables are present. The new behavior is that an explicit exception is
    now raised, with a message to change the synchronize setting. This is upgraded
    from a warning emitted as of 0.9.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
  prefs: []
  type: TYPE_NORMAL
- en: Resurrect Event has been Removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “resurrect” ORM event has been removed entirely. This event ceased to have
    any function since version 0.8 removed the older “mutable” system from the unit
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: '### Change to single-table-inheritance criteria when using from_self(), count()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a single-table inheritance mapping, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Query.from_self()` or [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") against a subclass would produce a subquery, but
    then add the “WHERE” criteria for subtypes to the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue with this is that if the inner query does not specify all columns,
    then we can’t add the WHERE clause on the outside (it actually tries, and produces
    a bad query). This decision apparently goes way back to 0.6.5 with the note “may
    need to make more adjustments to this”. Well, those adjustments have arrived!
    So now the above query will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'So that queries that don’t include “type” will still work!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)  ### single-table-inheritance
    criteria added to all ON clauses unconditionally'
  prefs: []
  type: TYPE_NORMAL
- en: 'When joining to a single-table inheritance subclass target, the ORM always
    adds the “single table criteria” when joining on a relationship. Given a mapping
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s been the behavior for quite some time that a JOIN on the relationship
    will render a “single inheritance” clause for the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Above, because we joined to a subclass `FooWidget`, [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") knew to add the `AND widget.type IN ('foo')` criteria
    to the ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change here is that the `AND widget.type IN()` criteria is now appended
    to *any* ON clause, not just those generated from a relationship, including one
    that is explicitly stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the “implicit” join when no ON clause of any kind is stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the ON clause for these would not include the single-inheritance
    criteria. Applications that are already adding this criteria to work around this
    will want to remove its explicit use, though it should continue to work fine if
    the criteria happens to be rendered twice in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Changes and fixes in handling of duplicate join targets](#bug-3233)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)  ### query.update() now
    resolves string names into mapped attribute names'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") states that the given `values` dictionary is “a
    dictionary with attributes names as keys”, implying that these are mapped attribute
    names. Unfortunately, the function was designed more in mind to receive attributes
    and SQL expressions and not as much strings; when strings were passed, these strings
    would be passed through straight to the core update statement without any resolution
    as far as how these names are represented on the mapped class, meaning the name
    would have to match that of a table column exactly, not how an attribute of that
    name was mapped onto the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The string names are now resolved as attribute names in earnest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the column `user_name` is mapped as `name`. Previously, a call to [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") that was passed strings would have to have been
    called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'The given string is now resolved against the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'It is typically preferable to use the attribute directly, to avoid any ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'The change also indicates that synonyms and hybrid attributes can be referred
    to by string name as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Warnings emitted when comparing objects with None values to relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'This change is new as of 1.0.1\. Some users are performing queries that are
    essentially of this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is not currently supported in SQLAlchemy. For all versions, it
    emits SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Note above, there is a comparison `WHERE ? = address.user_id` where the bound
    value `?` is receiving `None`, or `NULL` in SQL. **This will always return False
    in SQL**. The comparison here would in theory generate SQL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'But right now, **it does not**. Applications which are relying upon the fact
    that “NULL = NULL” produces False in all cases run the risk that someday, SQLAlchemy
    might fix this issue to generate “IS NULL”, and the queries will then produce
    different results. Therefore with this kind of operation, you will see a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Note that this pattern was broken in most cases for release 1.0.0 including
    all of the betas; a value like `SYMBOL('NEVER_SET')` would be generated. This
    issue has been fixed, but as a result of identifying this pattern, the warning
    is now there so that we can more safely repair this broken behavior (now captured
    in [#3373](https://www.sqlalchemy.org/trac/ticket/3373)) in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)'
  prefs: []
  type: TYPE_NORMAL
- en: '### A “negated contains or equals” relationship comparison will use the current
    value of attributes, not the database value'
  prefs: []
  type: TYPE_NORMAL
- en: This change is new as of 1.0.1; while we would have preferred for this to be
    in 1.0.0, it only became apparent as a result of [#3371](https://www.sqlalchemy.org/trac/ticket/3371).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'Given `A`, with primary key of 7, but which we changed to be 10 without flushing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'A query against a many-to-one relationship with this object as the target will
    use the value 10 in the bound parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'However, before this change, the negation of this criteria would **not** use
    10, it would use 7, unless the object were flushed first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces (in 0.9 and all versions prior to 1.0.1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'For a transient object, it would produce a broken query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: This inconsistency has been repaired, and in all queries the current attribute
    value, in this example `10`, will now be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Changes to attribute events and other operations regarding attributes that
    have no pre-existing value'
  prefs: []
  type: TYPE_NORMAL
- en: In this change, the default return value of `None` when accessing an object
    is now returned dynamically on each access, rather than implicitly setting the
    attribute’s state with a special “set” operation when it is first accessed. The
    visible result of this change is that `obj.__dict__` is not implicitly modified
    on get, and there are also some minor behavioral changes for [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") and related functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an object with no state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'It has always been SQLAlchemy’s behavior such that if we access a scalar or
    many-to-one attribute that was never set, it is returned as `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'This value of `None` is in fact now part of the state of `obj`, and is not
    unlike as though we had set the attribute explicitly, e.g. `obj.someattr = None`.
    However, the “set on get” here would behave differently as far as history and
    events. It would not emit any attribute event, and additionally if we view history,
    we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, it’s as though the attribute were always `None` and were never changed.
    This is explicitly different from if we had set the attribute first instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: The above means that the behavior of our “set” operation can be corrupted by
    the fact that the value was accessed via “get” earlier. In 1.0, this inconsistency
    has been resolved, by no longer actually setting anything when the default “getter”
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: The reason the above behavior hasn’t had much impact is because the INSERT statement
    in relational databases considers a missing value to be the same as NULL in most
    cases. Whether SQLAlchemy received a history event for a particular attribute
    set to None or not would usually not matter; as the difference between sending
    None/NULL or not wouldn’t have an impact. However, as [#3060](https://www.sqlalchemy.org/trac/ticket/3060)
    (described here in [Priority of attribute changes on relationship-bound attributes
    vs. FK-bound may appear to change](#migration-3060)) illustrates, there are some
    seldom edge cases where we do in fact want to positively have `None` set. Also,
    allowing the attribute event here means it’s now possible to create “default value”
    functions for ORM mapped attributes.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this change, the generation of the implicit “None” is now disabled
    for other situations where this used to occur; this includes when an attribute
    set operation on a many-to-one is received; previously, the “old” value would
    be “None” if it had been not set otherwise; it now will send the value `NEVER_SET`,
    which is a value that may be sent to an attribute listener now. This symbol may
    also be received when calling on mapper utility functions such as [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance"); if the primary key attributes
    have no setting at all, whereas the value would be `None` before, it will now
    be the `NEVER_SET` symbol, and no change to the object’s state occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Priority of attribute changes on relationship-bound attributes vs. FK-bound
    may appear to change'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side effect of [#3060](https://www.sqlalchemy.org/trac/ticket/3060), setting
    a relationship-bound attribute to `None` is now a tracked history event which
    refers to the intention of persisting `None` to that attribute. As it has always
    been the case that setting a relationship-bound attribute will trump direct assignment
    to the foreign key attributes, a change in behavior can be seen here when assigning
    None. Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the relationship-bound attribute takes precedence over the FK-bound
    attribute in all cases, whether or not the value we assign is a reference to an
    `A` object or is `None`. In 0.9, the behavior is inconsistent and only takes effect
    if a value is assigned; the None is not considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)'
  prefs: []
  type: TYPE_NORMAL
- en: '### session.expunge() will fully detach an object that’s been deleted'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") had a bug that caused an inconsistency in behavior
    regarding deleted objects. The [`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") function as well as the [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") attribute would still report object as
    belonging to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    subsequent to the expunge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is normal for `u1 not in sess` to be True while `inspect(u1).session`
    still refers to the session, while the transaction is ongoing subsequent to the
    delete operation and [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") has not been called; the full detachment normally
    completes once the transaction is committed. This issue would also impact functions
    that rely on [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") such as [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Joined/Subquery eager loading explicitly disallowed with yield_per'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") method easier to use, an exception is raised
    if any subquery eager loaders, or joined eager loaders that would use collections,
    are to take effect when yield_per is used, as these are currently not compatible
    with yield-per (subquery loading could be in theory, however). When this error
    is raised, the [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option can be sent with an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'or use [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option has the advantage that additional many-to-one
    joined loader options can still be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '### Changes and fixes in handling of duplicate join targets'
  prefs: []
  type: TYPE_NORMAL
- en: Changes here encompass bugs where an unexpected and inconsistent behavior would
    occur in some scenarios when joining to an entity twice, or to multiple single-table
    entities against the same table, without using a relationship-based ON clause,
    as well as when joining multiple times to the same target relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: 'A query that joins to `A.bs` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'Will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'The query deduplicates the redundant `A.bs` because it is attempting to support
    a case like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the `A.bs` is part of a “path”. As part of [#3367](https://www.sqlalchemy.org/trac/ticket/3367),
    arriving at the same endpoint twice without it being part of a larger path will
    now emit a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'The bigger change involves when joining to an entity without using a relationship-bound
    path. If we join to `B` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'In 0.9, this would render as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: This is problematic since the aliasing is implicit and in the case of different
    ON clauses can lead to unpredictable results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1.0, no automatic aliasing is applied and we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: This will raise an error from the database. While it might be nice if the “duplicate
    join target” acted identically if we joined both from redundant relationships
    vs. redundant non-relationship based targets, for now we are only changing the
    behavior in the more serious case where implicit aliasing would have occurred
    previously, and only emitting a warning in the relationship case. Ultimately,
    joining to the same thing twice without any aliasing to disambiguate should raise
    an error in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change also has an impact on single-table inheritance targets. Using a
    mapping as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'The two queries at the bottom are equivalent, and should both render the identical
    SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'The above SQL is invalid, as it renders “a” within the FROM list twice. However,
    the implicit aliasing bug would occur with the second query only and render this
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the second join to “a” is aliased. While this seems convenient,
    it’s not how single-inheritance queries work in general and is misleading and
    inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The net effect is that applications which were relying on this bug will now
    have an error raised by the database. The solution is to use the expected form.
    When referring to multiple subclasses of a single-inheritance entity in a query,
    you must manually use aliases to disambiguate the table, as all the subclasses
    normally refer to the same table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
  prefs: []
  type: TYPE_NORMAL
- en: Deferred Columns No Longer Implicitly Undefer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mapped attributes marked as deferred without explicit undeferral will now remain
    “deferred” even if their column is otherwise present in the result set in some
    way. This is a performance enhancement in that an ORM load no longer spends time
    searching for each deferred column when the result set is obtained. However, for
    an application that has been relying upon this, an explicit [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or similar option should now be used, in order to prevent
    a SELECT from being emitted when the attribute is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '### Deprecated ORM Event Hooks Removed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following ORM event hooks, some of which have been deprecated since 0.5,
    have been removed: `translate_row`, `populate_instance`, `append_result`, `create_instance`.
    The use cases for these hooks originated in the very early 0.1 / 0.2 series of
    SQLAlchemy and have long since been unnecessary. In particular, the hooks were
    largely unusable as the behavioral contracts within these events was strongly
    linked to the surrounding internals, such as how an instance needs to be created
    and initialized as well as how columns are located within an ORM-generated row.
    The removal of these hooks greatly simplifies the mechanics of ORM object loading.'
  prefs: []
  type: TYPE_NORMAL
- en: '### API Change for new Bundle feature when custom row loaders are used'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    object of 0.9 has a small change in API, when the `create_row_processor()` method
    is overridden on a custom class. Previously, the sample code looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'The unused `result` member is now removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Right inner join nesting now the default for joinedload with innerjoin=True'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") as well as [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") is now to use “nested” inner joins, that is, right-nested,
    as the default behavior when an inner join joined eager load is chained to an
    outer join eager load. In order to get the old behavior of chaining all joined
    eager loads as outer join when an outer join is present, use `innerjoin="unnested"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As introduced in [Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    from version 0.9, the behavior of `innerjoin="nested"` is that an inner join eager
    load chained to an outer join eager load will use a right-nested join. `"nested"`
    is now implied when using `innerjoin=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new default, this will render the FROM clause in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: That is, using a right-nested join for the INNER join so that the full result
    of `users` can be returned. The use of an INNER join is more efficient than using
    an OUTER join, and allows the [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") optimization parameter to take effect in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the older behavior, use `innerjoin="unnested"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'This will avoid right-nested joins and chain the joins together using all OUTER
    joins despite the innerjoin directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: As noted in the 0.9 notes, the only database backend that has difficulty with
    right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-nested join
    into a subquery as a join target on SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    - description of the feature as introduced in 0.9.4.'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Subqueries no longer applied to uselist=False joined eager loads'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a joined eager load like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy considers the relationship `A.b` to be a “one to many, loaded as
    a single value”, which is essentially a “one to one” relationship. However, joined
    eager loading has always treated the above as a situation where the main query
    needs to be inside a subquery, as would normally be needed for a collection of
    B objects where the main query has a LIMIT applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since the relationship of the inner query to the outer one is that
    at most only one row is shared in the case of `uselist=False` (in the same way
    as a many-to-one), the “subquery” used with LIMIT + joined eager loading is now
    dropped in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: In the case that the LEFT OUTER JOIN returns more than one row, the ORM has
    always emitted a warning here and ignored additional results for `uselist=False`,
    so the results in that error situation should not change.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
  prefs: []
  type: TYPE_NORMAL
- en: query.update() / query.delete() raises if used with join(), select_from(), from_self()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9, 2015)
    when the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods are invoked against a query which has also
    called upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), [`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin"), [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") or `Query.from_self()`. These are unsupported
    use cases which silently fail in the 0.9 series up until 0.9.10 where it emits
    a warning. In 1.0, these cases raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
  prefs: []
  type: TYPE_NORMAL
- en: query.update() with `synchronize_session='evaluate'` raises on multi-table update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “evaluator” for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") won’t work with multi-table updates, and needs
    to be set to `synchronize_session=False` or `synchronize_session='fetch'` when
    multiple tables are present. The new behavior is that an explicit exception is
    now raised, with a message to change the synchronize setting. This is upgraded
    from a warning emitted as of 0.9.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
  prefs: []
  type: TYPE_NORMAL
- en: Resurrect Event has been Removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The “resurrect” ORM event has been removed entirely. This event ceased to have
    any function since version 0.8 removed the older “mutable” system from the unit
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: '### Change to single-table-inheritance criteria when using from_self(), count()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a single-table inheritance mapping, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Query.from_self()` or [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") against a subclass would produce a subquery, but
    then add the “WHERE” criteria for subtypes to the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue with this is that if the inner query does not specify all columns,
    then we can’t add the WHERE clause on the outside (it actually tries, and produces
    a bad query). This decision apparently goes way back to 0.6.5 with the note “may
    need to make more adjustments to this”. Well, those adjustments have arrived!
    So now the above query will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'So that queries that don’t include “type” will still work!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'Renders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)'
  prefs: []
  type: TYPE_NORMAL
- en: '### single-table-inheritance criteria added to all ON clauses unconditionally'
  prefs: []
  type: TYPE_NORMAL
- en: 'When joining to a single-table inheritance subclass target, the ORM always
    adds the “single table criteria” when joining on a relationship. Given a mapping
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s been the behavior for quite some time that a JOIN on the relationship
    will render a “single inheritance” clause for the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Above, because we joined to a subclass `FooWidget`, [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") knew to add the `AND widget.type IN ('foo')` criteria
    to the ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change here is that the `AND widget.type IN()` criteria is now appended
    to *any* ON clause, not just those generated from a relationship, including one
    that is explicitly stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the “implicit” join when no ON clause of any kind is stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the ON clause for these would not include the single-inheritance
    criteria. Applications that are already adding this criteria to work around this
    will want to remove its explicit use, though it should continue to work fine if
    the criteria happens to be rendered twice in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Changes and fixes in handling of duplicate join targets](#bug-3233)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Warnings emitted when coercing full SQL fragments into text()'
  prefs: []
  type: TYPE_NORMAL
- en: Since SQLAlchemy’s inception, there has always been an emphasis on not getting
    in the way of the usage of plain text. The Core and ORM expression systems were
    intended to allow any number of points at which the user can just use plain text
    SQL expressions, not just in the sense that you can send a full SQL string to
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), but that you can send strings with SQL
    expressions into many functions, such as [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where"), [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that by “SQL expressions” we mean a **full fragment of a SQL string**,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'and we are **not talking about string arguments**, that is, the normal behavior
    of passing string values that become parameterized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: The Core tutorial has long featured an example of the use of this technique,
    using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct where virtually all components of
    it are specified as straight strings. However, despite this long-standing behavior
    and example, users are apparently surprised that this behavior exists, and when
    asking around the community, I was unable to find any user that was in fact *not*
    surprised that you can send a full string into a method like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter").
  prefs: []
  type: TYPE_NORMAL
- en: 'So the change here is to encourage the user to qualify textual strings when
    composing SQL that is partially or fully composed from textual fragments. When
    composing a select as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement is built up normally, with all the same coercions as before.
    However, one will see the following warnings emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'These warnings attempt to show exactly where the issue is by displaying the
    parameters as well as where the string was received. The warnings make use of
    the [Session.get_bind() handles a wider variety of inheritance scenarios](#feature-3178)
    so that parameterized warnings can be emitted safely without running out of memory,
    and as always, if one wishes the warnings to be exceptions, the [Python Warnings
    Filter](https://docs.python.org/2/library/warnings.html) should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the above warnings, our statement works just fine, but to get rid of
    the warnings we would rewrite our statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'and as the warnings suggest, we can give our statement more specificity about
    the text if we use [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") and [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Where note also that [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") and [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") can now be imported from “sqlalchemy” without
    the “sql” part.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior here applies to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") as well as to key methods on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") and [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having").
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY and GROUP BY are special cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'The output does what we say, but again it warns us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)  ### Python-side defaults
    invoked for each row individually when using a multivalued insert'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Python-side column defaults when using the multi-valued version
    of [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") were essentially not implemented, and
    would only work “by accident” in specific situations, when the dialect in use
    was using a non-positional (e.g. named) style of bound parameter, and when it
    was not necessary that a Python-side callable be invoked for each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature has been overhauled so that it works more similarly to that of
    an “executemany” style of invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example will invoke `next(counter)` for each row individually as
    would be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, a positional dialect would fail as a bind would not be generated
    for additional positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'And with a “named” dialect, the same value for “id” would be re-used in each
    row (hence this change is backwards-incompatible with a system that relied on
    this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'The system will also refuse to invoke a “server side” default as inline-rendered
    SQL, since it cannot be guaranteed that a server side default is compatible with
    this. If the VALUES clause renders for a specific column, then a Python-side value
    is required; if an omitted value only refers to a server-side default, an exception
    is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'will raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the value “d1” would be copied into that of the third row (but
    again, only with named format!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)  ### Event listeners can
    not be added or removed from within that event’s runner'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of an event listener from inside that same event itself would modify
    the elements of a list during iteration, which would cause still-attached event
    listeners to silently fail to fire. To prevent this while still maintaining performance,
    the lists have been replaced with `collections.deque()`, which does not allow
    any additions or removals during iteration, and instead raises `RuntimeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)  ### The INSERT…FROM SELECT
    construct now implies `inline=True`'
  prefs: []
  type: TYPE_NORMAL
- en: Using [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now implies `inline=True` on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"). This helps to fix a bug where an INSERT…FROM
    SELECT construct would inadvertently be compiled as “implicit returning” on supporting
    backends, which would cause breakage in the case of an INSERT that inserts zero
    rows (as implicit returning expects a row), as well as arbitrary return data in
    the case of an INSERT that inserts multiple rows (e.g. only the first row of many).
    A similar change is also applied to an INSERT..VALUES with multiple parameter
    sets; implicit RETURNING will no longer emit for this statement either. As both
    of these constructs deal with variable numbers of rows, the `ResultProxy.inserted_primary_key`
    accessor does not apply. Previously, there was a documentation note that one may
    prefer `inline=True` with INSERT..FROM SELECT as some databases don’t support
    returning and therefore can’t do “implicit” returning, but there’s no reason an
    INSERT…FROM SELECT needs implicit returning in any case. Regular explicit [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") should be used to return variable
    numbers of result rows if inserted data is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)  ### `autoload_with` now
    implies `autoload=True`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can be set up for reflection by passing [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)  ### DBAPI exception wrapping
    and handle_error() event improvements'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s wrapping of DBAPI exceptions was not taking place in the case where
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object was invalidated, and then tried to reconnect and encountered an error;
    this has been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the recently added `ConnectionEvents.handle_error()` event is
    now invoked for errors that occur upon initial connect, upon reconnect, and when
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    is used given a custom connection function via [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") object has a new datamember [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") that will always refer to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in use, in those cases when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object is not available (e.g. on initial connect).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)  ### ForeignKeyConstraint.columns
    is now a ColumnCollection'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") was previously a plain list
    containing either strings or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, depending on how the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") was constructed and whether it was associated
    with a table. The collection is now a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), and is only initialized after the
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). A new accessor [`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys") is added to unconditionally
    return string keys for the local set of columns regardless of how the object was
    constructed or its current state.  ### MetaData.sorted_tables accessor is “deterministic”'
  prefs: []
  type: TYPE_NORMAL
- en: The sorting of tables resulting from the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor is “deterministic”; the ordering
    should be the same in all cases regardless of Python hashing. This is done by
    first sorting the tables by name before passing them to the topological algorithm,
    which maintains that ordering as it iterates.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change does **not** yet apply to the ordering applied when emitting
    [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)  ### null(), false() and
    true() constants are no longer singletons'
  prefs: []
  type: TYPE_NORMAL
- en: 'These three constants were changed to return a “singleton” value in 0.9; unfortunately,
    that would lead to a query like the following to not render as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: rendering only `SELECT NULL AS anon_1`, because the two [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constructs would come out as the same `NULL`
    object, and SQLAlchemy’s Core model is based on object identity in order to determine
    lexical significance. The change in 0.9 had no importance other than the desire
    to save on object overhead; in general, an unnamed construct needs to stay lexically
    unique so that it gets labeled uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)  ### SQLite/Oracle have
    distinct methods for temporary table/view name reporting'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") methods in the case of
    SQLite/Oracle would also return the names of temporary tables and views, which
    is not provided by any other dialect (in the case of MySQL at least it is not
    even possible). This logic has been moved out to two new methods [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") and [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names").
  prefs: []
  type: TYPE_NORMAL
- en: Note that reflection of a specific named temporary table or temporary view,
    either by `Table('name', autoload=True)` or via methods like [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") continues to function for
    most if not all dialects. For SQLite specifically, there is a bug fix for UNIQUE
    constraint reflection from temp tables as well, which is [#3203](https://www.sqlalchemy.org/trac/ticket/3203).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)  ### Warnings emitted
    when coercing full SQL fragments into text()'
  prefs: []
  type: TYPE_NORMAL
- en: Since SQLAlchemy’s inception, there has always been an emphasis on not getting
    in the way of the usage of plain text. The Core and ORM expression systems were
    intended to allow any number of points at which the user can just use plain text
    SQL expressions, not just in the sense that you can send a full SQL string to
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), but that you can send strings with SQL
    expressions into many functions, such as [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where"), [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that by “SQL expressions” we mean a **full fragment of a SQL string**,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'and we are **not talking about string arguments**, that is, the normal behavior
    of passing string values that become parameterized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: The Core tutorial has long featured an example of the use of this technique,
    using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct where virtually all components of
    it are specified as straight strings. However, despite this long-standing behavior
    and example, users are apparently surprised that this behavior exists, and when
    asking around the community, I was unable to find any user that was in fact *not*
    surprised that you can send a full string into a method like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter").
  prefs: []
  type: TYPE_NORMAL
- en: 'So the change here is to encourage the user to qualify textual strings when
    composing SQL that is partially or fully composed from textual fragments. When
    composing a select as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement is built up normally, with all the same coercions as before.
    However, one will see the following warnings emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'These warnings attempt to show exactly where the issue is by displaying the
    parameters as well as where the string was received. The warnings make use of
    the [Session.get_bind() handles a wider variety of inheritance scenarios](#feature-3178)
    so that parameterized warnings can be emitted safely without running out of memory,
    and as always, if one wishes the warnings to be exceptions, the [Python Warnings
    Filter](https://docs.python.org/2/library/warnings.html) should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the above warnings, our statement works just fine, but to get rid of
    the warnings we would rewrite our statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'and as the warnings suggest, we can give our statement more specificity about
    the text if we use [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") and [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Where note also that [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") and [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") can now be imported from “sqlalchemy” without
    the “sql” part.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior here applies to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") as well as to key methods on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") and [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having").
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY and GROUP BY are special cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'The output does what we say, but again it warns us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)'
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY and GROUP BY are special cases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'The output does what we say, but again it warns us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Python-side defaults invoked for each row individually when using a multivalued
    insert'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Python-side column defaults when using the multi-valued version
    of [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") were essentially not implemented, and
    would only work “by accident” in specific situations, when the dialect in use
    was using a non-positional (e.g. named) style of bound parameter, and when it
    was not necessary that a Python-side callable be invoked for each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature has been overhauled so that it works more similarly to that of
    an “executemany” style of invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example will invoke `next(counter)` for each row individually as
    would be expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, a positional dialect would fail as a bind would not be generated
    for additional positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'And with a “named” dialect, the same value for “id” would be re-used in each
    row (hence this change is backwards-incompatible with a system that relied on
    this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'The system will also refuse to invoke a “server side” default as inline-rendered
    SQL, since it cannot be guaranteed that a server side default is compatible with
    this. If the VALUES clause renders for a specific column, then a Python-side value
    is required; if an omitted value only refers to a server-side default, an exception
    is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'will raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, the value “d1” would be copied into that of the third row (but
    again, only with named format!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Event listeners can not be added or removed from within that event’s runner'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of an event listener from inside that same event itself would modify
    the elements of a list during iteration, which would cause still-attached event
    listeners to silently fail to fire. To prevent this while still maintaining performance,
    the lists have been replaced with `collections.deque()`, which does not allow
    any additions or removals during iteration, and instead raises `RuntimeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The INSERT…FROM SELECT construct now implies `inline=True`'
  prefs: []
  type: TYPE_NORMAL
- en: Using [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now implies `inline=True` on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"). This helps to fix a bug where an INSERT…FROM
    SELECT construct would inadvertently be compiled as “implicit returning” on supporting
    backends, which would cause breakage in the case of an INSERT that inserts zero
    rows (as implicit returning expects a row), as well as arbitrary return data in
    the case of an INSERT that inserts multiple rows (e.g. only the first row of many).
    A similar change is also applied to an INSERT..VALUES with multiple parameter
    sets; implicit RETURNING will no longer emit for this statement either. As both
    of these constructs deal with variable numbers of rows, the `ResultProxy.inserted_primary_key`
    accessor does not apply. Previously, there was a documentation note that one may
    prefer `inline=True` with INSERT..FROM SELECT as some databases don’t support
    returning and therefore can’t do “implicit” returning, but there’s no reason an
    INSERT…FROM SELECT needs implicit returning in any case. Regular explicit [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") should be used to return variable
    numbers of result rows if inserted data is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `autoload_with` now implies `autoload=True`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can be set up for reflection by passing [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)'
  prefs: []
  type: TYPE_NORMAL
- en: '### DBAPI exception wrapping and handle_error() event improvements'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s wrapping of DBAPI exceptions was not taking place in the case where
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object was invalidated, and then tried to reconnect and encountered an error;
    this has been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the recently added `ConnectionEvents.handle_error()` event is
    now invoked for errors that occur upon initial connect, upon reconnect, and when
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    is used given a custom connection function via [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") object has a new datamember [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") that will always refer to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in use, in those cases when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object is not available (e.g. on initial connect).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ForeignKeyConstraint.columns is now a ColumnCollection'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") was previously a plain list
    containing either strings or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, depending on how the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") was constructed and whether it was associated
    with a table. The collection is now a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), and is only initialized after the
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). A new accessor [`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys") is added to unconditionally
    return string keys for the local set of columns regardless of how the object was
    constructed or its current state.'
  prefs: []
  type: TYPE_NORMAL
- en: '### MetaData.sorted_tables accessor is “deterministic”'
  prefs: []
  type: TYPE_NORMAL
- en: The sorting of tables resulting from the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor is “deterministic”; the ordering
    should be the same in all cases regardless of Python hashing. This is done by
    first sorting the tables by name before passing them to the topological algorithm,
    which maintains that ordering as it iterates.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change does **not** yet apply to the ordering applied when emitting
    [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)'
  prefs: []
  type: TYPE_NORMAL
- en: '### null(), false() and true() constants are no longer singletons'
  prefs: []
  type: TYPE_NORMAL
- en: 'These three constants were changed to return a “singleton” value in 0.9; unfortunately,
    that would lead to a query like the following to not render as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: rendering only `SELECT NULL AS anon_1`, because the two [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constructs would come out as the same `NULL`
    object, and SQLAlchemy’s Core model is based on object identity in order to determine
    lexical significance. The change in 0.9 had no importance other than the desire
    to save on object overhead; in general, an unnamed construct needs to stay lexically
    unique so that it gets labeled uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)'
  prefs: []
  type: TYPE_NORMAL
- en: '### SQLite/Oracle have distinct methods for temporary table/view name reporting'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") methods in the case of
    SQLite/Oracle would also return the names of temporary tables and views, which
    is not provided by any other dialect (in the case of MySQL at least it is not
    even possible). This logic has been moved out to two new methods [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") and [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names").
  prefs: []
  type: TYPE_NORMAL
- en: Note that reflection of a specific named temporary table or temporary view,
    either by `Table('name', autoload=True)` or via methods like [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") continues to function for
    most if not all dialects. For SQLite specifically, there is a bug fix for UNIQUE
    constraint reflection from temp tables as well, which is [#3203](https://www.sqlalchemy.org/trac/ticket/3203).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Overhaul of ENUM type create/drop rules'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") have been made more strict with regards
    to creating and dropping of the TYPE.
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **without** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will be created *and* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: This means that if a second table also has an enum named ‘myenum’, the above
    DROP operation will now fail. In order to accommodate the use case of a common
    shared enumerated type, the behavior of a metadata-associated enumeration has
    been enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **with** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will *not* be created *or* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"),
    with the exception of [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") called with the `checkfirst=True` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
  prefs: []
  type: TYPE_NORMAL
- en: New PostgreSQL Table options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS, and
    INHERITS, when rendering DDL via the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Table Options](../dialects/postgresql.html#postgresql-table-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New get_enums() method with PostgreSQL Dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    method returns a [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") object in the case of PostgreSQL,
    which includes a new [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") method that returns
    information on all available `ENUM` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")  ### PostgreSQL Dialect
    reflects Materialized Views, Foreign Tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the `Table` construct with `autoload=True` will now match a name that exists
    in the database as a materialized view or foreign table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") will return plain and
    materialized view names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") does **not** change
    for PostgreSQL, it continues to return only the names of plain tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new method [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") is
    added which will return the names of tables that are specifically marked as “foreign”
    in the PostgreSQL schema tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change to reflection involves adding `'m'` and `'f'` to the list of qualifiers
    we use when querying `pg_class.relkind`, but this change is new in 1.0.0 to avoid
    any backwards-incompatible surprises for those running 0.9 in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)  ### PostgreSQL `has_table()`
    now works for temporary tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple fix such that “has table” for temporary tables now works,
    so that code like the following may proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'The very unlikely case that this behavior will cause a non-failing application
    to behave differently, is because PostgreSQL allows a non-temporary table to silently
    overwrite a temporary table. So code like the following will now act completely
    differently, no longer creating the real table following the temporary table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)  ### PostgreSQL FILTER
    keyword'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard FILTER keyword for aggregate functions is now supported by
    PostgreSQL as of 9.4\. SQLAlchemy allows this using [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
  prefs: []
  type: TYPE_NORMAL
- en: PG8000 dialect supports client side encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") parameter is now honored by the pg8000 dialect, using
    on connect handler which emits `SET CLIENT_ENCODING` matching the selected encoding.
  prefs: []
  type: TYPE_NORMAL
- en: PG8000 native JSONB support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for PG8000 versions greater than 1.10.1 has been added, where JSONB
    is supported natively.
  prefs: []
  type: TYPE_NORMAL
- en: Support for psycopg2cffi Dialect on PyPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for the pypy psycopg2cffi dialect is added.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Overhaul of ENUM type create/drop rules'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") have been made more strict with regards
    to creating and dropping of the TYPE.
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **without** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will be created *and* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: This means that if a second table also has an enum named ‘myenum’, the above
    DROP operation will now fail. In order to accommodate the use case of a common
    shared enumerated type, the behavior of a metadata-associated enumeration has
    been enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **with** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will *not* be created *or* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"),
    with the exception of [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") called with the `checkfirst=True` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
  prefs: []
  type: TYPE_NORMAL
- en: New PostgreSQL Table options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS, and
    INHERITS, when rendering DDL via the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Table Options](../dialects/postgresql.html#postgresql-table-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New get_enums() method with PostgreSQL Dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    method returns a [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") object in the case of PostgreSQL,
    which includes a new [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") method that returns
    information on all available `ENUM` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")'
  prefs: []
  type: TYPE_NORMAL
- en: '### PostgreSQL Dialect reflects Materialized Views, Foreign Tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: the `Table` construct with `autoload=True` will now match a name that exists
    in the database as a materialized view or foreign table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") will return plain and
    materialized view names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") does **not** change
    for PostgreSQL, it continues to return only the names of plain tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new method [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") is
    added which will return the names of tables that are specifically marked as “foreign”
    in the PostgreSQL schema tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change to reflection involves adding `'m'` and `'f'` to the list of qualifiers
    we use when querying `pg_class.relkind`, but this change is new in 1.0.0 to avoid
    any backwards-incompatible surprises for those running 0.9 in production.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)'
  prefs: []
  type: TYPE_NORMAL
- en: '### PostgreSQL `has_table()` now works for temporary tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple fix such that “has table” for temporary tables now works,
    so that code like the following may proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'The very unlikely case that this behavior will cause a non-failing application
    to behave differently, is because PostgreSQL allows a non-temporary table to silently
    overwrite a temporary table. So code like the following will now act completely
    differently, no longer creating the real table following the temporary table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)'
  prefs: []
  type: TYPE_NORMAL
- en: '### PostgreSQL FILTER keyword'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard FILTER keyword for aggregate functions is now supported by
    PostgreSQL as of 9.4\. SQLAlchemy allows this using [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
  prefs: []
  type: TYPE_NORMAL
- en: PG8000 dialect supports client side encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") parameter is now honored by the pg8000 dialect, using
    on connect handler which emits `SET CLIENT_ENCODING` matching the selected encoding.
  prefs: []
  type: TYPE_NORMAL
- en: PG8000 native JSONB support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for PG8000 versions greater than 1.10.1 has been added, where JSONB
    is supported natively.
  prefs: []
  type: TYPE_NORMAL
- en: Support for psycopg2cffi Dialect on PyPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for the pypy psycopg2cffi dialect is added.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### MySQL TIMESTAMP Type now renders NULL / NOT NULL in all cases'
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL dialect has always worked around MySQL’s implicit NOT NULL default
    associated with TIMESTAMP columns by emitting NULL for such a type, if the column
    is set up with `nullable=True`. However, MySQL 5.6.6 and above features a new
    flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which repairs MySQL’s non-standard behavior to make it behave like any other type;
    to accommodate this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all
    TIMESTAMP columns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)  ### MySQL SET Type Overhauled
    to support empty sets, unicode, blank value handling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    type historically not included a system of handling blank sets and empty values
    separately; as different drivers had different behaviors for treatment of empty
    strings and empty-string-set representations, the SET type tried only to hedge
    between these behaviors, opting to treat the empty set as `set([''])` as is still
    the current behavior for the MySQL-Connector-Python DBAPI. Part of the rationale
    here was that it was otherwise impossible to actually store a blank string within
    a MySQL SET, as the driver gives us back strings with no way to discern between
    `set([''])` and `set()`. It was left to the user to determine if `set([''])` actually
    meant “empty set” or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new behavior moves the use case for the blank string, which is an unusual
    case that isn’t even documented in MySQL’s documentation, into a special case,
    and the default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") is now:'
  prefs: []
  type: TYPE_NORMAL
- en: to treat the empty string `''` as returned by MySQL-python into the empty set
    `set()`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to convert the single-blank value set `set([''])` returned by MySQL-Connector-Python
    into the empty set `set()`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle the case of a set type that actually wishes includes the blank value
    `''` in its list of possible values, a new feature (required in this use case)
    is implemented whereby the set value is persisted and loaded as a bitwise integer
    value; the flag [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") is added in order to enable this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag allows the set to be persisted and retrieved
    with no ambiguity of values. Theoretically this flag can be turned on in all cases,
    as long as the given list of values to the type matches the ordering exactly as
    declared in the database; it only makes the SQL echo output a bit more unusual.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") otherwise remains the same, roundtripping values
    using strings. The string-based behavior now supports unicode fully including
    MySQL-python with use_unicode=0.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL internal “no such table” exceptions not passed to event handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MySQL dialect will now disable `ConnectionEvents.handle_error()` events
    from firing for those statements which it uses internally to detect if a table
    exists or not. This is achieved using an execution option `skip_user_error_events`
    that disables the handle error event for the scope of that execution. In this
    way, user code that rewrites exceptions doesn’t need to worry about the MySQL
    dialect or other dialects that occasionally need to catch SQLAlchemy specific
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Changed the default value of `raise_on_warnings` for MySQL-Connector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changed the default value of “raise_on_warnings” to False for MySQL-Connector.
    This was set at True for some reason. The “buffered” flag unfortunately must stay
    at True as MySQLconnector does not allow a cursor to be closed unless all results
    are fully fetched.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
  prefs: []
  type: TYPE_NORMAL
- en: '### MySQL boolean symbols “true”, “false” work again'
  prefs: []
  type: TYPE_NORMAL
- en: 0.9’s overhaul of the IS/IS NOT operators as well as boolean types in [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    disallowed the MySQL dialect from making use of the “true” and “false” symbols
    in the context of “IS” / “IS NOT”. Apparently, even though MySQL has no “boolean”
    type, it supports IS / IS NOT when the special “true” and “false” symbols are
    used, even though these are otherwise synonymous with “1” and “0” (and IS/IS NOT
    don’t work with the numerics).
  prefs: []
  type: TYPE_NORMAL
- en: So the change here is that the MySQL dialect remains “non native boolean”, but
    the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    symbols again produce the keywords “true” and “false”, so that an expression like
    `column.is_(true())` again works on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)  ### The match() operator
    now returns an agnostic MatchType compatible with MySQL’s floating point return
    value'
  prefs: []
  type: TYPE_NORMAL
- en: The return type of a [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") expression is now a new type
    called [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType").
    This is a subclass of [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), that can be intercepted by the dialect in order to
    produce a different result type at SQL execution time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code like the following will now function correctly and return floating points
    on MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)  ### Drizzle Dialect is
    now an External Dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialect for [Drizzle](https://www.drizzle.org/) is now an external dialect,
    available at [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle).
    This dialect was added to SQLAlchemy right before SQLAlchemy was able to accommodate
    third party dialects well; going forward, all databases that aren’t within the
    “ubiquitous use” category are third party dialects. The dialect’s implementation
    hasn’t changed and is still based on the MySQL + MySQLdb dialects within SQLAlchemy.
    The dialect is as of yet unreleased and in “attic” status; however it passes the
    majority of tests and is generally in decent working order, if someone wants to
    pick up on polishing it.  ### MySQL TIMESTAMP Type now renders NULL / NOT NULL
    in all cases'
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL dialect has always worked around MySQL’s implicit NOT NULL default
    associated with TIMESTAMP columns by emitting NULL for such a type, if the column
    is set up with `nullable=True`. However, MySQL 5.6.6 and above features a new
    flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which repairs MySQL’s non-standard behavior to make it behave like any other type;
    to accommodate this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all
    TIMESTAMP columns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)'
  prefs: []
  type: TYPE_NORMAL
- en: '### MySQL SET Type Overhauled to support empty sets, unicode, blank value handling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    type historically not included a system of handling blank sets and empty values
    separately; as different drivers had different behaviors for treatment of empty
    strings and empty-string-set representations, the SET type tried only to hedge
    between these behaviors, opting to treat the empty set as `set([''])` as is still
    the current behavior for the MySQL-Connector-Python DBAPI. Part of the rationale
    here was that it was otherwise impossible to actually store a blank string within
    a MySQL SET, as the driver gives us back strings with no way to discern between
    `set([''])` and `set()`. It was left to the user to determine if `set([''])` actually
    meant “empty set” or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new behavior moves the use case for the blank string, which is an unusual
    case that isn’t even documented in MySQL’s documentation, into a special case,
    and the default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") is now:'
  prefs: []
  type: TYPE_NORMAL
- en: to treat the empty string `''` as returned by MySQL-python into the empty set
    `set()`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to convert the single-blank value set `set([''])` returned by MySQL-Connector-Python
    into the empty set `set()`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle the case of a set type that actually wishes includes the blank value
    `''` in its list of possible values, a new feature (required in this use case)
    is implemented whereby the set value is persisted and loaded as a bitwise integer
    value; the flag [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") is added in order to enable this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag allows the set to be persisted and retrieved
    with no ambiguity of values. Theoretically this flag can be turned on in all cases,
    as long as the given list of values to the type matches the ordering exactly as
    declared in the database; it only makes the SQL echo output a bit more unusual.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") otherwise remains the same, roundtripping values
    using strings. The string-based behavior now supports unicode fully including
    MySQL-python with use_unicode=0.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL internal “no such table” exceptions not passed to event handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MySQL dialect will now disable `ConnectionEvents.handle_error()` events
    from firing for those statements which it uses internally to detect if a table
    exists or not. This is achieved using an execution option `skip_user_error_events`
    that disables the handle error event for the scope of that execution. In this
    way, user code that rewrites exceptions doesn’t need to worry about the MySQL
    dialect or other dialects that occasionally need to catch SQLAlchemy specific
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Changed the default value of `raise_on_warnings` for MySQL-Connector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changed the default value of “raise_on_warnings” to False for MySQL-Connector.
    This was set at True for some reason. The “buffered” flag unfortunately must stay
    at True as MySQLconnector does not allow a cursor to be closed unless all results
    are fully fetched.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
  prefs: []
  type: TYPE_NORMAL
- en: '### MySQL boolean symbols “true”, “false” work again'
  prefs: []
  type: TYPE_NORMAL
- en: 0.9’s overhaul of the IS/IS NOT operators as well as boolean types in [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    disallowed the MySQL dialect from making use of the “true” and “false” symbols
    in the context of “IS” / “IS NOT”. Apparently, even though MySQL has no “boolean”
    type, it supports IS / IS NOT when the special “true” and “false” symbols are
    used, even though these are otherwise synonymous with “1” and “0” (and IS/IS NOT
    don’t work with the numerics).
  prefs: []
  type: TYPE_NORMAL
- en: So the change here is that the MySQL dialect remains “non native boolean”, but
    the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    symbols again produce the keywords “true” and “false”, so that an expression like
    `column.is_(true())` again works on MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The match() operator now returns an agnostic MatchType compatible with
    MySQL’s floating point return value'
  prefs: []
  type: TYPE_NORMAL
- en: The return type of a [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") expression is now a new type
    called [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType").
    This is a subclass of [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), that can be intercepted by the dialect in order to
    produce a different result type at SQL execution time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code like the following will now function correctly and return floating points
    on MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Drizzle Dialect is now an External Dialect'
  prefs: []
  type: TYPE_NORMAL
- en: The dialect for [Drizzle](https://www.drizzle.org/) is now an external dialect,
    available at [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle).
    This dialect was added to SQLAlchemy right before SQLAlchemy was able to accommodate
    third party dialects well; going forward, all databases that aren’t within the
    “ubiquitous use” category are third party dialects. The dialect’s implementation
    hasn’t changed and is still based on the MySQL + MySQLdb dialects within SQLAlchemy.
    The dialect is as of yet unreleased and in “attic” status; however it passes the
    majority of tests and is generally in decent working order, if someone wants to
    pick up on polishing it.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect and
    reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both with
    and without names. Previously, foreign key names were ignored and unnamed unique
    constraints were skipped. In particular this will help with Alembic’s new SQLite
    migration features.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, for both foreign keys and unique constraints, the result of
    PRAGMA foreign_keys, index_list, and index_info is combined with regular expression
    parsing of the CREATE TABLE statement overall to form a complete picture of the
    names of constraints, as well as differentiating UNIQUE constraints that were
    created as UNIQUE vs. unnamed INDEXes.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect and
    reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both with
    and without names. Previously, foreign key names were ignored and unnamed unique
    constraints were skipped. In particular this will help with Alembic’s new SQLite
    migration features.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, for both foreign keys and unique constraints, the result of
    PRAGMA foreign_keys, index_list, and index_info is combined with regular expression
    parsing of the CREATE TABLE statement overall to form a complete picture of the
    names of constraints, as well as differentiating UNIQUE constraints that were
    created as UNIQUE vs. unnamed INDEXes.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### PyODBC driver name is required with hostname-based SQL Server connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. with
    an explicit hostname, now requires a driver name - SQLAlchemy will no longer attempt
    to guess a default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy’s previously hardcoded default of “SQL Server” is obsolete on Windows,
    and SQLAlchemy cannot be tasked with guessing the best driver based on operation
    system/driver detection. Using a DSN is always preferred when using ODBC to avoid
    this issue entirely.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, VARBINARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rendering of the [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") types has been changed for SQL Server 2012 and
    greater, with options to control the behavior completely, based on deprecation
    guidelines from Microsoft. See [Large Text/Binary Type Deprecation](../dialects/mssql.html#mssql-large-type-deprecation)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '### PyODBC driver name is required with hostname-based SQL Server connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. with
    an explicit hostname, now requires a driver name - SQLAlchemy will no longer attempt
    to guess a default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy’s previously hardcoded default of “SQL Server” is obsolete on Windows,
    and SQLAlchemy cannot be tasked with guessing the best driver based on operation
    system/driver detection. Using a DSN is always preferred when using ODBC to avoid
    this issue entirely.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, VARBINARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rendering of the [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") types has been changed for SQL Server 2012 and
    greater, with options to control the behavior completely, based on deprecation
    guidelines from Microsoft. See [Large Text/Binary Type Deprecation](../dialects/mssql.html#mssql-large-type-deprecation)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Improved support for CTEs in Oracle'
  prefs: []
  type: TYPE_NORMAL
- en: 'CTE support has been fixed up for Oracle, and there is also a new feature `CTE.with_suffixes()`
    that can assist with Oracle’s special directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
  prefs: []
  type: TYPE_NORMAL
- en: New Oracle Keywords for DDL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keywords such as COMPRESS, ON COMMIT, BITMAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Table Options](../dialects/oracle.html#oracle-table-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Specific Index Options](../dialects/oracle.html#oracle-index-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improved support for CTEs in Oracle'
  prefs: []
  type: TYPE_NORMAL
- en: 'CTE support has been fixed up for Oracle, and there is also a new feature `CTE.with_suffixes()`
    that can assist with Oracle’s special directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
  prefs: []
  type: TYPE_NORMAL
- en: New Oracle Keywords for DDL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keywords such as COMPRESS, ON COMMIT, BITMAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Table Options](../dialects/oracle.html#oracle-table-options)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle Specific Index Options](../dialects/oracle.html#oracle-index-options)'
  prefs: []
  type: TYPE_NORMAL
