["```py\nfrom sqlalchemy import create_engine, Column, Integer\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base(create_engine(\"sqlite://\"))\n\nclass Foo(Base):\n    __tablename__ = \"foo\"\n    id = Column(Integer, primary_key=True)\n\nBase.metadata.create_all()\n\nsession = sessionmaker()()\n\n# constraint violation\nsession.add_all([Foo(id=1), Foo(id=1)])\n\ntry:\n    session.commit()\nexcept:\n    # ignore error\n    pass\n\n# continue using session without rolling back\nsession.commit()\n```", "```py\ntry:\n    # <use session>\n    session.commit()\nexcept:\n    session.rollback()\n    raise\nfinally:\n    session.close()  # optional, depends on use case\n```", "```py\ntest=> create table foo(id integer primary key);\nNOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index \"foo_pkey\" for table \"foo\"\nCREATE TABLE\ntest=> begin;\nBEGIN\ntest=> insert into foo values(1);\nINSERT 0 1\ntest=> commit;\nCOMMIT\ntest=> begin;\nBEGIN\ntest=> insert into foo values(1);\nERROR:  duplicate key value violates unique constraint \"foo_pkey\"\ntest=> insert into foo values(2);\nERROR:  current transaction is aborted, commands ignored until end of transaction block\n```", "```py\nsess = Session()  # begins a logical transaction\ntry:\n    sess.flush()\n\n    sess.commit()\nexcept:\n    sess.rollback()\n```", "```py\nq = session.query(User).outerjoin(User.addresses).filter(User.name == \"jack\")\n```", "```py\n>>> q.count()\n2\n```", "```py\n>>> q.all()\n[User(id=5, name='jack', ...)]\n```", "```py\n>>> session.query(User.id, User.name).outerjoin(User.addresses).filter(\n...     User.name == \"jack\"\n... ).all()\n[(5, 'jack'), (5, 'jack')]\n```", "```py\nclass Iterates:\n    def __len__(self):\n        print(\"LEN!\")\n        return 5\n\n    def __iter__(self):\n        print(\"ITER!\")\n        return iter([1, 2, 3, 4, 5])\n\nlist(Iterates())\n```", "```py\nITER!\nLEN!\n```", "```py\nfoo = session.get(Foo, 7)\no.foo = foo\nSession.commit()\n```", "```py\no = session.scalars(select(SomeClass).limit(1)).first()\n\n# assume the existing o.foo_id value is None;\n# accessing o.foo will reconcile this as ``None``, but will effectively\n# \"load\" the value of None\nassert o.foo is None\n\n# now set foo_id to something.  o.foo will not be immediately affected\no.foo_id = 7\n```", "```py\n# attribute is already \"loaded\" as None, has not been\n# reconciled with o.foo_id = 7 yet\nassert o.foo is None\n```", "```py\nsession.commit()  # expires all attributes\n\nfoo_7 = session.get(Foo, 7)\n\n# o.foo will lazyload again, this time getting the new object\nassert o.foo is foo_7\n```", "```py\no = session.scalars(select(SomeClass).limit(1)).first()\no.foo_id = 7\nSession.expire(o, [\"foo\"])  # object must be persistent for this\n\nfoo_7 = session.get(Foo, 7)\n\nassert o.foo is foo_7  # o.foo lazyloads on access\n```", "```py\nnew_obj = SomeClass()\nnew_obj.foo_id = 7\n\nSession.add(new_obj)\n\n# returns None but this is not a \"lazyload\", as the object is not\n# persistent in the DB yet, and the None value is not part of the\n# object's state\nassert new_obj.foo is None\n\nSession.flush()  # emits INSERT\n\nassert new_obj.foo is foo_7  # now it loads\n```", "```py\nfrom sqlalchemy import inspect\n\ndef walk(obj):\n    deque = [obj]\n\n    seen = set()\n\n    while deque:\n        obj = deque.pop(0)\n        if obj in seen:\n            continue\n        else:\n            seen.add(obj)\n            yield obj\n        insp = inspect(obj)\n        for relationship in insp.mapper.relationships:\n            related = getattr(obj, relationship.key)\n            if relationship.uselist:\n                deque.extend(related)\n            elif related is not None:\n                deque.append(related)\n```", "```py\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    c_id = Column(ForeignKey(\"c.id\"))\n    c = relationship(\"C\", backref=\"bs\")\n\nclass C(Base):\n    __tablename__ = \"c\"\n    id = Column(Integer, primary_key=True)\n\na1 = A(bs=[B(), B(c=C())])\n\nfor obj in walk(a1):\n    print(obj)\n```", "```py\n<__main__.A object at 0x10303b190>\n<__main__.B object at 0x103025210>\n<__main__.B object at 0x10303b0d0>\n<__main__.C object at 0x103025490>\n```", "```py\nfrom sqlalchemy import create_engine, Column, Integer\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base(create_engine(\"sqlite://\"))\n\nclass Foo(Base):\n    __tablename__ = \"foo\"\n    id = Column(Integer, primary_key=True)\n\nBase.metadata.create_all()\n\nsession = sessionmaker()()\n\n# constraint violation\nsession.add_all([Foo(id=1), Foo(id=1)])\n\ntry:\n    session.commit()\nexcept:\n    # ignore error\n    pass\n\n# continue using session without rolling back\nsession.commit()\n```", "```py\ntry:\n    # <use session>\n    session.commit()\nexcept:\n    session.rollback()\n    raise\nfinally:\n    session.close()  # optional, depends on use case\n```", "```py\ntest=> create table foo(id integer primary key);\nNOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index \"foo_pkey\" for table \"foo\"\nCREATE TABLE\ntest=> begin;\nBEGIN\ntest=> insert into foo values(1);\nINSERT 0 1\ntest=> commit;\nCOMMIT\ntest=> begin;\nBEGIN\ntest=> insert into foo values(1);\nERROR:  duplicate key value violates unique constraint \"foo_pkey\"\ntest=> insert into foo values(2);\nERROR:  current transaction is aborted, commands ignored until end of transaction block\n```", "```py\nsess = Session()  # begins a logical transaction\ntry:\n    sess.flush()\n\n    sess.commit()\nexcept:\n    sess.rollback()\n```", "```py\ntest=> create table foo(id integer primary key);\nNOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index \"foo_pkey\" for table \"foo\"\nCREATE TABLE\ntest=> begin;\nBEGIN\ntest=> insert into foo values(1);\nINSERT 0 1\ntest=> commit;\nCOMMIT\ntest=> begin;\nBEGIN\ntest=> insert into foo values(1);\nERROR:  duplicate key value violates unique constraint \"foo_pkey\"\ntest=> insert into foo values(2);\nERROR:  current transaction is aborted, commands ignored until end of transaction block\n```", "```py\nsess = Session()  # begins a logical transaction\ntry:\n    sess.flush()\n\n    sess.commit()\nexcept:\n    sess.rollback()\n```", "```py\nq = session.query(User).outerjoin(User.addresses).filter(User.name == \"jack\")\n```", "```py\n>>> q.count()\n2\n```", "```py\n>>> q.all()\n[User(id=5, name='jack', ...)]\n```", "```py\n>>> session.query(User.id, User.name).outerjoin(User.addresses).filter(\n...     User.name == \"jack\"\n... ).all()\n[(5, 'jack'), (5, 'jack')]\n```", "```py\nclass Iterates:\n    def __len__(self):\n        print(\"LEN!\")\n        return 5\n\n    def __iter__(self):\n        print(\"ITER!\")\n        return iter([1, 2, 3, 4, 5])\n\nlist(Iterates())\n```", "```py\nITER!\nLEN!\n```", "```py\nfoo = session.get(Foo, 7)\no.foo = foo\nSession.commit()\n```", "```py\no = session.scalars(select(SomeClass).limit(1)).first()\n\n# assume the existing o.foo_id value is None;\n# accessing o.foo will reconcile this as ``None``, but will effectively\n# \"load\" the value of None\nassert o.foo is None\n\n# now set foo_id to something.  o.foo will not be immediately affected\no.foo_id = 7\n```", "```py\n# attribute is already \"loaded\" as None, has not been\n# reconciled with o.foo_id = 7 yet\nassert o.foo is None\n```", "```py\nsession.commit()  # expires all attributes\n\nfoo_7 = session.get(Foo, 7)\n\n# o.foo will lazyload again, this time getting the new object\nassert o.foo is foo_7\n```", "```py\no = session.scalars(select(SomeClass).limit(1)).first()\no.foo_id = 7\nSession.expire(o, [\"foo\"])  # object must be persistent for this\n\nfoo_7 = session.get(Foo, 7)\n\nassert o.foo is foo_7  # o.foo lazyloads on access\n```", "```py\nnew_obj = SomeClass()\nnew_obj.foo_id = 7\n\nSession.add(new_obj)\n\n# returns None but this is not a \"lazyload\", as the object is not\n# persistent in the DB yet, and the None value is not part of the\n# object's state\nassert new_obj.foo is None\n\nSession.flush()  # emits INSERT\n\nassert new_obj.foo is foo_7  # now it loads\n```", "```py\nfrom sqlalchemy import inspect\n\ndef walk(obj):\n    deque = [obj]\n\n    seen = set()\n\n    while deque:\n        obj = deque.pop(0)\n        if obj in seen:\n            continue\n        else:\n            seen.add(obj)\n            yield obj\n        insp = inspect(obj)\n        for relationship in insp.mapper.relationships:\n            related = getattr(obj, relationship.key)\n            if relationship.uselist:\n                deque.extend(related)\n            elif related is not None:\n                deque.append(related)\n```", "```py\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\", backref=\"a\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    c_id = Column(ForeignKey(\"c.id\"))\n    c = relationship(\"C\", backref=\"bs\")\n\nclass C(Base):\n    __tablename__ = \"c\"\n    id = Column(Integer, primary_key=True)\n\na1 = A(bs=[B(), B(c=C())])\n\nfor obj in walk(a1):\n    print(obj)\n```", "```py\n<__main__.A object at 0x10303b190>\n<__main__.B object at 0x103025210>\n<__main__.B object at 0x10303b0d0>\n<__main__.C object at 0x103025490>\n```"]