- en: Composing Mapped Hierarchies with Mixins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混合类组合映射层次结构
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html](https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html](https://docs.sqlalchemy.org/en/20/orm/declarative_mixins.html)
- en: A common need when mapping classes using the [Declarative](mapping_styles.html#orm-declarative-mapping)
    style is to share common functionality, such as particular columns, table or mapper
    options, naming schemes, or other mapped properties, across many classes. When
    using declarative mappings, this idiom is supported via the use of [mixin classes](../glossary.html#term-mixin-classes),
    as well as via augmenting the declarative base class itself.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[Declarative](mapping_styles.html#orm-declarative-mapping)风格映射类时，常见的需求是共享常见功能，例如特定列、表或映射器选项、命名方案或其他映射属性，跨多个类。在使用声明性映射时，可以通过使用[mixin类](../glossary.html#term-mixin-classes)，以及通过扩展声明性基类本身来支持此习惯用法。
- en: Tip
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In addition to mixin classes, common column options may also be shared among
    many classes using [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`
    types; see [Mapping Multiple Type Configurations to Python Types](declarative_tables.html#orm-declarative-mapped-column-type-map-pep593)
    and [Mapping Whole Column Declarations to Python Types](declarative_tables.html#orm-declarative-mapped-column-pep593)
    for background on these SQLAlchemy 2.0 features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了mixin类之外，还可以使用[**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`
    类型共享许多类的常见列选项；请参阅[将多种类型配置映射到Python类型](declarative_tables.html#orm-declarative-mapped-column-type-map-pep593)和[将整个列声明映射到Python类型](declarative_tables.html#orm-declarative-mapped-column-pep593)以获取有关这些SQLAlchemy
    2.0功能的背景信息。
- en: 'An example of some commonly mixed-in idioms is below:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的混合用法示例：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above example illustrates a class `MyModel` which includes two mixins `CommonMixin`
    and `HasLogRecord` in its bases, as well as a supplementary class `LogRecord`
    which also includes `CommonMixin`, demonstrating a variety of constructs that
    are supported on mixins and base classes, including:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例说明了一个类`MyModel`，它包括两个混合类`CommonMixin`和`HasLogRecord`，以及一个补充类`LogRecord`，该类也包括`CommonMixin`，演示了在混合类和基类上支持的各种构造，包括：
- en: columns declared using [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") are copied from mixins or base classes onto the target
    class to be mapped; above this is illustrated via the column attributes `CommonMixin.id`
    and `HasLogRecord.log_record_id`.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")、[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")声明的列将从混合类或基类复制到要映射的目标类；上面通过列属性`CommonMixin.id`和`HasLogRecord.log_record_id`说明了这一点。
- en: Declarative directives such as `__table_args__` and `__mapper_args__` can be
    assigned to a mixin or base class, where they will take effect automatically for
    any classes which inherit from the mixin or base. The above example illustrates
    this using the `__table_args__` and `__mapper_args__` attributes.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将声明性指令（如`__table_args__`和`__mapper_args__`）分配给混合类或基类，在继承混合类或基类的任何类中，这些指令将自动生效。上述示例使用`__table_args__`和`__mapper_args__`属性说明了这一点。
- en: All Declarative directives, including all of `__tablename__`, `__table__`, `__table_args__`
    and `__mapper_args__`, may be implemented using user-defined class methods, which
    are decorated with the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorator (specifically the [`declared_attr.directive`](mapping_api.html#sqlalchemy.orm.declared_attr.directive
    "sqlalchemy.orm.declared_attr.directive") sub-member, more on that in a moment).
    Above, this is illustrated using a `def __tablename__(cls)` classmethod that generates
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    name dynamically; when applied to the `MyModel` class, the table name will be
    generated as `"mymodel"`, and when applied to the `LogRecord` class, the table
    name will be generated as `"logrecord"`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的 Declarative 指令，包括 `__tablename__`、`__table__`、`__table_args__` 和 `__mapper_args__`，都可以使用用户定义的类方法来实现，这些方法使用了
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰器进行修饰（具体地说是 [`declared_attr.directive`](mapping_api.html#sqlalchemy.orm.declared_attr.directive
    "sqlalchemy.orm.declared_attr.directive") 子成员，稍后会详细介绍）。上面的示例使用了一个 `def __tablename__(cls)`
    类方法动态生成一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    名称；当应用到 `MyModel` 类时，表名将生成为 `"mymodel"`，而当应用到 `LogRecord` 类时，表名将生成为 `"logrecord"`。
- en: Other ORM properties such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") can be generated on the target class to be mapped
    using user-defined class methods also decorated with the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorator. Above, this is illustrated by generating
    a many-to-one [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to a mapped object called `LogRecord`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 ORM 属性，如 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，也可以通过在目标类上生成的用户定义的类方法来生成，并且这些类方法也使用了 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 装饰器进行修饰。上面的例子演示了通过生成一个多对一的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 到一个名为 `LogRecord` 的映射对象来实现此功能。
- en: 'The features above may all be demonstrated using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述功能都可以使用 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 示例进行演示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The examples of [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") will attempt to illustrate the correct [**PEP
    484**](https://peps.python.org/pep-0484/) annotations for each method example.
    The use of annotations with [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions are **completely optional**, and are
    not consumed by Declarative; however, these annotations are required in order
    to pass Mypy `--strict` type checking.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    的示例将尝试说明每个方法示例的正确的 [**PEP 484**](https://peps.python.org/pep-0484/) 注解。使用 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 函数的注解是**完全可选**的，并且不会被 Declarative 消耗；然而，为了通过 Mypy
    的 `--strict` 类型检查，这些注解是必需的。'
- en: Additionally, the [`declared_attr.directive`](mapping_api.html#sqlalchemy.orm.declared_attr.directive
    "sqlalchemy.orm.declared_attr.directive") sub-member illustrated above is optional
    as well, and is only significant for [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools, as it adjusts for the expected return type when creating methods
    to override Declarative directives such as `__tablename__`, `__mapper_args__`
    and `__table_args__`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，上面所示的 [`declared_attr.directive`](mapping_api.html#sqlalchemy.orm.declared_attr.directive
    "sqlalchemy.orm.declared_attr.directive") 子成员也是可选的，它只对 [**PEP 484**](https://peps.python.org/pep-0484/)
    类型工具有意义，因为它调整了创建用于重写 Declarative 指令的方法时的期望返回类型，例如 `__tablename__`、`__mapper_args__`
    和 `__table_args__`。
- en: 'New in version 2.0: As part of [**PEP 484**](https://peps.python.org/pep-0484/)
    typing support for the SQLAlchemy ORM, added the [`declared_attr.directive`](mapping_api.html#sqlalchemy.orm.declared_attr.directive
    "sqlalchemy.orm.declared_attr.directive") to [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to distinguish between [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") attributes and Declarative configurational attributes'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中新增：作为 SQLAlchemy ORM 的 [**PEP 484**](https://peps.python.org/pep-0484/)
    类型支持的一部分，添加了 [`declared_attr.directive`](mapping_api.html#sqlalchemy.orm.declared_attr.directive
    "sqlalchemy.orm.declared_attr.directive") 来将 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 区分为 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 属性和声明性配置属性之间的区别。
- en: 'There’s no fixed convention for the order of mixins and base classes. Normal
    Python method resolution rules apply, and the above example would work just as
    well with:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类和基类的顺序没有固定的约定。普通的 Python 方法解析规则适用，上述示例也同样适用：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works because `Base` here doesn’t define any of the variables that `CommonMixin`
    or `HasLogRecord` defines, i.e. `__tablename__`, `__table_args__`, `id`, etc.
    If the `Base` did define an attribute of the same name, the class placed first
    in the inherits list would determine which attribute is used on the newly defined
    class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这里的 `Base` 没有定义 `CommonMixin` 或 `HasLogRecord` 定义的任何变量，即 `__tablename__`、`__table_args__`、`id`
    等。如果 `Base` 定义了同名属性，则位于继承列表中的第一个类将决定在新定义的类上使用哪个属性。
- en: Tip
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: While the above example is using [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    form based on the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation class, mixin classes also work perfectly well with non-annotated and
    legacy Declarative forms, such as when using [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly instead of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column").
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述示例使用了基于 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    注解类的[注释声明表](declarative_tables.html#orm-declarative-mapped-column)形式，但混合类与非注释和遗留声明形式也完全兼容，比如直接使用
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    而不是 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    时。
- en: 'Changed in version 2.0: For users coming from the 1.4 series of SQLAlchemy
    who may have been using the [mypy plugin](extensions/mypy.html), the [`declarative_mixin()`](mapping_api.html#sqlalchemy.orm.declarative_mixin
    "sqlalchemy.orm.declarative_mixin") class decorator is no longer needed to mark
    declarative mixins, assuming the mypy plugin is no longer in use.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：对于从 SQLAlchemy 1.4 系列迁移到的用户可能一直在使用 [mypy 插件](extensions/mypy.html)，不再需要使用
    [`declarative_mixin()`](mapping_api.html#sqlalchemy.orm.declarative_mixin "sqlalchemy.orm.declarative_mixin")
    类装饰器来标记声明性混合类，假设不再使用 mypy 插件。
- en: Augmenting the Base
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩充基类
- en: 'In addition to using a pure mixin, most of the techniques in this section can
    also be applied to the base class directly, for patterns that should apply to
    all classes derived from a particular base. The example below illustrates some
    of the previous section’s example in terms of the `Base` class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用纯混合类之外，本节中的大多数技术也可以直接应用于基类，用于适用于从特定基类派生的所有类的模式。下面的示例演示了上一节中的一些示例在 `Base`
    类方面的情况：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Where above, `MyModel` as well as `LogRecord`, in deriving from `Base`, will
    both have their table name derived from their class name, a primary key column
    named `id`, as well as the above table and mapper arguments defined by `Base.__table_args__`
    and `Base.__mapper_args__`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，`MyModel` 以及 `LogRecord`，在从 `Base` 派生时，它们的表名都将根据其类名派生，一个名为 `id` 的主键列，以及由
    `Base.__table_args__` 和 `Base.__mapper_args__` 定义的上述表和映射器参数。
- en: 'When using legacy [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"), the [`declarative_base.cls`](mapping_api.html#sqlalchemy.orm.declarative_base.params.cls
    "sqlalchemy.orm.declarative_base") parameter may be used as follows to generate
    an equivalent effect, as illustrated in the non-annotated example below:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用遗留 [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 或 [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base") 时，可以像下面的非注释示例中所示使用 [`declarative_base.cls`](mapping_api.html#sqlalchemy.orm.declarative_base.params.cls
    "sqlalchemy.orm.declarative_base") 参数来生成等效效果：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Mixing in Columns
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合列
- en: 'Columns can be indicated in mixins assuming the [Declarative table](declarative_tables.html#orm-declarative-table)
    style of configuration is in use (as opposed to [imperative table](declarative_tables.html#orm-imperative-table-configuration)
    configuration), so that columns declared on the mixin can then be copied to be
    part of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that the Declarative process generates. All three of the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") constructs may be declared inline in a declarative
    mixin:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用[声明式表](declarative_tables.html#orm-declarative-table) 风格的配置（而不是[命令式表](declarative_tables.html#orm-imperative-table-configuration)
    配置），则可以在混合中指定列，以便混合中声明的列随后将被复制为声明式进程生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的一部分。在声明式混合中可以内联声明三种构造：[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")、[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Where above, all declarative classes that include `TimestampMixin` in their
    class bases will automatically include a column `created_at` that applies a timestamp
    to all row insertions, as well as an `updated_at` column, which does not include
    a default for the purposes of the example (if it did, we would use the [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameter which is accepted by [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")). These column constructs are always **copied
    from the originating mixin or base class**, so that the same mixin/base class
    may be applied to any number of target classes which will each have their own
    column constructs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述位置，所有包含`TimestampMixin`在其类基础中的声明性类将自动包含一个应用于所有行插入的时间戳的列`created_at`，以及一个`updated_at`列，该列不包含示例目的的默认值（如果有的话，我们将使用[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 参数，该参数由[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 接受）。这些列结构始终是**从原始混合或基类复制**的，因此相同的混合/基类可以应用于任意数量的目标类，每个目标类都将具有自己的列结构。
- en: 'All Declarative column forms are supported by mixins, including:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声明式列形式都受混合支持，包括：
- en: '**Annotated attributes** - with or without [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") present:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有注解的属性** - 无论是否存在[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")：'
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**mapped_column** - with or without [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") present:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mapped_column** - 无论是否存在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")：'
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Column** - legacy Declarative form:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列** - 传统的声明式形式：'
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In each of the above forms, Declarative handles the column-based attributes
    on the mixin class by creating a **copy** of the construct, which is then applied
    to the target class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述每种形式中，声明式通过创建构造的**副本**来处理混合类上的基于列的属性，然后将其应用于目标类。
- en: 'Changed in version 2.0: The declarative API can now accommodate [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects as well as [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs of any form when using mixins without
    the need to use [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr"). Previous limitations which prevented columns
    with [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    elements from being used directly in mixins have been removed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 2.0 起更改：声明式 API 现在可以容纳[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象以及使用混合时的任何形式的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造，而无需使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")。已经删除了以前的限制，该限制阻止具有[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 元素的列直接在混合中使用。
- en: '## Mixing in Relationships'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '## 混入关系'
- en: 'Relationships created by [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") are provided with declarative mixin classes exclusively
    using the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    approach, eliminating any ambiguity which could arise when copying a relationship
    and its possibly column-bound contents. Below is an example which combines a foreign
    key column and a relationship so that two classes `Foo` and `Bar` can both be
    configured to reference a common target class via many-to-one:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")创建的关系，仅使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")方法提供声明性混合类，从而消除了复制关系及其可能绑定到列的内容时可能出现的任何歧义。下面是一个示例，其中结合了外键列和关系，以便两个类`Foo`和`Bar`都可以通过多对一引用到一个公共目标类：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the above mapping, each of `Foo` and `Bar` contain a relationship to `Target`
    accessed along the `.target` attribute:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的映射，`Foo`和`Bar`中的每一个都包含一个访问`.target`属性的到`Target`的关系：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Special arguments such as [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") may also be used within mixed-in classmethods,
    which often need to refer to the class that’s being mapped. For schemes that need
    to refer to locally mapped columns, in ordinary cases these columns are made available
    by Declarative as attributes on the mapped class which is passed as the `cls`
    argument to the decorated classmethod. Using this feature, we could for example
    rewrite the `RefTargetMixin.target` method using an explicit primaryjoin which
    refers to pending mapped columns on both `Target` and `cls`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊参数，比如[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")，也可以在混合类方法中使用，这些方法通常需要引用正在映射的类。对于需要引用本地映射列的方案，在普通情况下，这些列将作为Declarative的属性在映射类上提供，并作为传递给装饰类方法的`cls`参数。利用这个特性，我们可以例如重新编写`RefTargetMixin.target`方法，使用明确的primaryjoin，它引用了`Target`和`cls`上的待定映射列：
- en: '[PRE11]  ## Mixing in [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") classes'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]  ## 混合使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 和其他 [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") 类'
- en: 'Like [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship"),
    other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    subclasses such as [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") also need to have class-local copies generated
    when used by mixins, so are also declared within functions that are decorated
    by [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr").
    Within the function, other ordinary mapped columns that were declared with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be made available from the `cls` argument so
    that they may be used to compose new attributes, as in the example below which
    adds two columns together:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 像[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")一样，其他的[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")子类，比如[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")，在混合使用时也需要生成类本地副本，因此也在被[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰的函数中声明。在函数内部，使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")、[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")声明的其他普通映射列将从`cls`参数中提供，以便可以用于组合新的属性，如下面的示例，将两列相加：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Above, we may make use of `Something.x_plus_y` in a statement where it produces
    the full expression:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们可以在语句中使用`Something.x_plus_y`，产生完整的表达式：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    decorator causes the decorated callable to behave exactly as a classmethod. However,
    typing tools like [Pylance](https://github.com/microsoft/pylance-release) may
    not be able to recognize this, which can sometimes cause it to complain about
    access to the `cls` variable inside the body of the function. To resolve this
    issue when it occurs, the `@classmethod` decorator may be combined directly with
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    as:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰器使装饰的可调用对象的行为与类方法完全相同。然而，像[Pylance](https://github.com/microsoft/pylance-release)这样的类型工具可能无法识别这一点，有时会因为无法访问函数体内的
    `cls` 变量而抱怨。要解决此问题，当发生时，可以直接将 `@classmethod` 装饰器与[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 结合使用，如下所示：'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'New in version 2.0: - [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") can accommodate a function decorated with `@classmethod`
    to help with [**PEP 484**](https://peps.python.org/pep-0484/) integration where
    needed.  ## Using Mixins and Base Classes with Mapped Inheritance Patterns'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本2.0中：- [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    可以适应使用 `@classmethod` 装饰的函数来协助[**PEP 484**](https://peps.python.org/pep-0484/)集成的需要。##
    使用混合和基类进行映射继承模式
- en: When dealing with mapper inheritance patterns as documented at [Mapping Class
    Inheritance Hierarchies](inheritance.html), some additional capabilities are present
    when using [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    either with mixin classes, or when augmenting both mapped and un-mapped superclasses
    in a class hierarchy.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理如[映射类继承层次结构](inheritance.html)中记录的映射器继承模式时，当使用 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 时，可以使用一些附加功能，无论是与混合类一起使用，还是在类层次结构中增加映射和未映射的超类时。
- en: When defining functions decorated by [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") on mixins or base classes to be interpreted by
    subclasses in a mapped inheritance hierarchy, there is an important distinction
    made between functions that generate the special names used by Declarative such
    as `__tablename__`, `__mapper_args__` vs. those that may generate ordinary mapped
    attributes such as [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). Functions that define **Declarative directives**
    are **invoked for each subclass in a hierarchy**, whereas functions that generate
    **mapped attributes** are **invoked only for the first mapped superclass in a
    hierarchy**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当在映射继承层次结构中由子类解释的函数由[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰在混合或基类上定义时，必须区分两种情况，即生成 Declarative 使用的特殊名称如
    `__tablename__`、`__mapper_args__` 与生成普通映射属性如[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 和[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。定义 **Declarative 指令** 的函数会 **在层次结构中的每个子类中调用**，而生成
    **映射属性** 的函数只会 **在层次结构中的第一个映射的超类中调用**。
- en: The rationale for this difference in behavior is based on the fact that mapped
    properties are already inheritable by classes, such as a particular column on
    a superclass’ mapped table should not be duplicated to that of a subclass as well,
    whereas elements that are specific to a particular class or its mapped table are
    not inheritable, such as the name of the table that is locally mapped.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为差异的基本原理是，映射属性已经可以被类继承，例如，超类映射表上的特定列不应该在子类中重复出现，而特定于特定类或其映射表的元素不可继承，例如，局部映射的表的名称。
- en: The difference in behavior between these two use cases is demonstrated in the
    following two sections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种用例之间行为上的差异在以下两个部分中得到了展示。
- en: Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with inheriting [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    arguments
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")结合继承的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")参数
- en: A common recipe with mixins is to create a `def __tablename__(cls)` function
    that generates a name for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") dynamically.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 mixin 的一个常见方法是创建一个 `def __tablename__(cls)` 函数，动态生成映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 名称。
- en: 'This recipe can be used to generate table names for an inheriting mapper hierarchy
    as in the example below which creates a mixin that gives every class a simple
    table name based on class name. The recipe is illustrated below where a table
    name is generated for the `Person` mapped class and the `Engineer` subclass of
    `Person`, but not for the `Manager` subclass of `Person`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以用于生成继承映射层次结构中的表名称，就像下面的示例一样，该示例创建一个 mixin，根据类名给每个类生成一个简单的表名称。下面的示例说明了如何为
    `Person` 映射类和 `Person` 的 `Engineer` 子类生成表名称，但不为 `Person` 的 `Manager` 子类生成表名称：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the above example, both the `Person` base class as well as the `Engineer`
    class, being subclasses of the `Tablename` mixin class which generates new table
    names, will have a generated `__tablename__` attribute, which to Declarative indicates
    that each class should have its own [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") generated to which it will be mapped. For the `Engineer`
    subclass, the style of inheritance applied is [joined table inheritance](inheritance.html#joined-inheritance),
    as it will be mapped to a table `engineer` that joins to the base `person` table.
    Any other subclasses that inherit from `Person` will also have this style of inheritance
    applied by default (and within this particular example, would need to each specify
    a primary key column; more on that in the next section).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`Person` 基类和 `Engineer` 类都是 `Tablename` mixin 类的子类，该类生成新的表名称，因此它们都将具有生成的
    `__tablename__` 属性。对于 Declarative，这意味着每个类都应该有自己的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 生成，并将其映射到其中。对于 `Engineer` 子类，所应用的继承风格是[联合表继承](inheritance.html#joined-inheritance)，因为它将映射到一个与基本
    `person` 表连接的 `engineer` 表。从 `Person` 继承的任何其他子类也将默认应用此继承风格（在此特定示例中，每个子类都需要指定一个主键列；关于这一点，后面会详细介绍）。
- en: By contrast, the `Manager` subclass of `Person` **overrides** the `__tablename__`
    classmethod to return `None`. This indicates to Declarative that this class should
    **not** have a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    generated, and will instead make use exclusively of the base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `Person` is mapped. For the `Manager` subclass,
    the style of inheritance applied is [single table inheritance](inheritance.html#single-inheritance).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Person` 的 `Manager` 子类**覆盖**了 `__tablename__` 类方法，将其返回值设为 `None`。这表明对于
    Declarative 来说，该类**不应**生成一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，而应仅使用 `Person` 映射到的基本 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。对于 `Manager` 子类，所应用的继承风格是[单表继承](inheritance.html#single-inheritance)。
- en: The example above illustrates that Declarative directives like `__tablename__`
    are necessarily **applied to each subclass** individually, as each mapped class
    needs to state which [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    it will be mapped towards, or if it will map itself to the inheriting superclass’
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例说明了 Declarative 指令（如 `__tablename__`）必须**分别应用于每个子类**，因为每个映射类都需要说明将映射到哪个
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，或者是否将自身映射到继承的超类的
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")。
- en: 'If we instead wanted to **reverse** the default table scheme illustrated above,
    so that single table inheritance were the default and joined table inheritance
    could be defined only when a `__tablename__` directive were supplied to override
    it, we can make use of Declarative helpers within the top-most `__tablename__()`
    method, in this case a helper called [`has_inherited_table()`](mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table"). This function will return `True` if a superclass
    is already mapped to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). We may use this helper within the base-most `__tablename__()`
    classmethod so that we may **conditionally** return `None` for the table name,
    if a table is already present, thus indicating single-table inheritance for inheriting
    subclasses by default:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望**反转**上面说明的默认表方案，使得单表继承成为默认，只有在提供了 `__tablename__` 指令以覆盖它时才能定义连接表继承，我们可以在顶级
    `__tablename__()` 方法中使用 Declarative 助手，本例中称为 [`has_inherited_table()`](mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table")。此函数将返回 `True` 如果超类已经映射到一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。我们可以在基类中的最低级 `__tablename__()` 类方法中使用此辅助函数，以便我们**有条件地**如果表已经存在，则返回
    `None` 作为表名，从而默认为继承子类的单表继承：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '### Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to generate table-specific inheriting columns'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    生成特定于表的继承列'
- en: 'In contrast to how `__tablename__` and other special names are handled when
    used with [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr"),
    when we mix in columns and properties (e.g. relationships, column properties,
    etc.), the function is invoked for the **base class only** in the hierarchy, unless
    the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    directive is used in combination with the [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") sub-directive. Below, only the `Person`
    class will receive a column called `id`; the mapping will fail on `Engineer`,
    which is not given a primary key:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与在与 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    一起使用时如何处理 `__tablename__` 和其他特殊名称不同，当我们混入列和属性（例如关系、列属性等）时，该函数仅在层次结构中的**基类**调用，除非结合使用
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    指令和 [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") 子指令。在下面的示例中，只有 `Person` 类将收到名为 `id`
    的列；对于未给出主键的 `Engineer`，映射将失败：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is usually the case in joined-table inheritance that we want distinctly
    named columns on each subclass. However in this case, we may want to have an `id`
    column on every table, and have them refer to each other via foreign key. We can
    achieve this as a mixin by using the [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") modifier, which indicates that the function
    should be invoked **for each class in the hierarchy**, in *almost* (see warning
    below) the same way as it does for `__tablename__`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接表继承中，通常情况下我们希望每个子类具有不同命名的列。然而在这种情况下，我们可能希望每个表上都有一个 `id` 列，并且通过外键相互引用。我们可以通过使用
    [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") 修饰符作为 mixin 来实现这一点，该修饰符表示应该**对层次结构中的每个类**调用该函数，几乎（见下面的警告）与对
    `__tablename__` 调用方式相同：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Warning
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") feature currently does **not** allow
    for a subclass to override the attribute with a different function or value. This
    is a current limitation in the mechanics of how `@declared_attr` is resolved,
    and a warning is emitted if this condition is detected. This limitation only applies
    to ORM mapped columns, relationships, and other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") styles of attribute. It does **not** apply to
    Declarative directives such as `__tablename__`, `__mapper_args__`, etc., which
    resolve in a different way internally than that of [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading").
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") 功能**不允许**子类使用不同的函数或值覆盖属性。这是在如何解析 `@declared_attr`
    的机制中的当前限制，并且如果检测到此条件，则会发出警告。此限制仅适用于 ORM 映射的列、关系和其他属性的[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")风格。它**不**适用于诸如 `__tablename__`、`__mapper_args__`
    等的声明性指令，这些指令在内部以与[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")不同的方式解析。
- en: Combining Table/Mapper Arguments from Multiple Mixins
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个混合类组合表/映射器参数
- en: 'In the case of `__table_args__` or `__mapper_args__` specified with declarative
    mixins, you may want to combine some parameters from several mixins with those
    you wish to define on the class itself. The [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorator can be used here to create user-defined
    collation routines that pull from multiple collections:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用声明性混合类指定 `__table_args__` 或 `__mapper_args__` 时，您可能希望将一些参数从多个混合类中与您希望在类本身上定义的参数结合起来。可以在这里使用
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰器来创建用户定义的排序例程，该例程从多个集合中提取：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '## Creating Indexes and Constraints with Naming Conventions on Mixins'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '## 在混合类上使用命名约定创建索引和约束'
- en: Using named constraints such as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), where each object is to be unique to a specific
    table descending from a mixin, requires that an individual instance of each object
    is created per actual mapped class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有命名约束的使用，如 [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")，其中每个对象应该是唯一的，针对从混合类派生的特定表，需要为每个实际映射的类创建每个对象的单独实例。
- en: 'As a simple example, to define a named, potentially multicolumn [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") that applies to all tables derived from a mixin, use
    the “inline” form of [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") and establish it as part of `__table_args__`, using
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    to establish `__table_args__()` as a class method that will be invoked for each
    subclass:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的示例，要定义一个命名的、可能是多列的 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")，该索引适用于从混合类派生的所有表，可以使用 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 的“内联”形式，并将其建立为 `__table_args__` 的一部分，使用 [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 来建立 `__table_args__()` 作为一个类方法，该方法将被每个子类调用：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The above example would generate two tables `"table_a"` and `"table_b"`, with
    indexes `"test_idx_table_a"` and `"test_idx_table_b"`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例将生成两个表 `"table_a"` 和 `"table_b"`，其中包含索引 `"test_idx_table_a"` 和 `"test_idx_table_b"`
- en: 'Typically, in modern SQLAlchemy we would use a naming convention, as documented
    at [Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions).
    While naming conventions take place automatically using the [`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") as new [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects are created, as this convention is applied
    at object construction time based on the parent [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for a particular [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint"), a distinct [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") object needs to be created for each inheriting
    subclass with its own [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), again using [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") with `__table_args__()`, below illustrated using
    an abstract mapped base:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在现代 SQLAlchemy 中，我们会使用一种命名约定，如在[配置约束命名约定](../core/constraints.html#constraint-naming-conventions)中记录的那样。虽然命名约定会在创建新的[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象时自动进行，因为此约定是在基于特定[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")的父[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的对象构造时间应用的，因此需要为每个继承子类创建一个不同的[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象，并再次使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")与`__table_args__()`，下面通过使用抽象映射基类进行说明：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The above mapping will generate DDL that includes table-specific names for
    all constraints, including primary key, CHECK constraint, unique constraint:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将生成包含所有约束的表特定名称的 DDL，包括主键、CHECK 约束、唯一约束：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Augmenting the Base
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强基类
- en: 'In addition to using a pure mixin, most of the techniques in this section can
    also be applied to the base class directly, for patterns that should apply to
    all classes derived from a particular base. The example below illustrates some
    of the previous section’s example in terms of the `Base` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用纯混合外，本节中的大多数技术也可以直接应用于基类，用于适用于从特定基类派生的所有类的模式。下面的示例说明了如何在`Base`类方面应用上一节的一些示例：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Where above, `MyModel` as well as `LogRecord`, in deriving from `Base`, will
    both have their table name derived from their class name, a primary key column
    named `id`, as well as the above table and mapper arguments defined by `Base.__table_args__`
    and `Base.__mapper_args__`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`MyModel` 和 `LogRecord`，在派生自`Base`时，它们的表名都将根据其类名派生，一个名为`id`的主键列，以及由`Base.__table_args__`和`Base.__mapper_args__`定义的上述表和映射器参数。
- en: 'When using legacy [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"), the [`declarative_base.cls`](mapping_api.html#sqlalchemy.orm.declarative_base.params.cls
    "sqlalchemy.orm.declarative_base") parameter may be used as follows to generate
    an equivalent effect, as illustrated in the non-annotated example below:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用旧版[`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")或[`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")时，可以使用[`declarative_base.cls`](mapping_api.html#sqlalchemy.orm.declarative_base.params.cls
    "sqlalchemy.orm.declarative_base")参数来生成等效效果，如下所示的未注释示例：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Mixing in Columns
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合列
- en: 'Columns can be indicated in mixins assuming the [Declarative table](declarative_tables.html#orm-declarative-table)
    style of configuration is in use (as opposed to [imperative table](declarative_tables.html#orm-imperative-table-configuration)
    configuration), so that columns declared on the mixin can then be copied to be
    part of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that the Declarative process generates. All three of the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), and [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") constructs may be declared inline in a declarative
    mixin:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用[声明式表](declarative_tables.html#orm-declarative-table)的配置风格（而不是[命令式表](declarative_tables.html#orm-imperative-table-configuration)配置），则可以在混合类中指示列，以便在声明式过程生成的
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的一部分。可以在声明式混合类中内联声明三种构造：[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")、[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 和 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Where above, all declarative classes that include `TimestampMixin` in their
    class bases will automatically include a column `created_at` that applies a timestamp
    to all row insertions, as well as an `updated_at` column, which does not include
    a default for the purposes of the example (if it did, we would use the [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") parameter which is accepted by [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")). These column constructs are always **copied
    from the originating mixin or base class**, so that the same mixin/base class
    may be applied to any number of target classes which will each have their own
    column constructs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，所有包括 `TimestampMixin` 在其类基类中的声明式类将自动包含一个名为 `created_at` 的列，该列对所有行插入应用时间戳，以及一个名为
    `updated_at` 的列，该列不包含默认值以示例为目的（如果有的话，我们将使用 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 参数，该参数被 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 接受）。这些列构造始终从源混合类或基类**复制**，因此可以将相同的混合类/基类应用于任意数量的目标类，每个目标类都将有自己的列构造。
- en: 'All Declarative column forms are supported by mixins, including:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声明式列形式都受到混合类的支持，包括：
- en: '**Annotated attributes** - with or without [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") present:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带注释的属性** - 无论是否存在 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")：'
- en: '[PRE26]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**mapped_column** - with or without [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") present:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mapped_column** - 无论是否存在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")：'
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Column** - legacy Declarative form:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Column** - 传统的声明式形式：'
- en: '[PRE28]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In each of the above forms, Declarative handles the column-based attributes
    on the mixin class by creating a **copy** of the construct, which is then applied
    to the target class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述每种形式中，声明式通过创建构造的**副本**来处理混合类上的基于列的属性，然后将其应用于目标类。
- en: 'Changed in version 2.0: The declarative API can now accommodate [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects as well as [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs of any form when using mixins without
    the need to use [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr"). Previous limitations which prevented columns
    with [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    elements from being used directly in mixins have been removed.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本 2.0 中的变化**：声明式 API 现在可以接受 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象以及任何形式的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造，当使用混合类时无需使用 [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")。已经移除了以前的限制，这些限制阻止直接在混合类中使用具有 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 元素的列。'
- en: '## Mixing in Relationships'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '## 混入关系'
- en: 'Relationships created by [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") are provided with declarative mixin classes exclusively
    using the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    approach, eliminating any ambiguity which could arise when copying a relationship
    and its possibly column-bound contents. Below is an example which combines a foreign
    key column and a relationship so that two classes `Foo` and `Bar` can both be
    configured to reference a common target class via many-to-one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")创建的关系通过[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")方法提供的声明式混合类，排除了在复制关系及其可能与列绑定的内容时可能出现的任何歧义。下面是一个示例，将外键列和关系组合在一起，以便两个类`Foo`和`Bar`都可以配置为通过多对一引用一个共同的目标类：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the above mapping, each of `Foo` and `Bar` contain a relationship to `Target`
    accessed along the `.target` attribute:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，每个`Foo`和`Bar`都包含一个到`Target`的关系，通过`.target`属性访问：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Special arguments such as [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") may also be used within mixed-in classmethods,
    which often need to refer to the class that’s being mapped. For schemes that need
    to refer to locally mapped columns, in ordinary cases these columns are made available
    by Declarative as attributes on the mapped class which is passed as the `cls`
    argument to the decorated classmethod. Using this feature, we could for example
    rewrite the `RefTargetMixin.target` method using an explicit primaryjoin which
    refers to pending mapped columns on both `Target` and `cls`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")的特殊参数也可以在混入的classmethod中使用，这些参数通常需要引用正在映射的类。对于需要引用本地映射列的方案，在普通情况下，这些列通过Declarative作为映射类的属性提供，该类作为参数`cls`传递给修饰的classmethod。使用此功能，我们可以例如使用显式的primaryjoin重写`RefTargetMixin.target`方法，该方法引用了`Target`和`cls`上的待定映射列：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '## Mixing in [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") classes'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '## 混合使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")和其他[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")类'
- en: 'Like [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship"),
    other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    subclasses such as [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") also need to have class-local copies generated
    when used by mixins, so are also declared within functions that are decorated
    by [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr").
    Within the function, other ordinary mapped columns that were declared with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be made available from the `cls` argument so
    that they may be used to compose new attributes, as in the example below which
    adds two columns together:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")类似，其他[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")子类，如[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")在被混合使用时也需要生成类局部副本，因此在被[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")修饰的函数内声明。在该函数内，使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")、[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")声明的其他普通映射列将从`cls`参数中提取，以便它们可以被用来组合新的属性，如下例所示，将两个列相加：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Above, we may make use of `Something.x_plus_y` in a statement where it produces
    the full expression:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以在生成完整表达式的语句中使用`Something.x_plus_y`：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    decorator causes the decorated callable to behave exactly as a classmethod. However,
    typing tools like [Pylance](https://github.com/microsoft/pylance-release) may
    not be able to recognize this, which can sometimes cause it to complain about
    access to the `cls` variable inside the body of the function. To resolve this
    issue when it occurs, the `@classmethod` decorator may be combined directly with
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")装饰器使装饰的可调用对象表现得完全像一个类方法。然而，像[Pylance](https://github.com/microsoft/pylance-release)这样的类型工具可能无法识别这一点，这有时会导致它在函数体内部抱怨无法访问`cls`变量。当出现此问题时，可以直接将`@classmethod`装饰器与[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")结合使用来解决：'
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'New in version 2.0: - [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") can accommodate a function decorated with `@classmethod`
    to help with [**PEP 484**](https://peps.python.org/pep-0484/) integration where
    needed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本2.0中：- [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")可以容纳使用`@classmethod`装饰的函数，以帮助需要的[**PEP
    484**](https://peps.python.org/pep-0484/)集成。
- en: '## Using Mixins and Base Classes with Mapped Inheritance Patterns'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用混合类和基类与映射继承模式'
- en: When dealing with mapper inheritance patterns as documented at [Mapping Class
    Inheritance Hierarchies](inheritance.html), some additional capabilities are present
    when using [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    either with mixin classes, or when augmenting both mapped and un-mapped superclasses
    in a class hierarchy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理[映射类继承层次结构](inheritance.html)中所记录的映射继承模式时，使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")时，无论是使用混合类还是在类层次结构中增加映射和非映射的超类时，都会存在一些额外的功能。
- en: When defining functions decorated by [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") on mixins or base classes to be interpreted by
    subclasses in a mapped inheritance hierarchy, there is an important distinction
    made between functions that generate the special names used by Declarative such
    as `__tablename__`, `__mapper_args__` vs. those that may generate ordinary mapped
    attributes such as [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). Functions that define **Declarative directives**
    are **invoked for each subclass in a hierarchy**, whereas functions that generate
    **mapped attributes** are **invoked only for the first mapped superclass in a
    hierarchy**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当在混合类或基类上定义由[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰的函数，以便由映射继承层次结构中的子类解释时，有一个重要的区别是函数生成特殊名称（例如`__tablename__`、`__mapper_args__`）与生成普通映射属性（例如[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")）之间的区别。定义**声明性指令**的函数在层次结构中的每个子类中都会被**调用**，而生成**映射属性**的函数仅在层次结构中的第一个映射的超类中被**调用**。
- en: The rationale for this difference in behavior is based on the fact that mapped
    properties are already inheritable by classes, such as a particular column on
    a superclass’ mapped table should not be duplicated to that of a subclass as well,
    whereas elements that are specific to a particular class or its mapped table are
    not inheritable, such as the name of the table that is locally mapped.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为差异的原理是映射属性已经可以被类继承，例如，超类映射表上的特定列不应该重复到子类中，而特定于特定类或其映射表的元素不可继承，例如本地映射的表名。
- en: The difference in behavior between these two use cases is demonstrated in the
    following two sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种用例之间行为上的差异在以下两个部分中得到展示。
- en: Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with inheriting [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    arguments
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有继承[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")和[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")参数的[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")
- en: A common recipe with mixins is to create a `def __tablename__(cls)` function
    that generates a name for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") dynamically.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合类的常见方法是创建一个`def __tablename__(cls)`函数，动态生成映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的名称。
- en: 'This recipe can be used to generate table names for an inheriting mapper hierarchy
    as in the example below which creates a mixin that gives every class a simple
    table name based on class name. The recipe is illustrated below where a table
    name is generated for the `Person` mapped class and the `Engineer` subclass of
    `Person`, but not for the `Manager` subclass of `Person`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方可用于为继承映射器层次结构生成表名，如下例所示，该示例创建了一个混合类，根据类名为每个类提供一个简单的表名。下面的示例说明了这个配方，在这个示例中为`Person`映射类和`Person`的子类`Engineer`生成了一个表名，但没有为`Person`的子类`Manager`生成表名：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the above example, both the `Person` base class as well as the `Engineer`
    class, being subclasses of the `Tablename` mixin class which generates new table
    names, will have a generated `__tablename__` attribute, which to Declarative indicates
    that each class should have its own [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") generated to which it will be mapped. For the `Engineer`
    subclass, the style of inheritance applied is [joined table inheritance](inheritance.html#joined-inheritance),
    as it will be mapped to a table `engineer` that joins to the base `person` table.
    Any other subclasses that inherit from `Person` will also have this style of inheritance
    applied by default (and within this particular example, would need to each specify
    a primary key column; more on that in the next section).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`Person`基类以及`Engineer`类，作为生成新表名的`Tablename`混合类的子类，都将有一个生成的`__tablename__`属性，这对于
    Declarative 表示每个类应该有自己的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")生成并映射到它。对于`Engineer`子类，应用的继承风格是[联接表继承](inheritance.html#joined-inheritance)，因为它将映射到一个与基本`person`表连接的`engineer`表。从`Person`继承的任何其他子类也将默认应用这种继承风格（在这个特定示例中，需要为每个子类指定一个主键列；在下一节中会详细介绍）。
- en: By contrast, the `Manager` subclass of `Person` **overrides** the `__tablename__`
    classmethod to return `None`. This indicates to Declarative that this class should
    **not** have a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    generated, and will instead make use exclusively of the base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `Person` is mapped. For the `Manager` subclass,
    the style of inheritance applied is [single table inheritance](inheritance.html#single-inheritance).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Person`的子类`Manager` **覆盖** 了`__tablename__`类方法以返回`None`。这告诉 Declarative
    这个类 **不应** 生成一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，而应该完全使用`Person`映射到的基本[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。对于`Manager`子类，应用的继承风格是[单表继承](inheritance.html#single-inheritance)。
- en: The example above illustrates that Declarative directives like `__tablename__`
    are necessarily **applied to each subclass** individually, as each mapped class
    needs to state which [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    it will be mapped towards, or if it will map itself to the inheriting superclass’
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例说明了 Declarative 指令如`__tablename__`必须**分别应用于每个子类**，因为每个映射类都需要声明将映射到哪个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，或者是否将自身映射到继承的超类的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。
- en: 'If we instead wanted to **reverse** the default table scheme illustrated above,
    so that single table inheritance were the default and joined table inheritance
    could be defined only when a `__tablename__` directive were supplied to override
    it, we can make use of Declarative helpers within the top-most `__tablename__()`
    method, in this case a helper called [`has_inherited_table()`](mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table"). This function will return `True` if a superclass
    is already mapped to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). We may use this helper within the base-most `__tablename__()`
    classmethod so that we may **conditionally** return `None` for the table name,
    if a table is already present, thus indicating single-table inheritance for inheriting
    subclasses by default:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望**反转**上述默认表方案，使单表继承成为默认情况，并且只有在提供`__tablename__`指令以覆盖它时才能定义联接表继承，则可以在顶层`__tablename__()`方法中使用
    Declarative 辅助函数，在本例中是一个称为[`has_inherited_table()`](mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table")的辅助函数。如果超类已经映射到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，此函数将返回`True`。我们可以在最基本的`__tablename__()`类方法中使用此辅助函数，以便在表已存在时**有条件地**返回`None`作为表名，从而默认情况下通过继承子类进行单表继承：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '### Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to generate table-specific inheriting columns'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")生成特定表继承列'
- en: 'In contrast to how `__tablename__` and other special names are handled when
    used with [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr"),
    when we mix in columns and properties (e.g. relationships, column properties,
    etc.), the function is invoked for the **base class only** in the hierarchy, unless
    the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    directive is used in combination with the [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") sub-directive. Below, only the `Person`
    class will receive a column called `id`; the mapping will fail on `Engineer`,
    which is not given a primary key:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与在使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")时处理`__tablename__`和其他特殊名称的方式相反，当我们混合列和属性（例如关系、列属性等）时，该函数仅在层次结构中的**基类**上调用，除非在与[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")子指令结合使用时使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")指令。在下面的示例中，只有`Person`类将接收一个名为`id`的列；对于未给出主键的`Engineer`，映射将失败：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It is usually the case in joined-table inheritance that we want distinctly
    named columns on each subclass. However in this case, we may want to have an `id`
    column on every table, and have them refer to each other via foreign key. We can
    achieve this as a mixin by using the [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") modifier, which indicates that the function
    should be invoked **for each class in the hierarchy**, in *almost* (see warning
    below) the same way as it does for `__tablename__`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '在联接表继承中，通常情况下我们希望每个子类上都有不同命名的列。然而，在这种情况下，我们可能希望在每个表上都有一个`id`列，并通过外键引用它们。我们可以通过使用[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")修饰符作为混合来实现这一点，该修饰符指示该函数应该以*几乎*（请参阅下面的警告）与`__tablename__`相同的方式为层次结构中的每个类调用：  '
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Warning
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") feature currently does **not** allow
    for a subclass to override the attribute with a different function or value. This
    is a current limitation in the mechanics of how `@declared_attr` is resolved,
    and a warning is emitted if this condition is detected. This limitation only applies
    to ORM mapped columns, relationships, and other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") styles of attribute. It does **not** apply to
    Declarative directives such as `__tablename__`, `__mapper_args__`, etc., which
    resolve in a different way internally than that of [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading").
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") 特性目前**不允许**子类使用不同的函数或值覆盖属性。这是在解析`@declared_attr`的机制中的当前限制，并且如果检测到此条件，则会发出警告。这个限制仅适用于ORM映射的列、关系和其他[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")风格的属性。它**不适用于**声明性指令，如`__tablename__`、`__mapper_args__`等，在内部的解析方式与[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")不同。'
- en: Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with inheriting [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    arguments
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    与继承的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    和 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper") 参数
- en: A common recipe with mixins is to create a `def __tablename__(cls)` function
    that generates a name for the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") dynamically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mixin的一个常见方法是创建一个`def __tablename__(cls)`函数，该函数动态生成映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 名称。
- en: 'This recipe can be used to generate table names for an inheriting mapper hierarchy
    as in the example below which creates a mixin that gives every class a simple
    table name based on class name. The recipe is illustrated below where a table
    name is generated for the `Person` mapped class and the `Engineer` subclass of
    `Person`, but not for the `Manager` subclass of `Person`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可用于为继承的映射器层次结构生成表名，如下例所示，它创建了一个基于类名的简单表名的mixin。下面的示例说明了该示例，其中为`Person`映射类和`Person`的`Engineer`子类生成了一个表名，但未为`Person`的`Manager`子类生成表名：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the above example, both the `Person` base class as well as the `Engineer`
    class, being subclasses of the `Tablename` mixin class which generates new table
    names, will have a generated `__tablename__` attribute, which to Declarative indicates
    that each class should have its own [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") generated to which it will be mapped. For the `Engineer`
    subclass, the style of inheritance applied is [joined table inheritance](inheritance.html#joined-inheritance),
    as it will be mapped to a table `engineer` that joins to the base `person` table.
    Any other subclasses that inherit from `Person` will also have this style of inheritance
    applied by default (and within this particular example, would need to each specify
    a primary key column; more on that in the next section).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`Person`基类和`Engineer`类都是`Tablename` mixin类的子类，该类生成新的表名，因此它们都会有一个生成的`__tablename__`属性，对于声明性来说，这表示每个类都应该有自己的
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    生成，并且将映射到该表。对于`Engineer`子类，应用的继承风格是[联接表继承](inheritance.html#joined-inheritance)，因为它将映射到一个连接到基本`person`表的表`engineer`。从`Person`继承的任何其他子类也将默认应用此继承风格（并且在这个特定示例中，每个子类都需要指定一个主键列；更多关于这一点的内容将在下一节中介绍）。
- en: By contrast, the `Manager` subclass of `Person` **overrides** the `__tablename__`
    classmethod to return `None`. This indicates to Declarative that this class should
    **not** have a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    generated, and will instead make use exclusively of the base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `Person` is mapped. For the `Manager` subclass,
    the style of inheritance applied is [single table inheritance](inheritance.html#single-inheritance).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Person`的`Manager`子类**覆盖**了`__tablename__`类方法以返回`None`。这表明对于Declarative来说，这个类应该**不**生成一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，而是完全使用`Person`被映射到的基础[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。对于`Manager`子类，应用的继承样式是[单表继承](inheritance.html#single-inheritance)。
- en: The example above illustrates that Declarative directives like `__tablename__`
    are necessarily **applied to each subclass** individually, as each mapped class
    needs to state which [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    it will be mapped towards, or if it will map itself to the inheriting superclass’
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table").
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例说明Declarative指令如`__tablename__`必须**分别应用于每个子类**，因为每个映射类都需要说明它将映射到哪个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，或者它将自行映射到继承超类的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。
- en: 'If we instead wanted to **reverse** the default table scheme illustrated above,
    so that single table inheritance were the default and joined table inheritance
    could be defined only when a `__tablename__` directive were supplied to override
    it, we can make use of Declarative helpers within the top-most `__tablename__()`
    method, in this case a helper called [`has_inherited_table()`](mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table"). This function will return `True` if a superclass
    is already mapped to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). We may use this helper within the base-most `__tablename__()`
    classmethod so that we may **conditionally** return `None` for the table name,
    if a table is already present, thus indicating single-table inheritance for inheriting
    subclasses by default:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望**反转**上面示例中的默认表方案，使得单表继承成为默认，并且只有在提供了`__tablename__`指令来覆盖它时才能定义连接表继承，我们可以在最顶层的`__tablename__()`方法中使用Declarative助手，本例中称为[`has_inherited_table()`](mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table")。此函数将在超类已经映射到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")时返回`True`。我们可以在最基本的`__tablename__()`类方法中使用此助手，以便我们可以在表已经存在时**有条件地**返回`None`作为表名，从而默认指示继承子类的单表继承：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '### Using [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") to generate table-specific inheriting columns'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")生成特定于表的继承列'
- en: 'In contrast to how `__tablename__` and other special names are handled when
    used with [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr"),
    when we mix in columns and properties (e.g. relationships, column properties,
    etc.), the function is invoked for the **base class only** in the hierarchy, unless
    the [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    directive is used in combination with the [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") sub-directive. Below, only the `Person`
    class will receive a column called `id`; the mapping will fail on `Engineer`,
    which is not given a primary key:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与在使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")时处理`__tablename__`和其他特殊名称的方式相反，当我们混合列和属性（例如关系、列属性等）时，该函数仅在层次结构中的**基类**中调用，除非与[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")子指令结合使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")指令。下面，只有`Person`类将收到名为`id`的列；对于未给出主键的`Engineer`，映射将失败：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is usually the case in joined-table inheritance that we want distinctly
    named columns on each subclass. However in this case, we may want to have an `id`
    column on every table, and have them refer to each other via foreign key. We can
    achieve this as a mixin by using the [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") modifier, which indicates that the function
    should be invoked **for each class in the hierarchy**, in *almost* (see warning
    below) the same way as it does for `__tablename__`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接表继承中通常情况下，我们希望每个子类都有具有不同名称的列。但在这种情况下，我们可能希望在每个表上都有一个`id`列，并且通过外键相互引用。我们可以通过使用[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")修饰符作为混入来实现此目的，该修饰符指示该函数应在**层次结构中的每个类**中调用，与`__tablename__`几乎（参见下面的警告）相同的方式：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Warning
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") feature currently does **not** allow
    for a subclass to override the attribute with a different function or value. This
    is a current limitation in the mechanics of how `@declared_attr` is resolved,
    and a warning is emitted if this condition is detected. This limitation only applies
    to ORM mapped columns, relationships, and other [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") styles of attribute. It does **not** apply to
    Declarative directives such as `__tablename__`, `__mapper_args__`, etc., which
    resolve in a different way internally than that of [`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading").
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") 特性目前**不**允许子类使用不同的函数或值来覆盖属性。这是在解析`@declared_attr`时当前机制的限制，并且如果检测到此条件，则会发出警告。此限制仅适用于ORM映射的列、关联和其他[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")风格的属性。它**不**适用于诸如`__tablename__`、`__mapper_args__`等的声明性指令，后者在内部解析方式与[`declared_attr.cascading`](mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")不同。'
- en: Combining Table/Mapper Arguments from Multiple Mixins
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将来自多个混入的表/映射器参数组合起来
- en: 'In the case of `__table_args__` or `__mapper_args__` specified with declarative
    mixins, you may want to combine some parameters from several mixins with those
    you wish to define on the class itself. The [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorator can be used here to create user-defined
    collation routines that pull from multiple collections:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用声明性混入指定的`__table_args__`或`__mapper_args__`的情况下，您可能希望将几个混入的一些参数与您希望在类本身上定义的参数合并。在这里可以使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰器来创建用户定义的排序例程，这些例程来自多个集合：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '## Creating Indexes and Constraints with Naming Conventions on Mixins'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用混入创建具有命名约定的索引和约束'
- en: Using named constraints such as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), where each object is to be unique to a specific
    table descending from a mixin, requires that an individual instance of each object
    is created per actual mapped class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名约束，如[`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")，其中每个对象应该是从混入派生的特定表上唯一的，需要为每个实际映射类创建每个对象的单个实例。
- en: 'As a simple example, to define a named, potentially multicolumn [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") that applies to all tables derived from a mixin, use
    the “inline” form of [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") and establish it as part of `__table_args__`, using
    [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    to establish `__table_args__()` as a class method that will be invoked for each
    subclass:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，要定义一个命名的、可能是多列的[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")，该索引适用于从混合类派生的所有表，可以使用[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")的“内联”形式，并将其建立为`__table_args__`的一部分，使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")来建立`__table_args__()`作为一个类方法，该方法将被调用用于每个子类：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The above example would generate two tables `"table_a"` and `"table_b"`, with
    indexes `"test_idx_table_a"` and `"test_idx_table_b"`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子将生成两个表`"table_a"`和`"table_b"`，带有索引`"test_idx_table_a"`和`"test_idx_table_b"`。
- en: 'Typically, in modern SQLAlchemy we would use a naming convention, as documented
    at [Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions).
    While naming conventions take place automatically using the [`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData") as new [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") objects are created, as this convention is applied
    at object construction time based on the parent [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for a particular [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint"), a distinct [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") object needs to be created for each inheriting
    subclass with its own [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), again using [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") with `__table_args__()`, below illustrated using
    an abstract mapped base:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在现代SQLAlchemy中，我们会使用命名约定，如[配置约束命名约定](../core/constraints.html#constraint-naming-conventions)中所述。虽然命名约定在创建新的[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象时会自动进行，因为该约定是根据特定的父[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")在对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时应用于对象构建时时的，需要为每个继承子类创建一个独立的[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")对象，并再次使用[`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")与`__table_args__()`，下面以抽象映射基类进行说明：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The above mapping will generate DDL that includes table-specific names for
    all constraints, including primary key, CHECK constraint, unique constraint:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将生成包括所有约束的特定于表的名称的DDL，包括主键、CHECK约束、唯一约束：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
