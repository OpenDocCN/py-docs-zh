["```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass CommonMixin:\n  \"\"\"define a series of common elements that may be applied to mapped\n classes using this class as a mixin class.\"\"\"\n\n    @declared_attr.directive\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n    __mapper_args__ = {\"eager_defaults\": True}\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass HasLogRecord:\n  \"\"\"mark classes that have a many-to-one relationship to the\n ``LogRecord`` class.\"\"\"\n\n    log_record_id: Mapped[int] = mapped_column(ForeignKey(\"logrecord.id\"))\n\n    @declared_attr\n    def log_record(self) -> Mapped[\"LogRecord\"]:\n        return relationship(\"LogRecord\")\n\nclass LogRecord(CommonMixin, Base):\n    log_info: Mapped[str]\n\nclass MyModel(CommonMixin, HasLogRecord, Base):\n    name: Mapped[str]\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(MyModel).join(MyModel.log_record))\nSELECT  mymodel.name,  mymodel.id,  mymodel.log_record_id\nFROM  mymodel  JOIN  logrecord  ON  logrecord.id  =  mymodel.log_record_id \n```", "```py\nclass MyModel(Base, HasLogRecord, CommonMixin):\n    name: Mapped[str] = mapped_column()\n```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n  \"\"\"define a series of common elements that may be applied to mapped\n classes using this class as a base class.\"\"\"\n\n    @declared_attr.directive\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n    __mapper_args__ = {\"eager_defaults\": True}\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass HasLogRecord:\n  \"\"\"mark classes that have a many-to-one relationship to the\n ``LogRecord`` class.\"\"\"\n\n    log_record_id: Mapped[int] = mapped_column(ForeignKey(\"logrecord.id\"))\n\n    @declared_attr\n    def log_record(self) -> Mapped[\"LogRecord\"]:\n        return relationship(\"LogRecord\")\n\nclass LogRecord(Base):\n    log_info: Mapped[str]\n\nclass MyModel(HasLogRecord, Base):\n    name: Mapped[str]\n```", "```py\n# legacy declarative_base() use\n\nfrom sqlalchemy import Integer, String\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import declarative_base\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base:\n  \"\"\"define a series of common elements that may be applied to mapped\n classes using this class as a base class.\"\"\"\n\n    @declared_attr.directive\n    def __tablename__(cls):\n        return cls.__name__.lower()\n\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n    __mapper_args__ = {\"eager_defaults\": True}\n\n    id = mapped_column(Integer, primary_key=True)\n\nBase = declarative_base(cls=Base)\n\nclass HasLogRecord:\n  \"\"\"mark classes that have a many-to-one relationship to the\n ``LogRecord`` class.\"\"\"\n\n    log_record_id = mapped_column(ForeignKey(\"logrecord.id\"))\n\n    @declared_attr\n    def log_record(self):\n        return relationship(\"LogRecord\")\n\nclass LogRecord(Base):\n    log_info = mapped_column(String)\n\nclass MyModel(HasLogRecord, Base):\n    name = mapped_column(String)\n```", "```py\nclass TimestampMixin:\n    created_at: Mapped[datetime] = mapped_column(default=func.now())\n    updated_at: Mapped[datetime]\n\nclass MyModel(TimestampMixin, Base):\n    __tablename__ = \"test\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n```", "```py\n    class TimestampMixin:\n        created_at: Mapped[datetime] = mapped_column(default=func.now())\n        updated_at: Mapped[datetime]\n    ```", "```py\n    class TimestampMixin:\n        created_at = mapped_column(default=func.now())\n        updated_at: Mapped[datetime] = mapped_column()\n    ```", "```py\n    class TimestampMixin:\n        created_at = Column(DateTime, default=func.now())\n        updated_at = Column(DateTime)\n    ```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass RefTargetMixin:\n    target_id: Mapped[int] = mapped_column(ForeignKey(\"target.id\"))\n\n    @declared_attr\n    def target(cls) -> Mapped[\"Target\"]:\n        return relationship(\"Target\")\n\nclass Foo(RefTargetMixin, Base):\n    __tablename__ = \"foo\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Bar(RefTargetMixin, Base):\n    __tablename__ = \"bar\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Target(Base):\n    __tablename__ = \"target\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Foo).join(Foo.target))\nSELECT  foo.id,  foo.target_id\nFROM  foo  JOIN  target  ON  target.id  =  foo.target_id\n>>> print(select(Bar).join(Bar.target))\nSELECT  bar.id,  bar.target_id\nFROM  bar  JOIN  target  ON  target.id  =  bar.target_id \n```", "```py\nclass Target(Base):\n    __tablename__ = \"target\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass RefTargetMixin:\n    target_id: Mapped[int] = mapped_column(ForeignKey(\"target.id\"))\n\n    @declared_attr\n    def target(cls) -> Mapped[\"Target\"]:\n        # illustrates explicit 'primaryjoin' argument\n        return relationship(\"Target\", primaryjoin=Target.id == cls.target_id)\n```", "```py\nfrom sqlalchemy.orm import column_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SomethingMixin:\n    x: Mapped[int]\n    y: Mapped[int]\n\n    @declared_attr\n    def x_plus_y(cls) -> Mapped[int]:\n        return column_property(cls.x + cls.y)\n\nclass Something(SomethingMixin, Base):\n    __tablename__ = \"something\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Something.x_plus_y))\nSELECT  something.x  +  something.y  AS  anon_1\nFROM  something \n```", "```py\nclass SomethingMixin:\n    x: Mapped[int]\n    y: Mapped[int]\n\n    @declared_attr\n    @classmethod\n    def x_plus_y(cls) -> Mapped[int]:\n        return column_property(cls.x + cls.y)\n```", "```py\nfrom typing import Optional\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Tablename:\n    @declared_attr.directive\n    def __tablename__(cls) -> Optional[str]:\n        return cls.__name__.lower()\n\nclass Person(Tablename, Base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    id: Mapped[int] = mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n\n    primary_language: Mapped[str]\n\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n\nclass Manager(Person):\n    @declared_attr.directive\n    def __tablename__(cls) -> Optional[str]:\n  \"\"\"override __tablename__ so that Manager is single-inheritance to Person\"\"\"\n\n        return None\n\n    __mapper_args__ = {\"polymorphic_identity\": \"manager\"}\n```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import has_inherited_table\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Tablename:\n    @declared_attr.directive\n    def __tablename__(cls):\n        if has_inherited_table(cls):\n            return None\n        return cls.__name__.lower()\n\nclass Person(Tablename, Base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    @declared_attr.directive\n    def __tablename__(cls):\n  \"\"\"override __tablename__ so that Engineer is joined-inheritance to Person\"\"\"\n\n        return cls.__name__.lower()\n\n    id: Mapped[int] = mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n\n    primary_language: Mapped[str]\n\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n\nclass Manager(Person):\n    __mapper_args__ = {\"polymorphic_identity\": \"manager\"}\n```", "```py\nclass HasId:\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Person(HasId, Base):\n    __tablename__ = \"person\"\n\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\n# this mapping will fail, as there's no primary key\nclass Engineer(Person):\n    __tablename__ = \"engineer\"\n\n    primary_language: Mapped[str]\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n```", "```py\nclass HasIdMixin:\n    @declared_attr.cascading\n    def id(cls) -> Mapped[int]:\n        if has_inherited_table(cls):\n            return mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n        else:\n            return mapped_column(Integer, primary_key=True)\n\nclass Person(HasIdMixin, Base):\n    __tablename__ = \"person\"\n\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    __tablename__ = \"engineer\"\n\n    primary_language: Mapped[str]\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n```", "```py\nfrom sqlalchemy.orm import declarative_mixin, declared_attr\n\nclass MySQLSettings:\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n\nclass MyOtherMixin:\n    __table_args__ = {\"info\": \"foo\"}\n\nclass MyModel(MySQLSettings, MyOtherMixin, Base):\n    __tablename__ = \"my_model\"\n\n    @declared_attr.directive\n    def __table_args__(cls):\n        args = dict()\n        args.update(MySQLSettings.__table_args__)\n        args.update(MyOtherMixin.__table_args__)\n        return args\n\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\nclass MyMixin:\n    a = mapped_column(Integer)\n    b = mapped_column(Integer)\n\n    @declared_attr.directive\n    def __table_args__(cls):\n        return (Index(f\"test_idx_{cls.__tablename__}\", \"a\", \"b\"),)\n\nclass MyModelA(MyMixin, Base):\n    __tablename__ = \"table_a\"\n    id = mapped_column(Integer, primary_key=True)\n\nclass MyModelB(MyMixin, Base):\n    __tablename__ = \"table_b\"\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\nfrom uuid import UUID\n\nfrom sqlalchemy import CheckConstraint\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nconstraint_naming_conventions = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\nclass Base(DeclarativeBase):\n    metadata = MetaData(naming_convention=constraint_naming_conventions)\n\nclass MyAbstractBase(Base):\n    __abstract__ = True\n\n    @declared_attr.directive\n    def __table_args__(cls):\n        return (\n            UniqueConstraint(\"uuid\"),\n            CheckConstraint(\"x > 0 OR y < 100\", name=\"xy_chk\"),\n        )\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    uuid: Mapped[UUID]\n    x: Mapped[int]\n    y: Mapped[int]\n\nclass ModelAlpha(MyAbstractBase):\n    __tablename__ = \"alpha\"\n\nclass ModelBeta(MyAbstractBase):\n    __tablename__ = \"beta\"\n```", "```py\nCREATE  TABLE  alpha  (\n  id  INTEGER  NOT  NULL,\n  uuid  CHAR(32)  NOT  NULL,\n  x  INTEGER  NOT  NULL,\n  y  INTEGER  NOT  NULL,\n  CONSTRAINT  pk_alpha  PRIMARY  KEY  (id),\n  CONSTRAINT  uq_alpha_uuid  UNIQUE  (uuid),\n  CONSTRAINT  ck_alpha_xy_chk  CHECK  (x  >  0  OR  y  <  100)\n)\n\nCREATE  TABLE  beta  (\n  id  INTEGER  NOT  NULL,\n  uuid  CHAR(32)  NOT  NULL,\n  x  INTEGER  NOT  NULL,\n  y  INTEGER  NOT  NULL,\n  CONSTRAINT  pk_beta  PRIMARY  KEY  (id),\n  CONSTRAINT  uq_beta_uuid  UNIQUE  (uuid),\n  CONSTRAINT  ck_beta_xy_chk  CHECK  (x  >  0  OR  y  <  100)\n)\n```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n  \"\"\"define a series of common elements that may be applied to mapped\n classes using this class as a base class.\"\"\"\n\n    @declared_attr.directive\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n    __mapper_args__ = {\"eager_defaults\": True}\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass HasLogRecord:\n  \"\"\"mark classes that have a many-to-one relationship to the\n ``LogRecord`` class.\"\"\"\n\n    log_record_id: Mapped[int] = mapped_column(ForeignKey(\"logrecord.id\"))\n\n    @declared_attr\n    def log_record(self) -> Mapped[\"LogRecord\"]:\n        return relationship(\"LogRecord\")\n\nclass LogRecord(Base):\n    log_info: Mapped[str]\n\nclass MyModel(HasLogRecord, Base):\n    name: Mapped[str]\n```", "```py\n# legacy declarative_base() use\n\nfrom sqlalchemy import Integer, String\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import declarative_base\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base:\n  \"\"\"define a series of common elements that may be applied to mapped\n classes using this class as a base class.\"\"\"\n\n    @declared_attr.directive\n    def __tablename__(cls):\n        return cls.__name__.lower()\n\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n    __mapper_args__ = {\"eager_defaults\": True}\n\n    id = mapped_column(Integer, primary_key=True)\n\nBase = declarative_base(cls=Base)\n\nclass HasLogRecord:\n  \"\"\"mark classes that have a many-to-one relationship to the\n ``LogRecord`` class.\"\"\"\n\n    log_record_id = mapped_column(ForeignKey(\"logrecord.id\"))\n\n    @declared_attr\n    def log_record(self):\n        return relationship(\"LogRecord\")\n\nclass LogRecord(Base):\n    log_info = mapped_column(String)\n\nclass MyModel(HasLogRecord, Base):\n    name = mapped_column(String)\n```", "```py\nclass TimestampMixin:\n    created_at: Mapped[datetime] = mapped_column(default=func.now())\n    updated_at: Mapped[datetime]\n\nclass MyModel(TimestampMixin, Base):\n    __tablename__ = \"test\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n```", "```py\n    class TimestampMixin:\n        created_at: Mapped[datetime] = mapped_column(default=func.now())\n        updated_at: Mapped[datetime]\n    ```", "```py\n    class TimestampMixin:\n        created_at = mapped_column(default=func.now())\n        updated_at: Mapped[datetime] = mapped_column()\n    ```", "```py\n    class TimestampMixin:\n        created_at = Column(DateTime, default=func.now())\n        updated_at = Column(DateTime)\n    ```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass RefTargetMixin:\n    target_id: Mapped[int] = mapped_column(ForeignKey(\"target.id\"))\n\n    @declared_attr\n    def target(cls) -> Mapped[\"Target\"]:\n        return relationship(\"Target\")\n\nclass Foo(RefTargetMixin, Base):\n    __tablename__ = \"foo\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Bar(RefTargetMixin, Base):\n    __tablename__ = \"bar\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Target(Base):\n    __tablename__ = \"target\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Foo).join(Foo.target))\nSELECT  foo.id,  foo.target_id\nFROM  foo  JOIN  target  ON  target.id  =  foo.target_id\n>>> print(select(Bar).join(Bar.target))\nSELECT  bar.id,  bar.target_id\nFROM  bar  JOIN  target  ON  target.id  =  bar.target_id \n```", "```py\nclass Target(Base):\n    __tablename__ = \"target\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass RefTargetMixin:\n    target_id: Mapped[int] = mapped_column(ForeignKey(\"target.id\"))\n\n    @declared_attr\n    def target(cls) -> Mapped[\"Target\"]:\n        # illustrates explicit 'primaryjoin' argument\n        return relationship(\"Target\", primaryjoin=Target.id == cls.target_id)\n```", "```py\nfrom sqlalchemy.orm import column_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SomethingMixin:\n    x: Mapped[int]\n    y: Mapped[int]\n\n    @declared_attr\n    def x_plus_y(cls) -> Mapped[int]:\n        return column_property(cls.x + cls.y)\n\nclass Something(SomethingMixin, Base):\n    __tablename__ = \"something\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Something.x_plus_y))\nSELECT  something.x  +  something.y  AS  anon_1\nFROM  something \n```", "```py\nclass SomethingMixin:\n    x: Mapped[int]\n    y: Mapped[int]\n\n    @declared_attr\n    @classmethod\n    def x_plus_y(cls) -> Mapped[int]:\n        return column_property(cls.x + cls.y)\n```", "```py\nfrom typing import Optional\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Tablename:\n    @declared_attr.directive\n    def __tablename__(cls) -> Optional[str]:\n        return cls.__name__.lower()\n\nclass Person(Tablename, Base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    id: Mapped[int] = mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n\n    primary_language: Mapped[str]\n\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n\nclass Manager(Person):\n    @declared_attr.directive\n    def __tablename__(cls) -> Optional[str]:\n  \"\"\"override __tablename__ so that Manager is single-inheritance to Person\"\"\"\n\n        return None\n\n    __mapper_args__ = {\"polymorphic_identity\": \"manager\"}\n```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import has_inherited_table\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Tablename:\n    @declared_attr.directive\n    def __tablename__(cls):\n        if has_inherited_table(cls):\n            return None\n        return cls.__name__.lower()\n\nclass Person(Tablename, Base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    @declared_attr.directive\n    def __tablename__(cls):\n  \"\"\"override __tablename__ so that Engineer is joined-inheritance to Person\"\"\"\n\n        return cls.__name__.lower()\n\n    id: Mapped[int] = mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n\n    primary_language: Mapped[str]\n\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n\nclass Manager(Person):\n    __mapper_args__ = {\"polymorphic_identity\": \"manager\"}\n```", "```py\nclass HasId:\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Person(HasId, Base):\n    __tablename__ = \"person\"\n\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\n# this mapping will fail, as there's no primary key\nclass Engineer(Person):\n    __tablename__ = \"engineer\"\n\n    primary_language: Mapped[str]\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n```", "```py\nclass HasIdMixin:\n    @declared_attr.cascading\n    def id(cls) -> Mapped[int]:\n        if has_inherited_table(cls):\n            return mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n        else:\n            return mapped_column(Integer, primary_key=True)\n\nclass Person(HasIdMixin, Base):\n    __tablename__ = \"person\"\n\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    __tablename__ = \"engineer\"\n\n    primary_language: Mapped[str]\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n```", "```py\nfrom typing import Optional\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Tablename:\n    @declared_attr.directive\n    def __tablename__(cls) -> Optional[str]:\n        return cls.__name__.lower()\n\nclass Person(Tablename, Base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    id: Mapped[int] = mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n\n    primary_language: Mapped[str]\n\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n\nclass Manager(Person):\n    @declared_attr.directive\n    def __tablename__(cls) -> Optional[str]:\n  \"\"\"override __tablename__ so that Manager is single-inheritance to Person\"\"\"\n\n        return None\n\n    __mapper_args__ = {\"polymorphic_identity\": \"manager\"}\n```", "```py\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import has_inherited_table\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Tablename:\n    @declared_attr.directive\n    def __tablename__(cls):\n        if has_inherited_table(cls):\n            return None\n        return cls.__name__.lower()\n\nclass Person(Tablename, Base):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    @declared_attr.directive\n    def __tablename__(cls):\n  \"\"\"override __tablename__ so that Engineer is joined-inheritance to Person\"\"\"\n\n        return cls.__name__.lower()\n\n    id: Mapped[int] = mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n\n    primary_language: Mapped[str]\n\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n\nclass Manager(Person):\n    __mapper_args__ = {\"polymorphic_identity\": \"manager\"}\n```", "```py\nclass HasId:\n    id: Mapped[int] = mapped_column(primary_key=True)\n\nclass Person(HasId, Base):\n    __tablename__ = \"person\"\n\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\n# this mapping will fail, as there's no primary key\nclass Engineer(Person):\n    __tablename__ = \"engineer\"\n\n    primary_language: Mapped[str]\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n```", "```py\nclass HasIdMixin:\n    @declared_attr.cascading\n    def id(cls) -> Mapped[int]:\n        if has_inherited_table(cls):\n            return mapped_column(ForeignKey(\"person.id\"), primary_key=True)\n        else:\n            return mapped_column(Integer, primary_key=True)\n\nclass Person(HasIdMixin, Base):\n    __tablename__ = \"person\"\n\n    discriminator: Mapped[str]\n    __mapper_args__ = {\"polymorphic_on\": \"discriminator\"}\n\nclass Engineer(Person):\n    __tablename__ = \"engineer\"\n\n    primary_language: Mapped[str]\n    __mapper_args__ = {\"polymorphic_identity\": \"engineer\"}\n```", "```py\nfrom sqlalchemy.orm import declarative_mixin, declared_attr\n\nclass MySQLSettings:\n    __table_args__ = {\"mysql_engine\": \"InnoDB\"}\n\nclass MyOtherMixin:\n    __table_args__ = {\"info\": \"foo\"}\n\nclass MyModel(MySQLSettings, MyOtherMixin, Base):\n    __tablename__ = \"my_model\"\n\n    @declared_attr.directive\n    def __table_args__(cls):\n        args = dict()\n        args.update(MySQLSettings.__table_args__)\n        args.update(MyOtherMixin.__table_args__)\n        return args\n\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\nclass MyMixin:\n    a = mapped_column(Integer)\n    b = mapped_column(Integer)\n\n    @declared_attr.directive\n    def __table_args__(cls):\n        return (Index(f\"test_idx_{cls.__tablename__}\", \"a\", \"b\"),)\n\nclass MyModelA(MyMixin, Base):\n    __tablename__ = \"table_a\"\n    id = mapped_column(Integer, primary_key=True)\n\nclass MyModelB(MyMixin, Base):\n    __tablename__ = \"table_b\"\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\nfrom uuid import UUID\n\nfrom sqlalchemy import CheckConstraint\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nconstraint_naming_conventions = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\nclass Base(DeclarativeBase):\n    metadata = MetaData(naming_convention=constraint_naming_conventions)\n\nclass MyAbstractBase(Base):\n    __abstract__ = True\n\n    @declared_attr.directive\n    def __table_args__(cls):\n        return (\n            UniqueConstraint(\"uuid\"),\n            CheckConstraint(\"x > 0 OR y < 100\", name=\"xy_chk\"),\n        )\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    uuid: Mapped[UUID]\n    x: Mapped[int]\n    y: Mapped[int]\n\nclass ModelAlpha(MyAbstractBase):\n    __tablename__ = \"alpha\"\n\nclass ModelBeta(MyAbstractBase):\n    __tablename__ = \"beta\"\n```", "```py\nCREATE  TABLE  alpha  (\n  id  INTEGER  NOT  NULL,\n  uuid  CHAR(32)  NOT  NULL,\n  x  INTEGER  NOT  NULL,\n  y  INTEGER  NOT  NULL,\n  CONSTRAINT  pk_alpha  PRIMARY  KEY  (id),\n  CONSTRAINT  uq_alpha_uuid  UNIQUE  (uuid),\n  CONSTRAINT  ck_alpha_xy_chk  CHECK  (x  >  0  OR  y  <  100)\n)\n\nCREATE  TABLE  beta  (\n  id  INTEGER  NOT  NULL,\n  uuid  CHAR(32)  NOT  NULL,\n  x  INTEGER  NOT  NULL,\n  y  INTEGER  NOT  NULL,\n  CONSTRAINT  pk_beta  PRIMARY  KEY  (id),\n  CONSTRAINT  uq_beta_uuid  UNIQUE  (uuid),\n  CONSTRAINT  ck_beta_xy_chk  CHECK  (x  >  0  OR  y  <  100)\n)\n```"]