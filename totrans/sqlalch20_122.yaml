- en: Error Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/errors.html](https://docs.sqlalchemy.org/en/20/errors.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section lists descriptions and background for common error messages and
    warnings raised or emitted by SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy normally raises errors within the context of a SQLAlchemy-specific
    exception class. For details on these classes, see [Core Exceptions](core/exceptions.html)
    and [ORM Exceptions](orm/exceptions.html).
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy errors can roughly be separated into two categories, the **programming-time
    error** and the **runtime error**. Programming-time errors are raised as a result
    of functions or methods being called with incorrect arguments, or from other configuration-oriented
    methods such as mapper configurations that can’t be resolved. The programming-time
    error is typically immediate and deterministic. The runtime error on the other
    hand represents a failure that occurs as a program runs in response to some condition
    that occurs arbitrarily, such as database connections being exhausted or some
    data-related issue occurring. Runtime errors are more likely to be seen in the
    logs of a running application as the program encounters these states in response
    to load and data being encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Since runtime errors are not as easy to reproduce and often occur in response
    to some arbitrary condition as the program runs, they are more difficult to debug
    and also affect programs that have already been put into production.
  prefs: []
  type: TYPE_NORMAL
- en: Within this section, the goal is to try to provide background on some of the
    most common runtime errors as well as programming time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Connections and Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### QueuePool limit of size <x> overflow <y> reached, connection timed out,
    timeout <z>'
  prefs: []
  type: TYPE_NORMAL
- en: This is possibly the most common runtime error experienced, as it directly involves
    the work load of the application surpassing a configured limit, one which typically
    applies to nearly all SQLAlchemy applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following points summarize what this error means, beginning with the most
    fundamental points that most SQLAlchemy users should already be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: '**The SQLAlchemy Engine object uses a pool of connections by default** - What
    this means is that when one makes use of a SQL database connection resource of
    an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, and then [releases](glossary.html#term-releases) that resource, the database
    connection itself remains connected to the database and is returned to an internal
    queue where it can be used again. Even though the code may appear to be ending
    its conversation with the database, in many cases the application will still maintain
    a fixed number of database connections that persist until the application ends
    or the pool is explicitly disposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the pool, when an application makes use of a SQL database connection,
    most typically from either making use of [`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") or when making queries using an ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), this activity does not necessarily establish a new
    connection to the database at the moment the connection object is acquired; it
    instead consults the connection pool for a connection, which will often retrieve
    an existing connection from the pool to be re-used. If no connections are available,
    the pool will create a new database connection, but only if the pool has not surpassed
    a configured capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default pool used in most cases is called [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). When you ask this pool to give you a connection
    and none are available, it will create a new connection **if the total number
    of connections in play are less than a configured value**. This value is equal
    to the **pool size plus the max overflow**. That means if you have configured
    your engine as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    will allow **at most 30 connections** to be in play at any time, not including
    connections that were detached from the engine or invalidated. If a request for
    a new connection arrives and 30 connections are already in use by other parts
    of the application, the connection pool will block for a fixed period of time,
    before timing out and raising this error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to allow for a higher number of connections be in use at once, the
    pool can be adjusted using the [`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine") and [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") parameters as passed to the [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function. The timeout to wait for a connection to
    be available is configured using the [`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The pool can be configured to have unlimited overflow by setting [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") to the value “-1”. With this setting, the pool will
    still maintain a fixed pool of connections, however it will never block upon a
    new connection being requested; it will instead unconditionally make a new connection
    if none are available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, when running in this way, if the application has an issue where it
    is using up all available connectivity resources, it will eventually hit the configured
    limit of available connections on the database itself, which will again return
    an error. More seriously, when the application exhausts the database of connections,
    it usually will have caused a great amount of resources to be used up before failing,
    and can also interfere with other applications and database status mechanisms
    that rely upon being able to connect to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given the above, the connection pool can be looked at as a **safety valve for
    connection use**, providing a critical layer of protection against a rogue application
    causing the entire database to become unavailable to all other applications. When
    receiving this error message, it is vastly preferable to repair the issue using
    up too many connections and/or configure the limits appropriately, rather than
    allowing for unlimited overflow which does not actually solve the underlying issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What causes an application to use up all the connections that it has available?
  prefs: []
  type: TYPE_NORMAL
- en: '**The application is fielding too many concurrent requests to do work based
    on the configured value for the pool** - This is the most straightforward cause.
    If you have an application that runs in a thread pool that allows for 30 concurrent
    threads, with one connection in use per thread, if your pool is not configured
    to allow at least 30 connections checked out at once, you will get this error
    once your application receives enough concurrent requests. Solution is to raise
    the limits on the pool or lower the number of concurrent threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application is not returning connections to the pool** - This is the
    next most common reason, which is that the application is making use of the connection
    pool, but the program is failing to [release](glossary.html#term-release) these
    connections and is instead leaving them open. The connection pool as well as the
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    do have logic such that when the session and/or connection object is garbage collected,
    it results in the underlying connection resources being released, however this
    behavior cannot be relied upon to release resources in a timely manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common reason this can occur is that the application uses ORM sessions and
    does not call [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") upon them one the work involving that session
    is complete. Solution is to make sure ORM sessions if using the ORM, or engine-bound
    [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects if using Core, are explicitly closed at the end of the work being done,
    either via the appropriate `.close()` method, or by using one of the available
    context managers (e.g. “with:” statement) to properly release the resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The application is attempting to run long-running transactions** - A database
    transaction is a very expensive resource, and should **never be left idle waiting
    for some event to occur**. If an application is waiting for a user to push a button,
    or a result to come off of a long running job queue, or is holding a persistent
    connection open to a browser, **don’t keep a database transaction open for the
    whole time**. As the application needs to work with the database and interact
    with an event, open a short-lived transaction at that point and then close it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application is deadlocking** - Also a common cause of this error and
    more difficult to grasp, if an application is not able to complete its use of
    a connection either due to an application-side or database-side deadlock, the
    application can use up all the available connections which then leads to additional
    requests receiving this error. Reasons for deadlocks include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an implicit async system such as gevent or eventlet without properly monkeypatching
    all socket libraries and drivers, or which has bugs in not fully covering for
    all monkeypatched driver methods, or less commonly when the async system is being
    used against CPU-bound workloads and greenlets making use of database resources
    are simply waiting too long to attend to them. Neither implicit nor explicit async
    programming frameworks are typically necessary or appropriate for the vast majority
    of relational database operations; if an application must use an async system
    for some area of functionality, it’s best that database-oriented business methods
    run within traditional threads that pass messages to the async part of the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A database side deadlock, e.g. rows are mutually deadlocked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading errors, such as mutexes in a mutual deadlock, or calling upon an already
    locked mutex in the same thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind an alternative to using pooling is to turn off pooling entirely.
    See the section [Switching Pool Implementations](core/pooling.html#pool-switching)
    for background on this. However, note that when this error message is occurring,
    it is **always** due to a bigger problem in the application itself; the pool just
    helps to reveal the problem sooner.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](core/pooling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](core/connections.html)  ### Pool class
    cannot be used with asyncio engine (or vice versa)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    pool class uses a `thread.Lock` object internally and is not compatible with asyncio.
    If using the [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") function to create an [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine"), the appropriate queue pool class is [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), which is used automatically and does
    not need to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), the [`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") and [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") pool classes do not use locks and are also suitable
    for use with async engines.
  prefs: []
  type: TYPE_NORMAL
- en: This error is also raised in reverse in the unlikely case that the [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") pool class is indicated explicitly with
    the [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](core/pooling.html)  ### Can’t reconnect until invalid
    transaction is rolled back. Please rollback() fully before proceeding'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error condition refers to the case where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") was invalidated, either due to a database disconnect
    detection or due to an explicit call to [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate"), but there is still a transaction present
    that was initiated either explicitly by the [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or due to the connection automatically
    beginning a transaction as occurs in the 2.x series of SQLAlchemy when any SQL
    statements are emitted. When a connection is invalidated, any [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") that was in progress is now in an invalid state,
    and must be explicitly rolled back in order to remove it from the [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").  ## DBAPI Errors'
  prefs: []
  type: TYPE_NORMAL
- en: The Python database API, or DBAPI, is a specification for database drivers which
    can be located at [Pep-249](https://www.python.org/dev/peps/pep-0249/). This API
    specifies a set of exception classes that accommodate the full range of failure
    modes of the database.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy does not generate these exceptions directly. Instead, they are intercepted
    from the database driver and wrapped by the SQLAlchemy-provided exception [`DBAPIError`](core/exceptions.html#sqlalchemy.exc.DBAPIError
    "sqlalchemy.exc.DBAPIError"), however the messaging within the exception is **generated
    by the driver, not SQLAlchemy**.
  prefs: []
  type: TYPE_NORMAL
- en: '### InterfaceError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database interface rather
    than the database itself.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InterfaceError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    DatabaseError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database itself, and not
    the interface or data being passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### DataError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are due to problems with the processed data
    like division by zero, numeric value out of range, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### OperationalError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database’s operation and
    not necessarily under the control of the programmer, e.g. an unexpected disconnect
    occurs, the data source name is not found, a transaction could not be processed,
    a memory allocation error occurred during processing, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OperationalError` is the most common (but not the only) error class used
    by drivers in the context of the database connection being dropped, or not being
    able to connect to the database. For tips on how to deal with this, see the section
    [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ### IntegrityError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### InternalError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised when the database encounters an internal error, e.g. the cursor
    is not valid anymore, the transaction is out of sync, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InternalError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    ProgrammingError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for programming errors, e.g. table not found or already exists,
    syntax error in the SQL statement, wrong number of parameters specified, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProgrammingError` is sometimes raised by drivers in the context of the
    database connection being dropped, or not being able to connect to the database.
    For tips on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    NotSupportedError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised in case a method or database API was used which is not supported
    by the database, e.g. requesting a .rollback() on a connection that does not support
    transaction or has transactions turned off.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Expression Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Object will not produce a cache key, Performance Implications'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: If the warnings in question refer to widely used objects such as [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and are shown to be affecting the majority
    of SQL constructs being emitted (using the estimation techniques described at
    [Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging))
    such that caching is generally not enabled for an application, this will negatively
    impact performance and can in some cases effectively produce a **performance degradation**
    compared to prior SQLAlchemy versions. The FAQ at [Why is my application slow
    after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching) covers
    this in additional detail.
  prefs: []
  type: TYPE_NORMAL
- en: Caching disables itself if there’s any doubt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion attributes for caching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section  ### Compiler StrSQLCompiler
    can’t render element of type <element type>'
  prefs: []
  type: TYPE_NORMAL
- en: This error usually occurs when attempting to stringify a SQL expression construct
    that includes elements which are not part of the default compilation; in this
    case, the error will be against the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") class. In less common cases, it can
    also occur when the wrong kind of SQL expression is used with a particular type
    of database backend; in those cases, other kinds of SQL compiler classes will
    be named, such as `SQLCompiler` or `sqlalchemy.dialects.postgresql.PGCompiler`.
    The guidance below is more specific to the “stringification” use case but describes
    the general background as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a Core SQL construct or ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object can be stringified directly, such as when we use
    `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the above SQL expression is stringified, the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") compiler class is used, which is a special
    statement compiler that is invoked when a construct is stringified without any
    dialect-specific information.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are many constructs that are specific to some particular kind
    of database dialect, for which the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") doesn’t know how to turn into a string,
    such as the PostgreSQL [“insert on conflict”](postgresql_insert_on_conflict) construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to stringify constructs that are specific to particular backend, the
    [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method must be used, passing
    either an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or a [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object which will invoke the correct compiler. Below we use a PostgreSQL dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For an ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, the statement can be accessed using the `Query.statement` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See the FAQ link below for additional detail on direct stringification / compilation
    of SQL elements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](faq/sqlexpressions.html#faq-sql-expression-string)'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This often occurs when attempting to use a [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") object in the context of a SQL expression, usually
    within declarative such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `cprop` attribute is used inline before it has been mapped, however
    this `cprop` attribute is not a [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), it’s a [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"), which is an interim object and therefore does
    not have the full functionality of either the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or the [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") object that will be mapped onto the `Bar`
    class once the declarative process is complete.
  prefs: []
  type: TYPE_NORMAL
- en: While the [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") does have a `__clause_element__()` method, which
    allows it to work in some column-oriented contexts, it can’t work in an open-ended
    comparison context as illustrated above, since it has no Python `__eq__()` method
    that would allow it to interpret the comparison to the number “5” as a SQL expression
    and not a regular Python comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to access the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly using the [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '### A value is required for bind parameter <x> (in parameter group <y>)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs when a statement makes use of [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") either implicitly or explicitly and does
    not provide a value when the statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, no value has been provided for the parameter “my_param”. The correct
    approach is to provide a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the message takes the form “a value is required for bind parameter <x>
    in parameter group <y>”, the message is referring to the “executemany” style of
    execution. In this case, the statement is typically an INSERT, UPDATE, or DELETE
    and a list of parameters is being passed. In this format, the statement may be
    generated dynamically to include parameter positions for every parameter given
    in the argument list, where it will use the **first set of parameters** to determine
    what these should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the statement below is calculated based on the first parameter
    set to require the parameters, “a”, “b”, and “c” - these names determine the final
    string format of the statement which will be used for each set of parameters in
    the list. As the second entry does not contain “b”, this error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since “b” is required, pass it as `None` so that the INSERT may proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Parameters](tutorial/dbapi_transactions.html#tutorial-sending-parameters)  ###
    Expected FROM clause, got Select. To create a FROM clause, use the .subquery()
    method'
  prefs: []
  type: TYPE_NORMAL
- en: This refers to a change made as of SQLAlchemy 1.4 where a SELECT statement as
    generated by a function such as [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), but also including things like unions and
    textual SELECT expressions are no longer considered to be [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects and can’t be placed directly in
    the FROM clause of another SELECT statement without them being wrapped in a [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") first. This is a major conceptual change
    in the Core and the full rationale is discussed at [A SELECT statement is no longer
    implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an example as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `stmt` represents a SELECT statement. The error is produced when we
    want to use `stmt` directly as a FROM clause in another SELECT, such as if we
    attempted to select from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if we wanted to use it in a FROM clause such as in a JOIN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In previous versions of SQLAlchemy, using a SELECT inside of another SELECT
    would produce a parenthesized, unnamed subquery. In most cases, this form of SQL
    is not very useful as databases like MySQL and PostgreSQL require that subqueries
    in FROM clauses have named aliases, which means using the [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method or as of 1.4 using the [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method to produce this. On other
    databases, it is still much clearer for the subquery to have a name to resolve
    any ambiguity on future references to column names inside the subquery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the above practical reasons, there are a lot of other SQLAlchemy-oriented
    reasons the change is being made. The correct form of the above two statements
    therefore requires that [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617)  ###
    An alias is being generated automatically for raw clauseelement'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This deprecation warning refers to a very old and likely not well known pattern
    that applies to the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method as well as the [2.0 style](glossary.html#term-2.0-style)
    [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join "sqlalchemy.sql.expression.Select.join")
    method, where a join can be stated in terms of a [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") but the target is the [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other Core selectable to which the class is mapped,
    rather than an ORM entity such as a mapped class or [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The above pattern also allows an arbitrary selectable, such as a Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object, however there is no automatic adaptation
    of this element, meaning the Core element would need to be referenced directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way to specify a join target is always by using the mapped class
    itself or an [`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, in the latter case using the [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") modifier to set up an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Join to an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]  ### An alias is being generated automatically due to overlapping tables'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning is typically generated when querying using the [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method or the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method with mappings that involve joined table inheritance.
    The issue is that when joining between two joined inheritance models that share
    a common base table, a proper SQL JOIN between the two entities cannot be formed
    without applying an alias to one side or the other; SQLAlchemy applies an alias
    to the right side of the join. For example given a joined inheritance mapping
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping includes a relationship between the `Employee` and `Manager`
    classes. Since both classes make use of the “employee” database table, from a
    SQL perspective this is a [self referential relationship](orm/self_referential.html#self-referential).
    If we wanted to query from both the `Employee` and `Manager` models using a join,
    at the SQL level the “employee” table needs to be included twice in the query,
    which means it must be aliased. When we create such a join using the SQLAlchemy
    ORM, we get SQL that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Above, the SQL selects FROM the `employee` table, representing the `Employee`
    entity in the query. It then joins to a right-nested join of `employee AS employee_1
    JOIN manager AS manager_1`, where the `employee` table is stated again, except
    as an anonymous alias `employee_1`. This is the ‘automatic generation of an alias’
    to which the warning message refers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When SQLAlchemy loads ORM rows that each contain an `Employee` and a `Manager`
    object, the ORM must adapt rows from what above is the `employee_1` and `manager_1`
    table aliases into those of the un-aliased `Manager` class. This process is internally
    complex and does not accommodate for all API features, notably when trying to
    use eager loading features such as [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") with more deeply nested queries than are shown
    here. As the pattern is unreliable for more complex scenarios and involves implicit
    decisionmaking that is difficult to anticipate and follow, the warning is emitted
    and this pattern may be considered a legacy feature. The better way to write this
    query is to use the same patterns that apply to any other self-referential relationship,
    which is to use the [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct explicitly. For joined-inheritance and other
    join-oriented mappings, it is usually desirable to add the use of the [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") parameter, which will allow a JOIN of two or more tables
    to be aliased by applying an alias to the individual tables within the join, rather
    than embedding the join into a new subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then wanted to use [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate the `reports_to` attribute, we refer
    to the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Without using the explicit [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object, in some more nested cases the [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option does not have enough context to know where
    to get its data from, in the case that the ORM is “auto-aliasing” in a very nested
    context. Therefore it’s best not to rely on this feature and instead keep the
    SQL construction as explicit as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Object Relational Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### IllegalStateChangeError and concurrency exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 introduced a new system described at [Session raises proactively
    when illegal concurrent or reentrant access is detected](changelog/whatsnew_20.html#change-7433),
    which proactively detects concurrent methods being invoked on an individual instance
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object and by extension the [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") proxy object. These concurrent access calls
    typically, though not exclusively, would occur when a single instance of [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is shared among multiple concurrent threads without
    such access being synchronized, or similarly when a single instance of [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is shared among multiple concurrent tasks
    (such as when using a function like `asyncio.gather()`). These use patterns are
    not the appropriate use of these objects, where without the proactive warning
    system SQLAlchemy implements would still otherwise produce invalid state within
    the objects, producing hard-to-debug errors including driver-level errors on the
    database connections themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Instances of [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") are **mutable, stateful objects with no
    built-in synchronization** of method calls, and represent a **single, ongoing
    database transaction** upon a single database connection at a time for a particular
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction). A single database transaction is not an appropriate target
    for concurrent SQL commands; instead, an application that runs concurrent database
    operations should use concurrent transactions. For these objects then it follows
    that the appropriate pattern is [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") per thread, or [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") per task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more background on concurrency see the section [Is the Session thread-safe?
    Is AsyncSession safe to share in concurrent tasks?](orm/session_basics.html#session-faq-threadsafe).  ###
    Parent instance <x> is not bound to a Session; (lazy load/deferred load/refresh/etc.)
    operation cannot proceed'
  prefs: []
  type: TYPE_NORMAL
- en: This is likely the most common error message when dealing with the ORM, and
    it occurs as a result of the nature of a technique the ORM makes wide use of known
    as [lazy loading](glossary.html#term-lazy-loading). Lazy loading is a common object-relational
    pattern whereby an object that’s persisted by the ORM maintains a proxy to the
    database itself, such that when various attributes upon the object are accessed,
    their value may be retrieved from the database *lazily*. The advantage to this
    approach is that objects can be retrieved from the database without having to
    load all of their attributes or related data at once, and instead only that data
    which is requested can be delivered at that time. The major disadvantage is basically
    a mirror image of the advantage, which is that if lots of objects are being loaded
    which are known to require a certain set of data in all cases, it is wasteful
    to load that additional data piecemeal.
  prefs: []
  type: TYPE_NORMAL
- en: Another caveat of lazy loading beyond the usual efficiency concerns is that
    in order for lazy loading to proceed, the object has to **remain associated with
    a Session** in order to be able to retrieve its state. This error message means
    that an object has become de-associated with its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and is being asked to lazy load data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: The most common reason that objects become detached from their [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that the session itself was closed, typically via
    the [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method. The objects will then live on to be accessed further, very often within
    web applications where they are delivered to a server-side templating engine and
    are asked for further attributes which they cannot load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitigation of this error is via these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Try not to have detached objects; don’t close the session prematurely** -
    Often, applications will close out a transaction before passing off related objects
    to some other system which then fails due to this error. Sometimes the transaction
    doesn’t need to be closed so soon; an example is the web application closes out
    the transaction before the view is rendered. This is often done in the name of
    “correctness”, but may be seen as a mis-application of “encapsulation”, as this
    term refers to code organization, not actual actions. The template that uses an
    ORM object is making use of the [proxy pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
    which keeps database logic encapsulated from the caller. If the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be held open until the lifespan of the objects are
    done, this is the best approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Otherwise, load everything that’s needed up front** - It is very often impossible
    to keep the transaction open, especially in more complex applications that need
    to pass objects off to other systems that can’t run in the same context even though
    they’re in the same process. In this case, the application should prepare to deal
    with [detached](glossary.html#term-detached) objects, and should try to make appropriate
    use of [eager loading](glossary.html#term-eager-loading) to ensure that objects
    have what they need up front.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And importantly, set expire_on_commit to False** - When using detached objects,
    the most common reason objects need to re-load data is because they were expired
    from the last call to [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"). This expiration should not be used when dealing
    with detached objects; so the [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter be set to `False`. By preventing the objects
    from becoming expired outside of the transaction, the data which was loaded will
    remain present and will not incur additional lazy loads when that data is accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note also that [`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method unconditionally expires all contents
    in the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and should also be avoided in non-error scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Relationship Loading Techniques](orm/queryguide/relationships.html) - detailed
    documentation on eager loading and other relationship-oriented loading techniques'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Committing](orm/session_basics.html#session-committing) - background on session
    commit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Refreshing / Expiring](orm/session_state_management.html#session-expire) -
    background on attribute expiry  ### This Session’s transaction has been rolled
    back due to a previous exception during flush'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The flush process of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), described at [Flushing](orm/session_basics.html#session-flushing),
    will roll back the database transaction if an error is encountered, in order to
    maintain internal consistency. However, once this occurs, the session’s transaction
    is now “inactive” and must be explicitly rolled back by the calling application,
    in the same way that it would otherwise need to be explicitly committed if a failure
    had not occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a common error when using the ORM and typically applies to an application
    that doesn’t yet have correct “framing” around its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") operations. Further detail is described in the FAQ at
    [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](faq/sessions.html#faq-session-rollback).  ### For
    relationship <relationship>, delete-orphan cascade is normally configured only
    on the “one” side of a one-to-many relationship, and not on the “many” side of
    a many-to-one or many-to-many relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error arises when the “delete-orphan” [cascade](orm/cascades.html#unitofwork-cascades)
    is set on a many-to-one or many-to-many relationship, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Above, the “delete-orphan” setting on `B.a` indicates the intent that when every
    `B` object that refers to a particular `A` is deleted, that the `A` should then
    be deleted as well. That is, it expresses that the “orphan” which is being deleted
    would be an `A` object, and it becomes an “orphan” when every `B` that refers
    to it is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The “delete-orphan” cascade model does not support this functionality. The “orphan”
    consideration is only made in terms of the deletion of a single object which would
    then refer to zero or more objects that are now “orphaned” by this single deletion,
    which would result in those objects being deleted as well. In other words, it
    is designed only to track the creation of “orphans” based on the removal of one
    and only one “parent” object per orphan, which is the natural case in a one-to-many
    relationship where a deletion of the object on the “one” side results in the subsequent
    deletion of the related items on the “many” side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above mapping in support of this functionality would instead place the
    cascade setting on the one-to-many side, which looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Where the intent is expressed that when an `A` is deleted, all of the `B` objects
    to which it refers are also deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message then goes on to suggest the usage of the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag. This flag may be used to enforce that a relationship
    which is capable of having many objects refer to a particular object will in fact
    have only **one** object referring to it at a time. It is used for legacy or other
    less ideal database schemas where the foreign key relationships suggest a “many”
    collection, however in practice only one object would actually refer to a given
    target object at at time. This uncommon scenario can be demonstrated in terms
    of the above example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The above configuration will then install a validator which will enforce that
    only one `B` may be associated with an `A` at at time, within the scope of the
    `B.a` relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this validator is of limited scope and will not prevent multiple
    “parents” from being created via the other direction. For example, it will not
    detect the same setting in terms of `A.bs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, things will not go as expected later on, as the “delete-orphan” cascade
    will continue to work in terms of a **single** lead object, meaning if we delete
    **either** of the `B` objects, the `A` is deleted. The other `B` stays around,
    where the ORM will usually be smart enough to set the foreign key attribute to
    NULL, but this is usually not what’s desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For all the above examples, similar logic applies to the calculus of a many-to-many
    relationship; if a many-to-many relationship sets single_parent=True on one side,
    that side can use the “delete-orphan” cascade, however this is very unlikely to
    be what someone actually wants as the point of a many-to-many relationship is
    so that there can be many objects referring to an object in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, “delete-orphan” cascade is usually applied on the “one” side of a one-to-many
    relationship so that it deletes objects in the “many” side, and not the other
    way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.18: The text of the “delete-orphan” error message when
    used on a many-to-one or many-to-many relationship has been updated to be more
    descriptive.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Cascades](orm/cascades.html#unitofwork-cascades)'
  prefs: []
  type: TYPE_NORMAL
- en: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Instance <instance> is already associated with an instance of <instance> via
    its <attribute> attribute, and is only allowed a single parent.](#error-bbf1)  ###
    Instance <instance> is already associated with an instance of <instance> via its
    <attribute> attribute, and is only allowed a single parent.'
  prefs: []
  type: TYPE_NORMAL
- en: This error is emitted when the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag is used, and more than one object is assigned
    as the “parent” of an object at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent indicates that no more than a single `B` object may refer to a particular
    `A` object at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When this error occurs unexpectedly, it is usually because the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag was applied in response to the error message
    described at [For relationship <relationship>, delete-orphan cascade is normally
    configured only on the “one” side of a one-to-many relationship, and not on the
    “many” side of a many-to-one or many-to-many relationship.](#error-bbf0), and
    the issue is in fact a misunderstanding of the “delete-orphan” cascade setting.
    See that message for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](#error-bbf0)  ### relationship
    X will copy column Q to column P, which conflicts with relationship(s): ‘Y’'
  prefs: []
  type: TYPE_NORMAL
- en: This warning refers to the case when two or more relationships will write data
    to the same columns on flush, but the ORM does not have any means of coordinating
    these relationships together. Depending on specifics, the solution may be that
    two relationships need to be referenced by one another using [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), or that one or more of the relationships should
    be configured with [`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") to prevent conflicting writes, or sometimes that
    the configuration is fully intentional and should configure [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") to silence each warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the typical example that’s missing [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), given the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping will generate warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The relationships `Child.parent` and `Parent.children` appear to be in conflict.
    The solution is to apply [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'For more customized relationships where an “overlap” situation may be intentional
    and cannot be resolved, the [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") parameter may specify the names of relationships
    for which the warning should not take effect. This typically occurs for two or
    more relationships to the same underlying table that include custom [`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") conditions that limit the related items in each
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the ORM will know that the overlap between `Parent.c1`, `Parent.c2`
    and `Child.parent` is intentional.  ### Object cannot be converted to ‘persistent’
    state, as this identity map is no longer valid.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This message was added to accommodate for the case where a [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that would yield ORM objects is iterated after
    the originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has been closed, or otherwise had its [`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") method called. When a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") expunges all objects at once, the internal [identity
    map](glossary.html#term-identity-map) used by that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is replaced with a new one, and the original one discarded.
    An unconsumed and unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will internally maintain a reference to that
    now-discarded identity map. Therefore, when the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is consumed, the objects that would be yielded cannot
    be associated with that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This arrangement is by design as it is generally not
    recommended to iterate an unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object outside of the transactional context in which
    it was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The above situation typically will **not** occur when using the `asyncio` ORM
    extension, as when [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") returns a sync-style [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"), the results have been pre-buffered when the statement
    was executed. This is to allow secondary eager loaders to invoke without needing
    an additional `await` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pre-buffer results in the above situation using the regular [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in the same way that the `asyncio` extension does it,
    the `prebuffer_rows` execution option may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Above, the selected ORM objects are fully generated within the `session_obj`
    block, associated with `session_obj` and buffered within the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object for iteration. Outside the block, `session_obj`
    is closed and expunges these ORM objects. Iterating the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will yield those ORM objects, however as their
    originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has expunged them, they will be delivered in the [detached](glossary.html#term-detached)
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The above reference to a “pre-buffered” vs. “un-buffered” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object refers to the process by which the ORM converts
    incoming raw database rows from the [DBAPI](glossary.html#term-DBAPI) into ORM
    objects. It does not imply whether or not the underlying `cursor` object itself,
    which represents pending results from the DBAPI, is itself buffered or unbuffered,
    as this is essentially a lower layer of buffering. For background on buffering
    of the `cursor` results itself, see the section [Using Server Side Cursors (a.k.a.
    stream results)](core/connections.html#engine-stream-results).  ### Type annotation
    can’t be interpreted for Annotated Declarative Table form'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 introduces a new [Annotated Declarative Table](orm/declarative_tables.html#orm-declarative-mapped-column)
    declarative system which derives ORM mapped attribute information from [**PEP
    484**](https://peps.python.org/pep-0484/) annotations within class definitions
    at runtime. A requirement of this form is that all ORM annotations must make use
    of a generic container called [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to be properly annotated. Legacy SQLAlchemy mappings
    which include explicit [**PEP 484**](https://peps.python.org/pep-0484/) typing
    annotations, such as those which use the [legacy Mypy extension](orm/extensions/mypy.html)
    for typing support, may include directives such as those for [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that don’t include this generic.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve, the classes may be marked with the `__allow_unmapped__` boolean
    attribute until they can be fully migrated to the 2.0 syntax. See the migration
    notes at [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed
    ORM models](changelog/migration_20.html#migration-20-step-six) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](changelog/migration_20.html#migration-20-step-six) - in the [SQLAlchemy
    2.0 - Major Migration Guide](changelog/migration_20.html) document  ### When transforming
    <cls> to a dataclass, attribute(s) originate from superclass <cls> which is not
    a dataclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning occurs when using the SQLAlchemy ORM Mapped Dataclasses feature
    described at [Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    in conjunction with any mixin class or abstract base that is not itself declared
    as a dataclass, such as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, since `Mixin` does not itself extend from [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), the following warning is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to add [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") to the signature of `Mixin` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Python’s [**PEP 681**](https://peps.python.org/pep-0681/) specification does
    not accommodate for attributes declared on superclasses of dataclasses that are
    not themselves dataclasses; per the behavior of Python dataclasses, such fields
    are ignored, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `User` class will not include `create_user` in its constructor nor
    will it attempt to interpret `update_user` as a dataclass attribute. This is because
    `Mixin` is not a dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s dataclasses feature within the 2.0 series does not honor this
    behavior correctly; instead, attributes on non-dataclass mixins and superclasses
    are treated as part of the final dataclass configuration. However type checkers
    such as Pyright and Mypy will not consider these fields as part of the dataclass
    constructor as they are to be ignored per [**PEP 681**](https://peps.python.org/pep-0681/).
    Since their presence is ambiguous otherwise, SQLAlchemy 2.1 will require that
    mixin classes which have SQLAlchemy mapped attributes within a dataclass hierarchy
    have to themselves be dataclasses.  ### Python dataclasses error encountered when
    creating dataclass for <classname>'
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin class or [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator, SQLAlchemy makes use
    of the actual [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    module that’s in the Python standard library in order to apply dataclass behaviors
    to the target class. This API has its own error scenarios, most of which involve
    the construction of an `__init__()` method on the user defined class; the order
    of attributes declared on the class, as well as [on superclasses](https://docs.python.org/3/library/dataclasses.html#inheritance),
    determines how the `__init__()` method will be constructed and there are specific
    rules in how the attributes are organized as well as how they should make use
    of parameters such as `init=False`, `kw_only=True`, etc. **SQLAlchemy does not
    control or implement these rules**. Therefore, for errors of this nature, consult
    the [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) documentation,
    with special attention to the rules applied to [inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    on the python.org website'
  prefs: []
  type: TYPE_NORMAL
- en: '[inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance)
    - on the python.org website  ### per-row ORM Bulk Update by Primary Key requires
    that records contain primary key values'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs when making use of the [ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    feature without supplying primary key values in the given records, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the presence of a list of parameter dictionaries combined with usage
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to execute an ORM-enabled UPDATE statement will automatically make use of ORM
    Bulk Update by Primary Key, which expects parameter dictionaries to include primary
    key values, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the UPDATE statement without supplying per-record primary key values,
    use [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") to acquire the current [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), then invoke with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)'
  prefs: []
  type: TYPE_NORMAL
- en: AsyncIO Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### AwaitRequired'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy async mode requires an async driver to be used to connect to
    the db. This error is usually raised when trying to use the async version of SQLAlchemy
    with a non compatible [DBAPI](glossary.html#term-DBAPI).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Asynchronous I/O (asyncio)](orm/extensions/asyncio.html)  ### MissingGreenlet'
  prefs: []
  type: TYPE_NORMAL
- en: A call to the async [DBAPI](glossary.html#term-DBAPI) was initiated outside
    the greenlet spawn context usually setup by the SQLAlchemy AsyncIO proxy classes.
    Usually this error happens when an IO was attempted in an unexpected place, using
    a calling pattern that does not directly provide for use of the `await` keyword.
    When using the ORM this is nearly always due to the use of [lazy loading](glossary.html#term-lazy-loading),
    which is not directly supported under asyncio without additional steps and/or
    alternate loader patterns in order to use successfully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing Implicit IO when Using AsyncSession](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - covers most ORM scenarios where this problem can occur and how to mitigate,
    including specific patterns to use with lazy load scenarios.  ### No Inspection
    Available'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function directly on an [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") object is not currently supported, as there
    is not yet an awaitable form of the [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object available. Instead, the object
    is used by acquiring it using the [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function in such a way that it refers to the underlying
    [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") attribute of the [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") object; the `Inspector` is then used
    in a “synchronous” calling style by using the [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") method along with a custom
    function that performs the desired operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the Inspector to inspect schema objects](orm/extensions/asyncio.html#asyncio-inspector)
    - additional examples of using [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") with the asyncio extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Core Exception Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Core Exceptions](core/exceptions.html) for Core exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: ORM Exception Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [ORM Exceptions](orm/exceptions.html) for ORM exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions in this section are not generated by current SQLAlchemy versions,
    however are provided here to suit exception message hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: '### The <some function> in SQLAlchemy 2.0 will no longer <something>'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 represents a major shift for a wide variety of key SQLAlchemy
    usage patterns in both the Core and ORM components. The goal of the 2.0 release
    is to make a slight readjustment in some of the most fundamental assumptions of
    SQLAlchemy since its early beginnings, and to deliver a newly streamlined usage
    model that is hoped to be significantly more minimalist and consistent between
    the Core and ORM components, as well as more capable.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced at [SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html),
    the SQLAlchemy 2.0 project includes a comprehensive future compatibility system
    that’s integrated into the 1.4 series of SQLAlchemy, such that applications will
    have a clear, unambiguous, and incremental upgrade path in order to migrate applications
    to being fully 2.0 compatible. The `RemovedIn20Warning` deprecation warning is
    at the base of this system to provide guidance on what behaviors in an existing
    codebase will need to be modified. An overview of how to enable this warning is
    at [SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html) - An
    overview of the upgrade process from the 1.x series, as well as the current goals
    and progress of SQLAlchemy 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - specific guidelines on how to use “2.0 deprecations mode” in SQLAlchemy 1.4.  ###
    Object is being merged into a Session along the backref cascade'
  prefs: []
  type: TYPE_NORMAL
- en: This message refers to the “backref cascade” behavior of SQLAlchemy, removed
    in version 2.0\. This refers to the action of an object being added into a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as a result of another object that’s already present
    in that session being associated with it. As this behavior has been shown to be
    more confusing than helpful, the [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameters were added, which can be set to `False` to
    disable it, and in SQLAlchemy 2.0 the “cascade backrefs” behavior has been removed
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: For older SQLAlchemy versions, to set [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") to `False` on a backref that is currently configured
    using the [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") string parameter, the backref must be declared
    using the [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    function first so that the [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameter may be passed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the entire “cascade backrefs” behavior can be turned off across
    the board by using the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in “future” mode, by passing `True` for the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](changelog/migration_14.html#change-5150)
    - background on the change for SQLAlchemy 2.0.  ### select() construct created
    in “legacy” mode; keyword arguments, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct has been updated as of SQLAlchemy 1.4 to support the newer calling style
    that is standard in SQLAlchemy 2.0\. For backwards compatibility within the 1.4
    series, the construct accepts arguments in both the “legacy” style as well as
    the “new” style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “new” style features that column and table expressions are passed positionally
    to the [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct only; any other modifiers to the object must be passed using subsequent
    method chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, a [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in legacy forms of SQLAlchemy, before methods
    like [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") were even added, would like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even that the “whereclause” would be passed positionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For some years now, the additional “whereclause” and other arguments that are
    accepted have been removed from most narrative documentation, leading to a calling
    style that is most familiar as the list of column arguments passed as a list,
    but no further arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The document at [select() no longer accepts varied constructor arguments, columns
    are passed positionally](changelog/migration_20.html#migration-20-5284) describes
    this change in terms of [2.0 Migration](changelog/migration_20.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html)  ###
    A bind was located via legacy bound metadata, but since future=True is set on
    this Session, this bind is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of “bound metadata” is present up until SQLAlchemy 1.4; as of SQLAlchemy
    2.0 it’s been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error refers to the [`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData") parameter on the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that in turn allows objects like the ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to associate a particular mapped class with an `Engine`. In SQLAlchemy 2.0, the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    must be linked to each `Engine` directly. That is, instead of instantiating the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    without any arguments, and associating the [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    must instead be associated directly with the [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object should no longer be associated with any engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQLAlchemy 1.4, this [2.0 style](glossary.html#term-2.0-style) behavior
    is enabled when the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag is set on [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").  ### This Compiled object is not bound to any Engine
    or Connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error refers to the concept of “bound metadata”, which is a legacy SQLAlchemy
    pattern present only in 1.x versions. The issue occurs when one invokes the `Executable.execute()`
    method directly off of a Core expression object that is not associated with any
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'What the logic is expecting is that the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object has been **bound** to a [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Where above, any statement that derives from a [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which in turn derives from that [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will implicitly make use of the given [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in order to invoke the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the concept of bound metadata is **not present in SQLAlchemy 2.0**.
    The correct way to invoke statements is via the [`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method of a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the ORM, a similar facility is available via the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Basics of Statement Execution](tutorial/dbapi_transactions.html#tutorial-statement-execution)  ###
    This connection is on an inactive transaction. Please rollback() fully before
    proceeding'
  prefs: []
  type: TYPE_NORMAL
- en: This error condition was added to SQLAlchemy as of version 1.4, and does not
    apply to SQLAlchemy 2.0\. The error refers to the state where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is placed into a transaction using a method like
    [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"), and then a further “marker” transaction
    is created within that scope; the “marker” transaction is then rolled back using
    [`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or closed using [`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close"), however the outer transaction is still
    present in an “inactive” state and must be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Above, `transaction2` is a “marker” transaction, which indicates a logical nesting
    of transactions within an outer one; while the inner transaction can roll back
    the whole transaction via its rollback() method, its commit() method has no effect
    except to close the scope of the “marker” transaction itself. The call to `transaction2.rollback()`
    has the effect of **deactivating** transaction1 which means it is essentially
    rolled back at the database level, however is still present in order to accommodate
    a consistent nesting pattern of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct resolution is to ensure the outer transaction is also rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is not commonly used in Core. Within the ORM, a similar issue can
    occur which is the product of the ORM’s “logical” transaction structure; this
    is described in the FAQ entry at [“This Session’s transaction has been rolled
    back due to a previous exception during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  prefs: []
  type: TYPE_NORMAL
- en: The “subtransaction” pattern is removed in SQLAlchemy 2.0 so that this particular
    programming pattern is no longer be available, preventing this error message.
  prefs: []
  type: TYPE_NORMAL
- en: Connections and Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### QueuePool limit of size <x> overflow <y> reached, connection timed out,
    timeout <z>'
  prefs: []
  type: TYPE_NORMAL
- en: This is possibly the most common runtime error experienced, as it directly involves
    the work load of the application surpassing a configured limit, one which typically
    applies to nearly all SQLAlchemy applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following points summarize what this error means, beginning with the most
    fundamental points that most SQLAlchemy users should already be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: '**The SQLAlchemy Engine object uses a pool of connections by default** - What
    this means is that when one makes use of a SQL database connection resource of
    an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, and then [releases](glossary.html#term-releases) that resource, the database
    connection itself remains connected to the database and is returned to an internal
    queue where it can be used again. Even though the code may appear to be ending
    its conversation with the database, in many cases the application will still maintain
    a fixed number of database connections that persist until the application ends
    or the pool is explicitly disposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the pool, when an application makes use of a SQL database connection,
    most typically from either making use of [`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") or when making queries using an ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), this activity does not necessarily establish a new
    connection to the database at the moment the connection object is acquired; it
    instead consults the connection pool for a connection, which will often retrieve
    an existing connection from the pool to be re-used. If no connections are available,
    the pool will create a new database connection, but only if the pool has not surpassed
    a configured capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default pool used in most cases is called [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). When you ask this pool to give you a connection
    and none are available, it will create a new connection **if the total number
    of connections in play are less than a configured value**. This value is equal
    to the **pool size plus the max overflow**. That means if you have configured
    your engine as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    will allow **at most 30 connections** to be in play at any time, not including
    connections that were detached from the engine or invalidated. If a request for
    a new connection arrives and 30 connections are already in use by other parts
    of the application, the connection pool will block for a fixed period of time,
    before timing out and raising this error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to allow for a higher number of connections be in use at once, the
    pool can be adjusted using the [`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine") and [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") parameters as passed to the [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function. The timeout to wait for a connection to
    be available is configured using the [`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The pool can be configured to have unlimited overflow by setting [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") to the value “-1”. With this setting, the pool will
    still maintain a fixed pool of connections, however it will never block upon a
    new connection being requested; it will instead unconditionally make a new connection
    if none are available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, when running in this way, if the application has an issue where it
    is using up all available connectivity resources, it will eventually hit the configured
    limit of available connections on the database itself, which will again return
    an error. More seriously, when the application exhausts the database of connections,
    it usually will have caused a great amount of resources to be used up before failing,
    and can also interfere with other applications and database status mechanisms
    that rely upon being able to connect to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given the above, the connection pool can be looked at as a **safety valve for
    connection use**, providing a critical layer of protection against a rogue application
    causing the entire database to become unavailable to all other applications. When
    receiving this error message, it is vastly preferable to repair the issue using
    up too many connections and/or configure the limits appropriately, rather than
    allowing for unlimited overflow which does not actually solve the underlying issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What causes an application to use up all the connections that it has available?
  prefs: []
  type: TYPE_NORMAL
- en: '**The application is fielding too many concurrent requests to do work based
    on the configured value for the pool** - This is the most straightforward cause.
    If you have an application that runs in a thread pool that allows for 30 concurrent
    threads, with one connection in use per thread, if your pool is not configured
    to allow at least 30 connections checked out at once, you will get this error
    once your application receives enough concurrent requests. Solution is to raise
    the limits on the pool or lower the number of concurrent threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application is not returning connections to the pool** - This is the
    next most common reason, which is that the application is making use of the connection
    pool, but the program is failing to [release](glossary.html#term-release) these
    connections and is instead leaving them open. The connection pool as well as the
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    do have logic such that when the session and/or connection object is garbage collected,
    it results in the underlying connection resources being released, however this
    behavior cannot be relied upon to release resources in a timely manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common reason this can occur is that the application uses ORM sessions and
    does not call [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") upon them one the work involving that session
    is complete. Solution is to make sure ORM sessions if using the ORM, or engine-bound
    [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects if using Core, are explicitly closed at the end of the work being done,
    either via the appropriate `.close()` method, or by using one of the available
    context managers (e.g. “with:” statement) to properly release the resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The application is attempting to run long-running transactions** - A database
    transaction is a very expensive resource, and should **never be left idle waiting
    for some event to occur**. If an application is waiting for a user to push a button,
    or a result to come off of a long running job queue, or is holding a persistent
    connection open to a browser, **don’t keep a database transaction open for the
    whole time**. As the application needs to work with the database and interact
    with an event, open a short-lived transaction at that point and then close it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application is deadlocking** - Also a common cause of this error and
    more difficult to grasp, if an application is not able to complete its use of
    a connection either due to an application-side or database-side deadlock, the
    application can use up all the available connections which then leads to additional
    requests receiving this error. Reasons for deadlocks include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an implicit async system such as gevent or eventlet without properly monkeypatching
    all socket libraries and drivers, or which has bugs in not fully covering for
    all monkeypatched driver methods, or less commonly when the async system is being
    used against CPU-bound workloads and greenlets making use of database resources
    are simply waiting too long to attend to them. Neither implicit nor explicit async
    programming frameworks are typically necessary or appropriate for the vast majority
    of relational database operations; if an application must use an async system
    for some area of functionality, it’s best that database-oriented business methods
    run within traditional threads that pass messages to the async part of the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A database side deadlock, e.g. rows are mutually deadlocked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading errors, such as mutexes in a mutual deadlock, or calling upon an already
    locked mutex in the same thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind an alternative to using pooling is to turn off pooling entirely.
    See the section [Switching Pool Implementations](core/pooling.html#pool-switching)
    for background on this. However, note that when this error message is occurring,
    it is **always** due to a bigger problem in the application itself; the pool just
    helps to reveal the problem sooner.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](core/pooling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](core/connections.html)  ### Pool class
    cannot be used with asyncio engine (or vice versa)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    pool class uses a `thread.Lock` object internally and is not compatible with asyncio.
    If using the [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") function to create an [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine"), the appropriate queue pool class is [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), which is used automatically and does
    not need to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), the [`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") and [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") pool classes do not use locks and are also suitable
    for use with async engines.
  prefs: []
  type: TYPE_NORMAL
- en: This error is also raised in reverse in the unlikely case that the [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") pool class is indicated explicitly with
    the [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](core/pooling.html)  ### Can’t reconnect until invalid
    transaction is rolled back. Please rollback() fully before proceeding'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error condition refers to the case where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") was invalidated, either due to a database disconnect
    detection or due to an explicit call to [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate"), but there is still a transaction present
    that was initiated either explicitly by the [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or due to the connection automatically
    beginning a transaction as occurs in the 2.x series of SQLAlchemy when any SQL
    statements are emitted. When a connection is invalidated, any [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") that was in progress is now in an invalid state,
    and must be explicitly rolled back in order to remove it from the [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").  ### QueuePool limit of size <x> overflow <y>
    reached, connection timed out, timeout <z>'
  prefs: []
  type: TYPE_NORMAL
- en: This is possibly the most common runtime error experienced, as it directly involves
    the work load of the application surpassing a configured limit, one which typically
    applies to nearly all SQLAlchemy applications.
  prefs: []
  type: TYPE_NORMAL
- en: The following points summarize what this error means, beginning with the most
    fundamental points that most SQLAlchemy users should already be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: '**The SQLAlchemy Engine object uses a pool of connections by default** - What
    this means is that when one makes use of a SQL database connection resource of
    an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, and then [releases](glossary.html#term-releases) that resource, the database
    connection itself remains connected to the database and is returned to an internal
    queue where it can be used again. Even though the code may appear to be ending
    its conversation with the database, in many cases the application will still maintain
    a fixed number of database connections that persist until the application ends
    or the pool is explicitly disposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the pool, when an application makes use of a SQL database connection,
    most typically from either making use of [`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") or when making queries using an ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), this activity does not necessarily establish a new
    connection to the database at the moment the connection object is acquired; it
    instead consults the connection pool for a connection, which will often retrieve
    an existing connection from the pool to be re-used. If no connections are available,
    the pool will create a new database connection, but only if the pool has not surpassed
    a configured capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default pool used in most cases is called [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). When you ask this pool to give you a connection
    and none are available, it will create a new connection **if the total number
    of connections in play are less than a configured value**. This value is equal
    to the **pool size plus the max overflow**. That means if you have configured
    your engine as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    will allow **at most 30 connections** to be in play at any time, not including
    connections that were detached from the engine or invalidated. If a request for
    a new connection arrives and 30 connections are already in use by other parts
    of the application, the connection pool will block for a fixed period of time,
    before timing out and raising this error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to allow for a higher number of connections be in use at once, the
    pool can be adjusted using the [`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine") and [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") parameters as passed to the [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function. The timeout to wait for a connection to
    be available is configured using the [`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The pool can be configured to have unlimited overflow by setting [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") to the value “-1”. With this setting, the pool will
    still maintain a fixed pool of connections, however it will never block upon a
    new connection being requested; it will instead unconditionally make a new connection
    if none are available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, when running in this way, if the application has an issue where it
    is using up all available connectivity resources, it will eventually hit the configured
    limit of available connections on the database itself, which will again return
    an error. More seriously, when the application exhausts the database of connections,
    it usually will have caused a great amount of resources to be used up before failing,
    and can also interfere with other applications and database status mechanisms
    that rely upon being able to connect to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given the above, the connection pool can be looked at as a **safety valve for
    connection use**, providing a critical layer of protection against a rogue application
    causing the entire database to become unavailable to all other applications. When
    receiving this error message, it is vastly preferable to repair the issue using
    up too many connections and/or configure the limits appropriately, rather than
    allowing for unlimited overflow which does not actually solve the underlying issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What causes an application to use up all the connections that it has available?
  prefs: []
  type: TYPE_NORMAL
- en: '**The application is fielding too many concurrent requests to do work based
    on the configured value for the pool** - This is the most straightforward cause.
    If you have an application that runs in a thread pool that allows for 30 concurrent
    threads, with one connection in use per thread, if your pool is not configured
    to allow at least 30 connections checked out at once, you will get this error
    once your application receives enough concurrent requests. Solution is to raise
    the limits on the pool or lower the number of concurrent threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application is not returning connections to the pool** - This is the
    next most common reason, which is that the application is making use of the connection
    pool, but the program is failing to [release](glossary.html#term-release) these
    connections and is instead leaving them open. The connection pool as well as the
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    do have logic such that when the session and/or connection object is garbage collected,
    it results in the underlying connection resources being released, however this
    behavior cannot be relied upon to release resources in a timely manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common reason this can occur is that the application uses ORM sessions and
    does not call [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") upon them one the work involving that session
    is complete. Solution is to make sure ORM sessions if using the ORM, or engine-bound
    [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects if using Core, are explicitly closed at the end of the work being done,
    either via the appropriate `.close()` method, or by using one of the available
    context managers (e.g. “with:” statement) to properly release the resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The application is attempting to run long-running transactions** - A database
    transaction is a very expensive resource, and should **never be left idle waiting
    for some event to occur**. If an application is waiting for a user to push a button,
    or a result to come off of a long running job queue, or is holding a persistent
    connection open to a browser, **don’t keep a database transaction open for the
    whole time**. As the application needs to work with the database and interact
    with an event, open a short-lived transaction at that point and then close it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The application is deadlocking** - Also a common cause of this error and
    more difficult to grasp, if an application is not able to complete its use of
    a connection either due to an application-side or database-side deadlock, the
    application can use up all the available connections which then leads to additional
    requests receiving this error. Reasons for deadlocks include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an implicit async system such as gevent or eventlet without properly monkeypatching
    all socket libraries and drivers, or which has bugs in not fully covering for
    all monkeypatched driver methods, or less commonly when the async system is being
    used against CPU-bound workloads and greenlets making use of database resources
    are simply waiting too long to attend to them. Neither implicit nor explicit async
    programming frameworks are typically necessary or appropriate for the vast majority
    of relational database operations; if an application must use an async system
    for some area of functionality, it’s best that database-oriented business methods
    run within traditional threads that pass messages to the async part of the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A database side deadlock, e.g. rows are mutually deadlocked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading errors, such as mutexes in a mutual deadlock, or calling upon an already
    locked mutex in the same thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind an alternative to using pooling is to turn off pooling entirely.
    See the section [Switching Pool Implementations](core/pooling.html#pool-switching)
    for background on this. However, note that when this error message is occurring,
    it is **always** due to a bigger problem in the application itself; the pool just
    helps to reveal the problem sooner.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](core/pooling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with Engines and Connections](core/connections.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Pool class cannot be used with asyncio engine (or vice versa)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    pool class uses a `thread.Lock` object internally and is not compatible with asyncio.
    If using the [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") function to create an [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine"), the appropriate queue pool class is [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), which is used automatically and does
    not need to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), the [`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") and [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") pool classes do not use locks and are also suitable
    for use with async engines.
  prefs: []
  type: TYPE_NORMAL
- en: This error is also raised in reverse in the unlikely case that the [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") pool class is indicated explicitly with
    the [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Connection Pooling](core/pooling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Can’t reconnect until invalid transaction is rolled back. Please rollback()
    fully before proceeding'
  prefs: []
  type: TYPE_NORMAL
- en: This error condition refers to the case where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") was invalidated, either due to a database disconnect
    detection or due to an explicit call to [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate"), but there is still a transaction present
    that was initiated either explicitly by the [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or due to the connection automatically
    beginning a transaction as occurs in the 2.x series of SQLAlchemy when any SQL
    statements are emitted. When a connection is invalidated, any [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") that was in progress is now in an invalid state,
    and must be explicitly rolled back in order to remove it from the [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: '## DBAPI Errors'
  prefs: []
  type: TYPE_NORMAL
- en: The Python database API, or DBAPI, is a specification for database drivers which
    can be located at [Pep-249](https://www.python.org/dev/peps/pep-0249/). This API
    specifies a set of exception classes that accommodate the full range of failure
    modes of the database.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy does not generate these exceptions directly. Instead, they are intercepted
    from the database driver and wrapped by the SQLAlchemy-provided exception [`DBAPIError`](core/exceptions.html#sqlalchemy.exc.DBAPIError
    "sqlalchemy.exc.DBAPIError"), however the messaging within the exception is **generated
    by the driver, not SQLAlchemy**.
  prefs: []
  type: TYPE_NORMAL
- en: '### InterfaceError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database interface rather
    than the database itself.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InterfaceError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    DatabaseError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database itself, and not
    the interface or data being passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### DataError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are due to problems with the processed data
    like division by zero, numeric value out of range, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### OperationalError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database’s operation and
    not necessarily under the control of the programmer, e.g. an unexpected disconnect
    occurs, the data source name is not found, a transaction could not be processed,
    a memory allocation error occurred during processing, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OperationalError` is the most common (but not the only) error class used
    by drivers in the context of the database connection being dropped, or not being
    able to connect to the database. For tips on how to deal with this, see the section
    [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ### IntegrityError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### InternalError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised when the database encounters an internal error, e.g. the cursor
    is not valid anymore, the transaction is out of sync, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InternalError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    ProgrammingError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for programming errors, e.g. table not found or already exists,
    syntax error in the SQL statement, wrong number of parameters specified, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProgrammingError` is sometimes raised by drivers in the context of the
    database connection being dropped, or not being able to connect to the database.
    For tips on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    NotSupportedError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised in case a method or database API was used which is not supported
    by the database, e.g. requesting a .rollback() on a connection that does not support
    transaction or has transactions turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### InterfaceError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database interface rather
    than the database itself.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `InterfaceError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  prefs: []
  type: TYPE_NORMAL
- en: '### DatabaseError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database itself, and not
    the interface or data being passed.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: '### DataError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are due to problems with the processed data
    like division by zero, numeric value out of range, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: '### OperationalError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for errors that are related to the database’s operation and
    not necessarily under the control of the programmer, e.g. an unexpected disconnect
    occurs, the data source name is not found, a transaction could not be processed,
    a memory allocation error occurred during processing, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `OperationalError` is the most common (but not the only) error class used
    by drivers in the context of the database connection being dropped, or not being
    able to connect to the database. For tips on how to deal with this, see the section
    [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  prefs: []
  type: TYPE_NORMAL
- en: '### IntegrityError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: '### InternalError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised when the database encounters an internal error, e.g. the cursor
    is not valid anymore, the transaction is out of sync, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `InternalError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  prefs: []
  type: TYPE_NORMAL
- en: '### ProgrammingError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised for programming errors, e.g. table not found or already exists,
    syntax error in the SQL statement, wrong number of parameters specified, etc.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProgrammingError` is sometimes raised by drivers in the context of the
    database connection being dropped, or not being able to connect to the database.
    For tips on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  prefs: []
  type: TYPE_NORMAL
- en: '### NotSupportedError'
  prefs: []
  type: TYPE_NORMAL
- en: Exception raised in case a method or database API was used which is not supported
    by the database, e.g. requesting a .rollback() on a connection that does not support
    transaction or has transactions turned off.
  prefs: []
  type: TYPE_NORMAL
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Expression Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Object will not produce a cache key, Performance Implications'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: If the warnings in question refer to widely used objects such as [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and are shown to be affecting the majority
    of SQL constructs being emitted (using the estimation techniques described at
    [Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging))
    such that caching is generally not enabled for an application, this will negatively
    impact performance and can in some cases effectively produce a **performance degradation**
    compared to prior SQLAlchemy versions. The FAQ at [Why is my application slow
    after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching) covers
    this in additional detail.
  prefs: []
  type: TYPE_NORMAL
- en: Caching disables itself if there’s any doubt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion attributes for caching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section  ### Compiler StrSQLCompiler
    can’t render element of type <element type>'
  prefs: []
  type: TYPE_NORMAL
- en: This error usually occurs when attempting to stringify a SQL expression construct
    that includes elements which are not part of the default compilation; in this
    case, the error will be against the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") class. In less common cases, it can
    also occur when the wrong kind of SQL expression is used with a particular type
    of database backend; in those cases, other kinds of SQL compiler classes will
    be named, such as `SQLCompiler` or `sqlalchemy.dialects.postgresql.PGCompiler`.
    The guidance below is more specific to the “stringification” use case but describes
    the general background as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a Core SQL construct or ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object can be stringified directly, such as when we use
    `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: When the above SQL expression is stringified, the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") compiler class is used, which is a special
    statement compiler that is invoked when a construct is stringified without any
    dialect-specific information.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are many constructs that are specific to some particular kind
    of database dialect, for which the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") doesn’t know how to turn into a string,
    such as the PostgreSQL [“insert on conflict”](postgresql_insert_on_conflict) construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to stringify constructs that are specific to particular backend, the
    [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method must be used, passing
    either an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or a [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object which will invoke the correct compiler. Below we use a PostgreSQL dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For an ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, the statement can be accessed using the `Query.statement` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See the FAQ link below for additional detail on direct stringification / compilation
    of SQL elements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](faq/sqlexpressions.html#faq-sql-expression-string)'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This often occurs when attempting to use a [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") object in the context of a SQL expression, usually
    within declarative such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `cprop` attribute is used inline before it has been mapped, however
    this `cprop` attribute is not a [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), it’s a [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"), which is an interim object and therefore does
    not have the full functionality of either the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or the [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") object that will be mapped onto the `Bar`
    class once the declarative process is complete.
  prefs: []
  type: TYPE_NORMAL
- en: While the [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") does have a `__clause_element__()` method, which
    allows it to work in some column-oriented contexts, it can’t work in an open-ended
    comparison context as illustrated above, since it has no Python `__eq__()` method
    that would allow it to interpret the comparison to the number “5” as a SQL expression
    and not a regular Python comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to access the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly using the [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '### A value is required for bind parameter <x> (in parameter group <y>)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs when a statement makes use of [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") either implicitly or explicitly and does
    not provide a value when the statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, no value has been provided for the parameter “my_param”. The correct
    approach is to provide a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: When the message takes the form “a value is required for bind parameter <x>
    in parameter group <y>”, the message is referring to the “executemany” style of
    execution. In this case, the statement is typically an INSERT, UPDATE, or DELETE
    and a list of parameters is being passed. In this format, the statement may be
    generated dynamically to include parameter positions for every parameter given
    in the argument list, where it will use the **first set of parameters** to determine
    what these should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the statement below is calculated based on the first parameter
    set to require the parameters, “a”, “b”, and “c” - these names determine the final
    string format of the statement which will be used for each set of parameters in
    the list. As the second entry does not contain “b”, this error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Since “b” is required, pass it as `None` so that the INSERT may proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Parameters](tutorial/dbapi_transactions.html#tutorial-sending-parameters)  ###
    Expected FROM clause, got Select. To create a FROM clause, use the .subquery()
    method'
  prefs: []
  type: TYPE_NORMAL
- en: This refers to a change made as of SQLAlchemy 1.4 where a SELECT statement as
    generated by a function such as [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), but also including things like unions and
    textual SELECT expressions are no longer considered to be [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects and can’t be placed directly in
    the FROM clause of another SELECT statement without them being wrapped in a [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") first. This is a major conceptual change
    in the Core and the full rationale is discussed at [A SELECT statement is no longer
    implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an example as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `stmt` represents a SELECT statement. The error is produced when we
    want to use `stmt` directly as a FROM clause in another SELECT, such as if we
    attempted to select from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if we wanted to use it in a FROM clause such as in a JOIN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In previous versions of SQLAlchemy, using a SELECT inside of another SELECT
    would produce a parenthesized, unnamed subquery. In most cases, this form of SQL
    is not very useful as databases like MySQL and PostgreSQL require that subqueries
    in FROM clauses have named aliases, which means using the [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method or as of 1.4 using the [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method to produce this. On other
    databases, it is still much clearer for the subquery to have a name to resolve
    any ambiguity on future references to column names inside the subquery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the above practical reasons, there are a lot of other SQLAlchemy-oriented
    reasons the change is being made. The correct form of the above two statements
    therefore requires that [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617)  ###
    An alias is being generated automatically for raw clauseelement'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This deprecation warning refers to a very old and likely not well known pattern
    that applies to the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method as well as the [2.0 style](glossary.html#term-2.0-style)
    [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join "sqlalchemy.sql.expression.Select.join")
    method, where a join can be stated in terms of a [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") but the target is the [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other Core selectable to which the class is mapped,
    rather than an ORM entity such as a mapped class or [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The above pattern also allows an arbitrary selectable, such as a Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object, however there is no automatic adaptation
    of this element, meaning the Core element would need to be referenced directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way to specify a join target is always by using the mapped class
    itself or an [`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, in the latter case using the [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") modifier to set up an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Join to an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]  ### An alias is being generated automatically due to overlapping tables'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning is typically generated when querying using the [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method or the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method with mappings that involve joined table inheritance.
    The issue is that when joining between two joined inheritance models that share
    a common base table, a proper SQL JOIN between the two entities cannot be formed
    without applying an alias to one side or the other; SQLAlchemy applies an alias
    to the right side of the join. For example given a joined inheritance mapping
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping includes a relationship between the `Employee` and `Manager`
    classes. Since both classes make use of the “employee” database table, from a
    SQL perspective this is a [self referential relationship](orm/self_referential.html#self-referential).
    If we wanted to query from both the `Employee` and `Manager` models using a join,
    at the SQL level the “employee” table needs to be included twice in the query,
    which means it must be aliased. When we create such a join using the SQLAlchemy
    ORM, we get SQL that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Above, the SQL selects FROM the `employee` table, representing the `Employee`
    entity in the query. It then joins to a right-nested join of `employee AS employee_1
    JOIN manager AS manager_1`, where the `employee` table is stated again, except
    as an anonymous alias `employee_1`. This is the ‘automatic generation of an alias’
    to which the warning message refers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When SQLAlchemy loads ORM rows that each contain an `Employee` and a `Manager`
    object, the ORM must adapt rows from what above is the `employee_1` and `manager_1`
    table aliases into those of the un-aliased `Manager` class. This process is internally
    complex and does not accommodate for all API features, notably when trying to
    use eager loading features such as [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") with more deeply nested queries than are shown
    here. As the pattern is unreliable for more complex scenarios and involves implicit
    decisionmaking that is difficult to anticipate and follow, the warning is emitted
    and this pattern may be considered a legacy feature. The better way to write this
    query is to use the same patterns that apply to any other self-referential relationship,
    which is to use the [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct explicitly. For joined-inheritance and other
    join-oriented mappings, it is usually desirable to add the use of the [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") parameter, which will allow a JOIN of two or more tables
    to be aliased by applying an alias to the individual tables within the join, rather
    than embedding the join into a new subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then wanted to use [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate the `reports_to` attribute, we refer
    to the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Without using the explicit [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object, in some more nested cases the [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option does not have enough context to know where
    to get its data from, in the case that the ORM is “auto-aliasing” in a very nested
    context. Therefore it’s best not to rely on this feature and instead keep the
    SQL construction as explicit as possible.  ### Object will not produce a cache
    key, Performance Implications'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: If the warnings in question refer to widely used objects such as [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and are shown to be affecting the majority
    of SQL constructs being emitted (using the estimation techniques described at
    [Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging))
    such that caching is generally not enabled for an application, this will negatively
    impact performance and can in some cases effectively produce a **performance degradation**
    compared to prior SQLAlchemy versions. The FAQ at [Why is my application slow
    after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching) covers
    this in additional detail.
  prefs: []
  type: TYPE_NORMAL
- en: Caching disables itself if there’s any doubt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion attributes for caching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section'
  prefs: []
  type: TYPE_NORMAL
- en: Caching disables itself if there’s any doubt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion attributes for caching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  prefs: []
  type: TYPE_NORMAL
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section'
  prefs: []
  type: TYPE_NORMAL
- en: '### Compiler StrSQLCompiler can’t render element of type <element type>'
  prefs: []
  type: TYPE_NORMAL
- en: This error usually occurs when attempting to stringify a SQL expression construct
    that includes elements which are not part of the default compilation; in this
    case, the error will be against the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") class. In less common cases, it can
    also occur when the wrong kind of SQL expression is used with a particular type
    of database backend; in those cases, other kinds of SQL compiler classes will
    be named, such as `SQLCompiler` or `sqlalchemy.dialects.postgresql.PGCompiler`.
    The guidance below is more specific to the “stringification” use case but describes
    the general background as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, a Core SQL construct or ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object can be stringified directly, such as when we use
    `print()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: When the above SQL expression is stringified, the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") compiler class is used, which is a special
    statement compiler that is invoked when a construct is stringified without any
    dialect-specific information.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are many constructs that are specific to some particular kind
    of database dialect, for which the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") doesn’t know how to turn into a string,
    such as the PostgreSQL [“insert on conflict”](postgresql_insert_on_conflict) construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to stringify constructs that are specific to particular backend, the
    [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method must be used, passing
    either an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or a [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object which will invoke the correct compiler. Below we use a PostgreSQL dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For an ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, the statement can be accessed using the `Query.statement` accessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: See the FAQ link below for additional detail on direct stringification / compilation
    of SQL elements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](faq/sqlexpressions.html#faq-sql-expression-string)'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This often occurs when attempting to use a [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") object in the context of a SQL expression, usually
    within declarative such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `cprop` attribute is used inline before it has been mapped, however
    this `cprop` attribute is not a [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), it’s a [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"), which is an interim object and therefore does
    not have the full functionality of either the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or the [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") object that will be mapped onto the `Bar`
    class once the declarative process is complete.
  prefs: []
  type: TYPE_NORMAL
- en: While the [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") does have a `__clause_element__()` method, which
    allows it to work in some column-oriented contexts, it can’t work in an open-ended
    comparison context as illustrated above, since it has no Python `__eq__()` method
    that would allow it to interpret the comparison to the number “5” as a SQL expression
    and not a regular Python comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to access the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly using the [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '### A value is required for bind parameter <x> (in parameter group <y>)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs when a statement makes use of [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") either implicitly or explicitly and does
    not provide a value when the statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, no value has been provided for the parameter “my_param”. The correct
    approach is to provide a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: When the message takes the form “a value is required for bind parameter <x>
    in parameter group <y>”, the message is referring to the “executemany” style of
    execution. In this case, the statement is typically an INSERT, UPDATE, or DELETE
    and a list of parameters is being passed. In this format, the statement may be
    generated dynamically to include parameter positions for every parameter given
    in the argument list, where it will use the **first set of parameters** to determine
    what these should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the statement below is calculated based on the first parameter
    set to require the parameters, “a”, “b”, and “c” - these names determine the final
    string format of the statement which will be used for each set of parameters in
    the list. As the second entry does not contain “b”, this error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Since “b” is required, pass it as `None` so that the INSERT may proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Parameters](tutorial/dbapi_transactions.html#tutorial-sending-parameters)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Expected FROM clause, got Select. To create a FROM clause, use the .subquery()
    method'
  prefs: []
  type: TYPE_NORMAL
- en: This refers to a change made as of SQLAlchemy 1.4 where a SELECT statement as
    generated by a function such as [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), but also including things like unions and
    textual SELECT expressions are no longer considered to be [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects and can’t be placed directly in
    the FROM clause of another SELECT statement without them being wrapped in a [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") first. This is a major conceptual change
    in the Core and the full rationale is discussed at [A SELECT statement is no longer
    implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an example as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `stmt` represents a SELECT statement. The error is produced when we
    want to use `stmt` directly as a FROM clause in another SELECT, such as if we
    attempted to select from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if we wanted to use it in a FROM clause such as in a JOIN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In previous versions of SQLAlchemy, using a SELECT inside of another SELECT
    would produce a parenthesized, unnamed subquery. In most cases, this form of SQL
    is not very useful as databases like MySQL and PostgreSQL require that subqueries
    in FROM clauses have named aliases, which means using the [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method or as of 1.4 using the [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method to produce this. On other
    databases, it is still much clearer for the subquery to have a name to resolve
    any ambiguity on future references to column names inside the subquery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the above practical reasons, there are a lot of other SQLAlchemy-oriented
    reasons the change is being made. The correct form of the above two statements
    therefore requires that [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617)'
  prefs: []
  type: TYPE_NORMAL
- en: '### An alias is being generated automatically for raw clauseelement'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This deprecation warning refers to a very old and likely not well known pattern
    that applies to the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method as well as the [2.0 style](glossary.html#term-2.0-style)
    [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join "sqlalchemy.sql.expression.Select.join")
    method, where a join can be stated in terms of a [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") but the target is the [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other Core selectable to which the class is mapped,
    rather than an ORM entity such as a mapped class or [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The above pattern also allows an arbitrary selectable, such as a Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object, however there is no automatic adaptation
    of this element, meaning the Core element would need to be referenced directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The correct way to specify a join target is always by using the mapped class
    itself or an [`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, in the latter case using the [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") modifier to set up an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Join to an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '### An alias is being generated automatically due to overlapping tables'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning is typically generated when querying using the [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method or the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method with mappings that involve joined table inheritance.
    The issue is that when joining between two joined inheritance models that share
    a common base table, a proper SQL JOIN between the two entities cannot be formed
    without applying an alias to one side or the other; SQLAlchemy applies an alias
    to the right side of the join. For example given a joined inheritance mapping
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping includes a relationship between the `Employee` and `Manager`
    classes. Since both classes make use of the “employee” database table, from a
    SQL perspective this is a [self referential relationship](orm/self_referential.html#self-referential).
    If we wanted to query from both the `Employee` and `Manager` models using a join,
    at the SQL level the “employee” table needs to be included twice in the query,
    which means it must be aliased. When we create such a join using the SQLAlchemy
    ORM, we get SQL that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Above, the SQL selects FROM the `employee` table, representing the `Employee`
    entity in the query. It then joins to a right-nested join of `employee AS employee_1
    JOIN manager AS manager_1`, where the `employee` table is stated again, except
    as an anonymous alias `employee_1`. This is the ‘automatic generation of an alias’
    to which the warning message refers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When SQLAlchemy loads ORM rows that each contain an `Employee` and a `Manager`
    object, the ORM must adapt rows from what above is the `employee_1` and `manager_1`
    table aliases into those of the un-aliased `Manager` class. This process is internally
    complex and does not accommodate for all API features, notably when trying to
    use eager loading features such as [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") with more deeply nested queries than are shown
    here. As the pattern is unreliable for more complex scenarios and involves implicit
    decisionmaking that is difficult to anticipate and follow, the warning is emitted
    and this pattern may be considered a legacy feature. The better way to write this
    query is to use the same patterns that apply to any other self-referential relationship,
    which is to use the [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct explicitly. For joined-inheritance and other
    join-oriented mappings, it is usually desirable to add the use of the [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") parameter, which will allow a JOIN of two or more tables
    to be aliased by applying an alias to the individual tables within the join, rather
    than embedding the join into a new subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then wanted to use [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate the `reports_to` attribute, we refer
    to the alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Without using the explicit [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object, in some more nested cases the [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option does not have enough context to know where
    to get its data from, in the case that the ORM is “auto-aliasing” in a very nested
    context. Therefore it’s best not to rely on this feature and instead keep the
    SQL construction as explicit as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Object Relational Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### IllegalStateChangeError and concurrency exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 introduced a new system described at [Session raises proactively
    when illegal concurrent or reentrant access is detected](changelog/whatsnew_20.html#change-7433),
    which proactively detects concurrent methods being invoked on an individual instance
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object and by extension the [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") proxy object. These concurrent access calls
    typically, though not exclusively, would occur when a single instance of [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is shared among multiple concurrent threads without
    such access being synchronized, or similarly when a single instance of [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is shared among multiple concurrent tasks
    (such as when using a function like `asyncio.gather()`). These use patterns are
    not the appropriate use of these objects, where without the proactive warning
    system SQLAlchemy implements would still otherwise produce invalid state within
    the objects, producing hard-to-debug errors including driver-level errors on the
    database connections themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Instances of [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") are **mutable, stateful objects with no
    built-in synchronization** of method calls, and represent a **single, ongoing
    database transaction** upon a single database connection at a time for a particular
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction). A single database transaction is not an appropriate target
    for concurrent SQL commands; instead, an application that runs concurrent database
    operations should use concurrent transactions. For these objects then it follows
    that the appropriate pattern is [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") per thread, or [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") per task.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more background on concurrency see the section [Is the Session thread-safe?
    Is AsyncSession safe to share in concurrent tasks?](orm/session_basics.html#session-faq-threadsafe).  ###
    Parent instance <x> is not bound to a Session; (lazy load/deferred load/refresh/etc.)
    operation cannot proceed'
  prefs: []
  type: TYPE_NORMAL
- en: This is likely the most common error message when dealing with the ORM, and
    it occurs as a result of the nature of a technique the ORM makes wide use of known
    as [lazy loading](glossary.html#term-lazy-loading). Lazy loading is a common object-relational
    pattern whereby an object that’s persisted by the ORM maintains a proxy to the
    database itself, such that when various attributes upon the object are accessed,
    their value may be retrieved from the database *lazily*. The advantage to this
    approach is that objects can be retrieved from the database without having to
    load all of their attributes or related data at once, and instead only that data
    which is requested can be delivered at that time. The major disadvantage is basically
    a mirror image of the advantage, which is that if lots of objects are being loaded
    which are known to require a certain set of data in all cases, it is wasteful
    to load that additional data piecemeal.
  prefs: []
  type: TYPE_NORMAL
- en: Another caveat of lazy loading beyond the usual efficiency concerns is that
    in order for lazy loading to proceed, the object has to **remain associated with
    a Session** in order to be able to retrieve its state. This error message means
    that an object has become de-associated with its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and is being asked to lazy load data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: The most common reason that objects become detached from their [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that the session itself was closed, typically via
    the [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method. The objects will then live on to be accessed further, very often within
    web applications where they are delivered to a server-side templating engine and
    are asked for further attributes which they cannot load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitigation of this error is via these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Try not to have detached objects; don’t close the session prematurely** -
    Often, applications will close out a transaction before passing off related objects
    to some other system which then fails due to this error. Sometimes the transaction
    doesn’t need to be closed so soon; an example is the web application closes out
    the transaction before the view is rendered. This is often done in the name of
    “correctness”, but may be seen as a mis-application of “encapsulation”, as this
    term refers to code organization, not actual actions. The template that uses an
    ORM object is making use of the [proxy pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
    which keeps database logic encapsulated from the caller. If the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be held open until the lifespan of the objects are
    done, this is the best approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Otherwise, load everything that’s needed up front** - It is very often impossible
    to keep the transaction open, especially in more complex applications that need
    to pass objects off to other systems that can’t run in the same context even though
    they’re in the same process. In this case, the application should prepare to deal
    with [detached](glossary.html#term-detached) objects, and should try to make appropriate
    use of [eager loading](glossary.html#term-eager-loading) to ensure that objects
    have what they need up front.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And importantly, set expire_on_commit to False** - When using detached objects,
    the most common reason objects need to re-load data is because they were expired
    from the last call to [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"). This expiration should not be used when dealing
    with detached objects; so the [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter be set to `False`. By preventing the objects
    from becoming expired outside of the transaction, the data which was loaded will
    remain present and will not incur additional lazy loads when that data is accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note also that [`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method unconditionally expires all contents
    in the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and should also be avoided in non-error scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Relationship Loading Techniques](orm/queryguide/relationships.html) - detailed
    documentation on eager loading and other relationship-oriented loading techniques'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Committing](orm/session_basics.html#session-committing) - background on session
    commit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Refreshing / Expiring](orm/session_state_management.html#session-expire) -
    background on attribute expiry  ### This Session’s transaction has been rolled
    back due to a previous exception during flush'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The flush process of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), described at [Flushing](orm/session_basics.html#session-flushing),
    will roll back the database transaction if an error is encountered, in order to
    maintain internal consistency. However, once this occurs, the session’s transaction
    is now “inactive” and must be explicitly rolled back by the calling application,
    in the same way that it would otherwise need to be explicitly committed if a failure
    had not occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a common error when using the ORM and typically applies to an application
    that doesn’t yet have correct “framing” around its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") operations. Further detail is described in the FAQ at
    [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](faq/sessions.html#faq-session-rollback).  ### For
    relationship <relationship>, delete-orphan cascade is normally configured only
    on the “one” side of a one-to-many relationship, and not on the “many” side of
    a many-to-one or many-to-many relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error arises when the “delete-orphan” [cascade](orm/cascades.html#unitofwork-cascades)
    is set on a many-to-one or many-to-many relationship, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Above, the “delete-orphan” setting on `B.a` indicates the intent that when every
    `B` object that refers to a particular `A` is deleted, that the `A` should then
    be deleted as well. That is, it expresses that the “orphan” which is being deleted
    would be an `A` object, and it becomes an “orphan” when every `B` that refers
    to it is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The “delete-orphan” cascade model does not support this functionality. The “orphan”
    consideration is only made in terms of the deletion of a single object which would
    then refer to zero or more objects that are now “orphaned” by this single deletion,
    which would result in those objects being deleted as well. In other words, it
    is designed only to track the creation of “orphans” based on the removal of one
    and only one “parent” object per orphan, which is the natural case in a one-to-many
    relationship where a deletion of the object on the “one” side results in the subsequent
    deletion of the related items on the “many” side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above mapping in support of this functionality would instead place the
    cascade setting on the one-to-many side, which looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Where the intent is expressed that when an `A` is deleted, all of the `B` objects
    to which it refers are also deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message then goes on to suggest the usage of the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag. This flag may be used to enforce that a relationship
    which is capable of having many objects refer to a particular object will in fact
    have only **one** object referring to it at a time. It is used for legacy or other
    less ideal database schemas where the foreign key relationships suggest a “many”
    collection, however in practice only one object would actually refer to a given
    target object at at time. This uncommon scenario can be demonstrated in terms
    of the above example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The above configuration will then install a validator which will enforce that
    only one `B` may be associated with an `A` at at time, within the scope of the
    `B.a` relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this validator is of limited scope and will not prevent multiple
    “parents” from being created via the other direction. For example, it will not
    detect the same setting in terms of `A.bs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'However, things will not go as expected later on, as the “delete-orphan” cascade
    will continue to work in terms of a **single** lead object, meaning if we delete
    **either** of the `B` objects, the `A` is deleted. The other `B` stays around,
    where the ORM will usually be smart enough to set the foreign key attribute to
    NULL, but this is usually not what’s desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: For all the above examples, similar logic applies to the calculus of a many-to-many
    relationship; if a many-to-many relationship sets single_parent=True on one side,
    that side can use the “delete-orphan” cascade, however this is very unlikely to
    be what someone actually wants as the point of a many-to-many relationship is
    so that there can be many objects referring to an object in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, “delete-orphan” cascade is usually applied on the “one” side of a one-to-many
    relationship so that it deletes objects in the “many” side, and not the other
    way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.18: The text of the “delete-orphan” error message when
    used on a many-to-one or many-to-many relationship has been updated to be more
    descriptive.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Cascades](orm/cascades.html#unitofwork-cascades)'
  prefs: []
  type: TYPE_NORMAL
- en: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Instance <instance> is already associated with an instance of <instance> via
    its <attribute> attribute, and is only allowed a single parent.](#error-bbf1)  ###
    Instance <instance> is already associated with an instance of <instance> via its
    <attribute> attribute, and is only allowed a single parent.'
  prefs: []
  type: TYPE_NORMAL
- en: This error is emitted when the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag is used, and more than one object is assigned
    as the “parent” of an object at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent indicates that no more than a single `B` object may refer to a particular
    `A` object at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: When this error occurs unexpectedly, it is usually because the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag was applied in response to the error message
    described at [For relationship <relationship>, delete-orphan cascade is normally
    configured only on the “one” side of a one-to-many relationship, and not on the
    “many” side of a many-to-one or many-to-many relationship.](#error-bbf0), and
    the issue is in fact a misunderstanding of the “delete-orphan” cascade setting.
    See that message for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](#error-bbf0)  ### relationship
    X will copy column Q to column P, which conflicts with relationship(s): ‘Y’'
  prefs: []
  type: TYPE_NORMAL
- en: This warning refers to the case when two or more relationships will write data
    to the same columns on flush, but the ORM does not have any means of coordinating
    these relationships together. Depending on specifics, the solution may be that
    two relationships need to be referenced by one another using [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), or that one or more of the relationships should
    be configured with [`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") to prevent conflicting writes, or sometimes that
    the configuration is fully intentional and should configure [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") to silence each warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the typical example that’s missing [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), given the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping will generate warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The relationships `Child.parent` and `Parent.children` appear to be in conflict.
    The solution is to apply [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'For more customized relationships where an “overlap” situation may be intentional
    and cannot be resolved, the [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") parameter may specify the names of relationships
    for which the warning should not take effect. This typically occurs for two or
    more relationships to the same underlying table that include custom [`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") conditions that limit the related items in each
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the ORM will know that the overlap between `Parent.c1`, `Parent.c2`
    and `Child.parent` is intentional.  ### Object cannot be converted to ‘persistent’
    state, as this identity map is no longer valid.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This message was added to accommodate for the case where a [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that would yield ORM objects is iterated after
    the originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has been closed, or otherwise had its [`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") method called. When a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") expunges all objects at once, the internal [identity
    map](glossary.html#term-identity-map) used by that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is replaced with a new one, and the original one discarded.
    An unconsumed and unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will internally maintain a reference to that
    now-discarded identity map. Therefore, when the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is consumed, the objects that would be yielded cannot
    be associated with that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This arrangement is by design as it is generally not
    recommended to iterate an unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object outside of the transactional context in which
    it was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The above situation typically will **not** occur when using the `asyncio` ORM
    extension, as when [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") returns a sync-style [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"), the results have been pre-buffered when the statement
    was executed. This is to allow secondary eager loaders to invoke without needing
    an additional `await` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pre-buffer results in the above situation using the regular [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in the same way that the `asyncio` extension does it,
    the `prebuffer_rows` execution option may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Above, the selected ORM objects are fully generated within the `session_obj`
    block, associated with `session_obj` and buffered within the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object for iteration. Outside the block, `session_obj`
    is closed and expunges these ORM objects. Iterating the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will yield those ORM objects, however as their
    originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has expunged them, they will be delivered in the [detached](glossary.html#term-detached)
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The above reference to a “pre-buffered” vs. “un-buffered” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object refers to the process by which the ORM converts
    incoming raw database rows from the [DBAPI](glossary.html#term-DBAPI) into ORM
    objects. It does not imply whether or not the underlying `cursor` object itself,
    which represents pending results from the DBAPI, is itself buffered or unbuffered,
    as this is essentially a lower layer of buffering. For background on buffering
    of the `cursor` results itself, see the section [Using Server Side Cursors (a.k.a.
    stream results)](core/connections.html#engine-stream-results).  ### Type annotation
    can’t be interpreted for Annotated Declarative Table form'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 introduces a new [Annotated Declarative Table](orm/declarative_tables.html#orm-declarative-mapped-column)
    declarative system which derives ORM mapped attribute information from [**PEP
    484**](https://peps.python.org/pep-0484/) annotations within class definitions
    at runtime. A requirement of this form is that all ORM annotations must make use
    of a generic container called [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to be properly annotated. Legacy SQLAlchemy mappings
    which include explicit [**PEP 484**](https://peps.python.org/pep-0484/) typing
    annotations, such as those which use the [legacy Mypy extension](orm/extensions/mypy.html)
    for typing support, may include directives such as those for [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that don’t include this generic.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve, the classes may be marked with the `__allow_unmapped__` boolean
    attribute until they can be fully migrated to the 2.0 syntax. See the migration
    notes at [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed
    ORM models](changelog/migration_20.html#migration-20-step-six) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](changelog/migration_20.html#migration-20-step-six) - in the [SQLAlchemy
    2.0 - Major Migration Guide](changelog/migration_20.html) document  ### When transforming
    <cls> to a dataclass, attribute(s) originate from superclass <cls> which is not
    a dataclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning occurs when using the SQLAlchemy ORM Mapped Dataclasses feature
    described at [Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    in conjunction with any mixin class or abstract base that is not itself declared
    as a dataclass, such as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, since `Mixin` does not itself extend from [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), the following warning is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to add [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") to the signature of `Mixin` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Python’s [**PEP 681**](https://peps.python.org/pep-0681/) specification does
    not accommodate for attributes declared on superclasses of dataclasses that are
    not themselves dataclasses; per the behavior of Python dataclasses, such fields
    are ignored, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `User` class will not include `create_user` in its constructor nor
    will it attempt to interpret `update_user` as a dataclass attribute. This is because
    `Mixin` is not a dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s dataclasses feature within the 2.0 series does not honor this
    behavior correctly; instead, attributes on non-dataclass mixins and superclasses
    are treated as part of the final dataclass configuration. However type checkers
    such as Pyright and Mypy will not consider these fields as part of the dataclass
    constructor as they are to be ignored per [**PEP 681**](https://peps.python.org/pep-0681/).
    Since their presence is ambiguous otherwise, SQLAlchemy 2.1 will require that
    mixin classes which have SQLAlchemy mapped attributes within a dataclass hierarchy
    have to themselves be dataclasses.  ### Python dataclasses error encountered when
    creating dataclass for <classname>'
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin class or [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator, SQLAlchemy makes use
    of the actual [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    module that’s in the Python standard library in order to apply dataclass behaviors
    to the target class. This API has its own error scenarios, most of which involve
    the construction of an `__init__()` method on the user defined class; the order
    of attributes declared on the class, as well as [on superclasses](https://docs.python.org/3/library/dataclasses.html#inheritance),
    determines how the `__init__()` method will be constructed and there are specific
    rules in how the attributes are organized as well as how they should make use
    of parameters such as `init=False`, `kw_only=True`, etc. **SQLAlchemy does not
    control or implement these rules**. Therefore, for errors of this nature, consult
    the [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) documentation,
    with special attention to the rules applied to [inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    on the python.org website'
  prefs: []
  type: TYPE_NORMAL
- en: '[inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance)
    - on the python.org website  ### per-row ORM Bulk Update by Primary Key requires
    that records contain primary key values'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs when making use of the [ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    feature without supplying primary key values in the given records, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the presence of a list of parameter dictionaries combined with usage
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to execute an ORM-enabled UPDATE statement will automatically make use of ORM
    Bulk Update by Primary Key, which expects parameter dictionaries to include primary
    key values, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the UPDATE statement without supplying per-record primary key values,
    use [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") to acquire the current [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), then invoke with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)  ###
    IllegalStateChangeError and concurrency exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 introduced a new system described at [Session raises proactively
    when illegal concurrent or reentrant access is detected](changelog/whatsnew_20.html#change-7433),
    which proactively detects concurrent methods being invoked on an individual instance
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object and by extension the [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") proxy object. These concurrent access calls
    typically, though not exclusively, would occur when a single instance of [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is shared among multiple concurrent threads without
    such access being synchronized, or similarly when a single instance of [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is shared among multiple concurrent tasks
    (such as when using a function like `asyncio.gather()`). These use patterns are
    not the appropriate use of these objects, where without the proactive warning
    system SQLAlchemy implements would still otherwise produce invalid state within
    the objects, producing hard-to-debug errors including driver-level errors on the
    database connections themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Instances of [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") are **mutable, stateful objects with no
    built-in synchronization** of method calls, and represent a **single, ongoing
    database transaction** upon a single database connection at a time for a particular
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction). A single database transaction is not an appropriate target
    for concurrent SQL commands; instead, an application that runs concurrent database
    operations should use concurrent transactions. For these objects then it follows
    that the appropriate pattern is [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") per thread, or [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") per task.
  prefs: []
  type: TYPE_NORMAL
- en: For more background on concurrency see the section [Is the Session thread-safe?
    Is AsyncSession safe to share in concurrent tasks?](orm/session_basics.html#session-faq-threadsafe).
  prefs: []
  type: TYPE_NORMAL
- en: '### Parent instance <x> is not bound to a Session; (lazy load/deferred load/refresh/etc.)
    operation cannot proceed'
  prefs: []
  type: TYPE_NORMAL
- en: This is likely the most common error message when dealing with the ORM, and
    it occurs as a result of the nature of a technique the ORM makes wide use of known
    as [lazy loading](glossary.html#term-lazy-loading). Lazy loading is a common object-relational
    pattern whereby an object that’s persisted by the ORM maintains a proxy to the
    database itself, such that when various attributes upon the object are accessed,
    their value may be retrieved from the database *lazily*. The advantage to this
    approach is that objects can be retrieved from the database without having to
    load all of their attributes or related data at once, and instead only that data
    which is requested can be delivered at that time. The major disadvantage is basically
    a mirror image of the advantage, which is that if lots of objects are being loaded
    which are known to require a certain set of data in all cases, it is wasteful
    to load that additional data piecemeal.
  prefs: []
  type: TYPE_NORMAL
- en: Another caveat of lazy loading beyond the usual efficiency concerns is that
    in order for lazy loading to proceed, the object has to **remain associated with
    a Session** in order to be able to retrieve its state. This error message means
    that an object has become de-associated with its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and is being asked to lazy load data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: The most common reason that objects become detached from their [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that the session itself was closed, typically via
    the [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method. The objects will then live on to be accessed further, very often within
    web applications where they are delivered to a server-side templating engine and
    are asked for further attributes which they cannot load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitigation of this error is via these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Try not to have detached objects; don’t close the session prematurely** -
    Often, applications will close out a transaction before passing off related objects
    to some other system which then fails due to this error. Sometimes the transaction
    doesn’t need to be closed so soon; an example is the web application closes out
    the transaction before the view is rendered. This is often done in the name of
    “correctness”, but may be seen as a mis-application of “encapsulation”, as this
    term refers to code organization, not actual actions. The template that uses an
    ORM object is making use of the [proxy pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
    which keeps database logic encapsulated from the caller. If the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be held open until the lifespan of the objects are
    done, this is the best approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Otherwise, load everything that’s needed up front** - It is very often impossible
    to keep the transaction open, especially in more complex applications that need
    to pass objects off to other systems that can’t run in the same context even though
    they’re in the same process. In this case, the application should prepare to deal
    with [detached](glossary.html#term-detached) objects, and should try to make appropriate
    use of [eager loading](glossary.html#term-eager-loading) to ensure that objects
    have what they need up front.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**And importantly, set expire_on_commit to False** - When using detached objects,
    the most common reason objects need to re-load data is because they were expired
    from the last call to [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"). This expiration should not be used when dealing
    with detached objects; so the [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter be set to `False`. By preventing the objects
    from becoming expired outside of the transaction, the data which was loaded will
    remain present and will not incur additional lazy loads when that data is accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note also that [`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method unconditionally expires all contents
    in the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and should also be avoided in non-error scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Relationship Loading Techniques](orm/queryguide/relationships.html) - detailed
    documentation on eager loading and other relationship-oriented loading techniques'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Committing](orm/session_basics.html#session-committing) - background on session
    commit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Refreshing / Expiring](orm/session_state_management.html#session-expire) -
    background on attribute expiry'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '### This Session’s transaction has been rolled back due to a previous exception
    during flush'
  prefs: []
  type: TYPE_NORMAL
- en: The flush process of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), described at [Flushing](orm/session_basics.html#session-flushing),
    will roll back the database transaction if an error is encountered, in order to
    maintain internal consistency. However, once this occurs, the session’s transaction
    is now “inactive” and must be explicitly rolled back by the calling application,
    in the same way that it would otherwise need to be explicitly committed if a failure
    had not occurred.
  prefs: []
  type: TYPE_NORMAL
- en: This is a common error when using the ORM and typically applies to an application
    that doesn’t yet have correct “framing” around its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") operations. Further detail is described in the FAQ at
    [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  prefs: []
  type: TYPE_NORMAL
- en: '### For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error arises when the “delete-orphan” [cascade](orm/cascades.html#unitofwork-cascades)
    is set on a many-to-one or many-to-many relationship, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Above, the “delete-orphan” setting on `B.a` indicates the intent that when every
    `B` object that refers to a particular `A` is deleted, that the `A` should then
    be deleted as well. That is, it expresses that the “orphan” which is being deleted
    would be an `A` object, and it becomes an “orphan” when every `B` that refers
    to it is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The “delete-orphan” cascade model does not support this functionality. The “orphan”
    consideration is only made in terms of the deletion of a single object which would
    then refer to zero or more objects that are now “orphaned” by this single deletion,
    which would result in those objects being deleted as well. In other words, it
    is designed only to track the creation of “orphans” based on the removal of one
    and only one “parent” object per orphan, which is the natural case in a one-to-many
    relationship where a deletion of the object on the “one” side results in the subsequent
    deletion of the related items on the “many” side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above mapping in support of this functionality would instead place the
    cascade setting on the one-to-many side, which looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Where the intent is expressed that when an `A` is deleted, all of the `B` objects
    to which it refers are also deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error message then goes on to suggest the usage of the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag. This flag may be used to enforce that a relationship
    which is capable of having many objects refer to a particular object will in fact
    have only **one** object referring to it at a time. It is used for legacy or other
    less ideal database schemas where the foreign key relationships suggest a “many”
    collection, however in practice only one object would actually refer to a given
    target object at at time. This uncommon scenario can be demonstrated in terms
    of the above example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The above configuration will then install a validator which will enforce that
    only one `B` may be associated with an `A` at at time, within the scope of the
    `B.a` relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this validator is of limited scope and will not prevent multiple
    “parents” from being created via the other direction. For example, it will not
    detect the same setting in terms of `A.bs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'However, things will not go as expected later on, as the “delete-orphan” cascade
    will continue to work in terms of a **single** lead object, meaning if we delete
    **either** of the `B` objects, the `A` is deleted. The other `B` stays around,
    where the ORM will usually be smart enough to set the foreign key attribute to
    NULL, but this is usually not what’s desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: For all the above examples, similar logic applies to the calculus of a many-to-many
    relationship; if a many-to-many relationship sets single_parent=True on one side,
    that side can use the “delete-orphan” cascade, however this is very unlikely to
    be what someone actually wants as the point of a many-to-many relationship is
    so that there can be many objects referring to an object in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, “delete-orphan” cascade is usually applied on the “one” side of a one-to-many
    relationship so that it deletes objects in the “many” side, and not the other
    way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.18: The text of the “delete-orphan” error message when
    used on a many-to-one or many-to-many relationship has been updated to be more
    descriptive.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Cascades](orm/cascades.html#unitofwork-cascades)'
  prefs: []
  type: TYPE_NORMAL
- en: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Instance <instance> is already associated with an instance of <instance> via
    its <attribute> attribute, and is only allowed a single parent.](#error-bbf1)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Instance <instance> is already associated with an instance of <instance>
    via its <attribute> attribute, and is only allowed a single parent.'
  prefs: []
  type: TYPE_NORMAL
- en: This error is emitted when the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag is used, and more than one object is assigned
    as the “parent” of an object at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent indicates that no more than a single `B` object may refer to a particular
    `A` object at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: When this error occurs unexpectedly, it is usually because the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag was applied in response to the error message
    described at [For relationship <relationship>, delete-orphan cascade is normally
    configured only on the “one” side of a one-to-many relationship, and not on the
    “many” side of a many-to-one or many-to-many relationship.](#error-bbf0), and
    the issue is in fact a misunderstanding of the “delete-orphan” cascade setting.
    See that message for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](#error-bbf0)'
  prefs: []
  type: TYPE_NORMAL
- en: '### relationship X will copy column Q to column P, which conflicts with relationship(s):
    ‘Y’'
  prefs: []
  type: TYPE_NORMAL
- en: This warning refers to the case when two or more relationships will write data
    to the same columns on flush, but the ORM does not have any means of coordinating
    these relationships together. Depending on specifics, the solution may be that
    two relationships need to be referenced by one another using [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), or that one or more of the relationships should
    be configured with [`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") to prevent conflicting writes, or sometimes that
    the configuration is fully intentional and should configure [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") to silence each warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the typical example that’s missing [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), given the following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping will generate warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The relationships `Child.parent` and `Parent.children` appear to be in conflict.
    The solution is to apply [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'For more customized relationships where an “overlap” situation may be intentional
    and cannot be resolved, the [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") parameter may specify the names of relationships
    for which the warning should not take effect. This typically occurs for two or
    more relationships to the same underlying table that include custom [`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") conditions that limit the related items in each
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Above, the ORM will know that the overlap between `Parent.c1`, `Parent.c2` and
    `Child.parent` is intentional.
  prefs: []
  type: TYPE_NORMAL
- en: '### Object cannot be converted to ‘persistent’ state, as this identity map
    is no longer valid.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.26.
  prefs: []
  type: TYPE_NORMAL
- en: 'This message was added to accommodate for the case where a [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that would yield ORM objects is iterated after
    the originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has been closed, or otherwise had its [`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") method called. When a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") expunges all objects at once, the internal [identity
    map](glossary.html#term-identity-map) used by that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is replaced with a new one, and the original one discarded.
    An unconsumed and unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will internally maintain a reference to that
    now-discarded identity map. Therefore, when the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is consumed, the objects that would be yielded cannot
    be associated with that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This arrangement is by design as it is generally not
    recommended to iterate an unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object outside of the transactional context in which
    it was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The above situation typically will **not** occur when using the `asyncio` ORM
    extension, as when [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") returns a sync-style [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"), the results have been pre-buffered when the statement
    was executed. This is to allow secondary eager loaders to invoke without needing
    an additional `await` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pre-buffer results in the above situation using the regular [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in the same way that the `asyncio` extension does it,
    the `prebuffer_rows` execution option may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Above, the selected ORM objects are fully generated within the `session_obj`
    block, associated with `session_obj` and buffered within the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object for iteration. Outside the block, `session_obj`
    is closed and expunges these ORM objects. Iterating the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will yield those ORM objects, however as their
    originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has expunged them, they will be delivered in the [detached](glossary.html#term-detached)
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The above reference to a “pre-buffered” vs. “un-buffered” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object refers to the process by which the ORM converts
    incoming raw database rows from the [DBAPI](glossary.html#term-DBAPI) into ORM
    objects. It does not imply whether or not the underlying `cursor` object itself,
    which represents pending results from the DBAPI, is itself buffered or unbuffered,
    as this is essentially a lower layer of buffering. For background on buffering
    of the `cursor` results itself, see the section [Using Server Side Cursors (a.k.a.
    stream results)](core/connections.html#engine-stream-results).
  prefs: []
  type: TYPE_NORMAL
- en: '### Type annotation can’t be interpreted for Annotated Declarative Table form'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 introduces a new [Annotated Declarative Table](orm/declarative_tables.html#orm-declarative-mapped-column)
    declarative system which derives ORM mapped attribute information from [**PEP
    484**](https://peps.python.org/pep-0484/) annotations within class definitions
    at runtime. A requirement of this form is that all ORM annotations must make use
    of a generic container called [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to be properly annotated. Legacy SQLAlchemy mappings
    which include explicit [**PEP 484**](https://peps.python.org/pep-0484/) typing
    annotations, such as those which use the [legacy Mypy extension](orm/extensions/mypy.html)
    for typing support, may include directives such as those for [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that don’t include this generic.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve, the classes may be marked with the `__allow_unmapped__` boolean
    attribute until they can be fully migrated to the 2.0 syntax. See the migration
    notes at [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed
    ORM models](changelog/migration_20.html#migration-20-step-six) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](changelog/migration_20.html#migration-20-step-six) - in the [SQLAlchemy
    2.0 - Major Migration Guide](changelog/migration_20.html) document'
  prefs: []
  type: TYPE_NORMAL
- en: '### When transforming <cls> to a dataclass, attribute(s) originate from superclass
    <cls> which is not a dataclass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This warning occurs when using the SQLAlchemy ORM Mapped Dataclasses feature
    described at [Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    in conjunction with any mixin class or abstract base that is not itself declared
    as a dataclass, such as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, since `Mixin` does not itself extend from [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), the following warning is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to add [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") to the signature of `Mixin` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Python’s [**PEP 681**](https://peps.python.org/pep-0681/) specification does
    not accommodate for attributes declared on superclasses of dataclasses that are
    not themselves dataclasses; per the behavior of Python dataclasses, such fields
    are ignored, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `User` class will not include `create_user` in its constructor nor
    will it attempt to interpret `update_user` as a dataclass attribute. This is because
    `Mixin` is not a dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s dataclasses feature within the 2.0 series does not honor this behavior
    correctly; instead, attributes on non-dataclass mixins and superclasses are treated
    as part of the final dataclass configuration. However type checkers such as Pyright
    and Mypy will not consider these fields as part of the dataclass constructor as
    they are to be ignored per [**PEP 681**](https://peps.python.org/pep-0681/). Since
    their presence is ambiguous otherwise, SQLAlchemy 2.1 will require that mixin
    classes which have SQLAlchemy mapped attributes within a dataclass hierarchy have
    to themselves be dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '### Python dataclasses error encountered when creating dataclass for <classname>'
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin class or [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator, SQLAlchemy makes use
    of the actual [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    module that’s in the Python standard library in order to apply dataclass behaviors
    to the target class. This API has its own error scenarios, most of which involve
    the construction of an `__init__()` method on the user defined class; the order
    of attributes declared on the class, as well as [on superclasses](https://docs.python.org/3/library/dataclasses.html#inheritance),
    determines how the `__init__()` method will be constructed and there are specific
    rules in how the attributes are organized as well as how they should make use
    of parameters such as `init=False`, `kw_only=True`, etc. **SQLAlchemy does not
    control or implement these rules**. Therefore, for errors of this nature, consult
    the [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) documentation,
    with special attention to the rules applied to [inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    on the python.org website'
  prefs: []
  type: TYPE_NORMAL
- en: '[inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance)
    - on the python.org website'
  prefs: []
  type: TYPE_NORMAL
- en: '### per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error occurs when making use of the [ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    feature without supplying primary key values in the given records, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the presence of a list of parameter dictionaries combined with usage
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to execute an ORM-enabled UPDATE statement will automatically make use of ORM
    Bulk Update by Primary Key, which expects parameter dictionaries to include primary
    key values, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the UPDATE statement without supplying per-record primary key values,
    use [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") to acquire the current [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), then invoke with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)'
  prefs: []
  type: TYPE_NORMAL
- en: AsyncIO Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### AwaitRequired'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy async mode requires an async driver to be used to connect to
    the db. This error is usually raised when trying to use the async version of SQLAlchemy
    with a non compatible [DBAPI](glossary.html#term-DBAPI).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Asynchronous I/O (asyncio)](orm/extensions/asyncio.html)  ### MissingGreenlet'
  prefs: []
  type: TYPE_NORMAL
- en: A call to the async [DBAPI](glossary.html#term-DBAPI) was initiated outside
    the greenlet spawn context usually setup by the SQLAlchemy AsyncIO proxy classes.
    Usually this error happens when an IO was attempted in an unexpected place, using
    a calling pattern that does not directly provide for use of the `await` keyword.
    When using the ORM this is nearly always due to the use of [lazy loading](glossary.html#term-lazy-loading),
    which is not directly supported under asyncio without additional steps and/or
    alternate loader patterns in order to use successfully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing Implicit IO when Using AsyncSession](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - covers most ORM scenarios where this problem can occur and how to mitigate,
    including specific patterns to use with lazy load scenarios.  ### No Inspection
    Available'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function directly on an [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") object is not currently supported, as there
    is not yet an awaitable form of the [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object available. Instead, the object
    is used by acquiring it using the [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function in such a way that it refers to the underlying
    [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") attribute of the [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") object; the `Inspector` is then used
    in a “synchronous” calling style by using the [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") method along with a custom
    function that performs the desired operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the Inspector to inspect schema objects](orm/extensions/asyncio.html#asyncio-inspector)
    - additional examples of using [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") with the asyncio extension.  ### AwaitRequired'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy async mode requires an async driver to be used to connect to
    the db. This error is usually raised when trying to use the async version of SQLAlchemy
    with a non compatible [DBAPI](glossary.html#term-DBAPI).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Asynchronous I/O (asyncio)](orm/extensions/asyncio.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### MissingGreenlet'
  prefs: []
  type: TYPE_NORMAL
- en: A call to the async [DBAPI](glossary.html#term-DBAPI) was initiated outside
    the greenlet spawn context usually setup by the SQLAlchemy AsyncIO proxy classes.
    Usually this error happens when an IO was attempted in an unexpected place, using
    a calling pattern that does not directly provide for use of the `await` keyword.
    When using the ORM this is nearly always due to the use of [lazy loading](glossary.html#term-lazy-loading),
    which is not directly supported under asyncio without additional steps and/or
    alternate loader patterns in order to use successfully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing Implicit IO when Using AsyncSession](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - covers most ORM scenarios where this problem can occur and how to mitigate,
    including specific patterns to use with lazy load scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: '### No Inspection Available'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function directly on an [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") object is not currently supported, as there
    is not yet an awaitable form of the [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object available. Instead, the object
    is used by acquiring it using the [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function in such a way that it refers to the underlying
    [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") attribute of the [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") object; the `Inspector` is then used
    in a “synchronous” calling style by using the [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") method along with a custom
    function that performs the desired operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the Inspector to inspect schema objects](orm/extensions/asyncio.html#asyncio-inspector)
    - additional examples of using [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") with the asyncio extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Core Exception Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Core Exceptions](core/exceptions.html) for Core exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: ORM Exception Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [ORM Exceptions](orm/exceptions.html) for ORM exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions in this section are not generated by current SQLAlchemy versions,
    however are provided here to suit exception message hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: '### The <some function> in SQLAlchemy 2.0 will no longer <something>'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 represents a major shift for a wide variety of key SQLAlchemy
    usage patterns in both the Core and ORM components. The goal of the 2.0 release
    is to make a slight readjustment in some of the most fundamental assumptions of
    SQLAlchemy since its early beginnings, and to deliver a newly streamlined usage
    model that is hoped to be significantly more minimalist and consistent between
    the Core and ORM components, as well as more capable.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced at [SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html),
    the SQLAlchemy 2.0 project includes a comprehensive future compatibility system
    that’s integrated into the 1.4 series of SQLAlchemy, such that applications will
    have a clear, unambiguous, and incremental upgrade path in order to migrate applications
    to being fully 2.0 compatible. The `RemovedIn20Warning` deprecation warning is
    at the base of this system to provide guidance on what behaviors in an existing
    codebase will need to be modified. An overview of how to enable this warning is
    at [SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html) - An
    overview of the upgrade process from the 1.x series, as well as the current goals
    and progress of SQLAlchemy 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - specific guidelines on how to use “2.0 deprecations mode” in SQLAlchemy 1.4.  ###
    Object is being merged into a Session along the backref cascade'
  prefs: []
  type: TYPE_NORMAL
- en: This message refers to the “backref cascade” behavior of SQLAlchemy, removed
    in version 2.0\. This refers to the action of an object being added into a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as a result of another object that’s already present
    in that session being associated with it. As this behavior has been shown to be
    more confusing than helpful, the [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameters were added, which can be set to `False` to
    disable it, and in SQLAlchemy 2.0 the “cascade backrefs” behavior has been removed
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: For older SQLAlchemy versions, to set [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") to `False` on a backref that is currently configured
    using the [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") string parameter, the backref must be declared
    using the [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    function first so that the [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameter may be passed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the entire “cascade backrefs” behavior can be turned off across
    the board by using the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in “future” mode, by passing `True` for the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](changelog/migration_14.html#change-5150)
    - background on the change for SQLAlchemy 2.0.  ### select() construct created
    in “legacy” mode; keyword arguments, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct has been updated as of SQLAlchemy 1.4 to support the newer calling style
    that is standard in SQLAlchemy 2.0\. For backwards compatibility within the 1.4
    series, the construct accepts arguments in both the “legacy” style as well as
    the “new” style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “new” style features that column and table expressions are passed positionally
    to the [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct only; any other modifiers to the object must be passed using subsequent
    method chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, a [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in legacy forms of SQLAlchemy, before methods
    like [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") were even added, would like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even that the “whereclause” would be passed positionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'For some years now, the additional “whereclause” and other arguments that are
    accepted have been removed from most narrative documentation, leading to a calling
    style that is most familiar as the list of column arguments passed as a list,
    but no further arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The document at [select() no longer accepts varied constructor arguments, columns
    are passed positionally](changelog/migration_20.html#migration-20-5284) describes
    this change in terms of [2.0 Migration](changelog/migration_20.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html)  ###
    A bind was located via legacy bound metadata, but since future=True is set on
    this Session, this bind is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of “bound metadata” is present up until SQLAlchemy 1.4; as of SQLAlchemy
    2.0 it’s been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error refers to the [`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData") parameter on the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that in turn allows objects like the ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to associate a particular mapped class with an `Engine`. In SQLAlchemy 2.0, the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    must be linked to each `Engine` directly. That is, instead of instantiating the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    without any arguments, and associating the [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    must instead be associated directly with the [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object should no longer be associated with any engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQLAlchemy 1.4, this [2.0 style](glossary.html#term-2.0-style) behavior
    is enabled when the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag is set on [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").  ### This Compiled object is not bound to any Engine
    or Connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error refers to the concept of “bound metadata”, which is a legacy SQLAlchemy
    pattern present only in 1.x versions. The issue occurs when one invokes the `Executable.execute()`
    method directly off of a Core expression object that is not associated with any
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'What the logic is expecting is that the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object has been **bound** to a [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Where above, any statement that derives from a [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which in turn derives from that [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will implicitly make use of the given [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in order to invoke the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the concept of bound metadata is **not present in SQLAlchemy 2.0**.
    The correct way to invoke statements is via the [`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method of a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the ORM, a similar facility is available via the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Basics of Statement Execution](tutorial/dbapi_transactions.html#tutorial-statement-execution)  ###
    This connection is on an inactive transaction. Please rollback() fully before
    proceeding'
  prefs: []
  type: TYPE_NORMAL
- en: This error condition was added to SQLAlchemy as of version 1.4, and does not
    apply to SQLAlchemy 2.0\. The error refers to the state where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is placed into a transaction using a method like
    [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"), and then a further “marker” transaction
    is created within that scope; the “marker” transaction is then rolled back using
    [`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or closed using [`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close"), however the outer transaction is still
    present in an “inactive” state and must be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Above, `transaction2` is a “marker” transaction, which indicates a logical nesting
    of transactions within an outer one; while the inner transaction can roll back
    the whole transaction via its rollback() method, its commit() method has no effect
    except to close the scope of the “marker” transaction itself. The call to `transaction2.rollback()`
    has the effect of **deactivating** transaction1 which means it is essentially
    rolled back at the database level, however is still present in order to accommodate
    a consistent nesting pattern of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct resolution is to ensure the outer transaction is also rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is not commonly used in Core. Within the ORM, a similar issue can
    occur which is the product of the ORM’s “logical” transaction structure; this
    is described in the FAQ entry at [“This Session’s transaction has been rolled
    back due to a previous exception during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  prefs: []
  type: TYPE_NORMAL
- en: 'The “subtransaction” pattern is removed in SQLAlchemy 2.0 so that this particular
    programming pattern is no longer be available, preventing this error message.  ###
    The <some function> in SQLAlchemy 2.0 will no longer <something>'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 represents a major shift for a wide variety of key SQLAlchemy
    usage patterns in both the Core and ORM components. The goal of the 2.0 release
    is to make a slight readjustment in some of the most fundamental assumptions of
    SQLAlchemy since its early beginnings, and to deliver a newly streamlined usage
    model that is hoped to be significantly more minimalist and consistent between
    the Core and ORM components, as well as more capable.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced at [SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html),
    the SQLAlchemy 2.0 project includes a comprehensive future compatibility system
    that’s integrated into the 1.4 series of SQLAlchemy, such that applications will
    have a clear, unambiguous, and incremental upgrade path in order to migrate applications
    to being fully 2.0 compatible. The `RemovedIn20Warning` deprecation warning is
    at the base of this system to provide guidance on what behaviors in an existing
    codebase will need to be modified. An overview of how to enable this warning is
    at [SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html) - An
    overview of the upgrade process from the 1.x series, as well as the current goals
    and progress of SQLAlchemy 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - specific guidelines on how to use “2.0 deprecations mode” in SQLAlchemy 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Object is being merged into a Session along the backref cascade'
  prefs: []
  type: TYPE_NORMAL
- en: This message refers to the “backref cascade” behavior of SQLAlchemy, removed
    in version 2.0\. This refers to the action of an object being added into a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as a result of another object that’s already present
    in that session being associated with it. As this behavior has been shown to be
    more confusing than helpful, the [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameters were added, which can be set to `False` to
    disable it, and in SQLAlchemy 2.0 the “cascade backrefs” behavior has been removed
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: For older SQLAlchemy versions, to set [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") to `False` on a backref that is currently configured
    using the [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") string parameter, the backref must be declared
    using the [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    function first so that the [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameter may be passed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the entire “cascade backrefs” behavior can be turned off across
    the board by using the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in “future” mode, by passing `True` for the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](changelog/migration_14.html#change-5150)
    - background on the change for SQLAlchemy 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '### select() construct created in “legacy” mode; keyword arguments, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct has been updated as of SQLAlchemy 1.4 to support the newer calling style
    that is standard in SQLAlchemy 2.0\. For backwards compatibility within the 1.4
    series, the construct accepts arguments in both the “legacy” style as well as
    the “new” style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “new” style features that column and table expressions are passed positionally
    to the [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct only; any other modifiers to the object must be passed using subsequent
    method chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, a [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in legacy forms of SQLAlchemy, before methods
    like [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") were even added, would like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even that the “whereclause” would be passed positionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'For some years now, the additional “whereclause” and other arguments that are
    accepted have been removed from most narrative documentation, leading to a calling
    style that is most familiar as the list of column arguments passed as a list,
    but no further arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The document at [select() no longer accepts varied constructor arguments, columns
    are passed positionally](changelog/migration_20.html#migration-20-5284) describes
    this change in terms of [2.0 Migration](changelog/migration_20.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### A bind was located via legacy bound metadata, but since future=True is
    set on this Session, this bind is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of “bound metadata” is present up until SQLAlchemy 1.4; as of SQLAlchemy
    2.0 it’s been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This error refers to the [`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData") parameter on the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that in turn allows objects like the ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to associate a particular mapped class with an `Engine`. In SQLAlchemy 2.0, the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    must be linked to each `Engine` directly. That is, instead of instantiating the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    without any arguments, and associating the [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    must instead be associated directly with the [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object should no longer be associated with any engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: In SQLAlchemy 1.4, this [2.0 style](glossary.html#term-2.0-style) behavior is
    enabled when the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag is set on [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  prefs: []
  type: TYPE_NORMAL
- en: '### This Compiled object is not bound to any Engine or Connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error refers to the concept of “bound metadata”, which is a legacy SQLAlchemy
    pattern present only in 1.x versions. The issue occurs when one invokes the `Executable.execute()`
    method directly off of a Core expression object that is not associated with any
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'What the logic is expecting is that the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object has been **bound** to a [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Where above, any statement that derives from a [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which in turn derives from that [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will implicitly make use of the given [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in order to invoke the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the concept of bound metadata is **not present in SQLAlchemy 2.0**.
    The correct way to invoke statements is via the [`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method of a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the ORM, a similar facility is available via the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Basics of Statement Execution](tutorial/dbapi_transactions.html#tutorial-statement-execution)'
  prefs: []
  type: TYPE_NORMAL
- en: '### This connection is on an inactive transaction. Please rollback() fully
    before proceeding'
  prefs: []
  type: TYPE_NORMAL
- en: This error condition was added to SQLAlchemy as of version 1.4, and does not
    apply to SQLAlchemy 2.0\. The error refers to the state where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is placed into a transaction using a method like
    [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"), and then a further “marker” transaction
    is created within that scope; the “marker” transaction is then rolled back using
    [`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or closed using [`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close"), however the outer transaction is still
    present in an “inactive” state and must be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Above, `transaction2` is a “marker” transaction, which indicates a logical nesting
    of transactions within an outer one; while the inner transaction can roll back
    the whole transaction via its rollback() method, its commit() method has no effect
    except to close the scope of the “marker” transaction itself. The call to `transaction2.rollback()`
    has the effect of **deactivating** transaction1 which means it is essentially
    rolled back at the database level, however is still present in order to accommodate
    a consistent nesting pattern of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct resolution is to ensure the outer transaction is also rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is not commonly used in Core. Within the ORM, a similar issue can
    occur which is the product of the ORM’s “logical” transaction structure; this
    is described in the FAQ entry at [“This Session’s transaction has been rolled
    back due to a previous exception during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  prefs: []
  type: TYPE_NORMAL
- en: The “subtransaction” pattern is removed in SQLAlchemy 2.0 so that this particular
    programming pattern is no longer be available, preventing this error message.
  prefs: []
  type: TYPE_NORMAL
