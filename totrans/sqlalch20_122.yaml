- en: Error Messages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误消息
- en: 原文：[https://docs.sqlalchemy.org/en/20/errors.html](https://docs.sqlalchemy.org/en/20/errors.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/errors.html](https://docs.sqlalchemy.org/en/20/errors.html)
- en: This section lists descriptions and background for common error messages and
    warnings raised or emitted by SQLAlchemy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了SQLAlchemy引发或发出的常见错误消息和警告的描述和背景。
- en: SQLAlchemy normally raises errors within the context of a SQLAlchemy-specific
    exception class. For details on these classes, see [Core Exceptions](core/exceptions.html)
    and [ORM Exceptions](orm/exceptions.html).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy通常在SQLAlchemy特定的异常类的上下文中引发错误。有关这些类的详细信息，请参见[核心异常](core/exceptions.html)和[ORM异常](orm/exceptions.html)。
- en: SQLAlchemy errors can roughly be separated into two categories, the **programming-time
    error** and the **runtime error**. Programming-time errors are raised as a result
    of functions or methods being called with incorrect arguments, or from other configuration-oriented
    methods such as mapper configurations that can’t be resolved. The programming-time
    error is typically immediate and deterministic. The runtime error on the other
    hand represents a failure that occurs as a program runs in response to some condition
    that occurs arbitrarily, such as database connections being exhausted or some
    data-related issue occurring. Runtime errors are more likely to be seen in the
    logs of a running application as the program encounters these states in response
    to load and data being encountered.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy错误大致可分为两类，即**编程时错误**和**运行时错误**。编程时错误是由于函数或方法使用不正确的参数而引发的，或者来自于无法解析的其他配置方法，例如无法解析的映射器配置。编程时错误通常是即时且确定的。另一方面，运行时错误表示程序运行时响应某些随机条件发生的失败，例如数据库连接耗尽或发生某些数据相关问题。运行时错误更可能出现在正在运行的应用程序的日志中，因为程序在遇到这些状态时会对负载和遇到的数据做出响应。
- en: Since runtime errors are not as easy to reproduce and often occur in response
    to some arbitrary condition as the program runs, they are more difficult to debug
    and also affect programs that have already been put into production.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运行时错误不容易重现，并且通常发生在程序运行时对某些任意条件的响应中，它们更难以调试，也会影响到已经投入生产的程序。
- en: Within this section, the goal is to try to provide background on some of the
    most common runtime errors as well as programming time errors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，目标是尝试提供关于一些最常见的运行时错误以及编程时错误的背景信息。
- en: Connections and Transactions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和事务
- en: '### QueuePool limit of size <x> overflow <y> reached, connection timed out,
    timeout <z>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### 队列池大小 <x> 超出 <y> 达到，连接超时，超时 <z>'
- en: This is possibly the most common runtime error experienced, as it directly involves
    the work load of the application surpassing a configured limit, one which typically
    applies to nearly all SQLAlchemy applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常见的运行时错误，直接涉及到应用程序的工作负载超过了一个配置的限制，这个限制通常适用于几乎所有的SQLAlchemy应用程序。
- en: The following points summarize what this error means, beginning with the most
    fundamental points that most SQLAlchemy users should already be familiar with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了此错误的含义，从大多数SQLAlchemy用户应该已经熟悉的最基本的要点开始。
- en: '**The SQLAlchemy Engine object uses a pool of connections by default** - What
    this means is that when one makes use of a SQL database connection resource of
    an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, and then [releases](glossary.html#term-releases) that resource, the database
    connection itself remains connected to the database and is returned to an internal
    queue where it can be used again. Even though the code may appear to be ending
    its conversation with the database, in many cases the application will still maintain
    a fixed number of database connections that persist until the application ends
    or the pool is explicitly disposed.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLAlchemy引擎对象默认使用一个连接池** - 这意味着当一个[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象使用一个SQL数据库连接资源，并且然后[释放](glossary.html#term-releases)该资源时，数据库连接本身保持连接到数据库，并返回到一个内部队列，可以再次使用。即使代码似乎已经结束了与数据库的对话，在许多情况下，应用程序仍将保持一定数量的数据库连接，直到应用程序结束或池明确释放为止。'
- en: Because of the pool, when an application makes use of a SQL database connection,
    most typically from either making use of [`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") or when making queries using an ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), this activity does not necessarily establish a new
    connection to the database at the moment the connection object is acquired; it
    instead consults the connection pool for a connection, which will often retrieve
    an existing connection from the pool to be re-used. If no connections are available,
    the pool will create a new database connection, but only if the pool has not surpassed
    a configured capacity.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于池的存在，当应用程序使用SQL数据库连接时，通常是从使用[`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect")或使用ORM[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")进行查询时，此活动不一定会在获取连接对象时立即建立到数据库的新连接；它反而会向连接池查询连接，该连接池通常会从池中检索一个现有的连接以供重用。如果没有可用连接，则池将创建一个新的数据库连接，但仅当池未超过配置的容量时。
- en: 'The default pool used in most cases is called [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). When you ask this pool to give you a connection
    and none are available, it will create a new connection **if the total number
    of connections in play are less than a configured value**. This value is equal
    to the **pool size plus the max overflow**. That means if you have configured
    your engine as:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下使用的默认池被称为[`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")。当您请求此池提供连接并且没有可用连接时，它会创建一个新连接**如果当前使用的连接总数小于配置的值**。这个值等于**池大小加上最大溢出**。这意味着如果您已将引擎配置为：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    will allow **at most 30 connections** to be in play at any time, not including
    connections that were detached from the engine or invalidated. If a request for
    a new connection arrives and 30 connections are already in use by other parts
    of the application, the connection pool will block for a fixed period of time,
    before timing out and raising this error message.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述[`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")将允许**最多30个连接**在任何时候使用，不包括从引擎分离或失效的连接。如果一个新连接的请求到达，而应用程序的其他部分已经使用了30个连接，连接池将在固定时间内阻塞，然后超时并引发此错误消息。
- en: In order to allow for a higher number of connections be in use at once, the
    pool can be adjusted using the [`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine") and [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") parameters as passed to the [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function. The timeout to wait for a connection to
    be available is configured using the [`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine") parameter.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了允许一次使用更多的连接，可以使用传递给[`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")函数的[`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine")和[`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine")参数来调整池。等待连接可用的超时时间通过[`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine")参数进行配置。
- en: The pool can be configured to have unlimited overflow by setting [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") to the value “-1”. With this setting, the pool will
    still maintain a fixed pool of connections, however it will never block upon a
    new connection being requested; it will instead unconditionally make a new connection
    if none are available.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将[`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine")设置为值“-1”，可以配置池具有无限的溢出。使用此设置，池仍然会维护一组固定的连接，但如果没有可用连接，则绝对会创建一个新连接，而不会阻塞。
- en: However, when running in this way, if the application has an issue where it
    is using up all available connectivity resources, it will eventually hit the configured
    limit of available connections on the database itself, which will again return
    an error. More seriously, when the application exhausts the database of connections,
    it usually will have caused a great amount of resources to be used up before failing,
    and can also interfere with other applications and database status mechanisms
    that rely upon being able to connect to the database.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，当以这种方式运行时，如果应用程序存在使用所有可用连接资源的问题，最终会达到数据库本身可用连接的配置限制，这将再次返回一个错误。更严重的是，当应用程序耗尽连接数据库的连接时，通常会在失败之前使用大量资源，并且还可能干扰依赖于能够连接到数据库的其他应用程序和数据库状态机制。
- en: Given the above, the connection pool can be looked at as a **safety valve for
    connection use**, providing a critical layer of protection against a rogue application
    causing the entire database to become unavailable to all other applications. When
    receiving this error message, it is vastly preferable to repair the issue using
    up too many connections and/or configure the limits appropriately, rather than
    allowing for unlimited overflow which does not actually solve the underlying issue.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鉴于上述情况，可以将连接池视为连接使用的**安全阀**，为防止恶意应用程序导致整个数据库对所有其他应用程序不可用提供了关键的保护层。在收到此错误消息时，最好修复使用过多连接的问题和/或适当配置限制，而不是允许无限溢出，因为这实际上并不能解决潜在的问题。
- en: What causes an application to use up all the connections that it has available?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 什么导致应用程序使用完所有可用的连接？
- en: '**The application is fielding too many concurrent requests to do work based
    on the configured value for the pool** - This is the most straightforward cause.
    If you have an application that runs in a thread pool that allows for 30 concurrent
    threads, with one connection in use per thread, if your pool is not configured
    to allow at least 30 connections checked out at once, you will get this error
    once your application receives enough concurrent requests. Solution is to raise
    the limits on the pool or lower the number of concurrent threads.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序正在处理基于池配置值的太多并发请求以执行工作** - 这是最直接的原因。如果您有一个在允许 30 个并发线程的线程池中运行的应用程序，并且每个线程使用一个连接，如果您的池未配置为允许至少同时检出
    30 个连接，那么一旦您的应用程序接收到足够的并发请求，您将收到此错误。解决方案是提高池的限制或降低并发线程数。'
- en: '**The application is not returning connections to the pool** - This is the
    next most common reason, which is that the application is making use of the connection
    pool, but the program is failing to [release](glossary.html#term-release) these
    connections and is instead leaving them open. The connection pool as well as the
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    do have logic such that when the session and/or connection object is garbage collected,
    it results in the underlying connection resources being released, however this
    behavior cannot be relied upon to release resources in a timely manner.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序未将连接返回到池中** - 这是下一个最常见的原因，即应用程序正在使用连接池，但程序未能[释放](glossary.html#term-release)这些连接，而是将它们保持打开状态。连接池以及ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    确实具有逻辑，以便当会话和/或连接对象被垃圾收集时，会导致底层连接资源被释放，但是不能依赖此行为及时释放资源。'
- en: A common reason this can occur is that the application uses ORM sessions and
    does not call [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") upon them one the work involving that session
    is complete. Solution is to make sure ORM sessions if using the ORM, or engine-bound
    [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects if using Core, are explicitly closed at the end of the work being done,
    either via the appropriate `.close()` method, or by using one of the available
    context managers (e.g. “with:” statement) to properly release the resource.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 造成这种情况的常见原因是应用程序使用ORM会话，但在完成涉及该会话的工作后未调用 [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")。解决方法是确保ORM会话（如果使用ORM）或引擎绑定的[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象（如果使用Core）在完成工作后明确关闭，可以通过适当的`.close()`方法或使用可用的上下文管理器之一（例如，“with:”语句）来正确释放资源。
- en: '**The application is attempting to run long-running transactions** - A database
    transaction is a very expensive resource, and should **never be left idle waiting
    for some event to occur**. If an application is waiting for a user to push a button,
    or a result to come off of a long running job queue, or is holding a persistent
    connection open to a browser, **don’t keep a database transaction open for the
    whole time**. As the application needs to work with the database and interact
    with an event, open a short-lived transaction at that point and then close it.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序试图运行长时间事务** - 数据库事务是非常昂贵的资源，**永远不应保持空闲以等待某个事件发生**。如果应用程序正在等待用户按下按钮，或者等待长时间运行的作业队列中的结果，或者保持持久连接以向浏览器发送请求，**不要在整个时间内保持数据库事务处于打开状态**。当应用程序需要与数据库交互并与事件交互时，在该点打开一个短暂的事务，然后关闭它。'
- en: '**The application is deadlocking** - Also a common cause of this error and
    more difficult to grasp, if an application is not able to complete its use of
    a connection either due to an application-side or database-side deadlock, the
    application can use up all the available connections which then leads to additional
    requests receiving this error. Reasons for deadlocks include:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序发生死锁** - 也是此错误的常见原因，更难以理解，如果应用程序由于应用程序端或数据库端的死锁而无法完成对连接的使用，则应用程序可能会使用完所有可用连接，从而导致附加请求接收到此错误。造成死锁的原因包括：'
- en: Using an implicit async system such as gevent or eventlet without properly monkeypatching
    all socket libraries and drivers, or which has bugs in not fully covering for
    all monkeypatched driver methods, or less commonly when the async system is being
    used against CPU-bound workloads and greenlets making use of database resources
    are simply waiting too long to attend to them. Neither implicit nor explicit async
    programming frameworks are typically necessary or appropriate for the vast majority
    of relational database operations; if an application must use an async system
    for some area of functionality, it’s best that database-oriented business methods
    run within traditional threads that pass messages to the async part of the application.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用隐式异步系统（如 gevent 或 eventlet）时，如果未正确地对所有套接字库和驱动程序进行猴子补丁，或者对所有猴子补丁驱动程序方法的覆盖不完全，或者在异步系统用于
    CPU 绑定的工作负载并且使用数据库资源的 greenlets 等待时间过长时，可能会出现问题。通常情况下，隐式或显式的异步编程框架对于绝大多数关系型数据库操作来说通常不是必要的或合适的；如果应用程序必须在某些功能区域使用异步系统，则最好是数据库导向型业务方法在传统线程内运行，而将消息传递给应用程序的异步部分。
- en: A database side deadlock, e.g. rows are mutually deadlocked
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库端的死锁，例如行相互死锁
- en: Threading errors, such as mutexes in a mutual deadlock, or calling upon an already
    locked mutex in the same thread
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程错误，例如互相死锁的互斥体，或者在同一线程中调用已锁定的互斥体
- en: Keep in mind an alternative to using pooling is to turn off pooling entirely.
    See the section [Switching Pool Implementations](core/pooling.html#pool-switching)
    for background on this. However, note that when this error message is occurring,
    it is **always** due to a bigger problem in the application itself; the pool just
    helps to reveal the problem sooner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用连接池的另一种选择是完全关闭连接池。有关此问题的背景，请参阅[切换池实现](core/pooling.html#pool-switching)一节。然而，要注意，当发生此错误消息时，这总是由于应用程序本身的问题更大；池只是帮助更早地揭示问题。
- en: See also
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Connection Pooling](core/pooling.html)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接池](core/pooling.html)'
- en: '[Working with Engines and Connections](core/connections.html)  ### Pool class
    cannot be used with asyncio engine (or vice versa)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[与引擎和连接一起工作](core/connections.html) ### Pool 类不能与 asyncio 引擎一起使用（反之亦然）'
- en: The [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    pool class uses a `thread.Lock` object internally and is not compatible with asyncio.
    If using the [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") function to create an [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine"), the appropriate queue pool class is [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), which is used automatically and does
    not need to be specified.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")池类在内部使用`thread.Lock`对象，与asyncio不兼容。如果使用[`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine")函数创建[`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")，则适当的队列池类是[`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")，它会自动使用，无需指定。'
- en: In addition to [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), the [`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") and [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") pool classes do not use locks and are also suitable
    for use with async engines.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")之外，[`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")和[`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")池类不使用锁，并且也适用于与异步引擎一起使用。
- en: This error is also raised in reverse in the unlikely case that the [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") pool class is indicated explicitly with
    the [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果使用[`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")函数明确指定[`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")池类，则也会引发此错误。
- en: See also
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Connection Pooling](core/pooling.html)  ### Can’t reconnect until invalid
    transaction is rolled back. Please rollback() fully before proceeding'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接池](core/pooling.html)  ### 在无效事务回滚之前无法重新连接。请在继续之前完全回滚()'
- en: 'This error condition refers to the case where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") was invalidated, either due to a database disconnect
    detection or due to an explicit call to [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate"), but there is still a transaction present
    that was initiated either explicitly by the [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or due to the connection automatically
    beginning a transaction as occurs in the 2.x series of SQLAlchemy when any SQL
    statements are emitted. When a connection is invalidated, any [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") that was in progress is now in an invalid state,
    and must be explicitly rolled back in order to remove it from the [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").  ## DBAPI Errors'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误条件指的是[`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")被使无效，无论是由于数据库断开连接检测还是由于显式调用[`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate")，但仍然存在一个事务，该事务是由[`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin")方法显式启动，或者由于连接在发出任何SQL语句时自动开始事务，如SQLAlchemy
    2.x系列中发生的情况。当连接被使无效时，任何正在进行的[`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")现在处于无效状态，必须显式回滚以将其从[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")中移除。  ## DBAPI错误'
- en: The Python database API, or DBAPI, is a specification for database drivers which
    can be located at [Pep-249](https://www.python.org/dev/peps/pep-0249/). This API
    specifies a set of exception classes that accommodate the full range of failure
    modes of the database.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python数据库API，或者DBAPI，是一个数据库驱动程序的规范，可以在[Pep-249](https://www.python.org/dev/peps/pep-0249/)找到。这个API指定了一组异常类，适应了数据库的所有故障模式。
- en: SQLAlchemy does not generate these exceptions directly. Instead, they are intercepted
    from the database driver and wrapped by the SQLAlchemy-provided exception [`DBAPIError`](core/exceptions.html#sqlalchemy.exc.DBAPIError
    "sqlalchemy.exc.DBAPIError"), however the messaging within the exception is **generated
    by the driver, not SQLAlchemy**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 不直接生成这些异常。相反，它们被从数据库驱动程序拦截并由 SQLAlchemy 提供的异常 [`DBAPIError`](core/exceptions.html#sqlalchemy.exc.DBAPIError
    "sqlalchemy.exc.DBAPIError") 包装，但异常中的消息 **由驱动程序生成，而非 SQLAlchemy**。
- en: '### InterfaceError'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '### InterfaceError'
- en: Exception raised for errors that are related to the database interface rather
    than the database itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库本身而非数据库接口相关的错误引发的异常。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自于数据库驱动程序（DBAPI），而非 SQLAlchemy 本身。
- en: 'The `InterfaceError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    DatabaseError'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterfaceError` 有时会由驱动程序在数据库连接被断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参阅 [处理断开连接](core/pooling.html#pool-disconnects)
    部分。  ### DatabaseError'
- en: Exception raised for errors that are related to the database itself, and not
    the interface or data being passed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库本身而非接口或传递的数据相关的错误引发的异常。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### DataError'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是[DBAPI 错误](#error-dbapi)，源自于数据库驱动程序（DBAPI），而非 SQLAlchemy 本身。  ### DataError'
- en: Exception raised for errors that are due to problems with the processed data
    like division by zero, numeric value out of range, etc.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理数据的问题而引发的错误，例如除以零、数值超出范围等。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### OperationalError'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是[DBAPI 错误](#error-dbapi)，源自于数据库驱动程序（DBAPI），而非 SQLAlchemy 本身。  ### OperationalError'
- en: Exception raised for errors that are related to the database’s operation and
    not necessarily under the control of the programmer, e.g. an unexpected disconnect
    occurs, the data source name is not found, a transaction could not be processed,
    a memory allocation error occurred during processing, etc.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库操作中出现的与程序员控制无关的错误引发的异常，例如出现意外断开连接、找不到数据源名称、无法处理事务、在处理过程中发生内存分配错误等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自于数据库驱动程序（DBAPI），而非 SQLAlchemy 本身。
- en: 'The `OperationalError` is the most common (but not the only) error class used
    by drivers in the context of the database connection being dropped, or not being
    able to connect to the database. For tips on how to deal with this, see the section
    [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ### IntegrityError'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在数据库连接被断开或无法连接到数据库的情况下，`OperationalError` 是驱动程序中最常见（但不是唯一）使用的错误类。有关如何处理此问题的提示，请参阅
    [处理断开连接](core/pooling.html#pool-disconnects) 部分。  ### IntegrityError'
- en: Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的关系完整性受到影响时引发的异常，例如外键检查失败。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### InternalError'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是[DBAPI 错误](#error-dbapi)，源自于数据库驱动程序（DBAPI），而非 SQLAlchemy 本身。  ### InternalError'
- en: Exception raised when the database encounters an internal error, e.g. the cursor
    is not valid anymore, the transaction is out of sync, etc.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库遇到内部错误时引发的异常，例如游标不再有效、事务不同步等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自于数据库驱动程序（DBAPI），而非 SQLAlchemy 本身。
- en: 'The `InternalError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    ProgrammingError'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`InternalError` 有时会由驱动程序在数据库连接被断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参阅 [处理断开连接](core/pooling.html#pool-disconnects)
    部分。  ### ProgrammingError'
- en: Exception raised for programming errors, e.g. table not found or already exists,
    syntax error in the SQL statement, wrong number of parameters specified, etc.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 引发编程错误的异常，例如找不到表或已存在，SQL 语句中的语法错误，指定的参数数量错误等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: 'The `ProgrammingError` is sometimes raised by drivers in the context of the
    database connection being dropped, or not being able to connect to the database.
    For tips on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    NotSupportedError'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgrammingError`有时由驱动程序引发，原因是数据库连接被断开，或者无法连接到数据库。有关如何处理此问题的提示，请参见[处理断开连接](core/pooling.html#pool-disconnects)部分。  ###
    NotSupportedError'
- en: Exception raised in case a method or database API was used which is not supported
    by the database, e.g. requesting a .rollback() on a connection that does not support
    transaction or has transactions turned off.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法或数据库 API 使用数据库不支持的情况下引发异常，例如在不支持事务或已关闭事务的连接上请求`.rollback()`。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: SQL Expression Language
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 表达语言
- en: '### Object will not produce a cache key, Performance Implications'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对象不会产生缓存键，性能影响'
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '自 SQLAlchemy 版本 1.4 起，包括[SQL 编译缓存机制](core/connections.html#sql-caching)在内，将允许
    Core 和 ORM SQL 结构缓存其字符串形式，以及用于从语句中提取结果的其他结构信息，从而在下次使用另一个结构等效构造时跳过相对昂贵的字符串编译过程。此系统依赖于为所有
    SQL 构造实现的功能，包括对象，如 [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")、[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 和 [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 对象，以生成完全代表其状态的**缓存键**，以影响 SQL 编译过程。 '
- en: If the warnings in question refer to widely used objects such as [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and are shown to be affecting the majority
    of SQL constructs being emitted (using the estimation techniques described at
    [Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging))
    such that caching is generally not enabled for an application, this will negatively
    impact performance and can in some cases effectively produce a **performance degradation**
    compared to prior SQLAlchemy versions. The FAQ at [Why is my application slow
    after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching) covers
    this in additional detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题中的警告涉及到广泛使用的对象，例如 [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，并且显示出影响大多数发出的 SQL 结构的情况（使用[估计缓存性能使用日志](core/connections.html#sql-caching-logging)中描述的估算技术），以至于缓存通常不会为应用程序启用，这将对性能产生负面影响，并且在某些情况下，与以前的
    SQLAlchemy 版本相比，实际上可能会产生**性能降低**。[为什么升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching)
    FAQ 对此进行了额外详细的介绍。
- en: Caching disables itself if there’s any doubt
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果存在任何疑问，缓存会自行禁用
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存依赖于能够生成准确表示语句**完整结构**的缓存键以一致的方式。如果特定的 SQL 结构（或类型）没有适当的指令，允许其生成正确的缓存键，则不能安全地启用缓存：
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须表示**完整的结构**：如果两个单独的结构实例的使用可能导致渲染不同的 SQL，则使用不捕捉第一个和第二个元素之间不同之处的缓存键缓存该元素的
    SQL 会导致为第二个实例缓存和渲染错误的 SQL。
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须是**一致的**：如果某个结构代表的状态每次都会更改，比如文字值，为每个实例生成唯一的 SQL，那么这个结构也不适合缓存，因为重复使用该结构会很快填满语句缓存，其中包含可能不会再次使用的唯一
    SQL 字符串，从而达不到缓存的目的。
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 出于上述两个原因，SQLAlchemy 的缓存系统对于决定是否缓存与对象对应的 SQL **非常谨慎**。
- en: Assertion attributes for caching
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存的断言属性
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基于以下标准发出警告。有关每个标准的详细信息，请参阅 [为什么在升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching)
    部分。
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    本身（即由我们传递给 [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    的 URL 的第一部分指定的模块，如 `postgresql+psycopg2://`）必须指示已经审查并测试以正确支持缓存，这由 [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") 属性设置为 `True` 来表示。在使用第三方方言时，请与方言的维护者协商，以便他们可以遵循
    [确保可以启用缓存的步骤](core/connections.html#engine-thirdparty-caching) 并发布新版本。'
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方或用户定义的类型，其继承自[`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")或[`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")必须在其定义中包含[`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok")属性，包括所有派生的子类，遵循[`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok")的文档字符串中描述的指南。如前所述，如果这些数据类型是从第三方库导入的，请与该库的维护者联系，以便他们提供必要的更改并发布新版本。
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方或用户定义的 SQL 构造，它们从诸如[`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")、[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")、[`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 等类继承，包括简单的子类以及设计用于与[自定义 SQL 构造和编译扩展](core/compiler.html)一起使用的构造，通常应包括[`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") 属性设置为 `True` 或 `False`，根据构造的设计而定，遵循[启用自定义构造的缓存支持](core/compiler.html#compilerext-caching)中描述的指南。
- en: See also
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用日志估算缓存性能](core/connections.html#sql-caching-logging) - 关于观察缓存行为和效率的背景信息'
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section  ### Compiler StrSQLCompiler
    can’t render element of type <element type>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[升级到 1.4 和/或 2.x 后，为什么我的应用变慢了？](faq/performance.html#faq-new-caching) - 在[常见问题解答](faq/index.html)部分  ###
    Compiler StrSQLCompiler 无法呈现 `<element type>` 类型的元素'
- en: This error usually occurs when attempting to stringify a SQL expression construct
    that includes elements which are not part of the default compilation; in this
    case, the error will be against the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") class. In less common cases, it can
    also occur when the wrong kind of SQL expression is used with a particular type
    of database backend; in those cases, other kinds of SQL compiler classes will
    be named, such as `SQLCompiler` or `sqlalchemy.dialects.postgresql.PGCompiler`.
    The guidance below is more specific to the “stringification” use case but describes
    the general background as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试对包含不是默认编译的元素的 SQL 表达式构造进行字符串化时，通常会发生此错误；在这种情况下，错误将针对[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler")类。在较少见的情况下，当使用错误类型的 SQL 表达式与特定类型的数据库后端时，也可能发生这种情况；在这些情况下，将命名其他类型的
    SQL 编译器类，例如 `SQLCompiler` 或 `sqlalchemy.dialects.postgresql.PGCompiler`。下面的指南更具体地针对“字符串化”用例，但也描述了一般背景。
- en: 'Normally, a Core SQL construct or ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object can be stringified directly, such as when we use
    `print()`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，核心 SQL 结构或 ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象可以直接字符串化，例如我们使用 `print()`：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the above SQL expression is stringified, the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") compiler class is used, which is a special
    statement compiler that is invoked when a construct is stringified without any
    dialect-specific information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述 SQL 表达式被字符串化时，会使用[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 编译器类，这是一个特殊的语句编译器，当一个结构被字符串化而没有任何特定于方言的信息时会被调用。
- en: 'However, there are many constructs that are specific to some particular kind
    of database dialect, for which the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") doesn’t know how to turn into a string,
    such as the PostgreSQL [“insert on conflict”](postgresql_insert_on_conflict) construct:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多结构是特定于某种特定类型的数据库方言的，对于这些结构，[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 并不知道如何转换成字符串，例如 PostgreSQL 的[“插入冲突”](postgresql_insert_on_conflict)
    结构：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to stringify constructs that are specific to particular backend, the
    [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method must be used, passing
    either an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or a [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object which will invoke the correct compiler. Below we use a PostgreSQL dialect:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了字符串化特定于特定后端的结构，必须使用 [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 方法，传递一个 [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或一个 [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") 对象，这将调用正确的编译器。 下面我们使用 PostgreSQL 方言：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For an ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, the statement can be accessed using the `Query.statement` accessor:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象，可以使用 `Query.statement` 访问器访问语句：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See the FAQ link below for additional detail on direct stringification / compilation
    of SQL elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下面的常见问题解答链接，了解有关直接字符串化/编译 SQL 元素的额外细节。
- en: See also
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](faq/sqlexpressions.html#faq-sql-expression-string)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何将 SQL 表达式渲染为字符串，可能包含内联的绑定参数？](faq/sqlexpressions.html#faq-sql-expression-string)'
- en: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'TypeError: <operator> 不支持在 ‘ColumnProperty’ 和 <something> 实例之间的操作'
- en: 'This often occurs when attempting to use a [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") object in the context of a SQL expression, usually
    within declarative such as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这经常发生在尝试在 SQL 表达式的上下文中使用[`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 或 [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 对象时，通常在声明性语句中，例如：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above, the `cprop` attribute is used inline before it has been mapped, however
    this `cprop` attribute is not a [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), it’s a [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"), which is an interim object and therefore does
    not have the full functionality of either the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or the [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") object that will be mapped onto the `Bar`
    class once the declarative process is complete.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，在映射之前内联使用了 `cprop` 属性，但是这个 `cprop` 属性不是一个[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，而是一个[`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")，这是一个临时对象，因此不具备 [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或 [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") 对象的全部功能，后者将在声明过程完成后映射到 `Bar` 类上。
- en: While the [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") does have a `__clause_element__()` method, which
    allows it to work in some column-oriented contexts, it can’t work in an open-ended
    comparison context as illustrated above, since it has no Python `__eq__()` method
    that would allow it to interpret the comparison to the number “5” as a SQL expression
    and not a regular Python comparison.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    确实有一个 `__clause_element__()` 方法，允许它在某些基于列的上下文中工作，但是它不能在上述开放式比较上下文中工作，因为它没有 Python
    `__eq__()` 方法，该方法将允许它将对数字 “5” 的比较解释为 SQL 表达式而不是常规的 Python 比较。
- en: 'The solution is to access the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly using the [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是直接访问 [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")，使用
    [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") 属性：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '### A value is required for bind parameter <x> (in parameter group <y>)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '### 绑定参数 <x>（在参数组 <y> 中）需要一个值。'
- en: 'This error occurs when a statement makes use of [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") either implicitly or explicitly and does
    not provide a value when the statement is executed:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当语句使用 [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") 而在执行语句时未提供值时，就会发生此错误：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Above, no value has been provided for the parameter “my_param”. The correct
    approach is to provide a value:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，未提供参数 “my_param” 的值。正确的方法是提供一个值：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the message takes the form “a value is required for bind parameter <x>
    in parameter group <y>”, the message is referring to the “executemany” style of
    execution. In this case, the statement is typically an INSERT, UPDATE, or DELETE
    and a list of parameters is being passed. In this format, the statement may be
    generated dynamically to include parameter positions for every parameter given
    in the argument list, where it will use the **first set of parameters** to determine
    what these should be.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息采用“需要参数组 <y> 中的绑定参数 <x> 的值”形式时，消息是指向 “executemany” 执行方式。在这种情况下，语句通常是 INSERT、UPDATE
    或 DELETE，并传递了参数列表。在这种格式中，语句可以动态生成，以包括参数列表中的每个参数的参数位置，其中它将使用 **第一组参数** 来确定这些参数应该是什么。
- en: 'For example, the statement below is calculated based on the first parameter
    set to require the parameters, “a”, “b”, and “c” - these names determine the final
    string format of the statement which will be used for each set of parameters in
    the list. As the second entry does not contain “b”, this error is generated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的语句是基于第一个参数集设置为需要参数 “a”、“b” 和 “c” 而计算的 - 这些名称确定了语句的最终字符串格式，该格式将用于列表中的每组参数。由于第二个条目不包含
    “b”，因此会生成此错误：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since “b” is required, pass it as `None` so that the INSERT may proceed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要 “b”，因此将其传递为 `None`，以便 INSERT 可以继续进行：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Sending Parameters](tutorial/dbapi_transactions.html#tutorial-sending-parameters)  ###
    Expected FROM clause, got Select. To create a FROM clause, use the .subquery()
    method'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[发送参数](tutorial/dbapi_transactions.html#tutorial-sending-parameters)  ### 预期的
    FROM 子句，却收到了 Select。要创建 FROM 子句，请使用 `.subquery()` 方法。'
- en: This refers to a change made as of SQLAlchemy 1.4 where a SELECT statement as
    generated by a function such as [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), but also including things like unions and
    textual SELECT expressions are no longer considered to be [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects and can’t be placed directly in
    the FROM clause of another SELECT statement without them being wrapped in a [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") first. This is a major conceptual change
    in the Core and the full rationale is discussed at [A SELECT statement is no longer
    implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是SQLAlchemy 1.4中的一个更改，即由`select()`等函数生成的SELECT语句，但也包括联合和文本SELECT表达式等，不再被视为[`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")对象，不能直接放在另一个SELECT语句的FROM子句中，而必须首先将它们包装在[`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")中。这是Core中的一个重大概念变化，完整的原因讨论在[不再将SELECT语句隐式视为FROM子句](changelog/migration_14.html#change-4617)中。
- en: 'Given an example as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个示例如下：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Above, `stmt` represents a SELECT statement. The error is produced when we
    want to use `stmt` directly as a FROM clause in another SELECT, such as if we
    attempted to select from it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`stmt`代表一个SELECT语句。当我们想直接将`stmt`作为另一个SELECT语句中的FROM子句使用时，就会产生错误，比如如果我们尝试从中选择：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or if we wanted to use it in a FROM clause such as in a JOIN:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果我们想在FROM子句中使用它，比如在JOIN中：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In previous versions of SQLAlchemy, using a SELECT inside of another SELECT
    would produce a parenthesized, unnamed subquery. In most cases, this form of SQL
    is not very useful as databases like MySQL and PostgreSQL require that subqueries
    in FROM clauses have named aliases, which means using the [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method or as of 1.4 using the [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method to produce this. On other
    databases, it is still much clearer for the subquery to have a name to resolve
    any ambiguity on future references to column names inside the subquery.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy的早期版本中，在另一个SELECT语句中使用SELECT会产生一个带括号的无名称子查询。在大多数情况下，这种SQL形式并不是很有用，因为像MySQL和PostgreSQL这样的数据库要求FROM子句中的子查询具有命名别名，这意味着使用[`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias")方法或者从1.4版本开始使用[`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")方法来生成这个别名。在其他数据库中，为子查询命名仍然更清晰，以解决子查询内部列名的任何歧义。
- en: 'Beyond the above practical reasons, there are a lot of other SQLAlchemy-oriented
    reasons the change is being made. The correct form of the above two statements
    therefore requires that [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") is used:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述实际原因外，还有许多其他与SQLAlchemy相关的原因导致进行了更改。因此，上述两个语句的正确形式要求使用[`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617)  ###
    An alias is being generated automatically for raw clauseelement'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[不再将SELECT语句隐式视为FROM子句](changelog/migration_14.html#change-4617)  ### 为原始clauseelement自动生成别名'
- en: New in version 1.4.26.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4.26开始新增。
- en: 'This deprecation warning refers to a very old and likely not well known pattern
    that applies to the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method as well as the [2.0 style](glossary.html#term-2.0-style)
    [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join "sqlalchemy.sql.expression.Select.join")
    method, where a join can be stated in terms of a [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") but the target is the [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other Core selectable to which the class is mapped,
    rather than an ORM entity such as a mapped class or [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此废弃警告指的是一个非常古老且可能不太熟知的模式，适用于旧版 [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 方法以及 [2.0 风格](glossary.html#term-2.0-style) [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法，其中可以根据 [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 来说明连接，但是目标是映射到的 [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 或其他 Core 可选择对象，而不是 ORM 实体，如映射的类或[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The above pattern also allows an arbitrary selectable, such as a Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object, however there is no automatic adaptation
    of this element, meaning the Core element would need to be referenced directly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式还允许使用任意可选择的对象，例如 Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") 或 [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") 对象，但是这个元素没有自动适应，这意味着必须直接引用 Core 元素：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The correct way to specify a join target is always by using the mapped class
    itself or an [`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, in the latter case using the [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") modifier to set up an alias:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 指定连接目标的正确方式始终是使用映射的类本身或一个[`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象，在后一种情况下，使用 [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")修饰符设置别名：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Join to an alias:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 加入到一个别名：
- en: '[PRE19]  ### An alias is being generated automatically due to overlapping tables'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]  ### 由于重叠的表而自动生成别名'
- en: New in version 1.4.26.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.4.26 新增。
- en: 'This warning is typically generated when querying using the [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method or the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method with mappings that involve joined table inheritance.
    The issue is that when joining between two joined inheritance models that share
    a common base table, a proper SQL JOIN between the two entities cannot be formed
    without applying an alias to one side or the other; SQLAlchemy applies an alias
    to the right side of the join. For example given a joined inheritance mapping
    as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用涉及加入表继承的映射进行查询时，通常会生成此警告。问题在于，在两个具有共同基表的加入继承模型之间进行连接时，不能形成适当的 SQL JOIN 而不对其中一侧应用别名；SQLAlchemy
    将别名应用于连接的右侧。例如，给定一个加入继承映射如下：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The above mapping includes a relationship between the `Employee` and `Manager`
    classes. Since both classes make use of the “employee” database table, from a
    SQL perspective this is a [self referential relationship](orm/self_referential.html#self-referential).
    If we wanted to query from both the `Employee` and `Manager` models using a join,
    at the SQL level the “employee” table needs to be included twice in the query,
    which means it must be aliased. When we create such a join using the SQLAlchemy
    ORM, we get SQL that looks like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射包括`Employee`和`Manager`类之间的关系。由于这两个类都使用了“employee”数据库表，从 SQL 的角度来看，这是一种[自引用关系](orm/self_referential.html#self-referential)。如果我们想要使用连接从`Employee`和`Manager`模型中查询，那么在
    SQL 层面上，“employee”表需要在查询中包含两次，这意味着它必须被别名化。当我们使用 SQLAlchemy ORM 创建这样一个连接时，得到的 SQL
    如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Above, the SQL selects FROM the `employee` table, representing the `Employee`
    entity in the query. It then joins to a right-nested join of `employee AS employee_1
    JOIN manager AS manager_1`, where the `employee` table is stated again, except
    as an anonymous alias `employee_1`. This is the ‘automatic generation of an alias’
    to which the warning message refers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的SQL语句中，选择了`employee`表，代表了查询中的`Employee`实体。然后连接到`employee AS employee_1 JOIN
    manager AS manager_1`的右嵌套连接，其中`employee`表再次出现，但作为一个匿名别名`employee_1`。这就是警告消息所指的“自动生成别名”。
- en: 'When SQLAlchemy loads ORM rows that each contain an `Employee` and a `Manager`
    object, the ORM must adapt rows from what above is the `employee_1` and `manager_1`
    table aliases into those of the un-aliased `Manager` class. This process is internally
    complex and does not accommodate for all API features, notably when trying to
    use eager loading features such as [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") with more deeply nested queries than are shown
    here. As the pattern is unreliable for more complex scenarios and involves implicit
    decisionmaking that is difficult to anticipate and follow, the warning is emitted
    and this pattern may be considered a legacy feature. The better way to write this
    query is to use the same patterns that apply to any other self-referential relationship,
    which is to use the [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct explicitly. For joined-inheritance and other
    join-oriented mappings, it is usually desirable to add the use of the [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") parameter, which will allow a JOIN of two or more tables
    to be aliased by applying an alias to the individual tables within the join, rather
    than embedding the join into a new subquery:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQLAlchemy加载包含`Employee`和`Manager`对象的ORM行时，ORM必须将来自上述`employee_1`和`manager_1`表别名的行适应为未别名化的`Manager`类的行。这个过程在内部是复杂的，并且不支持所有API特性，特别是当尝试在比这里展示的更深度嵌套的查询中使用[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")等急加载特性时。由于这种模式对于更复杂的情况不可靠，并涉及难以预测和遵循的隐式决策，因此会发出警告，并且这种模式可能被视为传统特性。编写此查询的更好方式是使用适用于任何其他自引用关系的相同模式，即显式使用[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造。对于连接继承和其他基于连接的映射，通常希望添加使用[`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased")参数，这将允许通过将别名应用于连接中的各个表来对两个或更多表进行连接别名化，而不是将连接嵌入到新的子查询中：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we then wanted to use [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate the `reports_to` attribute, we refer
    to the alias:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")来填充`reports_to`属性，我们将引用别名：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Without using the explicit [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object, in some more nested cases the [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option does not have enough context to know where
    to get its data from, in the case that the ORM is “auto-aliasing” in a very nested
    context. Therefore it’s best not to rely on this feature and instead keep the
    SQL construction as explicit as possible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些更嵌套的情况下，如果不使用显式的[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象，[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")选项可能无法获得足够的上下文来确定从哪里获取数据，特别是在ORM在非常嵌套的上下文中“自动别名”时。因此，最好不要依赖这个特性，而是尽可能将SQL构造明确化。
- en: Object Relational Mapping
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象关系映射
- en: '### IllegalStateChangeError and concurrency exceptions'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '### IllegalStateChangeError和并发异常'
- en: SQLAlchemy 2.0 introduced a new system described at [Session raises proactively
    when illegal concurrent or reentrant access is detected](changelog/whatsnew_20.html#change-7433),
    which proactively detects concurrent methods being invoked on an individual instance
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object and by extension the [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") proxy object. These concurrent access calls
    typically, though not exclusively, would occur when a single instance of [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is shared among multiple concurrent threads without
    such access being synchronized, or similarly when a single instance of [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is shared among multiple concurrent tasks
    (such as when using a function like `asyncio.gather()`). These use patterns are
    not the appropriate use of these objects, where without the proactive warning
    system SQLAlchemy implements would still otherwise produce invalid state within
    the objects, producing hard-to-debug errors including driver-level errors on the
    database connections themselves.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 引入了一个新系统，详见[会话在检测到非法并发或重入访问时主动引发](changelog/whatsnew_20.html#change-7433)，该系统主动检测在单个
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的实例以及其扩展的 [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") 代理对象上调用并发方法。这些并发访问调用通常会发生在单个 [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 实例在多个并发线程之间共享而没有进行同步访问时，或者类似地，当单个 [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") 实例在多个并发任务之间共享时（例如使用 `asyncio.gather()`
    这样的函数）。这些使用模式不是这些对象的适当用法，在没有 SQLAlchemy 实现的主动警告系统的情况下，仍然会在对象内部产生无效状态，从而产生难以调试的错误，包括数据库连接本身的驱动程序级错误。
- en: Instances of [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") are **mutable, stateful objects with no
    built-in synchronization** of method calls, and represent a **single, ongoing
    database transaction** upon a single database connection at a time for a particular
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction). A single database transaction is not an appropriate target
    for concurrent SQL commands; instead, an application that runs concurrent database
    operations should use concurrent transactions. For these objects then it follows
    that the appropriate pattern is [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") per thread, or [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") per task.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    和 [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") 的实例都是**可变、有状态的对象，没有内置的方法调用同步**，并且代表着一次单一的数据库事务，该事务在一次特定的
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    或 [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") 绑定的数据库连接上进行（请注意，这些对象都支持同时绑定到多个引擎，但在这种情况下，在事务范围内仍然只会有一个连接与引擎相关）。单个数据库事务不是并发
    SQL 命令的适当目标；相反，运行并发数据库操作的应用程序应该使用并发事务。因此，对于这些对象，适当的模式是每个线程一个 [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 或每个任务一个 [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")。'
- en: 'For more background on concurrency see the section [Is the Session thread-safe?
    Is AsyncSession safe to share in concurrent tasks?](orm/session_basics.html#session-faq-threadsafe).  ###
    Parent instance <x> is not bound to a Session; (lazy load/deferred load/refresh/etc.)
    operation cannot proceed'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '有关并发的更多背景信息，请参阅[会话是否线程安全？AsyncSession是否可以在并发任务中共享？](orm/session_basics.html#session-faq-threadsafe)一节。
    ### 父实例 <x> 未绑定到会话；（延迟加载/延迟加载/刷新等）操作无法继续'
- en: This is likely the most common error message when dealing with the ORM, and
    it occurs as a result of the nature of a technique the ORM makes wide use of known
    as [lazy loading](glossary.html#term-lazy-loading). Lazy loading is a common object-relational
    pattern whereby an object that’s persisted by the ORM maintains a proxy to the
    database itself, such that when various attributes upon the object are accessed,
    their value may be retrieved from the database *lazily*. The advantage to this
    approach is that objects can be retrieved from the database without having to
    load all of their attributes or related data at once, and instead only that data
    which is requested can be delivered at that time. The major disadvantage is basically
    a mirror image of the advantage, which is that if lots of objects are being loaded
    which are known to require a certain set of data in all cases, it is wasteful
    to load that additional data piecemeal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能是处理ORM时最常见的错误消息，并且它是由ORM广泛使用的一种技术的性质引起的，这种技术称为[延迟加载](glossary.html#term-lazy-loading)。延迟加载是一种常见的对象关系模式，其中由ORM持久化的对象维护了与数据库本身的代理，以便当访问对象上的各种属性时，可以*延迟*从数据库中检索其值。这种方法的优点是可以从数据库中检索对象而不必一次加载其所有属性或相关数据，而只能在那时提供所请求的数据。其主要缺点基本上是优点的镜像，即如果正在加载大量对象，这些对象在所有情况下都需要某一组数据，则逐步加载该额外数据是一种浪费。
- en: Another caveat of lazy loading beyond the usual efficiency concerns is that
    in order for lazy loading to proceed, the object has to **remain associated with
    a Session** in order to be able to retrieve its state. This error message means
    that an object has become de-associated with its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and is being asked to lazy load data from the database.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于懒加载的另一个警告，除了通常的效率问题之外，还有一个要注意的是，为了进行懒加载，对象必须**保持与会话相关联**，以便能够检索其状态。这个错误消息意味着一个对象已经与其[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")解除关联，并且被要求从数据库中懒加载数据。
- en: The most common reason that objects become detached from their [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that the session itself was closed, typically via
    the [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method. The objects will then live on to be accessed further, very often within
    web applications where they are delivered to a server-side templating engine and
    are asked for further attributes which they cannot load.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对象变为分离状态的最常见原因是会话本身已关闭，通常是通过[`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法关闭的。然后，对象将继续存在以供进一步访问，这在Web应用程序中非常常见，其中它们被传递到服务器端模板引擎，并被要求加载更多属性。
- en: 'Mitigation of this error is via these techniques:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻这个错误的方法是通过以下技术：
- en: '**Try not to have detached objects; don’t close the session prematurely** -
    Often, applications will close out a transaction before passing off related objects
    to some other system which then fails due to this error. Sometimes the transaction
    doesn’t need to be closed so soon; an example is the web application closes out
    the transaction before the view is rendered. This is often done in the name of
    “correctness”, but may be seen as a mis-application of “encapsulation”, as this
    term refers to code organization, not actual actions. The template that uses an
    ORM object is making use of the [proxy pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
    which keeps database logic encapsulated from the caller. If the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be held open until the lifespan of the objects are
    done, this is the best approach.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量不要有分离的对象；不要过早关闭会话** - 通常，应用程序会在将相关对象传递给其他系统之前关闭事务，然后由于此错误而失败。有时，事务不需要那么快关闭；一个例子是Web应用在渲染视图之前关闭了事务。这通常是以“正确性”的名义而做的，但可能被视为“封装”的误用，因为此术语指的是代码组织，而不是实际操作。使用ORM对象的模板正在使用[代理模式](https://en.wikipedia.org/wiki/Proxy_pattern)，它将数据库逻辑封装在调用者之外。如果[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以保持打开状态直到对象的生命周期结束，那么这是最佳方法。'
- en: '**Otherwise, load everything that’s needed up front** - It is very often impossible
    to keep the transaction open, especially in more complex applications that need
    to pass objects off to other systems that can’t run in the same context even though
    they’re in the same process. In this case, the application should prepare to deal
    with [detached](glossary.html#term-detached) objects, and should try to make appropriate
    use of [eager loading](glossary.html#term-eager-loading) to ensure that objects
    have what they need up front.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否则，将需要的所有内容一次性加载** - 通常不可能保持事务处于打开状态，特别是在需要将对象传递给其他无法在同一上下文中运行的系统的更复杂的应用程序中。在这种情况下，应用程序应准备处理[分离](glossary.html#term-detached)对象，并应尽量恰当地使用[急加载](glossary.html#term-eager-loading)来确保对象一开始就拥有所需的内容。'
- en: '**And importantly, set expire_on_commit to False** - When using detached objects,
    the most common reason objects need to re-load data is because they were expired
    from the last call to [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"). This expiration should not be used when dealing
    with detached objects; so the [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter be set to `False`. By preventing the objects
    from becoming expired outside of the transaction, the data which was loaded will
    remain present and will not incur additional lazy loads when that data is accessed.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且重要的是，将 expire_on_commit 设置为 False** - 当使用分离的对象时，对象需要重新加载数据的最常见原因是因为它们在上次调用
    [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    时过期了。当处理分离的对象时，不应使用此过期；因此，[`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") 参数应设置为 `False`。通过防止对象在事务外过期，加载的数据将保持存在，并且在访问该数据时不会产生额外的延迟加载。'
- en: Note also that [`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method unconditionally expires all contents
    in the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and should also be avoided in non-error scenarios.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法无条件地使 [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的所有内容过期，并且在非错误情况下也应避免使用。'
- en: See also
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](orm/queryguide/relationships.html) - detailed
    documentation on eager loading and other relationship-oriented loading techniques'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[关系加载技术](orm/queryguide/relationships.html) - 关于急加载和其他基于关系的加载技术的详细文档'
- en: '[Committing](orm/session_basics.html#session-committing) - background on session
    commit'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[提交](orm/session_basics.html#session-committing) - 有关会话提交的背景'
- en: '[Refreshing / Expiring](orm/session_state_management.html#session-expire) -
    background on attribute expiry  ### This Session’s transaction has been rolled
    back due to a previous exception during flush'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[刷新 / 过期](orm/session_state_management.html#session-expire) - 属性过期的背景 ### 此
    Session 的事务由于在 flush 过程中出现先前的异常而被回滚'
- en: The flush process of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), described at [Flushing](orm/session_basics.html#session-flushing),
    will roll back the database transaction if an error is encountered, in order to
    maintain internal consistency. However, once this occurs, the session’s transaction
    is now “inactive” and must be explicitly rolled back by the calling application,
    in the same way that it would otherwise need to be explicitly committed if a failure
    had not occurred.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的 flush 过程，在遇到错误时会回滚数据库事务，以保持内部一致性。但是，一旦发生这种情况，会话的事务现在处于“不活动”状态，必须由调用方显式地回滚，就像如果没有发生失败，则必须显式地提交一样。'
- en: 'This is a common error when using the ORM and typically applies to an application
    that doesn’t yet have correct “framing” around its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") operations. Further detail is described in the FAQ at
    [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](faq/sessions.html#faq-session-rollback).  ### For
    relationship <relationship>, delete-orphan cascade is normally configured only
    on the “one” side of a one-to-many relationship, and not on the “many” side of
    a many-to-one or many-to-many relationship.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ORM时，这是一个常见错误，通常适用于尚未正确围绕其[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")操作进行“框架化”的应用程序。更多详细信息请参阅FAQ中的[“由于刷新期间的先前异常，此会话的事务已被回滚。”（或类似）](faq/sessions.html#faq-session-rollback)。###
    对于关系<relationship>，delete-orphan级联通常仅在一对多关系的“一”侧上配置，而不在多对一或多对多关系的“多”侧上配置。
- en: 'This error arises when the “delete-orphan” [cascade](orm/cascades.html#unitofwork-cascades)
    is set on a many-to-one or many-to-many relationship, such as:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多对一或多对多关系上设置“delete-orphan”[级联](orm/cascades.html#unitofwork-cascades)时，就会出现这个错误，例如：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Above, the “delete-orphan” setting on `B.a` indicates the intent that when every
    `B` object that refers to a particular `A` is deleted, that the `A` should then
    be deleted as well. That is, it expresses that the “orphan” which is being deleted
    would be an `A` object, and it becomes an “orphan” when every `B` that refers
    to it is deleted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，对`B.a`上的“delete-orphan”设置表示的意图是，当引用特定`A`的每个`B`对象被删除时，该`A`也应该被删除。也就是说，它表达了被删除的“孤儿”将是一个`A`对象，并且当引用它的每个`B`被删除时，它就成为一个“孤儿”。
- en: The “delete-orphan” cascade model does not support this functionality. The “orphan”
    consideration is only made in terms of the deletion of a single object which would
    then refer to zero or more objects that are now “orphaned” by this single deletion,
    which would result in those objects being deleted as well. In other words, it
    is designed only to track the creation of “orphans” based on the removal of one
    and only one “parent” object per orphan, which is the natural case in a one-to-many
    relationship where a deletion of the object on the “one” side results in the subsequent
    deletion of the related items on the “many” side.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: “delete-orphan”级联模型不支持这一功能。“孤儿”考虑仅在删除一个对象时进行，然后该对象将引用零个或多个现在由此单个删除“孤儿化”的对象，这将导致这些对象也被删除。换句话说，它仅设计用于跟踪基于删除一个且仅一个“父”对象每个孤儿的创建，这是一对多关系中的自然情况，其中在“一”侧的对象的删除导致“多”侧的相关项目随后被删除。
- en: 'The above mapping in support of this functionality would instead place the
    cascade setting on the one-to-many side, which looks like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一功能，上述映射将级联设置放在一对多的一侧，看起来像是：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Where the intent is expressed that when an `A` is deleted, all of the `B` objects
    to which it refers are also deleted.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中表达的意图是，当删除一个`A`时，它所引用的所有`B`对象也被删除。
- en: 'The error message then goes on to suggest the usage of the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag. This flag may be used to enforce that a relationship
    which is capable of having many objects refer to a particular object will in fact
    have only **one** object referring to it at a time. It is used for legacy or other
    less ideal database schemas where the foreign key relationships suggest a “many”
    collection, however in practice only one object would actually refer to a given
    target object at at time. This uncommon scenario can be demonstrated in terms
    of the above example as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后错误消息继续建议使用[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志。该标志可用于强制执行一个关系，该关系能够让许多对象引用特定对象，实际上每次只会有**一个**对象引用它。它用于传统或其他不太理想的数据库模式，其中外键关系暗示“多”集合，但实际上只有一个对象会引用给定目标对象。这种不常见的情况可以通过上面的示例来演示：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The above configuration will then install a validator which will enforce that
    only one `B` may be associated with an `A` at at time, within the scope of the
    `B.a` relationship:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将安装一个验证器，该验证器将强制执行在`B.a`关系的范围内，只能有一个`B`与一个`A`关联：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that this validator is of limited scope and will not prevent multiple
    “parents” from being created via the other direction. For example, it will not
    detect the same setting in terms of `A.bs`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此验证器的范围有限，并且不会阻止通过其他方向创建多个“父对象”。例如，它不会检测到关于`A.bs`的相同设置：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, things will not go as expected later on, as the “delete-orphan” cascade
    will continue to work in terms of a **single** lead object, meaning if we delete
    **either** of the `B` objects, the `A` is deleted. The other `B` stays around,
    where the ORM will usually be smart enough to set the foreign key attribute to
    NULL, but this is usually not what’s desired:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情不会按预期进行，因为“delete-orphan”级联将继续按照**单个**主导对象的术语工作，这意味着如果我们删除`B`对象中的**任意一个**，`A`就会被删除。另一个`B`还会留下，ORM通常足够智能以将外键属性设置为NULL，但这通常不是预期的结果：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For all the above examples, similar logic applies to the calculus of a many-to-many
    relationship; if a many-to-many relationship sets single_parent=True on one side,
    that side can use the “delete-orphan” cascade, however this is very unlikely to
    be what someone actually wants as the point of a many-to-many relationship is
    so that there can be many objects referring to an object in either direction.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述所有示例，类似的逻辑也适用于多对多关系的微积分；如果一个多对多关系在一侧设置了single_parent=True，那么该侧可以使用“delete-orphan”级联，但这很可能不是实际想要的，因为多对多关系的目的是使得可以有许多对象引用任一方向的对象。
- en: Overall, “delete-orphan” cascade is usually applied on the “one” side of a one-to-many
    relationship so that it deletes objects in the “many” side, and not the other
    way around.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，“delete-orphan”级联通常应用于一对多关系的“一”侧，以便删除“多”侧的对象，而不是反过来。
- en: 'Changed in version 1.3.18: The text of the “delete-orphan” error message when
    used on a many-to-one or many-to-many relationship has been updated to be more
    descriptive.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3.18版本中更改：当在多对一或多对多关系上使用“delete-orphan”错误消息时，已更新为更具描述性的文本。
- en: See also
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Cascades](orm/cascades.html#unitofwork-cascades)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[级联](orm/cascades.html#unitofwork-cascades)'
- en: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
- en: '[Instance <instance> is already associated with an instance of <instance> via
    its <attribute> attribute, and is only allowed a single parent.](#error-bbf1)  ###
    Instance <instance> is already associated with an instance of <instance> via its
    <attribute> attribute, and is only allowed a single parent.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[实例<instance>已通过其<attribute>属性与<instance>的实例关联，并且仅允许有一个单独的父对象。](#error-bbf1)  ###
    实例<instance>已通过其<attribute>属性与<instance>的实例关联，并且仅允许有一个单独的父对象。'
- en: This error is emitted when the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag is used, and more than one object is assigned
    as the “parent” of an object at once.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") 标志被使用，并且一个对象同时被指定为多个对象的“父对象”时，会发出此错误。
- en: 'Given the following mapping:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于以下映射：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The intent indicates that no more than a single `B` object may refer to a particular
    `A` object at once:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 意图表明，不会有多于一个`B`对象同时引用特定的`A`对象：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When this error occurs unexpectedly, it is usually because the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag was applied in response to the error message
    described at [For relationship <relationship>, delete-orphan cascade is normally
    configured only on the “one” side of a one-to-many relationship, and not on the
    “many” side of a many-to-one or many-to-many relationship.](#error-bbf0), and
    the issue is in fact a misunderstanding of the “delete-orphan” cascade setting.
    See that message for details.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当此错误出现意外时，通常是因为在对[对于关系<relationship>，delete-orphan级联通常仅在一对多关系的“一”侧配置，并不在多对一或多对多关系的“多”侧上。](#error-bbf0)描述的错误消息做出响应时应用了[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志，而实际问题是对“delete-orphan”级联设置的误解。有关详细信息，请参阅该消息。
- en: See also
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](#error-bbf0)  ### relationship
    X will copy column Q to column P, which conflicts with relationship(s): ‘Y’'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于关系<relationship>，删除孤儿级联通常仅在一对多关系的“一”方配置，并不在多对一或多对多关系的“多”方配置。](#error-bbf0)  ###
    关系 X 将列 Q 复制到列 P，与关系‘Y’冲突'
- en: This warning refers to the case when two or more relationships will write data
    to the same columns on flush, but the ORM does not have any means of coordinating
    these relationships together. Depending on specifics, the solution may be that
    two relationships need to be referenced by one another using [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), or that one or more of the relationships should
    be configured with [`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") to prevent conflicting writes, or sometimes that
    the configuration is fully intentional and should configure [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") to silence each warning.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此警告指的是在刷新时两个或多个关系将写入相同列的情况，但 ORM 没有任何手段来协调这些关系。根据具体情况，解决方案可能是两个关系需要使用[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")相互引用，或者一个或多个关系应该配置为[`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")以防止冲突写入，有时配置是完全有意的，应该配置[`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship")以消除每个警告。
- en: 'For the typical example that’s missing [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), given the following mapping:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缺少[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")的典型示例，给定以下映射：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The above mapping will generate warnings:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将生成警告：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The relationships `Child.parent` and `Parent.children` appear to be in conflict.
    The solution is to apply [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '关系`Child.parent`和`Parent.children`似乎存在冲突。解决方案是应用[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For more customized relationships where an “overlap” situation may be intentional
    and cannot be resolved, the [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") parameter may specify the names of relationships
    for which the warning should not take effect. This typically occurs for two or
    more relationships to the same underlying table that include custom [`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") conditions that limit the related items in each
    case:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更自定义的关系，在“重叠”情况可能是有意的且无法解决的情况下，[`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship")参数可以指定不应发生警告的关系名称。这通常发生在对同一底层表的两个或多个关系具有自定义[`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")条件以限制每种情况下相关项目的情况：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Above, the ORM will know that the overlap between `Parent.c1`, `Parent.c2`
    and `Child.parent` is intentional.  ### Object cannot be converted to ‘persistent’
    state, as this identity map is no longer valid.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述示例中，ORM 将知道`Parent.c1`、`Parent.c2`和`Child.parent`之间的重叠是有意的。  ### 对象无法转换为‘persistent’状态，因为此标识映射不再有效。'
- en: New in version 1.4.26.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4.26 中的新功能。
- en: 'This message was added to accommodate for the case where a [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that would yield ORM objects is iterated after
    the originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has been closed, or otherwise had its [`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") method called. When a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") expunges all objects at once, the internal [identity
    map](glossary.html#term-identity-map) used by that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is replaced with a new one, and the original one discarded.
    An unconsumed and unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will internally maintain a reference to that
    now-discarded identity map. Therefore, when the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is consumed, the objects that would be yielded cannot
    be associated with that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This arrangement is by design as it is generally not
    recommended to iterate an unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object outside of the transactional context in which
    it was created:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息是为了处理以下情况而添加的：在原始[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关闭后，或者在调用其[`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")方法后，迭代可能会产生ORM对象的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象。当一个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一次性地移除所有对象时，该[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用的内部[标识映射](glossary.html#term-identity-map)将被替换为一个新的映射，并且原始映射将被丢弃。一个未被使用和未被缓冲的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象将在内部保留对该现在被丢弃的标识映射的引用。因此，当消耗了[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")时，将无法将要产生的对象与该[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联起来。这种安排是有意的，因为通常不建议在创建它的事务上下文之外迭代未缓冲的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The above situation typically will **not** occur when using the `asyncio` ORM
    extension, as when [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") returns a sync-style [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"), the results have been pre-buffered when the statement
    was executed. This is to allow secondary eager loaders to invoke without needing
    an additional `await` call.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`asyncio` ORM扩展时，上述情况通常**不会**发生，因为当[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")返回同步风格的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")时，结果在执行语句时已经预先缓冲。这样可以允许次要的急切加载器调用而无需额外的`await`调用。
- en: 'To pre-buffer results in the above situation using the regular [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in the same way that the `asyncio` extension does it,
    the `prebuffer_rows` execution option may be used as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要在上述情况下像`asyncio`扩展一样预先缓冲结果，可以使用`prebuffer_rows`执行选项，如下所示：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Above, the selected ORM objects are fully generated within the `session_obj`
    block, associated with `session_obj` and buffered within the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object for iteration. Outside the block, `session_obj`
    is closed and expunges these ORM objects. Iterating the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will yield those ORM objects, however as their
    originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has expunged them, they will be delivered in the [detached](glossary.html#term-detached)
    state.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中，所选的ORM对象完全在`session_obj`块内生成，与`session_obj`关联，并在[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象中缓冲以供迭代。在块外，`session_obj`被关闭并且移除了这些ORM对象。迭代[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象将产生这些ORM对象，但是由于它们的来源[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")已经移除了它们，它们将以[分离](glossary.html#term-detached)状态提供。
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The above reference to a “pre-buffered” vs. “un-buffered” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object refers to the process by which the ORM converts
    incoming raw database rows from the [DBAPI](glossary.html#term-DBAPI) into ORM
    objects. It does not imply whether or not the underlying `cursor` object itself,
    which represents pending results from the DBAPI, is itself buffered or unbuffered,
    as this is essentially a lower layer of buffering. For background on buffering
    of the `cursor` results itself, see the section [Using Server Side Cursors (a.k.a.
    stream results)](core/connections.html#engine-stream-results).  ### Type annotation
    can’t be interpreted for Annotated Declarative Table form'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '上面对“预缓冲”与“非缓冲” [`Result`](core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    对象的引用是指 ORM 将来自 [DBAPI](glossary.html#term-DBAPI) 的原始数据库行转换为 ORM 对象的过程。这并不意味着底层的
    `cursor` 对象本身是否被缓冲，表示来自 DBAPI 的待处理结果，它本身是被缓冲的还是非缓冲的，因为这本质上是一个更低层的缓冲。关于 `cursor`
    结果本身的缓冲，请参阅[使用服务器端游标（也称为流结果）](core/connections.html#engine-stream-results)部分。  ###
    类型注释无法解释为注释的声明性表单'
- en: SQLAlchemy 2.0 introduces a new [Annotated Declarative Table](orm/declarative_tables.html#orm-declarative-mapped-column)
    declarative system which derives ORM mapped attribute information from [**PEP
    484**](https://peps.python.org/pep-0484/) annotations within class definitions
    at runtime. A requirement of this form is that all ORM annotations must make use
    of a generic container called [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to be properly annotated. Legacy SQLAlchemy mappings
    which include explicit [**PEP 484**](https://peps.python.org/pep-0484/) typing
    annotations, such as those which use the [legacy Mypy extension](orm/extensions/mypy.html)
    for typing support, may include directives such as those for [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that don’t include this generic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 引入了一个新的[注释声明式表](orm/declarative_tables.html#orm-declarative-mapped-column)声明系统，该系统从运行时类定义中的
    [**PEP 484**](https://peps.python.org/pep-0484/) 注释中派生 ORM 映射属性信息。此形式的要求是所有 ORM
    注释必须使用称为 [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    的通用容器进行正确注释。包括显式 [**PEP 484**](https://peps.python.org/pep-0484/) 类型注释的遗留 SQLAlchemy
    映射，例如使用 [遗留 Mypy 扩展](orm/extensions/mypy.html)进行类型支持的映射，可能包括诸如 [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的指令，不包括此通用容器。
- en: To resolve, the classes may be marked with the `__allow_unmapped__` boolean
    attribute until they can be fully migrated to the 2.0 syntax. See the migration
    notes at [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed
    ORM models](changelog/migration_20.html#migration-20-step-six) for an example.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决此问题，可以将类标记为 `__allow_unmapped__` 布尔属性，直到它们完全迁移到 2.0 语法。请参阅迁移说明，例如 [迁移到 2.0
    的第六步 - 向显式类型的 ORM 模型添加 __allow_unmapped__](changelog/migration_20.html#migration-20-step-six)
    的示例。
- en: See also
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](changelog/migration_20.html#migration-20-step-six) - in the [SQLAlchemy
    2.0 - Major Migration Guide](changelog/migration_20.html) document  ### When transforming
    <cls> to a dataclass, attribute(s) originate from superclass <cls> which is not
    a dataclass.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移到 2.0 的第六步 - 向显式类型的 ORM 模型添加 __allow_unmapped__](changelog/migration_20.html#migration-20-step-six)
    - 在 [SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) 文档中  ### 当将 <cls> 转换为数据类时，属性(s)
    源自非数据类的父类 <cls>。'
- en: 'This warning occurs when using the SQLAlchemy ORM Mapped Dataclasses feature
    described at [Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    in conjunction with any mixin class or abstract base that is not itself declared
    as a dataclass, such as in the example below:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用描述在任何 mixin 类或抽象基类中的 SQLAlchemy ORM 映射数据类特性，该特性本身并未声明为数据类，例如下面的示例所示时，会发生此警告：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Above, since `Mixin` does not itself extend from [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), the following warning is generated:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Mixin` 本身不是从 [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") 扩展的，因此会生成以下警告：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The fix is to add [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") to the signature of `Mixin` as well:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是在 `Mixin` 的签名中添加 [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Python’s [**PEP 681**](https://peps.python.org/pep-0681/) specification does
    not accommodate for attributes declared on superclasses of dataclasses that are
    not themselves dataclasses; per the behavior of Python dataclasses, such fields
    are ignored, as in the following example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Python的[**PEP 681**](https://peps.python.org/pep-0681/)规范不支持在数据类的超类上声明的属性，这些超类本身不是数据类；根据Python数据类的行为，这些字段将被忽略，如下例所示：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Above, the `User` class will not include `create_user` in its constructor nor
    will it attempt to interpret `update_user` as a dataclass attribute. This is because
    `Mixin` is not a dataclass.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`User`类将不会在其构造函数中包含`create_user`，也不会尝试将`update_user`解释为数据类属性。这是因为`Mixin`不是数据类。
- en: 'SQLAlchemy’s dataclasses feature within the 2.0 series does not honor this
    behavior correctly; instead, attributes on non-dataclass mixins and superclasses
    are treated as part of the final dataclass configuration. However type checkers
    such as Pyright and Mypy will not consider these fields as part of the dataclass
    constructor as they are to be ignored per [**PEP 681**](https://peps.python.org/pep-0681/).
    Since their presence is ambiguous otherwise, SQLAlchemy 2.1 will require that
    mixin classes which have SQLAlchemy mapped attributes within a dataclass hierarchy
    have to themselves be dataclasses.  ### Python dataclasses error encountered when
    creating dataclass for <classname>'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0系列中的数据类功能未正确遵守这一行为；相反，非数据类混合类和超类上的属性将被视为最终数据类配置的一部分。然而，像Pyright和Mypy这样的类型检查器不会将这些字段视为数据类构造函数的一部分，因为根据[**PEP
    681**](https://peps.python.org/pep-0681/)它们应该被忽略。否则，由于它们的存在是模棱两可的，SQLAlchemy 2.1将要求在数据类层次结构中具有SQLAlchemy映射属性的混合类本身必须是数据类。###
    创建<类名>数据类时遇到的Python数据类错误
- en: When using the [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin class or [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator, SQLAlchemy makes use
    of the actual [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    module that’s in the Python standard library in order to apply dataclass behaviors
    to the target class. This API has its own error scenarios, most of which involve
    the construction of an `__init__()` method on the user defined class; the order
    of attributes declared on the class, as well as [on superclasses](https://docs.python.org/3/library/dataclasses.html#inheritance),
    determines how the `__init__()` method will be constructed and there are specific
    rules in how the attributes are organized as well as how they should make use
    of parameters such as `init=False`, `kw_only=True`, etc. **SQLAlchemy does not
    control or implement these rules**. Therefore, for errors of this nature, consult
    the [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) documentation,
    with special attention to the rules applied to [inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")混合类或[`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")装饰器时，SQLAlchemy利用Python标准库中的实际[Python数据类](https://docs.python.org/3/library/dataclasses.html)模块，以将数据类行为应用于目标类。此API有其自己的错误场景，其中大部分涉及在用户定义的类上构建`__init__()`方法；在类上声明的属性的顺序，以及[在超类上](https://docs.python.org/3/library/dataclasses.html#inheritance)的顺序决定了`__init__()`方法将如何构建，还有特定规则规定了属性的组织方式以及它们应如何使用参数如`init=False`、`kw_only=True`等。**SQLAlchemy不控制或实现这些规则**。因此，对于这种类型的错误，请参考[Python数据类](https://docs.python.org/3/library/dataclasses.html)文档，特别注意应用于[继承](https://docs.python.org/3/library/dataclasses.html#inheritance)的规则。
- en: See also
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses documentation'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明式数据类映射](orm/dataclasses.html#orm-declarative-native-dataclasses) - SQLAlchemy数据类文档'
- en: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    on the python.org website'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python数据类](https://docs.python.org/3/library/dataclasses.html) - 在python.org网站上'
- en: '[inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance)
    - on the python.org website  ### per-row ORM Bulk Update by Primary Key requires
    that records contain primary key values'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[继承](https://docs.python.org/3/library/dataclasses.html#inheritance) - 在python.org网站上  ###
    按主键进行逐行ORM批量更新需要记录包含主键值'
- en: 'This error occurs when making use of the [ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    feature without supplying primary key values in the given records, such as:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在不提供给定记录中的主键值的情况下使用 [ORM 批量更新 by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    功能时会发生此错误，例如：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Above, the presence of a list of parameter dictionaries combined with usage
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to execute an ORM-enabled UPDATE statement will automatically make use of ORM
    Bulk Update by Primary Key, which expects parameter dictionaries to include primary
    key values, e.g.:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，参数字典列表的存在与使用[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")来执行
    ORM 启用的 UPDATE 语句会自动使用基于主键的 ORM 批量更新，该方法期望参数字典包含主键值，例如：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To invoke the UPDATE statement without supplying per-record primary key values,
    use [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") to acquire the current [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), then invoke with that:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不提供每个记录的主键值的情况下调用 UPDATE 语句，请使用[`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")来获取当前[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，然后使用该连接进行调用：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 批量更新 by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
- en: '[Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[针对具有多个参数集的 UPDATE 语句禁用基于主键的 ORM 批量更新](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)'
- en: AsyncIO Exceptions
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步 I/O 异常
- en: '### AwaitRequired'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '### 需要等待'
- en: The SQLAlchemy async mode requires an async driver to be used to connect to
    the db. This error is usually raised when trying to use the async version of SQLAlchemy
    with a non compatible [DBAPI](glossary.html#term-DBAPI).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的异步模式需要使用异步驱动程序连接到数据库。尝试使用不兼容的 [DBAPI](glossary.html#term-DBAPI)
    的情况下，通常会引发此错误。
- en: See also
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Asynchronous I/O (asyncio)](orm/extensions/asyncio.html)  ### MissingGreenlet'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步 I/O（asyncio）](orm/extensions/asyncio.html)  ### 丢失Greenlet'
- en: A call to the async [DBAPI](glossary.html#term-DBAPI) was initiated outside
    the greenlet spawn context usually setup by the SQLAlchemy AsyncIO proxy classes.
    Usually this error happens when an IO was attempted in an unexpected place, using
    a calling pattern that does not directly provide for use of the `await` keyword.
    When using the ORM this is nearly always due to the use of [lazy loading](glossary.html#term-lazy-loading),
    which is not directly supported under asyncio without additional steps and/or
    alternate loader patterns in order to use successfully.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对异步 [DBAPI](glossary.html#term-DBAPI) 的调用是在通常由 SQLAlchemy AsyncIO 代理类设置的 greenlet
    spawn 上下文之外启动的。通常情况下，当尝试在意料之外的位置进行 IO 时，会发生此错误，使用的调用模式不直接提供使用`await`关键字的情况。在使用
    ORM 时，几乎总是由于使用了[延迟加载](glossary.html#term-lazy-loading)，在不经过额外步骤和/或使用成功所需的替代加载器模式的情况下，不直接支持
    asyncio。
- en: See also
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Preventing Implicit IO when Using AsyncSession](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - covers most ORM scenarios where this problem can occur and how to mitigate,
    including specific patterns to use with lazy load scenarios.  ### No Inspection
    Available'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[在使用 AsyncSession 时防止隐式 IO](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - 涵盖了大多数可能出现此问题的 ORM 方案以及如何进行缓解，包括与延迟加载场景一起使用的特定模式。 ### 无可用检查'
- en: 'Using the [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function directly on an [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") object is not currently supported, as there
    is not yet an awaitable form of the [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object available. Instead, the object
    is used by acquiring it using the [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function in such a way that it refers to the underlying
    [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") attribute of the [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") object; the `Inspector` is then used
    in a “synchronous” calling style by using the [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") method along with a custom
    function that performs the desired operations:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在[`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")或[`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")对象上直接使用[`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")函数目前不受支持，因为尚未提供[`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection")对象的可等待形式。相反，通过使用[`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")函数获取对象，使其引用[`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")对象的底层[`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection")属性；然后通过使用[`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync")方法以及执行所需操作的自定义函数以“同步”调用样式使用`Inspector`：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See also
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using the Inspector to inspect schema objects](orm/extensions/asyncio.html#asyncio-inspector)
    - additional examples of using [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") with the asyncio extension.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用检查器检查模式对象](orm/extensions/asyncio.html#asyncio-inspector) - 使用[`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")与asyncio扩展的其他示例。'
- en: Core Exception Classes
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Core异常类
- en: See [Core Exceptions](core/exceptions.html) for Core exception classes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[Core Exceptions](core/exceptions.html)以获取Core异常类。
- en: ORM Exception Classes
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM异常类
- en: See [ORM Exceptions](orm/exceptions.html) for ORM exception classes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[ORM Exceptions](orm/exceptions.html)以获取ORM异常类。
- en: Legacy Exceptions
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗留异常
- en: Exceptions in this section are not generated by current SQLAlchemy versions,
    however are provided here to suit exception message hyperlinks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的异常不是由当前SQLAlchemy版本生成的，但在此提供以适应异常消息超链接。
- en: '### The <some function> in SQLAlchemy 2.0 will no longer <something>'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在SQLAlchemy 2.0中，<某个函数>将不再<某事>。'
- en: SQLAlchemy 2.0 represents a major shift for a wide variety of key SQLAlchemy
    usage patterns in both the Core and ORM components. The goal of the 2.0 release
    is to make a slight readjustment in some of the most fundamental assumptions of
    SQLAlchemy since its early beginnings, and to deliver a newly streamlined usage
    model that is hoped to be significantly more minimalist and consistent between
    the Core and ORM components, as well as more capable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0代表了Core和ORM组件中许多关键SQLAlchemy使用模式的重大转变。2.0版本的目标是对SQLAlchemy自其早期开始以来的一些最基本假设进行轻微调整，并提供一个新的简化使用模型，希望在Core和ORM组件之间更加简约一致，同时更具能力。
- en: Introduced at [SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html),
    the SQLAlchemy 2.0 project includes a comprehensive future compatibility system
    that’s integrated into the 1.4 series of SQLAlchemy, such that applications will
    have a clear, unambiguous, and incremental upgrade path in order to migrate applications
    to being fully 2.0 compatible. The `RemovedIn20Warning` deprecation warning is
    at the base of this system to provide guidance on what behaviors in an existing
    codebase will need to be modified. An overview of how to enable this warning is
    at [SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html)中介绍的SQLAlchemy 2.0项目包含了一个综合的未来兼容性系统，该系统集成到了SQLAlchemy
    1.4系列中，以便应用程序能够明确、清晰地、逐步地升级路径，将应用程序迁移到完全兼容2.0版本。`RemovedIn20Warning`弃用警告是该系统的基础，用于提供关于现有代码库中需要修改的行为的指导。如何启用此警告的概述在[SQLAlchemy
    2.0 弃用模式](changelog/migration_14.html#deprecation-20-mode)中。
- en: See also
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html) - An
    overview of the upgrade process from the 1.x series, as well as the current goals
    and progress of SQLAlchemy 2.0.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) - 从1.x系列升级流程的概述，以及SQLAlchemy
    2.0的当前目标和进展。'
- en: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - specific guidelines on how to use “2.0 deprecations mode” in SQLAlchemy 1.4.  ###
    Object is being merged into a Session along the backref cascade'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 弃用模式](changelog/migration_14.html#deprecation-20-mode) - 如何在SQLAlchemy
    1.4中使用“2.0弃用模式”的具体指南。 ### 对象正在通过反向引用级联合并到一个Session'
- en: This message refers to the “backref cascade” behavior of SQLAlchemy, removed
    in version 2.0\. This refers to the action of an object being added into a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as a result of another object that’s already present
    in that session being associated with it. As this behavior has been shown to be
    more confusing than helpful, the [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameters were added, which can be set to `False` to
    disable it, and in SQLAlchemy 2.0 the “cascade backrefs” behavior has been removed
    entirely.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本消息指的是SQLAlchemy中在2.0版本中删除的“反向引用级联”行为。这指的是将对象添加到[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的操作，因为该会话中已经存在的另一个对象与之关联。由于这种行为被证明比有用更令人困惑，因此添加了[`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")和[`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")参数，可以将其设置为`False`以禁用它，在SQLAlchemy 2.0中完全删除了“级联反向引用”行为。
- en: For older SQLAlchemy versions, to set [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") to `False` on a backref that is currently configured
    using the [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") string parameter, the backref must be declared
    using the [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    function first so that the [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameter may be passed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的SQLAlchemy版本，在当前使用[`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")字符串参数配置的反向引用上设置[`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")为`False`，必须首先使用[`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数声明该反向引用，以便传递[`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")参数。
- en: Alternatively, the entire “cascade backrefs” behavior can be turned off across
    the board by using the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in “future” mode, by passing `True` for the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") parameter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过在“未来”模式下使用[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")来完全关闭整个“级联反向引用”行为，通过将`True`传递给[`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")参数。
- en: See also
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](changelog/migration_14.html#change-5150)
    - background on the change for SQLAlchemy 2.0.  ### select() construct created
    in “legacy” mode; keyword arguments, etc.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[cascade_backrefs 行为在 2.0 中被弃用以移除](changelog/migration_14.html#change-5150)
    - 关于 SQLAlchemy 2.0 变更的背景。### select() 构造以“旧”模式创建；关键字参数等。'
- en: The [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct has been updated as of SQLAlchemy 1.4 to support the newer calling style
    that is standard in SQLAlchemy 2.0\. For backwards compatibility within the 1.4
    series, the construct accepts arguments in both the “legacy” style as well as
    the “new” style.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造已在 SQLAlchemy 1.4 中更新，以支持在 SQLAlchemy 2.0 中标准的新调用风格。为了向后兼容在 1.4 系列内，该构造接受“旧”风格和“新”风格的参数。'
- en: 'The “new” style features that column and table expressions are passed positionally
    to the [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct only; any other modifiers to the object must be passed using subsequent
    method chaining:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: “新”风格的特性是列和表达式只能按位置传递给[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造；对象的任何其他修饰符都必须使用后续的方法链传递：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For comparison, a [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in legacy forms of SQLAlchemy, before methods
    like [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") were even added, would like:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对比之下，在 SQLAlchemy 的旧形式中，[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 在像 [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 这样的方法甚至添加之前，可能是这样的：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or even that the “whereclause” would be passed positionally:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至“whereclause”会按位置传递：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For some years now, the additional “whereclause” and other arguments that are
    accepted have been removed from most narrative documentation, leading to a calling
    style that is most familiar as the list of column arguments passed as a list,
    but no further arguments:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，大多数叙述性文档已经删除了接受的“whereclause”和其他参数，导致调用风格更像是作为列参数传递的列列表，但没有进一步的参数：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The document at [select() no longer accepts varied constructor arguments, columns
    are passed positionally](changelog/migration_20.html#migration-20-5284) describes
    this change in terms of [2.0 Migration](changelog/migration_20.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() 不再接受多样的构造参数，列仅按位置传递](changelog/migration_20.html#migration-20-5284)
    中的文档描述了这一变更的[2.0 迁移](changelog/migration_20.html)。'
- en: See also
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() 不再接受多样的构造参数，列仅按位置传递](changelog/migration_20.html#migration-20-5284)'
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html)  ###
    A bind was located via legacy bound metadata, but since future=True is set on
    this Session, this bind is ignored.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html)  ### 通过旧绑定的元数据找到了一个绑定，但由于该
    Session 设置了 future=True，因此该绑定被忽略。'
- en: The concept of “bound metadata” is present up until SQLAlchemy 1.4; as of SQLAlchemy
    2.0 it’s been removed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 SQLAlchemy 1.4，都存在“bound metadata”的概念；从 SQLAlchemy 2.0 开始已经移除。
- en: 'This error refers to the [`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData") parameter on the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that in turn allows objects like the ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to associate a particular mapped class with an `Engine`. In SQLAlchemy 2.0, the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    must be linked to each `Engine` directly. That is, instead of instantiating the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    without any arguments, and associating the [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指的是[`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData")参数，该参数位于[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象上，该对象又允许ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将特定的映射类与`Engine`关联起来。在SQLAlchemy 2.0中，[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")必须直接链接到每个`Engine`。也就是说，不是实例化[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")或[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")而不带任何参数，并将[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")与[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")关联起来：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    must instead be associated directly with the [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object should no longer be associated with any engine:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")必须直接与[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联。[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象不应再关联任何引擎：'
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In SQLAlchemy 1.4, this [2.0 style](glossary.html#term-2.0-style) behavior
    is enabled when the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag is set on [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").  ### This Compiled object is not bound to any Engine
    or Connection'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '在SQLAlchemy 1.4中，当[`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")标志设置在[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上时，将启用此[2.0风格](glossary.html#term-2.0-style)行为。 ### 此编译对象未绑定到任何Engine或Connection'
- en: 'This error refers to the concept of “bound metadata”, which is a legacy SQLAlchemy
    pattern present only in 1.x versions. The issue occurs when one invokes the `Executable.execute()`
    method directly off of a Core expression object that is not associated with any
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指的是“绑定的元数据”概念，这是仅存在于1.x版本的传统SQLAlchemy模式。当直接在未关联任何[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的Core表达式对象上调用`Executable.execute()`方法时，会出现此问题：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'What the logic is expecting is that the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object has been **bound** to a [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑期望的是[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象已经**绑定**到一个[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")上：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Where above, any statement that derives from a [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which in turn derives from that [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will implicitly make use of the given [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in order to invoke the statement.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，任何从[`Table`](core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")派生的语句，又从[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")派生的语句将隐式地利用给定的[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")来调用该语句。
- en: 'Note that the concept of bound metadata is **not present in SQLAlchemy 2.0**.
    The correct way to invoke statements is via the [`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method of a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，绑定元数据的概念**在 SQLAlchemy 2.0 中不存在**。调用语句的正确方式是通过[`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")方法的[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When using the ORM, a similar facility is available via the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 ORM 时，可以通过[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")获得类似的功能：
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See also
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Basics of Statement Execution](tutorial/dbapi_transactions.html#tutorial-statement-execution)  ###
    This connection is on an inactive transaction. Please rollback() fully before
    proceeding'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[语句执行基础知识](tutorial/dbapi_transactions.html#tutorial-statement-execution)  ###
    此连接处于非活动事务状态。请在继续之前完全回滚()'
- en: This error condition was added to SQLAlchemy as of version 1.4, and does not
    apply to SQLAlchemy 2.0\. The error refers to the state where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is placed into a transaction using a method like
    [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"), and then a further “marker” transaction
    is created within that scope; the “marker” transaction is then rolled back using
    [`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or closed using [`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close"), however the outer transaction is still
    present in an “inactive” state and must be rolled back.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该错误条件是在 SQLAlchemy 版本 1.4 中添加的，不适用于 SQLAlchemy 2.0\. 该错误是指将[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")置于使用诸如[`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin")之类的方法创建的事务中，然后在该范围内创建进一步的“标记”事务；然后使用[`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback")回滚或使用[`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close")关闭“标记”事务，但是外部事务仍然处于“非活动”状态，必须回滚。
- en: 'The pattern looks like:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式看起来像：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Above, `transaction2` is a “marker” transaction, which indicates a logical nesting
    of transactions within an outer one; while the inner transaction can roll back
    the whole transaction via its rollback() method, its commit() method has no effect
    except to close the scope of the “marker” transaction itself. The call to `transaction2.rollback()`
    has the effect of **deactivating** transaction1 which means it is essentially
    rolled back at the database level, however is still present in order to accommodate
    a consistent nesting pattern of transactions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 上述中，`transaction2` 是一个“标记”事务，表示事务在外部事务内的逻辑嵌套；虽然内部事务可以通过其 rollback() 方法回滚整个事务，但其
    commit() 方法除了关闭“标记”事务的范围外，没有其他效果。调用 `transaction2.rollback()` 的效果是**取消激活** transaction1，这意味着它在数据库级别上实际上已回滚，但仍然存在以适应事务的一致嵌套模式。
- en: 'The correct resolution is to ensure the outer transaction is also rolled back:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的解决方法是确保外部事务也已回滚：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This pattern is not commonly used in Core. Within the ORM, a similar issue can
    occur which is the product of the ORM’s “logical” transaction structure; this
    is described in the FAQ entry at [“This Session’s transaction has been rolled
    back due to a previous exception during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在 Core 中不常用。在 ORM 中，可能会出现类似的问题，这是 ORM 的“逻辑”事务结构的产物；这在[“此会话的事务由于刷新期间的先前异常而被回滚。”（或类似内容）](faq/sessions.html#faq-session-rollback)的常见问题解答条目中有描述。
- en: The “subtransaction” pattern is removed in SQLAlchemy 2.0 so that this particular
    programming pattern is no longer be available, preventing this error message.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 中已删除“子事务”模式，因此不再提供此特定编程模式，从而防止出现此错误消息。
- en: Connections and Transactions
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和事务
- en: '### QueuePool limit of size <x> overflow <y> reached, connection timed out,
    timeout <z>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '### 队列池大小限制<x>已达到溢出<y>，连接超时，超时<z>'
- en: This is possibly the most common runtime error experienced, as it directly involves
    the work load of the application surpassing a configured limit, one which typically
    applies to nearly all SQLAlchemy applications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常见的运行时错误，因为它直接涉及应用程序的工作负载超过配置限制，这通常适用于几乎所有SQLAlchemy应用程序。
- en: The following points summarize what this error means, beginning with the most
    fundamental points that most SQLAlchemy users should already be familiar with.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点总结了这个错误的含义，从大多数SQLAlchemy用户应该已经熟悉的最基本点开始。
- en: '**The SQLAlchemy Engine object uses a pool of connections by default** - What
    this means is that when one makes use of a SQL database connection resource of
    an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, and then [releases](glossary.html#term-releases) that resource, the database
    connection itself remains connected to the database and is returned to an internal
    queue where it can be used again. Even though the code may appear to be ending
    its conversation with the database, in many cases the application will still maintain
    a fixed number of database connections that persist until the application ends
    or the pool is explicitly disposed.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLAlchemy引擎对象默认使用连接池** - 这意味着当使用[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象的SQL数据库连接资源，并且[释放](glossary.html#term-releases)该资源后，数据库连接本身仍保持连接状态，并返回到内部队列，可以再次使用。尽管代码可能看起来已经结束了与数据库的交互，但在许多情况下，应用程序仍会保持一定数量的数据库连接，直到应用程序结束或显式处理池。'
- en: Because of the pool, when an application makes use of a SQL database connection,
    most typically from either making use of [`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") or when making queries using an ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), this activity does not necessarily establish a new
    connection to the database at the moment the connection object is acquired; it
    instead consults the connection pool for a connection, which will often retrieve
    an existing connection from the pool to be re-used. If no connections are available,
    the pool will create a new database connection, but only if the pool has not surpassed
    a configured capacity.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于连接池，当应用程序使用SQL数据库连接时，通常是通过使用[`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect")或使用ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")进行查询时，此活动并不一定在获取连接对象时立即建立新连接到数据库；相反，它会向连接池查询连接，该连接池通常会检索一个现有连接以供重复使用。如果没有可用连接，连接池将创建一个新的数据库连接，但前提是池未超过配置容量。
- en: 'The default pool used in most cases is called [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). When you ask this pool to give you a connection
    and none are available, it will create a new connection **if the total number
    of connections in play are less than a configured value**. This value is equal
    to the **pool size plus the max overflow**. That means if you have configured
    your engine as:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数情况下使用的默认池称为[`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")。当您要求此池提供连接但没有可用连接时，它将创建一个新连接**如果当前连接总数小于配置值**。该值等于**池大小加上最大溢出**。这意味着如果您已将引擎配置为：
- en: '[PRE58]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The above [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    will allow **at most 30 connections** to be in play at any time, not including
    connections that were detached from the engine or invalidated. If a request for
    a new connection arrives and 30 connections are already in use by other parts
    of the application, the connection pool will block for a fixed period of time,
    before timing out and raising this error message.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述[`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")将允许**最多同时有30个连接**在使用中，不包括从引擎分离或失效的连接。如果新连接请求到达并且应用程序的其他部分已经使用了30个连接，连接池将阻塞一段固定时间，然后超时并引发此错误消息。
- en: In order to allow for a higher number of connections be in use at once, the
    pool can be adjusted using the [`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine") and [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") parameters as passed to the [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function. The timeout to wait for a connection to
    be available is configured using the [`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine") parameter.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了允许更多的连接同时使用，可以使用传递给[`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")函数的[`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine")和[`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine")参数来调整池。等待连接可用的超时时间是使用[`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine")参数配置的。
- en: The pool can be configured to have unlimited overflow by setting [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") to the value “-1”. With this setting, the pool will
    still maintain a fixed pool of connections, however it will never block upon a
    new connection being requested; it will instead unconditionally make a new connection
    if none are available.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过将[`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine")设置为值“-1”来配置池以具有无限溢出。使用此设置，池仍将维护一组固定的连接池，但如果没有可用的连接，则永远不会阻止新连接的请求；相反，如果没有可用的连接，它将无条件地建立一个新连接。
- en: However, when running in this way, if the application has an issue where it
    is using up all available connectivity resources, it will eventually hit the configured
    limit of available connections on the database itself, which will again return
    an error. More seriously, when the application exhausts the database of connections,
    it usually will have caused a great amount of resources to be used up before failing,
    and can also interfere with other applications and database status mechanisms
    that rely upon being able to connect to the database.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，以这种方式运行时，如果应用程序存在使用所有可用连接资源的问题，它最终将达到数据库本身可用连接的配置限制，这将再次返回错误。更严重的是，当应用程序耗尽数据库连接时，通常会在失败之前使用大量资源，并且还可能干扰其他依赖于能够连接到数据库的应用程序和数据库状态机制。
- en: Given the above, the connection pool can be looked at as a **safety valve for
    connection use**, providing a critical layer of protection against a rogue application
    causing the entire database to become unavailable to all other applications. When
    receiving this error message, it is vastly preferable to repair the issue using
    up too many connections and/or configure the limits appropriately, rather than
    allowing for unlimited overflow which does not actually solve the underlying issue.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据上述情况，连接池可以被视为连接使用的**安全阀**，为防止一个恶意应用导致整个数据库对所有其他应用不可用提供了至关重要的保护层。当收到此错误消息时，最好修复使用过多连接和/或适当配置限制的问题，而不是允许无限溢出，因为这实际上并不能解决潜在问题。
- en: What causes an application to use up all the connections that it has available?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序耗尽所有可用连接的原因是什么？
- en: '**The application is fielding too many concurrent requests to do work based
    on the configured value for the pool** - This is the most straightforward cause.
    If you have an application that runs in a thread pool that allows for 30 concurrent
    threads, with one connection in use per thread, if your pool is not configured
    to allow at least 30 connections checked out at once, you will get this error
    once your application receives enough concurrent requests. Solution is to raise
    the limits on the pool or lower the number of concurrent threads.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序正在处理过多的并发请求，以根据池的配置值进行工作** - 这是最直接的原因。如果您的应用程序在允许30个并发线程的线程池中运行，并且每个线程使用一个连接，则如果您的池未配置为允许同时至少检出30个连接，一旦您的应用程序接收到足够的并发请求，您将会收到此错误。解决方法是提高池的限制或降低并发线程数。'
- en: '**The application is not returning connections to the pool** - This is the
    next most common reason, which is that the application is making use of the connection
    pool, but the program is failing to [release](glossary.html#term-release) these
    connections and is instead leaving them open. The connection pool as well as the
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    do have logic such that when the session and/or connection object is garbage collected,
    it results in the underlying connection resources being released, however this
    behavior cannot be relied upon to release resources in a timely manner.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序没有将连接归还到池中** - 这是接下来最常见的原因，即应用程序正在使用连接池，但程序未能将这些连接[释放](glossary.html#term-release)并且仍然保持打开状态。连接池以及
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    都有逻辑，当会话和/或连接对象被垃圾回收时，底层连接资源将被释放，但不能依赖这种行为及时释放资源。'
- en: A common reason this can occur is that the application uses ORM sessions and
    does not call [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") upon them one the work involving that session
    is complete. Solution is to make sure ORM sessions if using the ORM, or engine-bound
    [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects if using Core, are explicitly closed at the end of the work being done,
    either via the appropriate `.close()` method, or by using one of the available
    context managers (e.g. “with:” statement) to properly release the resource.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种情况发生的常见原因是应用程序使用 ORM 会话但在完成使用该会话的工作后没有调用 [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")。解决方案是确保在完成工作时显式关闭 ORM 会话（如果使用 ORM）或引擎绑定的 [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象（如果使用 Core），通过适当的 `.close()` 方法或使用其中一个可用的上下文管理器（例如，“with:”语句）来正确释放资源。
- en: '**The application is attempting to run long-running transactions** - A database
    transaction is a very expensive resource, and should **never be left idle waiting
    for some event to occur**. If an application is waiting for a user to push a button,
    or a result to come off of a long running job queue, or is holding a persistent
    connection open to a browser, **don’t keep a database transaction open for the
    whole time**. As the application needs to work with the database and interact
    with an event, open a short-lived transaction at that point and then close it.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序试图运行长时间事务** - 数据库事务是一种非常昂贵的资源，绝对**不能让其空闲等待某些事件发生**。如果一个应用程序正在等待用户按下按钮，或者等待长时间运行的作业队列中的结果，或者正在保持与浏览器的持久连接打开，请**不要在整个时间段保持数据库事务处于打开状态**。当应用程序需要与数据库交互并处理事件时，在那一点上打开一个短暂的事务，然后关闭它。'
- en: '**The application is deadlocking** - Also a common cause of this error and
    more difficult to grasp, if an application is not able to complete its use of
    a connection either due to an application-side or database-side deadlock, the
    application can use up all the available connections which then leads to additional
    requests receiving this error. Reasons for deadlocks include:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序发生死锁** - 这也是这个错误的常见原因之一，也更难以理解，如果一个应用程序无法完成其对连接的使用，无论是由于应用程序端还是数据库端的死锁，应用程序都会使用完所有可用的连接，这样会导致其他请求收到这个错误。死锁的原因包括：'
- en: Using an implicit async system such as gevent or eventlet without properly monkeypatching
    all socket libraries and drivers, or which has bugs in not fully covering for
    all monkeypatched driver methods, or less commonly when the async system is being
    used against CPU-bound workloads and greenlets making use of database resources
    are simply waiting too long to attend to them. Neither implicit nor explicit async
    programming frameworks are typically necessary or appropriate for the vast majority
    of relational database operations; if an application must use an async system
    for some area of functionality, it’s best that database-oriented business methods
    run within traditional threads that pass messages to the async part of the application.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用隐式异步系统（例如 gevent 或 eventlet）而没有正确地 monkeypatch 所有的 socket 库和驱动程序，或者在没有完全覆盖所有被
    monkeypatch 的驱动程序方法的情况下存在漏洞，或者更少见的情况是异步系统正在用于 CPU 密集型工作负载且 greenlets 使用数据库资源的等待时间过长。对于绝大多数关系型数据库操作来说，隐式或显式的异步编程框架通常是不必要或不合适的；如果应用程序必须在某些功能区域使用异步系统，最好是数据库导向型业务方法在传统线程中运行，然后将消息传递给应用程序的异步部分。
- en: A database side deadlock, e.g. rows are mutually deadlocked
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库端死锁，例如行之间相互死锁
- en: Threading errors, such as mutexes in a mutual deadlock, or calling upon an already
    locked mutex in the same thread
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程错误，例如互相死锁的互斥锁，或者在同一线程中调用已锁定的互斥锁
- en: Keep in mind an alternative to using pooling is to turn off pooling entirely.
    See the section [Switching Pool Implementations](core/pooling.html#pool-switching)
    for background on this. However, note that when this error message is occurring,
    it is **always** due to a bigger problem in the application itself; the pool just
    helps to reveal the problem sooner.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用池的另一种选择是完全关闭池。请参阅[切换池实现](core/pooling.html#pool-switching)部分以了解相关背景信息。但是，请注意，当出现此错误消息时，**总是**由应用程序本身的更大问题引起；池只是帮助更快地暴露问题。
- en: See also
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Connection Pooling](core/pooling.html)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接池](core/pooling.html)'
- en: '[Working with Engines and Connections](core/connections.html)  ### Pool class
    cannot be used with asyncio engine (or vice versa)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用引擎和连接](core/connections.html)  ### 池类不能与asyncio引擎一起使用（反之亦然）'
- en: The [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    pool class uses a `thread.Lock` object internally and is not compatible with asyncio.
    If using the [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") function to create an [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine"), the appropriate queue pool class is [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), which is used automatically and does
    not need to be specified.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")池类在内部使用`thread.Lock`对象，并且与asyncio不兼容。如果使用[`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine")函数创建[`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")，则适当的队列池类是[`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")，它会自动使用，无需指定。'
- en: In addition to [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), the [`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") and [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") pool classes do not use locks and are also suitable
    for use with async engines.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")之外，[`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")和[`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")池类不使用锁，并且也适用于与异步引擎一起使用。
- en: This error is also raised in reverse in the unlikely case that the [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") pool class is indicated explicitly with
    the [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果使用[`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")函数显式指定了[`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")池类，则也会引发此错误。
- en: See also
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Connection Pooling](core/pooling.html)  ### Can’t reconnect until invalid
    transaction is rolled back. Please rollback() fully before proceeding'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接池](core/pooling.html)  ### 在无效事务回滚之前无法重新连接。请在继续之前完全回滚()'
- en: 'This error condition refers to the case where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") was invalidated, either due to a database disconnect
    detection or due to an explicit call to [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate"), but there is still a transaction present
    that was initiated either explicitly by the [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or due to the connection automatically
    beginning a transaction as occurs in the 2.x series of SQLAlchemy when any SQL
    statements are emitted. When a connection is invalidated, any [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") that was in progress is now in an invalid state,
    and must be explicitly rolled back in order to remove it from the [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").  ### QueuePool limit of size <x> overflow <y>
    reached, connection timed out, timeout <z>'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误条件指的是当一个[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")无效时，无论是因为数据库断开检测还是因为显式调用[`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate")，但仍然存在一个事务，该事务由[`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin")方法明确启动，或者由于连接在发出任何SQL语句时自动开始一个事务，如SQLAlchemy
    2.x系列中发生的情况。当连接无效时，任何正在进行中的[`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")现在处于无效状态，必须明确回滚才能将其从[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")中移除。### QueuePool大小为<x>的限制溢出<y>，连接超时，超时<z>
- en: This is possibly the most common runtime error experienced, as it directly involves
    the work load of the application surpassing a configured limit, one which typically
    applies to nearly all SQLAlchemy applications.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常见的运行时错误，因为它直接涉及应用程序的工作负载超过了配置的限制，这个限制通常适用于几乎所有的SQLAlchemy应用程序。
- en: The following points summarize what this error means, beginning with the most
    fundamental points that most SQLAlchemy users should already be familiar with.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几点总结了这个错误的含义，从大多数SQLAlchemy用户应该已经熟悉的最基本的点开始。
- en: '**The SQLAlchemy Engine object uses a pool of connections by default** - What
    this means is that when one makes use of a SQL database connection resource of
    an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object, and then [releases](glossary.html#term-releases) that resource, the database
    connection itself remains connected to the database and is returned to an internal
    queue where it can be used again. Even though the code may appear to be ending
    its conversation with the database, in many cases the application will still maintain
    a fixed number of database connections that persist until the application ends
    or the pool is explicitly disposed.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLAlchemy Engine对象默认使用连接池** - 这意味着当一个[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象的SQL数据库连接资源被使用，并且[释放](glossary.html#term-releases)了该资源后，数据库连接本身仍然保持连接状态，并返回到一个内部队列中，可以再次使用。尽管代码可能看起来已经结束了与数据库的交互，但在许多情况下，应用程序仍将保持一定数量的数据库连接，直到应用程序结束或显式释放池为止。'
- en: Because of the pool, when an application makes use of a SQL database connection,
    most typically from either making use of [`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") or when making queries using an ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), this activity does not necessarily establish a new
    connection to the database at the moment the connection object is acquired; it
    instead consults the connection pool for a connection, which will often retrieve
    an existing connection from the pool to be re-used. If no connections are available,
    the pool will create a new database connection, but only if the pool has not surpassed
    a configured capacity.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于连接池，当应用程序使用SQL数据库连接时，通常是通过使用[`Engine.connect()`](core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect")或通过使用ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")进行查询时，这个活动并不一定在获取连接对象时立即建立到数据库的新连接；它实际上是向连接池查询连接，这通常会从池中检索一个现有的连接以便重新使用。如果没有可用的连接，池将创建一个新的数据库连接，但只有在池没有超过配置容量时才会这样做。
- en: 'The default pool used in most cases is called [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). When you ask this pool to give you a connection
    and none are available, it will create a new connection **if the total number
    of connections in play are less than a configured value**. This value is equal
    to the **pool size plus the max overflow**. That means if you have configured
    your engine as:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下使用的默认池称为[`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")。当您要求此池提供连接，而没有可用连接时，它将创建一个新连接**如果当前使用的连接总数少于配置值**。这个值等于**池大小加上最大溢出**。这意味着如果您已将引擎配置为：
- en: '[PRE59]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The above [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    will allow **at most 30 connections** to be in play at any time, not including
    connections that were detached from the engine or invalidated. If a request for
    a new connection arrives and 30 connections are already in use by other parts
    of the application, the connection pool will block for a fixed period of time,
    before timing out and raising this error message.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述[`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")允许**最多
    30 个连接**同时存在，不包括已从引擎分离或失效的连接。如果请求新连接，并且应用程序的其他部分已使用 30 个连接，连接池将阻塞一段固定时间，然后超时并引发此错误消息。
- en: In order to allow for a higher number of connections be in use at once, the
    pool can be adjusted using the [`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine") and [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") parameters as passed to the [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function. The timeout to wait for a connection to
    be available is configured using the [`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine") parameter.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了允许更多连接同时使用，池可以使用传递给[`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")函数的[`create_engine.pool_size`](core/engines.html#sqlalchemy.create_engine.params.pool_size
    "sqlalchemy.create_engine")和[`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine")参数进行调整。等待可用连接的超时时间由[`create_engine.pool_timeout`](core/engines.html#sqlalchemy.create_engine.params.pool_timeout
    "sqlalchemy.create_engine")参数配置。
- en: The pool can be configured to have unlimited overflow by setting [`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine") to the value “-1”. With this setting, the pool will
    still maintain a fixed pool of connections, however it will never block upon a
    new connection being requested; it will instead unconditionally make a new connection
    if none are available.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将[`create_engine.max_overflow`](core/engines.html#sqlalchemy.create_engine.params.max_overflow
    "sqlalchemy.create_engine")设置为值“-1”，可以配置池具有无限溢出。使用此设置，池仍将维护一组固定的连接，但如果请求新连接时没有可用连接，它将无条件地创建一个新连接。
- en: However, when running in this way, if the application has an issue where it
    is using up all available connectivity resources, it will eventually hit the configured
    limit of available connections on the database itself, which will again return
    an error. More seriously, when the application exhausts the database of connections,
    it usually will have caused a great amount of resources to be used up before failing,
    and can also interfere with other applications and database status mechanisms
    that rely upon being able to connect to the database.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在这种方式下运行时，如果应用程序存在使用所有可用连接资源的问题，则最终会达到数据库本身可用连接的配置限制，这将再次返回错误。更严重的是，当应用程序耗尽数据库连接时，通常会在失败之前使用大量资源，并且还可能干扰其他依赖于能够连接到数据库的应用程序和数据库状态机制。
- en: Given the above, the connection pool can be looked at as a **safety valve for
    connection use**, providing a critical layer of protection against a rogue application
    causing the entire database to become unavailable to all other applications. When
    receiving this error message, it is vastly preferable to repair the issue using
    up too many connections and/or configure the limits appropriately, rather than
    allowing for unlimited overflow which does not actually solve the underlying issue.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 鉴于上述情况，连接池可以被视为连接使用的**安全阀**，提供了对于恶意应用程序使整个数据库对于所有其他应用程序不可用的关键保护层。当收到此错误消息时，最好修复使用太多连接和/或适当配置限制的问题，而不是允许无限溢出，这实际上并没有解决潜在问题。
- en: What causes an application to use up all the connections that it has available?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 什么原因会导致应用程序耗尽所有可用的连接？
- en: '**The application is fielding too many concurrent requests to do work based
    on the configured value for the pool** - This is the most straightforward cause.
    If you have an application that runs in a thread pool that allows for 30 concurrent
    threads, with one connection in use per thread, if your pool is not configured
    to allow at least 30 connections checked out at once, you will get this error
    once your application receives enough concurrent requests. Solution is to raise
    the limits on the pool or lower the number of concurrent threads.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序正在处理太多并发请求以执行基于池配置的工作** - 这是最直接的原因。如果您有一个运行在允许 30 个并发线程的线程池中的应用程序，每个线程使用一个连接，并且如果您的池没有配置为允许至少同时检出
    30 个连接，则在您的应用程序接收到足够的并发请求时，您将收到此错误。解决方法是提高池的限制或降低并发线程的数量。'
- en: '**The application is not returning connections to the pool** - This is the
    next most common reason, which is that the application is making use of the connection
    pool, but the program is failing to [release](glossary.html#term-release) these
    connections and is instead leaving them open. The connection pool as well as the
    ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    do have logic such that when the session and/or connection object is garbage collected,
    it results in the underlying connection resources being released, however this
    behavior cannot be relied upon to release resources in a timely manner.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序未将连接返回到池中** - 这是接下来最常见的原因，即应用程序正在使用连接池，但程序未能[释放](glossary.html#term-release)这些连接，而是保持它们处于打开状态。连接池以及ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")确实具有逻辑，使得当会话和/或连接对象被垃圾回收时，导致底层连接资源被释放，但不能依赖此行为及时释放资源。'
- en: A common reason this can occur is that the application uses ORM sessions and
    does not call [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") upon them one the work involving that session
    is complete. Solution is to make sure ORM sessions if using the ORM, or engine-bound
    [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects if using Core, are explicitly closed at the end of the work being done,
    either via the appropriate `.close()` method, or by using one of the available
    context managers (e.g. “with:” statement) to properly release the resource.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种情况经常发生的原因是应用程序使用ORM会话，但在完成涉及该会话的工作后未调用[`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")。解决方法是确保ORM会话（如果使用ORM）或绑定到引擎的[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象（如果使用Core）在完成工作后明确关闭，可以通过适当的`.close()`方法或使用其中一个可用的上下文管理器（例如“with:”语句）来正确释放资源。
- en: '**The application is attempting to run long-running transactions** - A database
    transaction is a very expensive resource, and should **never be left idle waiting
    for some event to occur**. If an application is waiting for a user to push a button,
    or a result to come off of a long running job queue, or is holding a persistent
    connection open to a browser, **don’t keep a database transaction open for the
    whole time**. As the application needs to work with the database and interact
    with an event, open a short-lived transaction at that point and then close it.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序正试图运行长时间事务** - 数据库事务是一种非常昂贵的资源，不应该**空闲等待某个事件发生**。如果应用程序正在等待用户按下按钮，或者等待长时间作业队列的结果，或者保持持久连接打开以与浏览器交互，**不要保持数据库事务始终处于打开状态**。当应用程序需要与数据库一起工作并与事件交互时，在那一点上打开一个短暂的事务，然后关闭它。'
- en: '**The application is deadlocking** - Also a common cause of this error and
    more difficult to grasp, if an application is not able to complete its use of
    a connection either due to an application-side or database-side deadlock, the
    application can use up all the available connections which then leads to additional
    requests receiving this error. Reasons for deadlocks include:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序发生死锁** - 这也是此错误的常见原因，更难以理解。如果应用程序由于应用程序端或数据库端的死锁而无法完成其对连接的使用，那么应用程序可能会耗尽所有可用连接，然后导致其他请求收到此错误。死锁的原因包括：'
- en: Using an implicit async system such as gevent or eventlet without properly monkeypatching
    all socket libraries and drivers, or which has bugs in not fully covering for
    all monkeypatched driver methods, or less commonly when the async system is being
    used against CPU-bound workloads and greenlets making use of database resources
    are simply waiting too long to attend to them. Neither implicit nor explicit async
    programming frameworks are typically necessary or appropriate for the vast majority
    of relational database operations; if an application must use an async system
    for some area of functionality, it’s best that database-oriented business methods
    run within traditional threads that pass messages to the async part of the application.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有正确地对所有套接字库和驱动程序进行猴子补丁，或者对所有猴子补丁驱动程序方法的覆盖不完全，或者在异步系统正在用于 CPU 密集型工作负载并且使用数据库资源的绿色线程等待太长时间时，则使用隐式异步系统，例如
    gevent 或 eventlet，会出现问题。通常，隐式或显式异步编程框架通常对绝大多数关系数据库操作都不是必要的或合适的；如果应用程序必须对某些功能区域使用异步系统，则最好是数据库导向的业务方法在传统线程中运行，然后将消息传递到应用程序的异步部分。
- en: A database side deadlock, e.g. rows are mutually deadlocked
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库端发生死锁，例如行相互死锁
- en: Threading errors, such as mutexes in a mutual deadlock, or calling upon an already
    locked mutex in the same thread
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程错误，例如互斥体在相互死锁，或在同一线程中调用已锁定的互斥体
- en: Keep in mind an alternative to using pooling is to turn off pooling entirely.
    See the section [Switching Pool Implementations](core/pooling.html#pool-switching)
    for background on this. However, note that when this error message is occurring,
    it is **always** due to a bigger problem in the application itself; the pool just
    helps to reveal the problem sooner.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除了使用池化技术的替代方法是完全关闭池化技术。请参阅[切换池实现](core/pooling.html#pool-switching)部分了解背景信息。但是，请注意，当出现此错误消息时，通常是由于应用程序本身存在更大的问题；池仅帮助更早地暴露问题。
- en: See also
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Connection Pooling](core/pooling.html)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接池](core/pooling.html)'
- en: '[Working with Engines and Connections](core/connections.html)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[与引擎和连接一起工作](core/connections.html)'
- en: '### Pool class cannot be used with asyncio engine (or vice versa)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '### 无法将 Pool 类与 asyncio 引擎一起使用（反之亦然）'
- en: The [`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    pool class uses a `thread.Lock` object internally and is not compatible with asyncio.
    If using the [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") function to create an [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine"), the appropriate queue pool class is [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), which is used automatically and does
    not need to be specified.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[`QueuePool`](core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    池类在内部使用 `thread.Lock` 对象，并且与 asyncio 不兼容。如果使用 [`create_async_engine()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") 函数创建 [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")，则适当的队列池类是 [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")，它会自动使用，无需指定。'
- en: In addition to [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool"), the [`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") and [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") pool classes do not use locks and are also suitable
    for use with async engines.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool")，[`NullPool`](core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") 和 [`StaticPool`](core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") 池类不使用锁，并且也适用于与异步引擎一起使用。
- en: This error is also raised in reverse in the unlikely case that the [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") pool class is indicated explicitly with
    the [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果使用 [`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 函数明确指定 [`AsyncAdaptedQueuePool`](core/pooling.html#sqlalchemy.pool.AsyncAdaptedQueuePool
    "sqlalchemy.pool.AsyncAdaptedQueuePool") 池类，则还会引发此错误。
- en: See also
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Connection Pooling](core/pooling.html)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接池](core/pooling.html)'
- en: '### Can’t reconnect until invalid transaction is rolled back. Please rollback()
    fully before proceeding'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '### 无法重新连接直到无效事务被完全回滚。请在继续之前完全回滚()'
- en: This error condition refers to the case where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") was invalidated, either due to a database disconnect
    detection or due to an explicit call to [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate"), but there is still a transaction present
    that was initiated either explicitly by the [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or due to the connection automatically
    beginning a transaction as occurs in the 2.x series of SQLAlchemy when any SQL
    statements are emitted. When a connection is invalidated, any [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") that was in progress is now in an invalid state,
    and must be explicitly rolled back in order to remove it from the [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误条件指的是 [`Connection`](core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    被作废的情况，可能是由于检测到数据库断开连接或由于显式调用 [`Connection.invalidate()`](core/connections.html#sqlalchemy.engine.Connection.invalidate
    "sqlalchemy.engine.Connection.invalidate")，但仍然存在已经由 [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") 方法显式启动的事务，或者由于连接在发出任何SQL语句时自动开始事务，这在SQLAlchemy的2.x系列中发生。当连接被作废时，任何正在进行的
    [`Transaction`](core/connections.html#sqlalchemy.engine.Transaction "sqlalchemy.engine.Transaction")
    现在处于无效状态，必须显式回滚以将其从 [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 中移除。
- en: '## DBAPI Errors'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '## DBAPI 错误'
- en: The Python database API, or DBAPI, is a specification for database drivers which
    can be located at [Pep-249](https://www.python.org/dev/peps/pep-0249/). This API
    specifies a set of exception classes that accommodate the full range of failure
    modes of the database.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Python数据库API，或DBAPI，是一种用于数据库驱动程序的规范，可以在 [Pep-249](https://www.python.org/dev/peps/pep-0249/)
    找到。此API指定了一组异常类，以适应数据库的所有故障模式。
- en: SQLAlchemy does not generate these exceptions directly. Instead, they are intercepted
    from the database driver and wrapped by the SQLAlchemy-provided exception [`DBAPIError`](core/exceptions.html#sqlalchemy.exc.DBAPIError
    "sqlalchemy.exc.DBAPIError"), however the messaging within the exception is **generated
    by the driver, not SQLAlchemy**.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 不会直接生成这些异常。相反，它们是从数据库驱动程序拦截并由SQLAlchemy提供的异常 [`DBAPIError`](core/exceptions.html#sqlalchemy.exc.DBAPIError
    "sqlalchemy.exc.DBAPIError") 包装的，但异常中的消息是**由驱动程序生成的，而不是SQLAlchemy**。
- en: '### InterfaceError'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '### InterfaceError'
- en: Exception raised for errors that are related to the database interface rather
    than the database itself.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库接口而不是数据库本身相关的错误引发的异常。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是 [DBAPI 错误](#error-dbapi) ，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: 'The `InterfaceError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    DatabaseError'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterfaceError` 有时会由驱动程序在数据库连接断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参阅 [处理断开连接](core/pooling.html#pool-disconnects)
    部分。  ### DatabaseError'
- en: Exception raised for errors that are related to the database itself, and not
    the interface or data being passed.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库本身相关而不是接口或传递的数据的错误引发的异常。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### DataError'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是 [DBAPI 错误](#error-dbapi) ，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。  ### DataError'
- en: Exception raised for errors that are due to problems with the processed data
    like division by zero, numeric value out of range, etc.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理的数据问题引发的异常，例如除以零，数值超出范围等。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### OperationalError'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。  ### OperationalError'
- en: Exception raised for errors that are related to the database’s operation and
    not necessarily under the control of the programmer, e.g. an unexpected disconnect
    occurs, the data source name is not found, a transaction could not be processed,
    a memory allocation error occurred during processing, etc.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库操作相关的错误引发的异常，不一定在程序员控制之下，例如出现意外断开连接，找不到数据源名称，无法处理事务，处理过程中发生内存分配错误等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: 'The `OperationalError` is the most common (but not the only) error class used
    by drivers in the context of the database connection being dropped, or not being
    able to connect to the database. For tips on how to deal with this, see the section
    [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ### IntegrityError'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationalError` 是由驱动程序在数据库连接断开或无法连接到数据库的情况下使用的最常见（但不是唯一）错误类别。有关如何处理此问题的提示，请参阅[处理断开连接](core/pooling.html#pool-disconnects)部分。  ###
    IntegrityError'
- en: Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库的关系完整性受到影响时引发的异常，例如外键检查失败。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### InternalError'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。  ### InternalError'
- en: Exception raised when the database encounters an internal error, e.g. the cursor
    is not valid anymore, the transaction is out of sync, etc.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库遇到内部错误时引发的异常，例如游标不再有效，事务不同步等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: 'The `InternalError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    ProgrammingError'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`InternalError` 有时会由驱动程序在数据库连接断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参阅[处理断开连接](core/pooling.html#pool-disconnects)部分。  ###
    ProgrammingError'
- en: Exception raised for programming errors, e.g. table not found or already exists,
    syntax error in the SQL statement, wrong number of parameters specified, etc.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程错误引发的异常，例如未找到表或已存在，SQL 语句中的语法错误，指定的参数数量错误等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: 'The `ProgrammingError` is sometimes raised by drivers in the context of the
    database connection being dropped, or not being able to connect to the database.
    For tips on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).  ###
    NotSupportedError'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgrammingError` 有时会由驱动程序在数据库连接断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参阅[处理断开连接](core/pooling.html#pool-disconnects)部分。  ###
    NotSupportedError'
- en: Exception raised in case a method or database API was used which is not supported
    by the database, e.g. requesting a .rollback() on a connection that does not support
    transaction or has transactions turned off.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用数据库不支持的方法或数据库 API 时引发的异常，例如在不支持事务或已关闭事务的连接上请求`.rollback()`。
- en: 'This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.  ### InterfaceError'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。  ### InterfaceError'
- en: Exception raised for errors that are related to the database interface rather
    than the database itself.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库本身而不是数据库接口相关的错误引发的异常。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: The `InterfaceError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterfaceError`有时由驱动程序在数据库连接断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参见[处理断开连接](core/pooling.html#pool-disconnects)部分。'
- en: '### DatabaseError'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '### DatabaseError'
- en: Exception raised for errors that are related to the database itself, and not
    the interface or data being passed.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与数据库本身相关的错误而引发的异常，而不是与传递的接口或数据相关。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: '### DataError'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '### DataError'
- en: Exception raised for errors that are due to problems with the processed data
    like division by zero, numeric value out of range, etc.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理数据的问题（例如除零，数值超出范围等）引发的错误。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: '### OperationalError'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '### OperationalError'
- en: Exception raised for errors that are related to the database’s operation and
    not necessarily under the control of the programmer, e.g. an unexpected disconnect
    occurs, the data source name is not found, a transaction could not be processed,
    a memory allocation error occurred during processing, etc.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与数据库操作相关的错误而引发的异常，不一定在程序员的控制之下，例如发生意外断开连接，数据源名称未找到，无法处理事务，处理过程中发生内存分配错误等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: The `OperationalError` is the most common (but not the only) error class used
    by drivers in the context of the database connection being dropped, or not being
    able to connect to the database. For tips on how to deal with this, see the section
    [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationalError`是驱动程序在数据库连接断开或无法连接到数据库的情况下最常见（但不是唯一）使用的错误类。有关如何处理此问题的提示，请参见[处理断开连接](core/pooling.html#pool-disconnects)部分。'
- en: '### IntegrityError'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '### IntegrityError'
- en: Exception raised when the relational integrity of the database is affected,
    e.g. a foreign key check fails.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库的关系完整性受到影响时引发异常，例如外键检查失败。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: '### InternalError'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '### InternalError'
- en: Exception raised when the database encounters an internal error, e.g. the cursor
    is not valid anymore, the transaction is out of sync, etc.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库遇到内部错误时引发异常，例如游标不再有效，事务不同步等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: The `InternalError` is sometimes raised by drivers in the context of the database
    connection being dropped, or not being able to connect to the database. For tips
    on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`InternalError`有时由驱动程序在数据库连接断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参见[处理断开连接](core/pooling.html#pool-disconnects)部分。'
- en: '### ProgrammingError'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '### ProgrammingError'
- en: Exception raised for programming errors, e.g. table not found or already exists,
    syntax error in the SQL statement, wrong number of parameters specified, etc.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程错误而引发的异常，例如表未找到或已存在，在SQL语句中存在语法错误，指定的参数数量错误等。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误是[DBAPI错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是SQLAlchemy本身。
- en: The `ProgrammingError` is sometimes raised by drivers in the context of the
    database connection being dropped, or not being able to connect to the database.
    For tips on how to deal with this, see the section [Dealing with Disconnects](core/pooling.html#pool-disconnects).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgrammingError`有时由驱动程序在数据库连接断开或无法连接到数据库的情况下引发。有关如何处理此问题的提示，请参见[处理断开连接](core/pooling.html#pool-disconnects)部分。'
- en: '### NotSupportedError'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '### NotSupportedError'
- en: Exception raised in case a method or database API was used which is not supported
    by the database, e.g. requesting a .rollback() on a connection that does not support
    transaction or has transactions turned off.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据库不支持的方法或数据库 API 时引发异常，例如在不支持事务或已关闭事务的连接上请求 .rollback()。
- en: This error is a [DBAPI Error](#error-dbapi) and originates from the database
    driver (DBAPI), not SQLAlchemy itself.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是一个[DBAPI 错误](#error-dbapi)，源自数据库驱动程序（DBAPI），而不是 SQLAlchemy 本身。
- en: SQL Expression Language
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 表达语言
- en: '### Object will not produce a cache key, Performance Implications'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对象不会生成缓存键，性能影响'
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 从版本 1.4 开始包含一个[SQL 编译缓存设施](core/connections.html#sql-caching)，它允许
    Core 和 ORM SQL 构造缓存它们的字符串形式，以及用于从语句中获取结果的其他结构信息，当下次使用另一个结构上等效的构造时，可以跳过相对昂贵的字符串编译过程。该系统依赖于为所有
    SQL 构造实现的功能，包括对象如[`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")、[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象，以生成完全代表它们状态的**缓存键**，以影响 SQL 编译过程。
- en: If the warnings in question refer to widely used objects such as [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and are shown to be affecting the majority
    of SQL constructs being emitted (using the estimation techniques described at
    [Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging))
    such that caching is generally not enabled for an application, this will negatively
    impact performance and can in some cases effectively produce a **performance degradation**
    compared to prior SQLAlchemy versions. The FAQ at [Why is my application slow
    after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching) covers
    this in additional detail.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题中的警告涉及到广泛使用的对象，如[`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象，并且显示影响到发出的大多数
    SQL 构造（使用[估算缓存性能使用日志记录](core/connections.html#sql-caching-logging)描述的估算技术），以至于缓存通常不会为应用程序启用，这将对性能产生负面影响，并且在某些情况下，与之前的
    SQLAlchemy 版本相比，实际上会产生**性能下降**。在[为什么升级到 1.4 和/或 2.x 后我的应用程序变慢？](faq/performance.html#faq-new-caching)的常见问题解答中详细介绍了这一点。
- en: Caching disables itself if there’s any doubt
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果有任何疑问，缓存会自行禁用。
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存依赖于能够以**一致**的方式生成准确代表语句**完整结构**的缓存键。如果特定的 SQL 构造（或类型）没有适当的指令，允许它生成正确的缓存键，那么不能安全地启用缓存：
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须代表**完整结构**：如果使用两个不同实例的构造可能导致渲染不同 SQL，那么针对第一个元素使用不捕捉第一和第二元素之间不同之处的缓存键缓存
    SQL，将导致第二个实例渲染出错误的 SQL。
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须是**一致的**：如果一个构造表示每次都会改变的状态，比如字面值，为每个实例生成唯一的 SQL，那么这个构造也不安全可缓存，因为重复使用构造将快速填满语句缓存，其中包含可能不会再次使用的唯一
    SQL 字符串，从而破坏了缓存的目的。
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述两个原因，SQLAlchemy 的缓存系统对于决定是否缓存与对象对应的 SQL 是**非常保守**的。
- en: Assertion attributes for caching
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存断言属性
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下标准发出警告。有关每个标准的详细信息，请参见 [为什么升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching)。
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    本身（即由我们传递给 [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    的 URL 的第一部分指定的模块，如 `postgresql+psycopg2://`），必须指示已经审查和测试以正确支持缓存，这由 [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") 属性设置为 `True` 来表示。在使用第三方方言时，请咨询方言的维护人员，以便他们遵循[确保可以启用缓存的步骤](core/connections.html#engine-thirdparty-caching)并发布新版本。'
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方或用户定义的类型，它们继承自[`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 或 [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")，必须在其定义中包含 [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") 属性，包括所有派生子类，遵循[`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok")的文档字符串中描述的准则。与以前一样，如果这些数据类型是从第三方库导入的，请咨询该库的维护人员，以便他们提供必要的更改并发布新版本。
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方或用户定义的 SQL 构造，从类似 [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")、[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")、[`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 等类继承，包括简单的子类以及设计用于与[自定义 SQL 构造和编译扩展](core/compiler.html)一起工作的那些，通常应包括
    [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") 属性设置为 `True` 或 `False`，根据构造的设计，遵循在[为自定义构造启用缓存支持](core/compiler.html#compilerext-caching)中描述的准则。
- en: See also
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用日志估算缓存性能](core/connections.html#sql-caching-logging) - 关于观察缓存行为和效率的背景知识'
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section  ### Compiler StrSQLCompiler
    can’t render element of type <element type>'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching) - 在[常见问题解答](faq/index.html)部分  ###
    Compiler StrSQLCompiler 无法渲染类型为 <element type> 的元素'
- en: This error usually occurs when attempting to stringify a SQL expression construct
    that includes elements which are not part of the default compilation; in this
    case, the error will be against the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") class. In less common cases, it can
    also occur when the wrong kind of SQL expression is used with a particular type
    of database backend; in those cases, other kinds of SQL compiler classes will
    be named, such as `SQLCompiler` or `sqlalchemy.dialects.postgresql.PGCompiler`.
    The guidance below is more specific to the “stringification” use case but describes
    the general background as well.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误通常发生在尝试将包含不属于默认编译的元素的 SQL 表达式构造转换为字符串时；在这种情况下，错误将针对 [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 类。在较少见的情况下，当使用错误类型的 SQL 表达式与特定类型的数据库后端一起使用时，也会发生这种情况；在这些情况下，将命名其他类型的
    SQL 编译器类，如 `SQLCompiler` 或 `sqlalchemy.dialects.postgresql.PGCompiler`。以下指导更具体地针对“字符串化”用例，但也描述了一般背景。
- en: 'Normally, a Core SQL construct or ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object can be stringified directly, such as when we use
    `print()`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，核心 SQL 构造或 ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象可以直接转换为字符串，例如当我们使用 `print()` 时：
- en: '[PRE60]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When the above SQL expression is stringified, the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") compiler class is used, which is a special
    statement compiler that is invoked when a construct is stringified without any
    dialect-specific information.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述 SQL 表达式被转换为字符串时，将使用 [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 编译器类，这是一个特殊的语句编译器，当一个构造被转换为字符串时，没有任何特定于方言的信息时会被调用。
- en: 'However, there are many constructs that are specific to some particular kind
    of database dialect, for which the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") doesn’t know how to turn into a string,
    such as the PostgreSQL [“insert on conflict”](postgresql_insert_on_conflict) construct:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多构造是特定于某种数据库方言的，对于这些构造，[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 不知道如何转换为字符串，例如 PostgreSQL 的 [“insert
    on conflict”](postgresql_insert_on_conflict) 构造：
- en: '[PRE61]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In order to stringify constructs that are specific to particular backend, the
    [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method must be used, passing
    either an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or a [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object which will invoke the correct compiler. Below we use a PostgreSQL dialect:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将特定于特定后端的结构字符串化，必须使用[`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法，传递一个[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或一个[`Dialect`](core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect")对象，该对象将调用正确的编译器。下面我们使用了一个 PostgreSQL 方言：
- en: '[PRE62]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For an ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, the statement can be accessed using the `Query.statement` accessor:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象，可以使用 `Query.statement` 访问器访问语句：
- en: '[PRE63]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See the FAQ link below for additional detail on direct stringification / compilation
    of SQL elements.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下方的常见问题解答链接，了解关于直接字符串化/编译 SQL 元素的额外细节。
- en: See also
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](faq/sqlexpressions.html#faq-sql-expression-string)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何将 SQL 表达式呈现为字符串，可能会内联绑定参数？](faq/sqlexpressions.html#faq-sql-expression-string)'
- en: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'TypeError: `<operator>`不支持‘ColumnProperty’和`<something>`实例之间的操作'
- en: 'This often occurs when attempting to use a [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") object in the context of a SQL expression, usually
    within declarative such as:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试在 SQL 表达式的上下文中使用 [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 或 [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 对象时，通常会发生这种情况，通常是在声明性的上下文中，如下所示：
- en: '[PRE64]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Above, the `cprop` attribute is used inline before it has been mapped, however
    this `cprop` attribute is not a [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), it’s a [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"), which is an interim object and therefore does
    not have the full functionality of either the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or the [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") object that will be mapped onto the `Bar`
    class once the declarative process is complete.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`cprop` 属性在映射之前内联使用，但是这个 `cprop` 属性不是一个[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，它是一个[`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")，这是一个临时对象，因此它没有 [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或 [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") 对象的全部功能，一旦声明过程完成，它将被映射到 `Bar` 类上。
- en: While the [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") does have a `__clause_element__()` method, which
    allows it to work in some column-oriented contexts, it can’t work in an open-ended
    comparison context as illustrated above, since it has no Python `__eq__()` method
    that would allow it to interpret the comparison to the number “5” as a SQL expression
    and not a regular Python comparison.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")
    有一个 `__clause_element__()` 方法，它允许它在某些面向列的上下文中工作，但它不能在上面示例中所示的开放式比较上下文中工作，因为它没有
    Python `__eq__()` 方法，该方法允许它将与数字“5”的比较解释为 SQL 表达式而不是常规 Python 比较。
- en: 'The solution is to access the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly using the [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是直接使用[`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")访问[`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression")属性：
- en: '[PRE65]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '### A value is required for bind parameter <x> (in parameter group <y>)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '### 绑定参数<x>（在参数组<y>中）需要一个值'
- en: 'This error occurs when a statement makes use of [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") either implicitly or explicitly and does
    not provide a value when the statement is executed:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 当语句隐式或显式地使用[`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，并且在执行语句时没有提供值时，会发生此错误：
- en: '[PRE66]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Above, no value has been provided for the parameter “my_param”. The correct
    approach is to provide a value:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，没有为参数“my_param”提供值。正确的方法是提供一个值：
- en: '[PRE67]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When the message takes the form “a value is required for bind parameter <x>
    in parameter group <y>”, the message is referring to the “executemany” style of
    execution. In this case, the statement is typically an INSERT, UPDATE, or DELETE
    and a list of parameters is being passed. In this format, the statement may be
    generated dynamically to include parameter positions for every parameter given
    in the argument list, where it will use the **first set of parameters** to determine
    what these should be.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息采用“在参数组< y >中需要为绑定参数< x >提供值”的形式时，消息是指执行的“executemany”风格。在这种情况下，语句通常是INSERT、UPDATE或DELETE，并且正在传递参数列表。在这种格式中，语句可以动态生成，以包含参数列表中提供的每个参数的参数位置，它将使用**第一组参数**来确定这些参数应该是什么。
- en: 'For example, the statement below is calculated based on the first parameter
    set to require the parameters, “a”, “b”, and “c” - these names determine the final
    string format of the statement which will be used for each set of parameters in
    the list. As the second entry does not contain “b”, this error is generated:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的语句是基于第一个参数集计算的，需要参数“a”、“b”和“c” - 这些名称确定了语句的最终字符串格式，该格式将用于列表中的每个参数集。由于第二个条目不包含“b”，因此会生成此错误：
- en: '[PRE68]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since “b” is required, pass it as `None` so that the INSERT may proceed:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“b”是必需的，因此将其传递为`None`，以便进行 INSERT 操作：
- en: '[PRE70]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Sending Parameters](tutorial/dbapi_transactions.html#tutorial-sending-parameters)  ###
    Expected FROM clause, got Select. To create a FROM clause, use the .subquery()
    method'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[发送参数](tutorial/dbapi_transactions.html#tutorial-sending-parameters) ### 期望的
    FROM 子句，得到 Select。要创建 FROM 子句，请使用 .subquery() 方法'
- en: This refers to a change made as of SQLAlchemy 1.4 where a SELECT statement as
    generated by a function such as [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), but also including things like unions and
    textual SELECT expressions are no longer considered to be [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects and can’t be placed directly in
    the FROM clause of another SELECT statement without them being wrapped in a [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") first. This is a major conceptual change
    in the Core and the full rationale is discussed at [A SELECT statement is no longer
    implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 SQLAlchemy 1.4 所做的更改，其中通过诸如[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")之类的函数生成的 SELECT 语句，但也包括联合和文本 SELECT 表达式等内容不再被视为[`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")对象，并且不能直接放置在另一个 SELECT 语句的 FROM 子句中，而不是首先将它们包装在[`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")中。这是核心中的一个重大概念性变化，完整的原理在[SELECT 语句不再隐式视为
    FROM 子句](changelog/migration_14.html#change-4617)中讨论。
- en: 'Given an example as:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个示例：
- en: '[PRE71]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Above, `stmt` represents a SELECT statement. The error is produced when we
    want to use `stmt` directly as a FROM clause in another SELECT, such as if we
    attempted to select from it:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`stmt`表示一个 SELECT 语句。当我们想要直接将`stmt`作为另一个 SELECT 语句的 FROM 子句时，比如如果我们试图从中选择：
- en: '[PRE72]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or if we wanted to use it in a FROM clause such as in a JOIN:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果我们想在 FROM 子句中使用它，比如在 JOIN 中：
- en: '[PRE73]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In previous versions of SQLAlchemy, using a SELECT inside of another SELECT
    would produce a parenthesized, unnamed subquery. In most cases, this form of SQL
    is not very useful as databases like MySQL and PostgreSQL require that subqueries
    in FROM clauses have named aliases, which means using the [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method or as of 1.4 using the [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method to produce this. On other
    databases, it is still much clearer for the subquery to have a name to resolve
    any ambiguity on future references to column names inside the subquery.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy的早期版本中，使用一个SELECT语句在另一个SELECT语句内会产生一个有括号的无名称子查询。在大多数情况下，这种形式的SQL不是很有用，因为像MySQL和PostgreSQL这样的数据库要求FROM子句中的子查询具有命名别名，这意味着需要使用[`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias")方法或者从1.4版本开始使用[`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")方法来产生这个。在其他数据库中，子查询有一个名称来解析子查询内部列名的任何歧义仍然更清晰。
- en: 'Beyond the above practical reasons, there are a lot of other SQLAlchemy-oriented
    reasons the change is being made. The correct form of the above two statements
    therefore requires that [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") is used:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述实际原因外，还有很多其他与SQLAlchemy相关的原因导致进行此更改。因此，上述两个语句的正确形式要求使用[`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")：
- en: '[PRE74]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: See also
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617)  ###
    An alias is being generated automatically for raw clauseelement'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[SELECT语句不再隐式地被视为FROM子句](changelog/migration_14.html#change-4617)  ### 为原始clauseelement自动生成别名'
- en: New in version 1.4.26.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4.26 中新增。
- en: 'This deprecation warning refers to a very old and likely not well known pattern
    that applies to the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method as well as the [2.0 style](glossary.html#term-2.0-style)
    [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join "sqlalchemy.sql.expression.Select.join")
    method, where a join can be stated in terms of a [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") but the target is the [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other Core selectable to which the class is mapped,
    rather than an ORM entity such as a mapped class or [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这个弃用警告指的是一个非常古老且可能不太为人所知的模式，适用于传统的[`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法以及[2.0风格](glossary.html#term-2.0-style)的[`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其中联接可以根据[`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")来表示，但目标是将类映射到的[`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")或其他核心可选择项，而不是ORM实体，比如映射类或[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造：
- en: '[PRE75]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The above pattern also allows an arbitrary selectable, such as a Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object, however there is no automatic adaptation
    of this element, meaning the Core element would need to be referenced directly:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式还允许任意可选择项，比如核心[`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")或[`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")对象，但是没有对此元素的自动适应，这意味着需要直接引用核心元素：
- en: '[PRE76]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The correct way to specify a join target is always by using the mapped class
    itself or an [`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, in the latter case using the [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") modifier to set up an alias:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 指定联接目标的正确方法始终是使用映射类本身或一个[`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象，后者使用[`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")修饰符来设置一个别名：
- en: '[PRE77]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Join to an alias:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 加入到别名：
- en: '[PRE78]  ### An alias is being generated automatically due to overlapping tables'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE78]  ### 由于重叠表而自动生成别名'
- en: New in version 1.4.26.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本为1.4.26。
- en: 'This warning is typically generated when querying using the [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method or the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method with mappings that involve joined table inheritance.
    The issue is that when joining between two joined inheritance models that share
    a common base table, a proper SQL JOIN between the two entities cannot be formed
    without applying an alias to one side or the other; SQLAlchemy applies an alias
    to the right side of the join. For example given a joined inheritance mapping
    as:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 此警告通常是在使用[`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法或传统的[`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法进行查询时生成的，其中涉及到涉及连接表继承的映射。问题在于，在两个共享共同基表的连接继承模型之间进行连接时，如果不对其中一个或另一个应用别名，就无法形成两个实体之间的适当SQL
    JOIN；SQLAlchemy将别名应用于连接的右侧。例如，考虑到连接继承映射：
- en: '[PRE79]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The above mapping includes a relationship between the `Employee` and `Manager`
    classes. Since both classes make use of the “employee” database table, from a
    SQL perspective this is a [self referential relationship](orm/self_referential.html#self-referential).
    If we wanted to query from both the `Employee` and `Manager` models using a join,
    at the SQL level the “employee” table needs to be included twice in the query,
    which means it must be aliased. When we create such a join using the SQLAlchemy
    ORM, we get SQL that looks like the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射包括`Employee`和`Manager`类之间的关系。由于两个类都使用“employee”数据库表，从SQL的角度来看，这是一种[自引用关系](orm/self_referential.html#self-referential)。如果我们想要使用连接从`Employee`和`Manager`模型中查询，SQL级别上“employee”表需要在查询中包含两次，这意味着它必须被别名化。当我们使用SQLAlchemy
    ORM创建这样的连接时，我们得到的SQL看起来像下面这样：
- en: '[PRE80]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Above, the SQL selects FROM the `employee` table, representing the `Employee`
    entity in the query. It then joins to a right-nested join of `employee AS employee_1
    JOIN manager AS manager_1`, where the `employee` table is stated again, except
    as an anonymous alias `employee_1`. This is the ‘automatic generation of an alias’
    to which the warning message refers.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的SQL从`employee`表中选择，表示查询中的`Employee`实体。然后加入到`employee AS employee_1 JOIN manager
    AS manager_1`的右嵌套连接，其中再次声明了`employee`表，但作为匿名别名`employee_1`。这就是警告消息所指的“自动生成别名”。
- en: 'When SQLAlchemy loads ORM rows that each contain an `Employee` and a `Manager`
    object, the ORM must adapt rows from what above is the `employee_1` and `manager_1`
    table aliases into those of the un-aliased `Manager` class. This process is internally
    complex and does not accommodate for all API features, notably when trying to
    use eager loading features such as [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") with more deeply nested queries than are shown
    here. As the pattern is unreliable for more complex scenarios and involves implicit
    decisionmaking that is difficult to anticipate and follow, the warning is emitted
    and this pattern may be considered a legacy feature. The better way to write this
    query is to use the same patterns that apply to any other self-referential relationship,
    which is to use the [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct explicitly. For joined-inheritance and other
    join-oriented mappings, it is usually desirable to add the use of the [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") parameter, which will allow a JOIN of two or more tables
    to be aliased by applying an alias to the individual tables within the join, rather
    than embedding the join into a new subquery:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQLAlchemy加载包含`Employee`和`Manager`对象的ORM行时，ORM必须将来自上述`employee_1`和`manager_1`表别名的行适应为未别名化的`Manager`类的行。这个过程在内部是复杂的，并且不支持所有API功能，特别是当尝试在比这里展示的更深度嵌套查询中使用急加载功能时，如[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")。由于该模式对于更复杂的情况不可靠，并涉及难以预测和遵循的隐式决策，因此会发出警告，并且该模式可能被视为传统功能。编写此查询的更好方法是使用适用于任何其他自引用关系的相同模式，即显式使用[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造。对于联接继承和其他基于联接的映射，通常希望添加使用[`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased")参数，这将允许通过将别名应用于联接中的各个表来对两个或更多表进行联接别名化，而不是将联接嵌入到新的子查询中：
- en: '[PRE81]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If we then wanted to use [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate the `reports_to` attribute, we refer
    to the alias:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")来填充`reports_to`属性，我们将引用别名：
- en: '[PRE82]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Without using the explicit [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object, in some more nested cases the [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option does not have enough context to know where
    to get its data from, in the case that the ORM is “auto-aliasing” in a very nested
    context. Therefore it’s best not to rely on this feature and instead keep the
    SQL construction as explicit as possible.  ### Object will not produce a cache
    key, Performance Implications'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些更嵌套的情况下，如果没有使用显式的[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象，在ORM在非常嵌套的上下文中“自动别名化”的情况下，[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")选项可能没有足够的上下文来知道从哪里获取其数据。因此，最好不要依赖此功能，而是尽可能保持SQL构造尽可能明确。###对象不会生成缓存键，性能影响
- en: SQLAlchemy as of version 1.4 includes a [SQL compilation caching facility](core/connections.html#sql-caching)
    which will allow Core and ORM SQL constructs to cache their stringified form,
    along with other structural information used to fetch results from the statement,
    allowing the relatively expensive string compilation process to be skipped when
    another structurally equivalent construct is next used. This system relies upon
    functionality that is implemented for all SQL constructs, including objects such
    as [`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select"),
    and [`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    objects, to produce a **cache key** which fully represents their state to the
    degree that it affects the SQL compilation process.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 截至版本 1.4，SQLAlchemy 包括一个[SQL 编译缓存设施](core/connections.html#sql-caching)，它允许
    Core 和 ORM SQL 构造缓存它们的字符串形式，以及用于从语句中获取结果的其他结构信息，这样当下次使用另一个结构等效的构造时，就可以跳过相对昂贵的字符串编译过程。该系统依赖于为所有
    SQL 构造实现的功能，包括诸如[`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")、[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`TypeEngine`](core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象等对象，以生成完全代表它们状态的**缓存键**，以至于影响 SQL 编译过程。
- en: If the warnings in question refer to widely used objects such as [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and are shown to be affecting the majority
    of SQL constructs being emitted (using the estimation techniques described at
    [Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging))
    such that caching is generally not enabled for an application, this will negatively
    impact performance and can in some cases effectively produce a **performance degradation**
    compared to prior SQLAlchemy versions. The FAQ at [Why is my application slow
    after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching) covers
    this in additional detail.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果警告涉及到广泛使用的对象，比如[`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象，并且显示为影响到大部分发出的
    SQL 构造（使用[通过日志估算缓存性能](core/connections.html#sql-caching-logging)描述的估算技术）以至于缓存通常不会为应用程序启用，这将对性能产生负面影响，并且在某些情况下，与之前的
    SQLAlchemy 版本相比实际上会产生**性能下降**。在[为什么升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching)的常见问题解答中详细介绍了这一点。
- en: Caching disables itself if there’s any doubt
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果存在任何疑问，缓存会自行禁用
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存依赖于能够生成一个缓存键，以一种**一致的**方式准确地表示语句的**完整结构**。如果某个特定的 SQL 构造（或类型）没有适当的指令来生成正确的缓存键，那么就不能安全地启用缓存：
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须表示**完整的结构**：如果两个单独实例的使用可能导致呈现不同 SQL，则针对第一个元素使用一个不捕获第一和第二个元素之间不同之处的缓存键缓存
    SQL，将导致为第二个实例缓存并呈现不正确的 SQL。
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须是**一致的**：如果一个构造代表每次都会更改的状态，比如文字值，为每个实例产生唯一的 SQL，那么这个构造也不安全可以缓存，因为重复使用这个构造将很快填满语句缓存，里面包含的唯一
    SQL 字符串可能不会再次使用，从而使缓存失去了意义。
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述两个原因，SQLAlchemy 的缓存系统在决定是否缓存与对象对应的 SQL 时**极其保守**。
- en: Assertion attributes for caching
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存的断言属性
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下标准发出警告。有关每个标准的更多详细信息，请参阅[升级到1.4和/或2.x后为什么我的应用程序变慢？](faq/performance.html#faq-new-caching)部分。
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")本身（即由我们传递给[`create_engine()`](core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")的URL的第一部分指定的模块，如`postgresql+psycopg2://`），必须指示已经审查并测试以正确支持缓存，这由[`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache")属性设置为`True`来指示。在使用第三方方言时，请与方言的维护者协商，以便他们遵循[确保可以启用缓存的步骤](core/connections.html#engine-thirdparty-caching)并发布新版本。'
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方或用户定义的类型，继承自[`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")或[`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")，必须在其定义中包含[`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok")属性，包括所有派生子类，在[`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok")的文档字符串中描述的指南中遵循。同样，如果这些数据类型是从第三方库导入的，请与该库的维护者协商，以便他们提供必要的更改并发布新版本。
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第三方或用户定义的SQL构造，从诸如[`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")、[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")、[`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")等类继承，包括简单的子类以及设计用于与[自定义SQL构造和编译扩展](core/compiler.html)一起工作的子类，通常应包含[`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache")属性设置为`True`或`False`，根据构造的设计，在[为自定义构造启用缓存支持](core/compiler.html#compilerext-caching)中描述的指南。 '
- en: See also
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用日志估算缓存性能](core/connections.html#sql-caching-logging) - 观察缓存行为和效率的背景'
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching) - 在[常见问题](faq/index.html)部分'
- en: Caching disables itself if there’s any doubt
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果有任何疑问，缓存会自行禁用
- en: 'Caching relies on being able to generate a cache key that accurately represents
    the **complete structure** of a statement in a **consistent** fashion. If a particular
    SQL construct (or type) does not have the appropriate directives in place which
    allow it to generate a proper cache key, then caching cannot be safely enabled:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存依赖于能够生成准确代表语句的**完整结构**的缓存键，以一致的方式。如果特定的 SQL 结构（或类型）没有适当的指令来允许其生成正确的缓存键，则不能安全地启用缓存：
- en: 'The cache key must represent the **complete structure**: If the usage of two
    separate instances of that construct may result in different SQL being rendered,
    caching the SQL against the first instance of the element using a cache key that
    does not capture the distinct differences between the first and second elements
    will result in incorrect SQL being cached and rendered for the second instance.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须代表**完整结构**：如果使用两个不同实例的结构可能导致渲染不同的 SQL，则使用不捕获第一个和第二个元素之间不同之处的缓存键对第一个元素的
    SQL 进行缓存将导致第二个实例的 SQL 被错误地缓存和渲染。
- en: 'The cache key must be **consistent**: If a construct represents state that
    changes every time, such as a literal value, producing unique SQL for every instance
    of it, this construct is also not safe to cache, as repeated use of the construct
    will quickly fill up the statement cache with unique SQL strings that will likely
    not be used again, defeating the purpose of the cache.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存键必须是**一致的**：如果一个结构代表每次都会改变的状态，比如字面值，为每个实例生成唯一的 SQL，那么这个结构也不能安全地缓存，因为对该结构的重复使用将迅速用唯一的
    SQL 字符串填满语句缓存，这些字符串可能不会再次使用，从而打破缓存的目的。
- en: For the above two reasons, SQLAlchemy’s caching system is **extremely conservative**
    about deciding to cache the SQL corresponding to an object.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述两个原因，SQLAlchemy 的缓存系统对于决定是否缓存与对象对应的 SQL 是**极端保守的**。
- en: Assertion attributes for caching
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓存的断言属性
- en: The warning is emitted based on the criteria below. For further detail on each,
    see the section [Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下标准发出警告。有关每个标准的更多详细信息，请参见 [为什么升级到 1.4 和/或 2.x 后我的应用程序变慢了？](faq/performance.html#faq-new-caching)一节。
- en: The [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    itself (i.e. the module that is specified by the first part of the URL we pass
    to [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    like `postgresql+psycopg2://`), must indicate it has been reviewed and tested
    to support caching correctly, which is indicated by the [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") attribute being set to `True`.
    When using third party dialects, consult with the maintainers of the dialect so
    that they may follow the [steps to ensure caching may be enabled](core/connections.html#engine-thirdparty-caching)
    in their dialect and publish a new release.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    本身（即我们传递给 [`create_engine()`](core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    的 URL 的第一部分指定的模块，如 `postgresql+psycopg2://`），必须指示它已经经过审查和测试，以正确支持缓存，这由 [`Dialect.supports_statement_cache`](core/internals.html#sqlalchemy.engine.Dialect.supports_statement_cache
    "sqlalchemy.engine.Dialect.supports_statement_cache") 属性设置为 `True` 来表示。使用第三方方言时，请咨询方言的维护者，以便他们可以按照[确保可以启用缓存的步骤](core/connections.html#engine-thirdparty-caching)进行操作，并发布一个新的版本。'
- en: Third party or user defined types that inherit from either [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") must include the [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") attribute in their definition, including
    for all derived subclasses, following the guidelines described in the docstring
    for [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok"). As before, if these datatypes are imported
    from third party libraries, consult with the maintainers of that library so that
    they may provide the necessary changes to their library and publish a new release.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 [`TypeDecorator`](core/custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    或 [`UserDefinedType`](core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") 继承的第三方或用户定义的类型必须在其定义中包含 [`ExternalType.cache_ok`](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") 属性，包括所有派生子类，在[外部类型缓存支持](core/type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") 的文档字符串中描述的准则。与以前一样，如果这些数据类型是从第三方库导入的，请咨询该库的维护者，以便他们提供必要的更改并发布新版本。
- en: Third party or user defined SQL constructs that subclass from classes such as
    [`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") etc, including simple subclasses as well as
    those which are designed to work with the [Custom SQL Constructs and Compilation
    Extension](core/compiler.html), should normally include the [`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute set to `True`
    or `False` based on the design of the construct, following the guidelines described
    at [Enabling Caching Support for Custom Constructs](core/compiler.html#compilerext-caching).
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方或用户定义的 SQL 构造，它们从类中子类化，如[`ClauseElement`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")，[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，[`Insert`](core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 等，包括简单的子类以及那些设计用于与 [自定义 SQL 构造和编译扩展](core/compiler.html)一起工作的子类，通常应该将[`HasCacheKey.inherit_cache`](core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") 属性设置为 `True` 或 `False`，根据构造的设计，遵循在
    [启用自定义构造的缓存支持](core/compiler.html#compilerext-caching) 中描述的准则。
- en: See also
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Estimating Cache Performance Using Logging](core/connections.html#sql-caching-logging)
    - background on observing cache behavior and efficiency'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用日志估算缓存性能](core/connections.html#sql-caching-logging) - 观察缓存行为和效率的背景知识'
- en: '[Why is my application slow after upgrading to 1.4 and/or 2.x?](faq/performance.html#faq-new-caching)
    - in the [Frequently Asked Questions](faq/index.html) section'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[为什么我的应用程序在升级到 1.4 和/或 2.x 后变慢？](faq/performance.html#faq-new-caching) - 在[常见问题解答](faq/index.html)部分'
- en: '### Compiler StrSQLCompiler can’t render element of type <element type>'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '### 编译器 StrSQLCompiler 无法渲染类型为 <element type> 的元素'
- en: This error usually occurs when attempting to stringify a SQL expression construct
    that includes elements which are not part of the default compilation; in this
    case, the error will be against the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") class. In less common cases, it can
    also occur when the wrong kind of SQL expression is used with a particular type
    of database backend; in those cases, other kinds of SQL compiler classes will
    be named, such as `SQLCompiler` or `sqlalchemy.dialects.postgresql.PGCompiler`.
    The guidance below is more specific to the “stringification” use case but describes
    the general background as well.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试将包含不属于默认编译的元素的 SQL 表达式构造进行字符串化时，通常会发生此错误；在这种情况下，错误将针对[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 类。在较少见的情况下，当使用错误类型的 SQL 表达式与特定类型的数据库后端时，也可能发生这种情况；在这些情况下，将命名其他类型的
    SQL 编译器类，例如 `SQLCompiler` 或 `sqlalchemy.dialects.postgresql.PGCompiler`。下面的指导更具体地针对“字符串化”用例，但也描述了一般背景。
- en: 'Normally, a Core SQL construct or ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object can be stringified directly, such as when we use
    `print()`:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Core SQL 构造或 ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象可以直接转换为字符串，比如当我们使用`print()`时：
- en: '[PRE83]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When the above SQL expression is stringified, the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") compiler class is used, which is a special
    statement compiler that is invoked when a construct is stringified without any
    dialect-specific information.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述 SQL 表达式被字符串化时，将使用[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 编译器类，这是一个特殊的语句编译器，当一个构造在没有任何特定于方言的信息的情况下被字符串化时会被调用。
- en: 'However, there are many constructs that are specific to some particular kind
    of database dialect, for which the [`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") doesn’t know how to turn into a string,
    such as the PostgreSQL [“insert on conflict”](postgresql_insert_on_conflict) construct:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多构造是特定于某种数据库方言的，对于这些构造，[`StrSQLCompiler`](core/internals.html#sqlalchemy.sql.compiler.StrSQLCompiler
    "sqlalchemy.sql.compiler.StrSQLCompiler") 不知道如何转换为字符串，比如 PostgreSQL 的[“insert
    on conflict”](postgresql_insert_on_conflict)构造：
- en: '[PRE84]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In order to stringify constructs that are specific to particular backend, the
    [`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method must be used, passing
    either an [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or a [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object which will invoke the correct compiler. Below we use a PostgreSQL dialect:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将特定于特定后端的构造转换为字符串，必须使用[`ClauseElement.compile()`](core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 方法，传递一个 [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或一个 [`Dialect`](core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") 对象，这将调用正确的编译器。下面我们使用一个 PostgreSQL 方言：
- en: '[PRE85]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For an ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, the statement can be accessed using the `Query.statement` accessor:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ORM [`Query`](orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象，可以通过`Query.statement`访问器访问语句：
- en: '[PRE86]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: See the FAQ link below for additional detail on direct stringification / compilation
    of SQL elements.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下面的 FAQ 链接，了解有关 SQL 元素的直接字符串化/编译的更多详细信息。
- en: See also
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](faq/sqlexpressions.html#faq-sql-expression-string)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何将 SQL 表达式呈现为字符串，可能包含内联的绑定参数？](faq/sqlexpressions.html#faq-sql-expression-string)'
- en: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'TypeError: <operator> not supported between instances of ‘ColumnProperty’ and
    <something>'
- en: 'This often occurs when attempting to use a [`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") or [`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") object in the context of a SQL expression, usually
    within declarative such as:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试在 SQL 表达式的上下文中使用[`column_property()`](orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")或[`deferred()`](orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")对象时，通常在声明中会出现这种情况：
- en: '[PRE87]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Above, the `cprop` attribute is used inline before it has been mapped, however
    this `cprop` attribute is not a [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), it’s a [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty"), which is an interim object and therefore does
    not have the full functionality of either the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object or the [`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") object that will be mapped onto the `Bar`
    class once the declarative process is complete.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，在映射之前内联使用了`cprop`属性，但是这个`cprop`属性不是一个[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，它是一个[`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty")，这是一个临时对象，因此不具备[`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象或[`InstrumentedAttribute`](orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute")对象的全部功能，一旦声明过程完成，它将映射到`Bar`类上。
- en: While the [`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") does have a `__clause_element__()` method, which
    allows it to work in some column-oriented contexts, it can’t work in an open-ended
    comparison context as illustrated above, since it has no Python `__eq__()` method
    that would allow it to interpret the comparison to the number “5” as a SQL expression
    and not a regular Python comparison.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`ColumnProperty`](orm/internals.html#sqlalchemy.orm.ColumnProperty "sqlalchemy.orm.ColumnProperty")确实具有`__clause_element__()`方法，允许它在某些面向列的上下文中工作，但是它无法在开放式比较上下文中工作，如上所示，因为它没有Python
    `__eq__()` 方法，该方法将允许它将对数字“5”的比较解释为 SQL 表达式而不是常规的 Python 比较。
- en: 'The solution is to access the [`Column`](core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly using the [`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是直接访问[`Column`](core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")，使用[`ColumnProperty.expression`](orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") 属性：
- en: '[PRE88]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '### A value is required for bind parameter <x> (in parameter group <y>)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '### 绑定参数<x>（在参数组<y>中）需要值'
- en: 'This error occurs when a statement makes use of [`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") either implicitly or explicitly and does
    not provide a value when the statement is executed:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 当语句在执行时使用[`bindparam()`](core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") 时，如果未显式或隐式地提供值，则会出现此错误：
- en: '[PRE89]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Above, no value has been provided for the parameter “my_param”. The correct
    approach is to provide a value:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况下，未为参数 “my_param” 提供任何值。正确的方法是提供一个值：
- en: '[PRE90]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When the message takes the form “a value is required for bind parameter <x>
    in parameter group <y>”, the message is referring to the “executemany” style of
    execution. In this case, the statement is typically an INSERT, UPDATE, or DELETE
    and a list of parameters is being passed. In this format, the statement may be
    generated dynamically to include parameter positions for every parameter given
    in the argument list, where it will use the **first set of parameters** to determine
    what these should be.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息采用“在参数组<y>中需要绑定参数<x>的值”的形式时，消息是指“executemany”执行风格。在这种情况下，语句通常是 INSERT、UPDATE
    或 DELETE，并且正在传递参数列表。在此格式中，语句可以动态生成，以包括参数列表中提供的每个参数的参数位置，其中它将使用**第一组参数**来确定这些参数应该是什么。
- en: 'For example, the statement below is calculated based on the first parameter
    set to require the parameters, “a”, “b”, and “c” - these names determine the final
    string format of the statement which will be used for each set of parameters in
    the list. As the second entry does not contain “b”, this error is generated:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下语句是基于第一个参数集计算的，要求参数 “a”、“b” 和 “c” - 这些名称确定语句的最终字符串格式，该格式将用于列表中每个参数集的参数。由于第二个条目不包含
    “b”，因此会生成此错误：
- en: '[PRE91]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Since “b” is required, pass it as `None` so that the INSERT may proceed:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“b”是必需的，因此将其传递为 `None`，以便 INSERT 可以继续进行：
- en: '[PRE93]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: See also
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Sending Parameters](tutorial/dbapi_transactions.html#tutorial-sending-parameters)'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[发送参数](tutorial/dbapi_transactions.html#tutorial-sending-parameters)'
- en: '### Expected FROM clause, got Select. To create a FROM clause, use the .subquery()
    method'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '### 期望 FROM 子句，但是得到了 Select。要创建 FROM 子句，请使用 `.subquery()` 方法'
- en: This refers to a change made as of SQLAlchemy 1.4 where a SELECT statement as
    generated by a function such as [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), but also including things like unions and
    textual SELECT expressions are no longer considered to be [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects and can’t be placed directly in
    the FROM clause of another SELECT statement without them being wrapped in a [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") first. This is a major conceptual change
    in the Core and the full rationale is discussed at [A SELECT statement is no longer
    implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是 SQLAlchemy 1.4 中的一项更改，根据此更改，由 [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 等函数生成的 SELECT 语句，但也包括联合和文本型 SELECT 表达式，不再被视为
    [`FromClause`](core/selectable.html#sqlalchemy.sql.expression.FromClause "sqlalchemy.sql.expression.FromClause")
    对象，而且不能直接放在另一个 SELECT 语句的 FROM 子句中，而必须首先将它们包装在 [`Subquery`](core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 中。这是 Core 中的一个重大概念变更，完整的解释在 [不再将 SELECT
    语句隐式视为 FROM 子句](changelog/migration_14.html#change-4617) 中讨论。
- en: 'Given an example as:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：
- en: '[PRE94]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Above, `stmt` represents a SELECT statement. The error is produced when we
    want to use `stmt` directly as a FROM clause in another SELECT, such as if we
    attempted to select from it:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述中，`stmt` 表示一个 SELECT 语句。当我们想要直接将 `stmt` 用作另一个 SELECT 的 FROM 子句时，比如我们试图从中选择时，会产生错误：
- en: '[PRE95]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Or if we wanted to use it in a FROM clause such as in a JOIN:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想在 FROM 子句中使用它，比如在 JOIN 中：
- en: '[PRE96]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In previous versions of SQLAlchemy, using a SELECT inside of another SELECT
    would produce a parenthesized, unnamed subquery. In most cases, this form of SQL
    is not very useful as databases like MySQL and PostgreSQL require that subqueries
    in FROM clauses have named aliases, which means using the [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method or as of 1.4 using the [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method to produce this. On other
    databases, it is still much clearer for the subquery to have a name to resolve
    any ambiguity on future references to column names inside the subquery.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 SQLAlchemy 版本中，使用一个 SELECT 嵌套在另一个 SELECT 中会产生一个带括号的、未命名的子查询。在大多数情况下，这种
    SQL 形式并不是很有用，因为像 MySQL 和 PostgreSQL 这样的数据库要求 FROM 子句中的子查询具有命名别名，这意味着需要使用 [`SelectBase.alias()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") 方法，或者从 1.4 开始使用 [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") 方法来实现这一点。在其他数据库中，为子查询命名仍然更清晰，以解决在子查询内部对列名的未来引用可能产生的任何歧义。
- en: 'Beyond the above practical reasons, there are a lot of other SQLAlchemy-oriented
    reasons the change is being made. The correct form of the above two statements
    therefore requires that [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") is used:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述实际原因外，还有许多其他基于 SQLAlchemy 的原因导致了这一更改的进行。因此，上述两个语句的正确形式要求使用 [`SelectBase.subquery()`](core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")：
- en: '[PRE97]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: See also
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](changelog/migration_14.html#change-4617)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '[不再将 SELECT 语句隐式视为 FROM 子句](changelog/migration_14.html#change-4617)'
- en: '### An alias is being generated automatically for raw clauseelement'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自动为原始 clauseelement 生成别名'
- en: New in version 1.4.26.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.4.26 版开始新加入的功能。
- en: 'This deprecation warning refers to a very old and likely not well known pattern
    that applies to the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method as well as the [2.0 style](glossary.html#term-2.0-style)
    [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join "sqlalchemy.sql.expression.Select.join")
    method, where a join can be stated in terms of a [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") but the target is the [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other Core selectable to which the class is mapped,
    rather than an ORM entity such as a mapped class or [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 此弃用警告是针对非常古老且可能不为人知的模式的，该模式适用于遗留的[`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法以及[2.0样式](glossary.html#term-2.0-style) [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其中可以根据[`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")指定连接，但目标是[`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")或其他映射到类的Core可选择对象，而不是ORM实体，如映射类或[`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造：
- en: '[PRE98]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The above pattern also allows an arbitrary selectable, such as a Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object, however there is no automatic adaptation
    of this element, meaning the Core element would need to be referenced directly:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 以上模式还允许任意可选择对象，例如Core [`Join`](core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")或[`Alias`](core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")对象，但是没有此元素的自动适应，这意味着必须直接引用Core元素：
- en: '[PRE99]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The correct way to specify a join target is always by using the mapped class
    itself or an [`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, in the latter case using the [`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") modifier to set up an alias:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 指定连接目标的正确方式始终是使用映射类本身或一个[`aliased`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")对象，后者使用[`PropComparator.of_type()`](orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")修饰符来设置别名：
- en: '[PRE100]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Join to an alias:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到别名：
- en: '[PRE101]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '### An alias is being generated automatically due to overlapping tables'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '### 由于表重叠而自动生成别名'
- en: New in version 1.4.26.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.4.26版新增。
- en: 'This warning is typically generated when querying using the [`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method or the legacy [`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method with mappings that involve joined table inheritance.
    The issue is that when joining between two joined inheritance models that share
    a common base table, a proper SQL JOIN between the two entities cannot be formed
    without applying an alias to one side or the other; SQLAlchemy applies an alias
    to the right side of the join. For example given a joined inheritance mapping
    as:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Select.join()`](core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法或遗留的[`Query.join()`](orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法查询涉及联合表继承的映射时，通常会生成此警告。问题在于，当在两个共享公共基表的联合继承模型之间进行连接时，如果不对其中一侧应用别名，则无法形成两个实体之间的适当SQL
    JOIN；SQLAlchemy对连接的右侧应用了别名。例如，给定一个联合继承映射：
- en: '[PRE102]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The above mapping includes a relationship between the `Employee` and `Manager`
    classes. Since both classes make use of the “employee” database table, from a
    SQL perspective this is a [self referential relationship](orm/self_referential.html#self-referential).
    If we wanted to query from both the `Employee` and `Manager` models using a join,
    at the SQL level the “employee” table needs to be included twice in the query,
    which means it must be aliased. When we create such a join using the SQLAlchemy
    ORM, we get SQL that looks like the following:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 以上映射包括`Employee`和`Manager`类之间的关系。由于这两个类都使用“employee”数据库表，从SQL角度来看，这是一个[自引用关系](orm/self_referential.html#self-referential)。如果我们想要使用连接从`Employee`和`Manager`模型查询，那么在SQL级别上，“employee”表需要在查询中出现两次，这意味着必须给它起个别名。当我们使用SQLAlchemy
    ORM创建这样的连接时，得到的SQL如下所示：
- en: '[PRE103]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Above, the SQL selects FROM the `employee` table, representing the `Employee`
    entity in the query. It then joins to a right-nested join of `employee AS employee_1
    JOIN manager AS manager_1`, where the `employee` table is stated again, except
    as an anonymous alias `employee_1`. This is the ‘automatic generation of an alias’
    to which the warning message refers.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，SQL 从 `employee` 表中选择，表示查询中的 `Employee` 实体。然后加入到一个右嵌套连接 `employee AS employee_1
    JOIN manager AS manager_1`，其中 `employee` 表再次出现，但是作为一个匿名别名 `employee_1`。这就是警告消息所指的‘自动生成别名’。
- en: 'When SQLAlchemy loads ORM rows that each contain an `Employee` and a `Manager`
    object, the ORM must adapt rows from what above is the `employee_1` and `manager_1`
    table aliases into those of the un-aliased `Manager` class. This process is internally
    complex and does not accommodate for all API features, notably when trying to
    use eager loading features such as [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") with more deeply nested queries than are shown
    here. As the pattern is unreliable for more complex scenarios and involves implicit
    decisionmaking that is difficult to anticipate and follow, the warning is emitted
    and this pattern may be considered a legacy feature. The better way to write this
    query is to use the same patterns that apply to any other self-referential relationship,
    which is to use the [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct explicitly. For joined-inheritance and other
    join-oriented mappings, it is usually desirable to add the use of the [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") parameter, which will allow a JOIN of two or more tables
    to be aliased by applying an alias to the individual tables within the join, rather
    than embedding the join into a new subquery:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQLAlchemy 加载包含一个 `Employee` 和一个 `Manager` 对象的 ORM 行时，ORM 必须将来自上面的 `employee_1`
    和 `manager_1` 表别名的行适配到未别名化的 `Manager` 类中。这个过程内部复杂，并且不能适应所有 API 特性，尤其是当尝试使用比这里显示的更深度嵌套的查询时，如
    [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") 等急切加载特性。由于该模式对于更复杂的场景不可靠，并涉及难以预测和遵循的隐式决策，因此会发出警告，并且该模式可能被视为一种传统特性。编写此查询的更好方法是使用适用于任何其他自引用关系的相同模式，即显式使用
    [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造。对于连接继承和其他基于连接的映射，通常希望添加使用 [`aliased.flat`](orm/queryguide/api.html#sqlalchemy.orm.aliased.params.flat
    "sqlalchemy.orm.aliased") 参数的使用，这将允许通过将别名应用于连接中的各个表来对两个或多个表进行 JOIN，而不是将连接嵌入到新的子查询中：
- en: '[PRE104]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If we then wanted to use [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") to populate the `reports_to` attribute, we refer
    to the alias:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用 [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") 来填充 `reports_to` 属性，我们引用别名：
- en: '[PRE105]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Without using the explicit [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object, in some more nested cases the [`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option does not have enough context to know where
    to get its data from, in the case that the ORM is “auto-aliasing” in a very nested
    context. Therefore it’s best not to rely on this feature and instead keep the
    SQL construction as explicit as possible.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些更嵌套的情况下，如果 ORM 在非常嵌套的上下文中“自动别名”，则不使用显式 [`aliased()`](orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") 对象，[`contains_eager()`](orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") 选项没有足够的上下文来知道从哪里获取其数据。因此，最好不要依赖此功能，而是尽可能保持 SQL
    构造的显式性。
- en: Object Relational Mapping
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象关系映射
- en: '### IllegalStateChangeError and concurrency exceptions'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '### IllegalStateChangeError 和并发异常'
- en: SQLAlchemy 2.0 introduced a new system described at [Session raises proactively
    when illegal concurrent or reentrant access is detected](changelog/whatsnew_20.html#change-7433),
    which proactively detects concurrent methods being invoked on an individual instance
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object and by extension the [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") proxy object. These concurrent access calls
    typically, though not exclusively, would occur when a single instance of [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is shared among multiple concurrent threads without
    such access being synchronized, or similarly when a single instance of [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is shared among multiple concurrent tasks
    (such as when using a function like `asyncio.gather()`). These use patterns are
    not the appropriate use of these objects, where without the proactive warning
    system SQLAlchemy implements would still otherwise produce invalid state within
    the objects, producing hard-to-debug errors including driver-level errors on the
    database connections themselves.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0引入了一个新系统，描述在[会话主动引发非法并发或重入访问时](changelog/whatsnew_20.html#change-7433)，该系统主动检测在[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的单个实例上调用并发方法以及通过扩展[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")代理对象。这些并发访问调用通常，尽管不是专门，会在单个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")实例在多个并发线程之间共享时发生，而没有进行同步访问，或者类似地，当单个[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")实例在多个并发任务之间共享时（例如在使用`asyncio.gather()`等函数时）。这些使用模式不是这些对象的适当使用方式，如果没有SQLAlchemy实现的主动警告系统，仍然会在对象内产生无效状态，导致难以调试的错误，包括数据库连接本身的驱动程序级错误。
- en: Instances of [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") are **mutable, stateful objects with no
    built-in synchronization** of method calls, and represent a **single, ongoing
    database transaction** upon a single database connection at a time for a particular
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction). A single database transaction is not an appropriate target
    for concurrent SQL commands; instead, an application that runs concurrent database
    operations should use concurrent transactions. For these objects then it follows
    that the appropriate pattern is [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") per thread, or [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") per task.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")的实例是**可变的、有状态的对象，没有内置的方法调用同步**，并代表一次性数据库事务，一次只能连接一个特定的[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")（请注意，这些对象都支持同时绑定到多个引擎，但在这种情况下，在事务范围内仍然只会有一个连接与引擎相关）。单个数据库事务不是并发SQL命令的适当目标；相反，运行并发数据库操作的应用程序应该使用并发事务。因此，对于这些对象，适当的模式是每个线程一个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，或每个任务一个[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")。'
- en: 'For more background on concurrency see the section [Is the Session thread-safe?
    Is AsyncSession safe to share in concurrent tasks?](orm/session_basics.html#session-faq-threadsafe).  ###
    Parent instance <x> is not bound to a Session; (lazy load/deferred load/refresh/etc.)
    operation cannot proceed'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 有关并发性的更多背景信息，请参阅[会话是否线程安全？AsyncSession在并发任务中是否安全共享？](orm/session_basics.html#session-faq-threadsafe)部分。###
    父实例<x>未绑定到会话；（延迟加载/延迟加载/刷新等）操作无法继续
- en: This is likely the most common error message when dealing with the ORM, and
    it occurs as a result of the nature of a technique the ORM makes wide use of known
    as [lazy loading](glossary.html#term-lazy-loading). Lazy loading is a common object-relational
    pattern whereby an object that’s persisted by the ORM maintains a proxy to the
    database itself, such that when various attributes upon the object are accessed,
    their value may be retrieved from the database *lazily*. The advantage to this
    approach is that objects can be retrieved from the database without having to
    load all of their attributes or related data at once, and instead only that data
    which is requested can be delivered at that time. The major disadvantage is basically
    a mirror image of the advantage, which is that if lots of objects are being loaded
    which are known to require a certain set of data in all cases, it is wasteful
    to load that additional data piecemeal.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是处理 ORM 时最常见的错误消息，它是由于 ORM 广泛使用的一种称为[延迟加载](glossary.html#term-lazy-loading)的技术的性质造成的。延迟加载是一种常见的对象关系模式，其中由
    ORM 持久化的对象维护与数据库本身的代理，以便当访问对象的各种属性时，可以从数据库中*惰性*检索它们的值。这种方法的优点是可以从数据库中检索对象而无需一次性加载所有属性或相关数据，而只需在那个时间点传递请求的数据即可。主要缺点基本上是优点的镜像，即如果加载了许多对象，这些对象在所有情况下都需要某组数据，则逐步加载该附加数据是浪费的。
- en: Another caveat of lazy loading beyond the usual efficiency concerns is that
    in order for lazy loading to proceed, the object has to **remain associated with
    a Session** in order to be able to retrieve its state. This error message means
    that an object has become de-associated with its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and is being asked to lazy load data from the database.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟加载的另一个警告是，为了使延迟加载继续进行，对象必须**保持与 Session 关联**，以便能够检索其状态。此错误消息意味着对象已从其[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中解除关联，并且正在被要求从数据库中惰性加载数据。
- en: The most common reason that objects become detached from their [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that the session itself was closed, typically via
    the [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method. The objects will then live on to be accessed further, very often within
    web applications where they are delivered to a server-side templating engine and
    are asked for further attributes which they cannot load.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 对象与其[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")分离的最常见原因是会话本身被关闭，通常是通过[`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法。这些对象将继续存在，很常见地在 web 应用程序中被访问，它们被传递到服务器端模板引擎，并被要求加载更多它们无法加载的属性。
- en: 'Mitigation of this error is via these techniques:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻此错误的方法是通过以下技术：
- en: '**Try not to have detached objects; don’t close the session prematurely** -
    Often, applications will close out a transaction before passing off related objects
    to some other system which then fails due to this error. Sometimes the transaction
    doesn’t need to be closed so soon; an example is the web application closes out
    the transaction before the view is rendered. This is often done in the name of
    “correctness”, but may be seen as a mis-application of “encapsulation”, as this
    term refers to code organization, not actual actions. The template that uses an
    ORM object is making use of the [proxy pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
    which keeps database logic encapsulated from the caller. If the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be held open until the lifespan of the objects are
    done, this is the best approach.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量不要有分离的对象；不要过早关闭会话** - 通常，应用程序会在将相关对象传递给其他系统之前关闭事务，然后由于此错误而失败。有时事务不需要那么快关闭；一个例子是
    web 应用程序在渲染视图之前关闭事务。这通常是以“正确性”的名义来做的，但可能被视为“封装”的错误应用，因为该术语指的是代码组织，而不是实际操作。使用 ORM
    对象的模板正在使用[代理模式](https://en.wikipedia.org/wiki/Proxy_pattern)，该模式将数据库逻辑封装在调用者之外。如果[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以保持打开，直到对象的寿命结束，这是最佳方法。'
- en: '**Otherwise, load everything that’s needed up front** - It is very often impossible
    to keep the transaction open, especially in more complex applications that need
    to pass objects off to other systems that can’t run in the same context even though
    they’re in the same process. In this case, the application should prepare to deal
    with [detached](glossary.html#term-detached) objects, and should try to make appropriate
    use of [eager loading](glossary.html#term-eager-loading) to ensure that objects
    have what they need up front.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否则，加载所有所需内容** - 很多时候不可能保持事务开启，特别是在需要将对象传递给无法在相同上下文中运行的其他系统的更复杂的应用程序中。在这种情况下，应用程序应准备处理[分离](glossary.html#term-detached)对象，并应尽量适当地使用[急切加载](glossary.html#term-eager-loading)来确保对象在一开始就拥有所需内容。'
- en: '**And importantly, set expire_on_commit to False** - When using detached objects,
    the most common reason objects need to re-load data is because they were expired
    from the last call to [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"). This expiration should not be used when dealing
    with detached objects; so the [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter be set to `False`. By preventing the objects
    from becoming expired outside of the transaction, the data which was loaded will
    remain present and will not incur additional lazy loads when that data is accessed.'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**而且，重要的是，将 expire_on_commit 设置为 False** - 在使用分离对象时，对象需要重新加载数据的最常见原因是因为它们在上一次调用[`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时被标记为过期。在处理分离对象时不应该使用这种过期机制；因此，[`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")参数应设置为`False`。通过防止对象在事务外部过期，加载的数据将保持存在，并且在访问数据时不会产生额外的延迟加载。'
- en: Note also that [`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method unconditionally expires all contents
    in the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and should also be avoided in non-error scenarios.
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还要注意，[`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法会无条件地使[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的所有内容过期，并且在非错误情况下也应该避免使用。
- en: See also
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](orm/queryguide/relationships.html) - detailed
    documentation on eager loading and other relationship-oriented loading techniques'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[关系加载技术](orm/queryguide/relationships.html) - 关于急切加载和其他基于关系的加载技术的详细文档'
- en: '[Committing](orm/session_basics.html#session-committing) - background on session
    commit'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[提交](orm/session_basics.html#session-committing) - 有关会话提交的背景信息'
- en: '[Refreshing / Expiring](orm/session_state_management.html#session-expire) -
    background on attribute expiry  ### This Session’s transaction has been rolled
    back due to a previous exception during flush'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[刷新/过期](orm/session_state_management.html#session-expire) - 属性过期的背景信息  ###
    由于在刷新过程中发生了先前的异常，此会话的事务已被回滚'
- en: The flush process of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), described at [Flushing](orm/session_basics.html#session-flushing),
    will roll back the database transaction if an error is encountered, in order to
    maintain internal consistency. However, once this occurs, the session’s transaction
    is now “inactive” and must be explicitly rolled back by the calling application,
    in the same way that it would otherwise need to be explicitly committed if a failure
    had not occurred.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的刷新过程，描述在[刷新](orm/session_basics.html#session-flushing)中，如果遇到错误，将回滚数据库事务，以保持内部一致性。然而，一旦发生这种情况，会话的事务现在是“不活动的”，必须由调用应用程序显式回滚，就像如果没有发生故障，否则需要显式提交一样。'
- en: 'This is a common error when using the ORM and typically applies to an application
    that doesn’t yet have correct “framing” around its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") operations. Further detail is described in the FAQ at
    [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](faq/sessions.html#faq-session-rollback).  ### For
    relationship <relationship>, delete-orphan cascade is normally configured only
    on the “one” side of a one-to-many relationship, and not on the “many” side of
    a many-to-one or many-to-many relationship.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ORM时，这是一个常见的错误，通常适用于尚未正确围绕其[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")操作进行“框架化”的应用程序。更多详细信息请参阅[常见问题解答](faq/sessions.html#faq-session-rollback)中的“由于刷新期间的先前异常，此会话的事务已被回滚。”或类似问题。###对于关系<relationship>，delete-orphan级联通常仅配置在一对多关系的“一”侧，而不是多对一或多对多关系的“多”侧。
- en: 'This error arises when the “delete-orphan” [cascade](orm/cascades.html#unitofwork-cascades)
    is set on a many-to-one or many-to-many relationship, such as:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当“delete-orphan”级联设置在多对一或多对多关系上时，会引发此错误，例如：
- en: '[PRE106]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Above, the “delete-orphan” setting on `B.a` indicates the intent that when every
    `B` object that refers to a particular `A` is deleted, that the `A` should then
    be deleted as well. That is, it expresses that the “orphan” which is being deleted
    would be an `A` object, and it becomes an “orphan” when every `B` that refers
    to it is deleted.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的“delete-orphan”设置在`B.a`上表示的意图是，当每个引用特定`A`的`B`对象被删除时，那么`A`也应该被删除。也就是说，它表达了正在被删除的“孤立”将是一个`A`对象，当每个引用它的`B`都被删除时，它变成了“孤立”。
- en: The “delete-orphan” cascade model does not support this functionality. The “orphan”
    consideration is only made in terms of the deletion of a single object which would
    then refer to zero or more objects that are now “orphaned” by this single deletion,
    which would result in those objects being deleted as well. In other words, it
    is designed only to track the creation of “orphans” based on the removal of one
    and only one “parent” object per orphan, which is the natural case in a one-to-many
    relationship where a deletion of the object on the “one” side results in the subsequent
    deletion of the related items on the “many” side.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: “delete-orphan”级联模型不支持此功能。只有在单个对象被删除的情况下才考虑“孤立”问题，这个对象随后会引用零个或多个现在由此单个删除而“孤立”的对象，这将导致这些对象也被删除。换句话说，它只设计用于跟踪基于“父”对象的单个删除而创建“孤立”对象的情况，这是一个自然的情况，即一对多关系中的一个对象的删除会导致“多”侧上的相关项目的后续删除。
- en: 'The above mapping in support of this functionality would instead place the
    cascade setting on the one-to-many side, which looks like:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此功能的上述映射将级联设置放置在一对多的一侧，如下所示：
- en: '[PRE107]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Where the intent is expressed that when an `A` is deleted, all of the `B` objects
    to which it refers are also deleted.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达意图时，即当删除一个`A`时，所有它所指向的`B`对象也被删除。
- en: 'The error message then goes on to suggest the usage of the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag. This flag may be used to enforce that a relationship
    which is capable of having many objects refer to a particular object will in fact
    have only **one** object referring to it at a time. It is used for legacy or other
    less ideal database schemas where the foreign key relationships suggest a “many”
    collection, however in practice only one object would actually refer to a given
    target object at at time. This uncommon scenario can be demonstrated in terms
    of the above example as follows:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息然后继续建议使用[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志。该标志可用于强制将能够有多个对象引用特定对象的关系实际上只有一个对象在某一时间引用它。它用于遗留或其他不太理想的数据库模式，在这些模式中，外键关系表明存在“多”集合，但实际上在任何时间只有一个对象会引用给定目标对象。可以通过上述示例来演示这种不常见的情况如下：
- en: '[PRE108]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The above configuration will then install a validator which will enforce that
    only one `B` may be associated with an `A` at at time, within the scope of the
    `B.a` relationship:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将安装一个验证器，该验证器将强制执行在`B.a`关系的范围内只能将一个`B`与一个`A`关联起来的规则：
- en: '[PRE109]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Note that this validator is of limited scope and will not prevent multiple
    “parents” from being created via the other direction. For example, it will not
    detect the same setting in terms of `A.bs`:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此验证器的范围有限，并且无法阻止通过其他方向创建多个“父”对象。例如，它不会检测到与`A.bs`相同的设置：
- en: '[PRE110]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'However, things will not go as expected later on, as the “delete-orphan” cascade
    will continue to work in terms of a **single** lead object, meaning if we delete
    **either** of the `B` objects, the `A` is deleted. The other `B` stays around,
    where the ORM will usually be smart enough to set the foreign key attribute to
    NULL, but this is usually not what’s desired:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，后续事情将不会如预期那样进行，因为“delete-orphan”级联将继续按照单个主要对象的术语工作，这意味着如果我们删除任一`B`对象，`A`将被删除。另一个`B`仍然存在，虽然ORM通常足够聪明以将外键属性设置为NULL，但这通常不是所期望的：
- en: '[PRE111]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: For all the above examples, similar logic applies to the calculus of a many-to-many
    relationship; if a many-to-many relationship sets single_parent=True on one side,
    that side can use the “delete-orphan” cascade, however this is very unlikely to
    be what someone actually wants as the point of a many-to-many relationship is
    so that there can be many objects referring to an object in either direction.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述所有示例，类似的逻辑适用于多对多关系的计算；如果多对多关系在一侧设置了single_parent=True，则该侧可以使用“delete-orphan”级联，但这几乎不可能是某人实际想要的，因为多对多关系的目的是可以有许多对象引用任一方向的对象。
- en: Overall, “delete-orphan” cascade is usually applied on the “one” side of a one-to-many
    relationship so that it deletes objects in the “many” side, and not the other
    way around.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，“delete-orphan”级联通常应用于一对多关系的“一”侧，以便删除“多”侧的对象，而不是相反。
- en: 'Changed in version 1.3.18: The text of the “delete-orphan” error message when
    used on a many-to-one or many-to-many relationship has been updated to be more
    descriptive.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.3.18 开始更改：当在一对多或多对多关系上使用“delete-orphan”时，错误消息的文本已更新为更具描述性。
- en: See also
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Cascades](orm/cascades.html#unitofwork-cascades)'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '[级联](orm/cascades.html#unitofwork-cascades)'
- en: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
- en: '[Instance <instance> is already associated with an instance of <instance> via
    its <attribute> attribute, and is only allowed a single parent.](#error-bbf1)  ###
    Instance <instance> is already associated with an instance of <instance> via its
    <attribute> attribute, and is only allowed a single parent.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[实例 <instance> 已通过其 <attribute> 属性与实例 <instance> 关联，且仅允许有一个父实例。](#error-bbf1)  ###
    实例 <instance> 已通过其 <attribute> 属性与实例 <instance> 关联，且仅允许有一个父实例。'
- en: This error is emitted when the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag is used, and more than one object is assigned
    as the “parent” of an object at once.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志，并且一次分配多个对象作为对象的“父”时，会发出此错误。
- en: 'Given the following mapping:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下映射：
- en: '[PRE112]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The intent indicates that no more than a single `B` object may refer to a particular
    `A` object at once:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 意图指示一次最多只能有一个`B`对象引用特定的`A`对象：
- en: '[PRE113]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: When this error occurs unexpectedly, it is usually because the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag was applied in response to the error message
    described at [For relationship <relationship>, delete-orphan cascade is normally
    configured only on the “one” side of a one-to-many relationship, and not on the
    “many” side of a many-to-one or many-to-many relationship.](#error-bbf0), and
    the issue is in fact a misunderstanding of the “delete-orphan” cascade setting.
    See that message for details.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 当此错误意外发生时，通常是因为在响应于[对于关系 <relationship>，delete-orphan级联通常仅在一对多关系的“一”侧上配置，而不在多对一或多对多关系的“多”侧上配置。](#error-bbf0)描述的错误消息时，应用了[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志，而实际问题是对“delete-orphan”级联设置的误解。有关详细信息，请参阅该消息。
- en: See also
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](#error-bbf0)  ### relationship
    X will copy column Q to column P, which conflicts with relationship(s): ‘Y’'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于关系<relationship>，删除孤立节点级联通常仅在一对多关系的“一”侧上配置，并不在多对一或多对多关系的“多”侧上配置。](#error-bbf0)  ###
    关系 X 将列 Q 复制到列 P，与关系‘Y’存在冲突。'
- en: This warning refers to the case when two or more relationships will write data
    to the same columns on flush, but the ORM does not have any means of coordinating
    these relationships together. Depending on specifics, the solution may be that
    two relationships need to be referenced by one another using [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), or that one or more of the relationships should
    be configured with [`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") to prevent conflicting writes, or sometimes that
    the configuration is fully intentional and should configure [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") to silence each warning.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 此警告是指当两个或更多关系在 flush 时将数据写入相同列，但 ORM 没有任何协调这些关系的方式时发生的情况。根据具体情况，解决方案可能是两个关系需要使用[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")相互引用，或者一个或多个关系应该配置为[`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")以防止冲突写入，或者有时配置是完全有意为之的，并应该配置[`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship")来抑制每个警告。
- en: 'For the typical example that’s missing [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), given the following mapping:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型示例，缺少[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")的情况，给定以下映射：
- en: '[PRE114]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The above mapping will generate warnings:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将生成警告：
- en: '[PRE115]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The relationships `Child.parent` and `Parent.children` appear to be in conflict.
    The solution is to apply [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 关系`Child.parent`和`Parent.children`似乎存在冲突。解决方案是应用[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")：
- en: '[PRE116]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'For more customized relationships where an “overlap” situation may be intentional
    and cannot be resolved, the [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") parameter may specify the names of relationships
    for which the warning should not take effect. This typically occurs for two or
    more relationships to the same underlying table that include custom [`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") conditions that limit the related items in each
    case:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更加定制化的关系，在“重叠”情况可能是有意为之且无法解决时，[`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship")参数可以指定不应该触发警告的关系名称。这通常发生在两个或更多关系指向相同基础表的情况下，这些关系包括自定义的[`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")条件，限制了每种情况下的相关项：
- en: '[PRE117]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Above, the ORM will know that the overlap between `Parent.c1`, `Parent.c2`
    and `Child.parent` is intentional.  ### Object cannot be converted to ‘persistent’
    state, as this identity map is no longer valid.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，ORM 将知道`Parent.c1`、`Parent.c2`和`Child.parent`之间的重叠是有意为之的。### 对象无法转换为“持久”状态，因为此标识映射不再有效。
- en: New in version 1.4.26.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4.26 中新增。
- en: 'This message was added to accommodate for the case where a [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that would yield ORM objects is iterated after
    the originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has been closed, or otherwise had its [`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") method called. When a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") expunges all objects at once, the internal [identity
    map](glossary.html#term-identity-map) used by that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is replaced with a new one, and the original one discarded.
    An unconsumed and unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will internally maintain a reference to that
    now-discarded identity map. Therefore, when the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is consumed, the objects that would be yielded cannot
    be associated with that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This arrangement is by design as it is generally not
    recommended to iterate an unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object outside of the transactional context in which
    it was created:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息添加是为了适应以下情况：在原始[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")关闭后或者已调用其[`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")方法后，迭代将产生ORM对象的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象。当一个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一次性清除所有对象时，该[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用的内部[身份映射](glossary.html#term-identity-map)将被替换为一个新的，并且原始的将被丢弃。一个未消耗且未缓冲的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象将在内部保持对该现在已丢弃的身份映射的引用。因此，当消耗[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")时，将要产生的对象无法与该[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。这种安排是有意设计的，因为通常不建议在创建它的事务上下文之外迭代未缓冲的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象：
- en: '[PRE118]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The above situation typically will **not** occur when using the `asyncio` ORM
    extension, as when [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") returns a sync-style [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"), the results have been pre-buffered when the statement
    was executed. This is to allow secondary eager loaders to invoke without needing
    an additional `await` call.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`asyncio` ORM扩展时，通常不会发生上述情况，因为当[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")返回一个同步风格的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")时，结果在语句执行时已经被预先缓冲。这样做是为了允许次级的急切加载器在不需要额外的`await`调用的情况下调用。
- en: 'To pre-buffer results in the above situation using the regular [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in the same way that the `asyncio` extension does it,
    the `prebuffer_rows` execution option may be used as follows:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下使用常规[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")来预缓冲结果，可以像`asyncio`扩展一样使用`prebuffer_rows`执行选项，如下所示：
- en: '[PRE119]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Above, the selected ORM objects are fully generated within the `session_obj`
    block, associated with `session_obj` and buffered within the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object for iteration. Outside the block, `session_obj`
    is closed and expunges these ORM objects. Iterating the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will yield those ORM objects, however as their
    originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has expunged them, they will be delivered in the [detached](glossary.html#term-detached)
    state.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，所选的ORM对象完全在`session_obj`块中生成，与`session_obj`关联并在[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象中缓冲以进行迭代。在块外，`session_obj`被关闭并且清除这些ORM对象。迭代[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象将产生这些ORM对象，但是由于它们的来源[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")已将它们清除，它们将以[分离](glossary.html#term-detached)状态交付。
- en: Note
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The above reference to a “pre-buffered” vs. “un-buffered” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object refers to the process by which the ORM converts
    incoming raw database rows from the [DBAPI](glossary.html#term-DBAPI) into ORM
    objects. It does not imply whether or not the underlying `cursor` object itself,
    which represents pending results from the DBAPI, is itself buffered or unbuffered,
    as this is essentially a lower layer of buffering. For background on buffering
    of the `cursor` results itself, see the section [Using Server Side Cursors (a.k.a.
    stream results)](core/connections.html#engine-stream-results).  ### Type annotation
    can’t be interpreted for Annotated Declarative Table form'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '上面提到的 “预缓冲” vs. “非缓冲” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象是指 ORM 将来自 [DBAPI](glossary.html#term-DBAPI) 的传入原始数据库行转换为
    ORM 对象的过程。它不意味着底层的 `cursor` 对象本身，它表示来自 DBAPI 的待处理结果，是缓冲的还是非缓冲的，因为这实际上是一个更低层的缓冲。有关缓冲
    `cursor` 结果本身的背景，请参阅 [使用服务器端游标（也称为流式结果）](core/connections.html#engine-stream-results)
    部分。 ### 无法解释注解式声明表形式的类型注解'
- en: SQLAlchemy 2.0 introduces a new [Annotated Declarative Table](orm/declarative_tables.html#orm-declarative-mapped-column)
    declarative system which derives ORM mapped attribute information from [**PEP
    484**](https://peps.python.org/pep-0484/) annotations within class definitions
    at runtime. A requirement of this form is that all ORM annotations must make use
    of a generic container called [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to be properly annotated. Legacy SQLAlchemy mappings
    which include explicit [**PEP 484**](https://peps.python.org/pep-0484/) typing
    annotations, such as those which use the [legacy Mypy extension](orm/extensions/mypy.html)
    for typing support, may include directives such as those for [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that don’t include this generic.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 引入了一种新的[注解式声明表](orm/declarative_tables.html#orm-declarative-mapped-column)声明系统，它从类定义中的
    [**PEP 484**](https://peps.python.org/pep-0484/) 注解在运行时派生 ORM 映射属性信息。这种形式的要求是，所有的
    ORM 注解都必须使用一个称为 [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    的通用容器才能正确注解。包括显式 [**PEP 484**](https://peps.python.org/pep-0484/) 类型注解的传统 SQLAlchemy
    映射，例如使用 [旧版 Mypy 扩展](orm/extensions/mypy.html) 进行类型支持的映射，可能包含诸如 [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 之类的指令，这些指令不包括这个通用容器。
- en: To resolve, the classes may be marked with the `__allow_unmapped__` boolean
    attribute until they can be fully migrated to the 2.0 syntax. See the migration
    notes at [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed
    ORM models](changelog/migration_20.html#migration-20-step-six) for an example.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此问题，可以在类中添加 `__allow_unmapped__` 布尔属性，直到它们可以完全迁移到 2.0 语法。参见 [迁移到 2.0 步骤六
    - 为明确定义的 ORM 模型添加 __allow_unmapped__](changelog/migration_20.html#migration-20-step-six)
    的迁移说明中的示例。
- en: See also
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](changelog/migration_20.html#migration-20-step-six) - in the [SQLAlchemy
    2.0 - Major Migration Guide](changelog/migration_20.html) document  ### When transforming
    <cls> to a dataclass, attribute(s) originate from superclass <cls> which is not
    a dataclass.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移到 2.0 步骤六 - 为明确定义的 ORM 模型添加 __allow_unmapped__](changelog/migration_20.html#migration-20-step-six)
    - 在 [SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) 文档中 ### 当将 <cls> 转换为数据类时，属性(s)
    来自不是数据类的超类 <cls>。'
- en: 'This warning occurs when using the SQLAlchemy ORM Mapped Dataclasses feature
    described at [Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    in conjunction with any mixin class or abstract base that is not itself declared
    as a dataclass, such as in the example below:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用在 [声明式数据类映射](orm/dataclasses.html#orm-declarative-native-dataclasses) 中描述的
    SQLAlchemy ORM 映射数据类功能与任何未本身声明为数据类的 mixin 类或抽象基类一起使用时（例如下面的示例）会出现此警告：
- en: '[PRE120]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Above, since `Mixin` does not itself extend from [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), the following warning is generated:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Mixin` 本身不扩展自 [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")，因此会生成以下警告：
- en: '[PRE121]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The fix is to add [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") to the signature of `Mixin` as well:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是在 `Mixin` 的签名中也添加 [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")：
- en: '[PRE122]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Python’s [**PEP 681**](https://peps.python.org/pep-0681/) specification does
    not accommodate for attributes declared on superclasses of dataclasses that are
    not themselves dataclasses; per the behavior of Python dataclasses, such fields
    are ignored, as in the following example:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 [**PEP 681**](https://peps.python.org/pep-0681/) 规范不适用于声明在不是 dataclasses
    的 dataclasses 超类上的属性；根据 Python dataclasses 的行为，这样的字段将被忽略，如以下示例所示：
- en: '[PRE123]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Above, the `User` class will not include `create_user` in its constructor nor
    will it attempt to interpret `update_user` as a dataclass attribute. This is because
    `Mixin` is not a dataclass.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `User` 类将不会在其构造函数中包含 `create_user`，也不会尝试将 `update_user` 解释为 dataclass 属性。这是因为
    `Mixin` 不是一个 dataclass。
- en: 'SQLAlchemy’s dataclasses feature within the 2.0 series does not honor this
    behavior correctly; instead, attributes on non-dataclass mixins and superclasses
    are treated as part of the final dataclass configuration. However type checkers
    such as Pyright and Mypy will not consider these fields as part of the dataclass
    constructor as they are to be ignored per [**PEP 681**](https://peps.python.org/pep-0681/).
    Since their presence is ambiguous otherwise, SQLAlchemy 2.1 will require that
    mixin classes which have SQLAlchemy mapped attributes within a dataclass hierarchy
    have to themselves be dataclasses.  ### Python dataclasses error encountered when
    creating dataclass for <classname>'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQLAlchemy 2.0 系列中的 dataclasses 功能未正确遵守此行为；相反，非 dataclass 混合类和超类上的属性被视为最终 dataclass
    配置的一部分。然而，像 Pyright 和 Mypy 这样的类型检查器不会将这些字段视为 dataclass 构造函数的一部分，因为根据 [**PEP 681**](https://peps.python.org/pep-0681/)，它们应该被忽略。由于否则存在歧义，因此
    SQLAlchemy 2.1 将要求在 dataclass 层次结构中具有 SQLAlchemy 映射属性的混合类本身必须是 dataclasses。  ###
    创建 <classname> 的 dataclass 时遇到的 Python dataclasses 错误'
- en: When using the [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin class or [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator, SQLAlchemy makes use
    of the actual [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    module that’s in the Python standard library in order to apply dataclass behaviors
    to the target class. This API has its own error scenarios, most of which involve
    the construction of an `__init__()` method on the user defined class; the order
    of attributes declared on the class, as well as [on superclasses](https://docs.python.org/3/library/dataclasses.html#inheritance),
    determines how the `__init__()` method will be constructed and there are specific
    rules in how the attributes are organized as well as how they should make use
    of parameters such as `init=False`, `kw_only=True`, etc. **SQLAlchemy does not
    control or implement these rules**. Therefore, for errors of this nature, consult
    the [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) documentation,
    with special attention to the rules applied to [inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") 混合类或 [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") 装饰器时，SQLAlchemy 使用实际的 [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    模块，该模块位于 Python 标准库中，以将 dataclass 行为应用于目标类。此 API 具有自己的错误场景，其中大部分涉及在用户定义的类上构建 `__init__()`
    方法；在类上声明的属性的顺序，以及[在超类上](https://docs.python.org/3/library/dataclasses.html#inheritance)的顺序决定了
    `__init__()` 方法将如何构建，并且有特定规则规定了属性的组织方式以及它们应该如何使用参数，如 `init=False`，`kw_only=True`
    等。**SQLAlchemy 不控制或实现这些规则**。因此，对于这种类型的错误，请参考 [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    文档，特别注意应用于[继承](https://docs.python.org/3/library/dataclasses.html#inheritance)的规则。
- en: See also
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses documentation'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明性 Dataclass 映射](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses 文档'
- en: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    on the python.org website'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    在 python.org 网站上'
- en: '[inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance)
    - on the python.org website  ### per-row ORM Bulk Update by Primary Key requires
    that records contain primary key values'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '[继承](https://docs.python.org/3/library/dataclasses.html#inheritance) - 在 python.org
    网站上'
- en: 'This error occurs when making use of the [ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    feature without supplying primary key values in the given records, such as:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[ORM通过主键进行批量更新](orm/queryguide/dml.html#orm-queryguide-bulk-update)功能时，如果在给定的记录中没有提供主键值，则会出现此错误，例如：
- en: '[PRE124]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Above, the presence of a list of parameter dictionaries combined with usage
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to execute an ORM-enabled UPDATE statement will automatically make use of ORM
    Bulk Update by Primary Key, which expects parameter dictionaries to include primary
    key values, e.g.:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况下，参数字典列表的存在结合使用[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")执行ORM启用的UPDATE语句将自动使用ORM通过主键进行批量更新，该批量更新期望参数字典包括主键值，例如：
- en: '[PRE125]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To invoke the UPDATE statement without supplying per-record primary key values,
    use [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") to acquire the current [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), then invoke with that:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不提供每个记录的主键值的情况下调用UPDATE语句，请使用[`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection")来获取当前的[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，然后使用它调用：
- en: '[PRE126]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: See also
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM通过主键进行批量更新](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
- en: '[Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)  ###
    IllegalStateChangeError and concurrency exceptions'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '[禁用通过主键进行批量ORM更新以使用多个参数集的UPDATE语句](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)
    ### 非法状态更改错误和并发异常'
- en: SQLAlchemy 2.0 introduced a new system described at [Session raises proactively
    when illegal concurrent or reentrant access is detected](changelog/whatsnew_20.html#change-7433),
    which proactively detects concurrent methods being invoked on an individual instance
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object and by extension the [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") proxy object. These concurrent access calls
    typically, though not exclusively, would occur when a single instance of [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is shared among multiple concurrent threads without
    such access being synchronized, or similarly when a single instance of [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is shared among multiple concurrent tasks
    (such as when using a function like `asyncio.gather()`). These use patterns are
    not the appropriate use of these objects, where without the proactive warning
    system SQLAlchemy implements would still otherwise produce invalid state within
    the objects, producing hard-to-debug errors including driver-level errors on the
    database connections themselves.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0引入了一个新系统，描述在[检测到非法并发或重新进入访问时，会主动引发会话](changelog/whatsnew_20.html#change-7433)，该系统主动检测在[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的个别实例上以及通过扩展[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")代理对象调用并发方法时的情况。这些并发访问调用通常，但不仅仅，会发生在单个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")实例在多个并发线程之间共享时，而没有同步这样的访问，或者类似地，当单个[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")实例在多个并发任务之间共享时（例如使用`asyncio.gather()`函数）。这些使用模式不是这些对象的适当使用方式，如果没有SQLAlchemy实现的主动警告系统，否则仍然会在对象内部产生无效状态，从而产生难以调试的错误，包括在数据库连接本身上的驱动程序级错误。
- en: Instances of [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") are **mutable, stateful objects with no
    built-in synchronization** of method calls, and represent a **single, ongoing
    database transaction** upon a single database connection at a time for a particular
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction). A single database transaction is not an appropriate target
    for concurrent SQL commands; instead, an application that runs concurrent database
    operations should use concurrent transactions. For these objects then it follows
    that the appropriate pattern is [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") per thread, or [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") per task.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")的实例是**可变的、有状态的对象，没有内置的方法调用同步**，并且代表一次**单一的持续数据库事务**，一次只能在一个特定的[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")上绑定的数据库连接（请注意，这些对象都支持同时绑定到多个引擎，但在这种情况下，在事务范围内仍然只有一个连接在运行）。单个数据库事务不是并发
    SQL 命令的适当目标；相反，运行并发数据库操作的应用程序应该使用并发事务。因此，对于这些对象，适当的模式是每个线程一个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，或每个任务一个[`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")。'
- en: For more background on concurrency see the section [Is the Session thread-safe?
    Is AsyncSession safe to share in concurrent tasks?](orm/session_basics.html#session-faq-threadsafe).
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 有关并发性的更多背景信息，请参阅[会话是否线程安全？AsyncSession 是否安全可在并发任务中共享？](orm/session_basics.html#session-faq-threadsafe)部分。
- en: '### Parent instance <x> is not bound to a Session; (lazy load/deferred load/refresh/etc.)
    operation cannot proceed'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '### 父实例 <x> 未绑定到会话；（延迟加载/延迟加载/刷新等）操作无法继续'
- en: This is likely the most common error message when dealing with the ORM, and
    it occurs as a result of the nature of a technique the ORM makes wide use of known
    as [lazy loading](glossary.html#term-lazy-loading). Lazy loading is a common object-relational
    pattern whereby an object that’s persisted by the ORM maintains a proxy to the
    database itself, such that when various attributes upon the object are accessed,
    their value may be retrieved from the database *lazily*. The advantage to this
    approach is that objects can be retrieved from the database without having to
    load all of their attributes or related data at once, and instead only that data
    which is requested can be delivered at that time. The major disadvantage is basically
    a mirror image of the advantage, which is that if lots of objects are being loaded
    which are known to require a certain set of data in all cases, it is wasteful
    to load that additional data piecemeal.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能是处理 ORM 时最常见的错误消息，它是由 ORM 广泛使用的一种技术的性质导致的，这种技术被称为[延迟加载](glossary.html#term-lazy-loading)。延迟加载是一种常见的对象关系模式，其中由
    ORM 持久化的对象维护一个代理到数据库本身，因此当访问对象上的各种属性时，它们的值可能会被*惰性地*从数据库中检索出来。这种方法的优势在于可以从数据库中检索对象，而无需一次加载所有属性或相关数据，而只需在请求时传递所需的数据。主要的缺点基本上是优势的镜像，即如果正在加载许多需要在所有情况下都需要一组数据的对象，逐步加载额外数据是浪费的。
- en: Another caveat of lazy loading beyond the usual efficiency concerns is that
    in order for lazy loading to proceed, the object has to **remain associated with
    a Session** in order to be able to retrieve its state. This error message means
    that an object has become de-associated with its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and is being asked to lazy load data from the database.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟加载的另一个警告是，为了使延迟加载继续进行，对象必须**保持与会话关联**，以便能够检索其状态。此错误消息意味着一个对象已经与其[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")解除关联，并且正在被要求从数据库中延迟加载数据。
- en: The most common reason that objects become detached from their [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that the session itself was closed, typically via
    the [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method. The objects will then live on to be accessed further, very often within
    web applications where they are delivered to a server-side templating engine and
    are asked for further attributes which they cannot load.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 对象从其 [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    分离的最常见原因是会话本身被关闭，通常是通过 [`Session.close()`](orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法。然后，这些对象将继续存在，被进一步访问，往往是在 Web 应用程序中，在那里它们被传递给服务器端模板引擎，并要求获取它们无法加载的进一步属性。
- en: 'Mitigation of this error is via these techniques:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个错误的缓解是通过这些技术：
- en: '**Try not to have detached objects; don’t close the session prematurely** -
    Often, applications will close out a transaction before passing off related objects
    to some other system which then fails due to this error. Sometimes the transaction
    doesn’t need to be closed so soon; an example is the web application closes out
    the transaction before the view is rendered. This is often done in the name of
    “correctness”, but may be seen as a mis-application of “encapsulation”, as this
    term refers to code organization, not actual actions. The template that uses an
    ORM object is making use of the [proxy pattern](https://en.wikipedia.org/wiki/Proxy_pattern)
    which keeps database logic encapsulated from the caller. If the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be held open until the lifespan of the objects are
    done, this is the best approach.'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量避免分离对象；不要过早关闭会话** - 通常，应用程序会在将相关对象传递给其他系统之前关闭事务，但由于这个错误而失败。有时，事务不需要那么快关闭；一个例子是
    Web 应用在视图呈现之前关闭事务。这通常是以“正确性”的名义而完成的，但可能被视为对“封装”的错误应用，因为此术语指的是代码组织，而不是实际操作。使用 ORM
    对象的模板正在使用[代理模式](https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F)来保持数据库逻辑与调用者的封装。如果[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以保持打开状态，直到对象的生命周期结束，这是最佳方法。'
- en: '**Otherwise, load everything that’s needed up front** - It is very often impossible
    to keep the transaction open, especially in more complex applications that need
    to pass objects off to other systems that can’t run in the same context even though
    they’re in the same process. In this case, the application should prepare to deal
    with [detached](glossary.html#term-detached) objects, and should try to make appropriate
    use of [eager loading](glossary.html#term-eager-loading) to ensure that objects
    have what they need up front.'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否则，加载所有需要的内容** - 很多时候是不可能保持事务处于打开状态的，特别是在需要将对象传递给其他系统的更复杂的应用程序中，即使它们在同一个进程中也无法运行在相同的上下文中。在这种情况下，应用程序应准备处理[分离的](glossary.html#term-detached)对象，并应尽量适当地使用[急切加载](glossary.html#term-eager-loading)以确保对象从一开始就拥有所需内容。'
- en: '**And importantly, set expire_on_commit to False** - When using detached objects,
    the most common reason objects need to re-load data is because they were expired
    from the last call to [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"). This expiration should not be used when dealing
    with detached objects; so the [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter be set to `False`. By preventing the objects
    from becoming expired outside of the transaction, the data which was loaded will
    remain present and will not incur additional lazy loads when that data is accessed.'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**而且，重要的是，将 expire_on_commit 设置为 False** - 当使用分离对象时，对象需要重新加载数据的最常见原因是因为它们从上一次调用
    [`Session.commit()`](orm/session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    被标记为过期。在处理分离对象时不应使用此过期；因此应将 [`Session.expire_on_commit`](orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") 参数设置为`False`。通过防止对象在事务外部过期，已加载的数据将保持存在，并且在访问该数据时不会产生额外的延迟加载。'
- en: Note also that [`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method unconditionally expires all contents
    in the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and should also be avoided in non-error scenarios.
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法会无条件地使 [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的所有内容过期，因此在非错误情况下也应避免使用。'
- en: See also
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship Loading Techniques](orm/queryguide/relationships.html) - detailed
    documentation on eager loading and other relationship-oriented loading techniques'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[关系加载技术](orm/queryguide/relationships.html) - 关于急加载和其他面向关系的加载技术的详细文档'
- en: '[Committing](orm/session_basics.html#session-committing) - background on session
    commit'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[提交](orm/session_basics.html#session-committing) - 会话提交的背景介绍'
- en: '[Refreshing / Expiring](orm/session_state_management.html#session-expire) -
    background on attribute expiry'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[刷新/过期](orm/session_state_management.html#session-expire) - 属性过期的背景介绍'
- en: '### This Session’s transaction has been rolled back due to a previous exception
    during flush'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '### 由于刷新期间的先前异常，此会话的事务已回滚'
- en: The flush process of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), described at [Flushing](orm/session_basics.html#session-flushing),
    will roll back the database transaction if an error is encountered, in order to
    maintain internal consistency. However, once this occurs, the session’s transaction
    is now “inactive” and must be explicitly rolled back by the calling application,
    in the same way that it would otherwise need to be explicitly committed if a failure
    had not occurred.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的刷新过程在遇到错误时会回滚数据库事务，以保持内部一致性。然而，一旦发生这种情况，会话的事务现在处于 “不活动” 状态，并且必须由调用应用程序显式地回滚，就像如果没有发生故障时需要显式提交一样。'
- en: This is a common error when using the ORM and typically applies to an application
    that doesn’t yet have correct “framing” around its [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") operations. Further detail is described in the FAQ at
    [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM 时，这是一个常见的错误，通常适用于尚未在其 [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 操作周围正确设置 “框架”的应用程序。更多详细信息请参阅[“由于刷新期间的先前异常，此会话的事务已回滚。”（或类似内容）的常见问题](faq/sessions.html#faq-session-rollback)。
- en: '### For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对于关系 <relationship>，只有在一对多关系的“一”端才通常配置了 delete-orphan 级联，而不是在多对一或多对多关系的“多”端。'
- en: 'This error arises when the “delete-orphan” [cascade](orm/cascades.html#unitofwork-cascades)
    is set on a many-to-one or many-to-many relationship, such as:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多对一或多对多关系上设置了 “delete-orphan” [级联](orm/cascades.html#unitofwork-cascades)
    时会出现此错误，例如：
- en: '[PRE127]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Above, the “delete-orphan” setting on `B.a` indicates the intent that when every
    `B` object that refers to a particular `A` is deleted, that the `A` should then
    be deleted as well. That is, it expresses that the “orphan” which is being deleted
    would be an `A` object, and it becomes an “orphan” when every `B` that refers
    to it is deleted.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `B.a` 上的 “delete-orphan” 设置表明了这样一个意图，即当指向特定 `A` 的每个 `B` 对象都被删除时，该 `A` 也应该被删除。也就是说，它表达了被删除的
    “孤立” 对象将是一个 `A` 对象，并且当指向它的每个 `B` 都被删除时，它就成为了一个 “孤立” 对象。
- en: The “delete-orphan” cascade model does not support this functionality. The “orphan”
    consideration is only made in terms of the deletion of a single object which would
    then refer to zero or more objects that are now “orphaned” by this single deletion,
    which would result in those objects being deleted as well. In other words, it
    is designed only to track the creation of “orphans” based on the removal of one
    and only one “parent” object per orphan, which is the natural case in a one-to-many
    relationship where a deletion of the object on the “one” side results in the subsequent
    deletion of the related items on the “many” side.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: “delete-orphan”级联模型不支持此功能。 “孤儿”考虑仅在单个对象的删除方面进行，然后引用零个或多个由此单个删除“孤儿”对象的对象，这将导致这些对象也被删除。换句话说，它仅设计为基于删除每个孤儿的一个且仅一个“父”对象的创建，“父”对象在一对多关系中的自然情况下导致“多”侧的相关项目随后被删除。
- en: 'The above mapping in support of this functionality would instead place the
    cascade setting on the one-to-many side, which looks like:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 为支持此功能的上述映射将在一对多关系的一侧放置级联设置，如下所示：
- en: '[PRE128]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Where the intent is expressed that when an `A` is deleted, all of the `B` objects
    to which it refers are also deleted.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达出当删除一个`A`时，所有它所引用的`B`对象也将被删除的意图时。
- en: 'The error message then goes on to suggest the usage of the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag. This flag may be used to enforce that a relationship
    which is capable of having many objects refer to a particular object will in fact
    have only **one** object referring to it at a time. It is used for legacy or other
    less ideal database schemas where the foreign key relationships suggest a “many”
    collection, however in practice only one object would actually refer to a given
    target object at at time. This uncommon scenario can be demonstrated in terms
    of the above example as follows:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息随后建议使用[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志。此标志可用于强制执行一个关系，该关系可以让多个对象引用特定对象，但实际上一次只能有**一个**对象引用它。它用于传统或其他不太理想的数据库模式，其中外键关系暗示“多”集合，但实际上只有一个对象会引用给定目标对象。这种不常见的情况可以如上例所示进行演示：
- en: '[PRE129]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The above configuration will then install a validator which will enforce that
    only one `B` may be associated with an `A` at at time, within the scope of the
    `B.a` relationship:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将安装一个验证器，该验证器将强制执行在`B.a`关系的范围内一次只能关联一个`B`与一个`A`：
- en: '[PRE130]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Note that this validator is of limited scope and will not prevent multiple
    “parents” from being created via the other direction. For example, it will not
    detect the same setting in terms of `A.bs`:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此验证器的范围有限，并不会阻止通过其他方向创建多个“父级”。例如，它不会检测到关于`A.bs`的相同设置：
- en: '[PRE131]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'However, things will not go as expected later on, as the “delete-orphan” cascade
    will continue to work in terms of a **single** lead object, meaning if we delete
    **either** of the `B` objects, the `A` is deleted. The other `B` stays around,
    where the ORM will usually be smart enough to set the foreign key attribute to
    NULL, but this is usually not what’s desired:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情不会按预期进行，因为“delete-orphan”级联将继续按照**单个**主要对象的方式工作，这意味着如果我们删除其中一个`B`对象，`A`将被删除。另一个`B`仍然存在，ORM通常会足够聪明地将外键属性设置为NULL，但这通常不是期望的结果：
- en: '[PRE132]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: For all the above examples, similar logic applies to the calculus of a many-to-many
    relationship; if a many-to-many relationship sets single_parent=True on one side,
    that side can use the “delete-orphan” cascade, however this is very unlikely to
    be what someone actually wants as the point of a many-to-many relationship is
    so that there can be many objects referring to an object in either direction.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述所有示例，类似的逻辑也适用于多对多关系的计算；如果多对多关系在一侧设置了single_parent=True，则该侧可以使用“delete-orphan”级联，但这很不可能是某人实际想要的，因为多对多关系的目的是让可以有许多对象相互引用。
- en: Overall, “delete-orphan” cascade is usually applied on the “one” side of a one-to-many
    relationship so that it deletes objects in the “many” side, and not the other
    way around.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，“delete-orphan”级联通常应用于一对多关系的“一”侧，以便删除“多”侧的对象，而不是相反。
- en: 'Changed in version 1.3.18: The text of the “delete-orphan” error message when
    used on a many-to-one or many-to-many relationship has been updated to be more
    descriptive.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.18版本中的更改：当在多对一或多对多关系上使用“delete-orphan”时，错误消息的文本已更新为更详细的描述。
- en: See also
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Cascades](orm/cascades.html#unitofwork-cascades)'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[级联](orm/cascades.html#unitofwork-cascades)'
- en: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](orm/cascades.html#cascade-delete-orphan)'
- en: '[Instance <instance> is already associated with an instance of <instance> via
    its <attribute> attribute, and is only allowed a single parent.](#error-bbf1)'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[实例<instance>已通过其<attribute>属性与<instance>的实例关联，并且只允许一个父级。](#error-bbf1)'
- en: '### Instance <instance> is already associated with an instance of <instance>
    via its <attribute> attribute, and is only allowed a single parent.'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '### 实例<instance>已通过其<attribute>属性与<instance>的实例关联，并且只允许一个父级。'
- en: This error is emitted when the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag is used, and more than one object is assigned
    as the “parent” of an object at once.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志，并且同时为一个对象分配了多个“父级”对象时，会发出此错误。
- en: 'Given the following mapping:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下映射：
- en: '[PRE133]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The intent indicates that no more than a single `B` object may refer to a particular
    `A` object at once:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 意图指示不超过一个`B`对象可以同时引用特定的`A`对象：
- en: '[PRE134]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: When this error occurs unexpectedly, it is usually because the [`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") flag was applied in response to the error message
    described at [For relationship <relationship>, delete-orphan cascade is normally
    configured only on the “one” side of a one-to-many relationship, and not on the
    “many” side of a many-to-one or many-to-many relationship.](#error-bbf0), and
    the issue is in fact a misunderstanding of the “delete-orphan” cascade setting.
    See that message for details.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种错误出现时，通常是因为在[错误消息](#error-bbf0)中描述的错误消息响应中应用了[`relationship.single_parent`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")标志，实际上问题是对“delete-orphan”级联设置的误解。请参阅该消息以了解详情。
- en: See also
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](#error-bbf0)'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于关系<relationship>，delete-orphan级联通常仅在一对多关系的“one”端上配置，并且不在多对一或多对多关系的“many”端上配置。](#error-bbf0)'
- en: '### relationship X will copy column Q to column P, which conflicts with relationship(s):
    ‘Y’'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关系X将列Q复制到列P，与关系‘Y’冲突'
- en: This warning refers to the case when two or more relationships will write data
    to the same columns on flush, but the ORM does not have any means of coordinating
    these relationships together. Depending on specifics, the solution may be that
    two relationships need to be referenced by one another using [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), or that one or more of the relationships should
    be configured with [`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") to prevent conflicting writes, or sometimes that
    the configuration is fully intentional and should configure [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") to silence each warning.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 此警告是指当两个或更多关系将数据写入相同的列时，但ORM没有任何协调这些关系的方式时。根据具体情况，解决方案可能是两个关系需要彼此引用，使用[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")，或者一个或多个关系应该配置为[`relationship.viewonly`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")以防止冲突的写入，有时配置是完全有意的，应该配置[`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship")以使每个警告静音。
- en: 'For the typical example that’s missing [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"), given the following mapping:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的缺少[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")的示例，给定以下映射：
- en: '[PRE135]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The above mapping will generate warnings:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将生成警告：
- en: '[PRE136]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The relationships `Child.parent` and `Parent.children` appear to be in conflict.
    The solution is to apply [`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship"):'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 关系`Child.parent`和`Parent.children`似乎存在冲突。解决方案是应用[`relationship.back_populates`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")：
- en: '[PRE137]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'For more customized relationships where an “overlap” situation may be intentional
    and cannot be resolved, the [`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship") parameter may specify the names of relationships
    for which the warning should not take effect. This typically occurs for two or
    more relationships to the same underlying table that include custom [`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") conditions that limit the related items in each
    case:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更自定义的关系，其中“重叠”情况可能是有意的并且无法解决的情况，[`relationship.overlaps`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.overlaps
    "sqlalchemy.orm.relationship")参数可以指定不应触发警告的关系名称。这通常发生在对同一基础表的两个或多个关系中，这些关系包括限制每种情况中相关项的自定义[`relationship.primaryjoin`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")条件：
- en: '[PRE138]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Above, the ORM will know that the overlap between `Parent.c1`, `Parent.c2` and
    `Child.parent` is intentional.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，ORM将知道`Parent.c1`、`Parent.c2`和`Child.parent`之间的重叠是有意的。
- en: '### Object cannot be converted to ‘persistent’ state, as this identity map
    is no longer valid.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对象无法转换为‘持久’状态，因为此标识映射不再有效。'
- en: New in version 1.4.26.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.4.26新增。
- en: 'This message was added to accommodate for the case where a [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object that would yield ORM objects is iterated after
    the originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has been closed, or otherwise had its [`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") method called. When a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") expunges all objects at once, the internal [identity
    map](glossary.html#term-identity-map) used by that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is replaced with a new one, and the original one discarded.
    An unconsumed and unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will internally maintain a reference to that
    now-discarded identity map. Therefore, when the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") is consumed, the objects that would be yielded cannot
    be associated with that [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This arrangement is by design as it is generally not
    recommended to iterate an unbuffered [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object outside of the transactional context in which
    it was created:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此消息是为了适应以下情况：当迭代一个在原始[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关闭后或在其上调用[`Session.expunge_all()`](orm/session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")方法后仍会产生ORM对象的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象时。当一个[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一次性删除所有对象时，该[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用的内部[标识映射](glossary.html#term-identity-map)将被替换为新的，并且原始映射将被丢弃。一个未使用且未缓冲的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象将在内部维护对该现在被丢弃的标识映射的引用。因此，当消耗了[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")时，将要产生的对象无法与该[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联。这种安排是有意设计的，因为通常不建议在创建它的事务上下文之外迭代未缓冲的[`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象：
- en: '[PRE139]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The above situation typically will **not** occur when using the `asyncio` ORM
    extension, as when [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") returns a sync-style [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result"), the results have been pre-buffered when the statement
    was executed. This is to allow secondary eager loaders to invoke without needing
    an additional `await` call.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `asyncio` ORM 扩展时，通常不会出现上述情况，因为当 [`AsyncSession`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") 返回一个同步风格的 [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 时，结果在语句执行时已经被预先缓冲。这样做是为了允许次级急切加载器在不需要额外的 `await` 调用的情况下调用。
- en: 'To pre-buffer results in the above situation using the regular [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in the same way that the `asyncio` extension does it,
    the `prebuffer_rows` execution option may be used as follows:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在上述情况下像 `asyncio` 扩展一样预先缓冲结果，可以使用 `prebuffer_rows` 执行选项如下所示：
- en: '[PRE140]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Above, the selected ORM objects are fully generated within the `session_obj`
    block, associated with `session_obj` and buffered within the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object for iteration. Outside the block, `session_obj`
    is closed and expunges these ORM objects. Iterating the [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object will yield those ORM objects, however as their
    originating [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has expunged them, they will be delivered in the [detached](glossary.html#term-detached)
    state.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，所选的 ORM 对象完全在 `session_obj` 块内生成，与 `session_obj` 关联并在 [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象内缓冲以供迭代。在块外，`session_obj` 被关闭并清除这些 ORM 对象。迭代 [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象将产生这些 ORM 对象，但是由于它们的来源 [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 已将它们清除，它们将以 [分离](glossary.html#term-detached) 状态传递。
- en: Note
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The above reference to a “pre-buffered” vs. “un-buffered” [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object refers to the process by which the ORM converts
    incoming raw database rows from the [DBAPI](glossary.html#term-DBAPI) into ORM
    objects. It does not imply whether or not the underlying `cursor` object itself,
    which represents pending results from the DBAPI, is itself buffered or unbuffered,
    as this is essentially a lower layer of buffering. For background on buffering
    of the `cursor` results itself, see the section [Using Server Side Cursors (a.k.a.
    stream results)](core/connections.html#engine-stream-results).
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提到的“预缓冲”与“未缓冲”的 [`Result`](core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象指的是 ORM 将传入的原始数据库行从 [DBAPI](glossary.html#term-DBAPI)
    转换为 ORM 对象的过程。这并不意味着底层的 `cursor` 对象本身，它代表了来自 DBAPI 的待处理结果，是缓冲的还是非缓冲的，因为这本质上是一个更低层次的缓冲。有关
    `cursor` 结果本身的缓冲背景，请参阅 [使用服务器端游标 (即流式结果)](core/connections.html#engine-stream-results)
    部分。
- en: '### Type annotation can’t be interpreted for Annotated Declarative Table form'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '### 无法解释注释的声明式表格形式的类型注释'
- en: SQLAlchemy 2.0 introduces a new [Annotated Declarative Table](orm/declarative_tables.html#orm-declarative-mapped-column)
    declarative system which derives ORM mapped attribute information from [**PEP
    484**](https://peps.python.org/pep-0484/) annotations within class definitions
    at runtime. A requirement of this form is that all ORM annotations must make use
    of a generic container called [`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to be properly annotated. Legacy SQLAlchemy mappings
    which include explicit [**PEP 484**](https://peps.python.org/pep-0484/) typing
    annotations, such as those which use the [legacy Mypy extension](orm/extensions/mypy.html)
    for typing support, may include directives such as those for [`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that don’t include this generic.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 引入了一个新的 [注释式声明表](orm/declarative_tables.html#orm-declarative-mapped-column)
    声明系统，它会在运行时从类定义中的 [**PEP 484**](https://peps.python.org/pep-0484/) 注释中派生 ORM 映射属性信息。这种形式的要求是，所有
    ORM 注释都必须使用一个名为[`Mapped`](orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的通用容器才能正确注释。包含显式
    [**PEP 484**](https://peps.python.org/pep-0484/) 类型注释的传统 SQLAlchemy 映射，例如那些使用
    [传统 Mypy 扩展](orm/extensions/mypy.html) 进行类型支持的映射，可能包含不包括此通用容器的诸如[`relationship()`](orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")之类的指令。
- en: To resolve, the classes may be marked with the `__allow_unmapped__` boolean
    attribute until they can be fully migrated to the 2.0 syntax. See the migration
    notes at [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed
    ORM models](changelog/migration_20.html#migration-20-step-six) for an example.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此问题，可以将类标记为`__allow_unmapped__`布尔属性，直到它们可以完全迁移到 2.0 语法。请参阅[迁移到 2.0 第六步 -
    向显式类型化的 ORM 模型添加 __allow_unmapped__](changelog/migration_20.html#migration-20-step-six)的迁移说明以获取示例。
- en: See also
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](changelog/migration_20.html#migration-20-step-six) - in the [SQLAlchemy
    2.0 - Major Migration Guide](changelog/migration_20.html) document'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移到 2.0 第六步 - 向显式类型化的 ORM 模型添加 __allow_unmapped__](changelog/migration_20.html#migration-20-step-six)
    - 在 [SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) 文档中'
- en: '### When transforming <cls> to a dataclass, attribute(s) originate from superclass
    <cls> which is not a dataclass.'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当将<cls>转换为数据类时，属性源自于不是数据类的超类<cls>。'
- en: 'This warning occurs when using the SQLAlchemy ORM Mapped Dataclasses feature
    described at [Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    in conjunction with any mixin class or abstract base that is not itself declared
    as a dataclass, such as in the example below:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '当与任何不是自身声明为数据类的混入类或抽象基类一起使用 SQLAlchemy ORM 映射数据类功能时，会出现此警告，例如下面的示例:'
- en: '[PRE141]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Above, since `Mixin` does not itself extend from [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"), the following warning is generated:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述情况下，由于`Mixin`本身不是扩展自[`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")，因此会生成以下警告:'
- en: '[PRE142]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The fix is to add [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") to the signature of `Mixin` as well:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '修复方法是在`Mixin`的签名中也添加[`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass"):'
- en: '[PRE143]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Python’s [**PEP 681**](https://peps.python.org/pep-0681/) specification does
    not accommodate for attributes declared on superclasses of dataclasses that are
    not themselves dataclasses; per the behavior of Python dataclasses, such fields
    are ignored, as in the following example:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python 的 [**PEP 681**](https://peps.python.org/pep-0681/) 规范不包含不是数据类本身的数据类超类上声明的属性;
    根据 Python 数据类的行为，这些字段会被忽略，如下例所示:'
- en: '[PRE144]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Above, the `User` class will not include `create_user` in its constructor nor
    will it attempt to interpret `update_user` as a dataclass attribute. This is because
    `Mixin` is not a dataclass.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`User`类将不会在其构造函数中包含`create_user`，也不会尝试将`update_user`解释为数据类属性。这是因为`Mixin`不是数据类。
- en: SQLAlchemy’s dataclasses feature within the 2.0 series does not honor this behavior
    correctly; instead, attributes on non-dataclass mixins and superclasses are treated
    as part of the final dataclass configuration. However type checkers such as Pyright
    and Mypy will not consider these fields as part of the dataclass constructor as
    they are to be ignored per [**PEP 681**](https://peps.python.org/pep-0681/). Since
    their presence is ambiguous otherwise, SQLAlchemy 2.1 will require that mixin
    classes which have SQLAlchemy mapped attributes within a dataclass hierarchy have
    to themselves be dataclasses.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0系列中的数据类功能未正确遵守此行为；相反，非数据类混合类和超类上的属性被视为最终数据类配置的一部分。但是像Pyright和Mypy这样的类型检查器不会将这些字段视为数据类构造函数的一部分，因为根据[**PEP
    681**](https://peps.python.org/pep-0681/)，它们应该被忽略。由于否则它们的存在是模棱两可的，因此SQLAlchemy
    2.1将要求在数据类层次结构中具有SQLAlchemy映射属性的混合类本身必须是数据类。
- en: '### Python dataclasses error encountered when creating dataclass for <classname>'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '### 创建<dataclass>类时遇到的Python数据类错误'
- en: When using the [`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin class or [`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass") decorator, SQLAlchemy makes use
    of the actual [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
    module that’s in the Python standard library in order to apply dataclass behaviors
    to the target class. This API has its own error scenarios, most of which involve
    the construction of an `__init__()` method on the user defined class; the order
    of attributes declared on the class, as well as [on superclasses](https://docs.python.org/3/library/dataclasses.html#inheritance),
    determines how the `__init__()` method will be constructed and there are specific
    rules in how the attributes are organized as well as how they should make use
    of parameters such as `init=False`, `kw_only=True`, etc. **SQLAlchemy does not
    control or implement these rules**. Therefore, for errors of this nature, consult
    the [Python dataclasses](https://docs.python.org/3/library/dataclasses.html) documentation,
    with special attention to the rules applied to [inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`MappedAsDataclass`](orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass")混合类或[`registry.mapped_as_dataclass()`](orm/mapping_api.html#sqlalchemy.orm.registry.mapped_as_dataclass
    "sqlalchemy.orm.registry.mapped_as_dataclass")装饰器时，SQLAlchemy利用Python标准库中实际的[Python数据类](https://docs.python.org/3/library/dataclasses.html)模块，以将数据类行为应用于目标类。此API具有自己的错误场景，其中大多数涉及在用户定义的类上构建`__init__()`方法；在类上声明的属性的顺序，以及[在超类上](https://docs.python.org/3/library/dataclasses.html#inheritance)声明的属性，决定了`__init__()`方法将如何构建，并且有特定规则规定了属性的组织方式以及它们应如何使用参数，如`init=False`，`kw_only=True`等。**SQLAlchemy不控制或实现这些规则**。因此，对于这种类型的错误，请参阅[Python数据类](https://docs.python.org/3/library/dataclasses.html)文档，特别注意应用于[继承](https://docs.python.org/3/library/dataclasses.html#inheritance)的规则。
- en: See also
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Dataclass Mapping](orm/dataclasses.html#orm-declarative-native-dataclasses)
    - SQLAlchemy dataclasses documentation'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明式数据类映射](orm/dataclasses.html#orm-declarative-native-dataclasses) - SQLAlchemy数据类文档'
- en: '[Python dataclasses](https://docs.python.org/3/library/dataclasses.html) -
    on the python.org website'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python数据类](https://docs.python.org/3/library/dataclasses.html) - 在python.org网站上'
- en: '[inheritance](https://docs.python.org/3/library/dataclasses.html#inheritance)
    - on the python.org website'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '[继承](https://docs.python.org/3/library/dataclasses.html#inheritance) - 在python.org网站上'
- en: '### per-row ORM Bulk Update by Primary Key requires that records contain primary
    key values'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '### 按主键进行每行ORM批量更新要求记录包含主键值'
- en: 'This error occurs when making use of the [ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)
    feature without supplying primary key values in the given records, such as:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当在给定记录中使用[ORM按主键批量更新](orm/queryguide/dml.html#orm-queryguide-bulk-update)功能而未提供主键值时，将出现此错误，例如：
- en: '[PRE145]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Above, the presence of a list of parameter dictionaries combined with usage
    of the [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to execute an ORM-enabled UPDATE statement will automatically make use of ORM
    Bulk Update by Primary Key, which expects parameter dictionaries to include primary
    key values, e.g.:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，将参数字典列表与使用[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")执行ORM启用的UPDATE语句结合使用将自动使用按主键进行ORM批量更新，该功能期望参数字典包含主键值，例如：
- en: '[PRE146]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'To invoke the UPDATE statement without supplying per-record primary key values,
    use [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") to acquire the current [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), then invoke with that:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在不提供每条记录主键值的情况下调用 UPDATE 语句，请使用 [`Session.connection()`](orm/session_api.html#sqlalchemy.orm.Session.connection
    "sqlalchemy.orm.Session.connection") 获取当前的 [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，然后使用它进行调用：
- en: '[PRE147]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: See also
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk UPDATE by Primary Key](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[按主键进行ORM批量更新](orm/queryguide/dml.html#orm-queryguide-bulk-update)'
- en: '[Disabling Bulk ORM Update by Primary Key for an UPDATE statement with multiple
    parameter sets](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '[禁用批量ORM按主键更新，以及包含多个参数集的UPDATE语句](orm/queryguide/dml.html#orm-queryguide-bulk-update-disabling)'
- en: AsyncIO Exceptions
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AsyncIO 异常
- en: '### AwaitRequired'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '### 等待所需'
- en: The SQLAlchemy async mode requires an async driver to be used to connect to
    the db. This error is usually raised when trying to use the async version of SQLAlchemy
    with a non compatible [DBAPI](glossary.html#term-DBAPI).
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 异步模式要求使用异步驱动程序连接到数据库。尝试使用不兼容的 [DBAPI](glossary.html#term-DBAPI) 的异步版本与
    SQLAlchemy 的异步版本一起使用时通常会引发此错误。
- en: See also
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Asynchronous I/O (asyncio)](orm/extensions/asyncio.html)  ### MissingGreenlet'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步 I/O (asyncio)](orm/extensions/asyncio.html)  ### 缺少 Greenlet'
- en: A call to the async [DBAPI](glossary.html#term-DBAPI) was initiated outside
    the greenlet spawn context usually setup by the SQLAlchemy AsyncIO proxy classes.
    Usually this error happens when an IO was attempted in an unexpected place, using
    a calling pattern that does not directly provide for use of the `await` keyword.
    When using the ORM this is nearly always due to the use of [lazy loading](glossary.html#term-lazy-loading),
    which is not directly supported under asyncio without additional steps and/or
    alternate loader patterns in order to use successfully.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有创建 SQLAlchemy AsyncIO 代理类设置的协程生成上下文之外启动异步 [DBAPI](glossary.html#term-DBAPI)
    调用时，通常会引发此错误。通常情况下，当在意外位置尝试进行 IO 操作时，使用了不直接提供 `await` 关键字的调用模式时会发生此错误。在使用 ORM
    时，几乎总是由于使用了[延迟加载](glossary.html#term-lazy-loading)，这在 asyncio 中不直接支持，需要采取额外步骤和/或替代加载器模式才能成功使用。
- en: See also
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Preventing Implicit IO when Using AsyncSession](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - covers most ORM scenarios where this problem can occur and how to mitigate,
    including specific patterns to use with lazy load scenarios.  ### No Inspection
    Available'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 AsyncSession 时防止隐式 IO](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - 涵盖了大多数可能发生此问题的 ORM 方案以及如何缓解这个问题，包括在懒加载情况下使用的特定模式。  ### 无可用检查'
- en: 'Using the [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function directly on an [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") object is not currently supported, as there
    is not yet an awaitable form of the [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object available. Instead, the object
    is used by acquiring it using the [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function in such a way that it refers to the underlying
    [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") attribute of the [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") object; the `Inspector` is then used
    in a “synchronous” calling style by using the [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") method along with a custom
    function that performs the desired operations:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 当前不支持直接在 [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 或 [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") 对象上直接使用 [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 函数，因为尚未提供 [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 对象的可等待形式。相反，该对象是通过使用 [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 函数获取的，以一种方式，使其引用 [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 对象的底层 [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") 属性；然后，通过使用 [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") 方法以及执行所需操作的自定义函数，以“同步”调用样式使用
    `Inspector`：
- en: '[PRE148]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: See also
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using the Inspector to inspect schema objects](orm/extensions/asyncio.html#asyncio-inspector)
    - additional examples of using [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") with the asyncio extension.  ### AwaitRequired'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Inspector 检查模式对象](orm/extensions/asyncio.html#asyncio-inspector) - 使用 asyncio
    扩展的 [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    的附加示例。### 必须等待'
- en: The SQLAlchemy async mode requires an async driver to be used to connect to
    the db. This error is usually raised when trying to use the async version of SQLAlchemy
    with a non compatible [DBAPI](glossary.html#term-DBAPI).
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的异步模式需要使用异步驱动程序连接到数据库。当尝试使用不兼容的[DBAPI](glossary.html#term-DBAPI)时，通常会引发此错误。
- en: See also
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Asynchronous I/O (asyncio)](orm/extensions/asyncio.html)'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步 I/O (asyncio)](orm/extensions/asyncio.html)'
- en: '### MissingGreenlet'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '### 缺少 Greenlet'
- en: A call to the async [DBAPI](glossary.html#term-DBAPI) was initiated outside
    the greenlet spawn context usually setup by the SQLAlchemy AsyncIO proxy classes.
    Usually this error happens when an IO was attempted in an unexpected place, using
    a calling pattern that does not directly provide for use of the `await` keyword.
    When using the ORM this is nearly always due to the use of [lazy loading](glossary.html#term-lazy-loading),
    which is not directly supported under asyncio without additional steps and/or
    alternate loader patterns in order to use successfully.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在由 SQLAlchemy AsyncIO 代理类设置的 greenlet spawn 上下文之外启动异步 [DBAPI](glossary.html#term-DBAPI)
    调用时会引发此错误。通常，当在意外位置尝试进行 IO 操作时，使用不直接提供 `await` 关键字的调用模式会发生此错误。在使用 ORM 时，这几乎总是由于使用
    [懒加载](glossary.html#term-lazy-loading)，在 asyncio 中，需要通过额外的步骤和/或替代加载程序模式才能成功使用。
- en: See also
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Preventing Implicit IO when Using AsyncSession](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - covers most ORM scenarios where this problem can occur and how to mitigate,
    including specific patterns to use with lazy load scenarios.'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '[在使用 AsyncSession 时预防隐式 IO](orm/extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    - 涵盖了大多数可能出现此问题的 ORM 方案以及如何缓解，包括在懒加载场景中使用的特定模式。'
- en: '### No Inspection Available'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '### 无可用检查'
- en: 'Using the [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function directly on an [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") or [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") object is not currently supported, as there
    is not yet an awaitable form of the [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object available. Instead, the object
    is used by acquiring it using the [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function in such a way that it refers to the underlying
    [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") attribute of the [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") object; the `Inspector` is then used
    in a “synchronous” calling style by using the [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") method along with a custom
    function that performs the desired operations:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在 [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 或 [`AsyncEngine`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") 对象上使用 [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 函数目前不受支持，因为尚未提供 [`Inspector`](core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 对象的可等待形式。相反，通过以获取 [`AsyncConnection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 对象的基础 [`AsyncConnection.sync_connection`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.sync_connection
    "sqlalchemy.ext.asyncio.AsyncConnection.sync_connection") 属性的方式获取该对象；然后使用 `Inspector`
    通过使用 [`AsyncConnection.run_sync()`](orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.run_sync
    "sqlalchemy.ext.asyncio.AsyncConnection.run_sync") 方法以及执行所需操作的自定义函数来进行 “同步” 调用：
- en: '[PRE149]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: See also
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using the Inspector to inspect schema objects](orm/extensions/asyncio.html#asyncio-inspector)
    - additional examples of using [`inspect()`](core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") with the asyncio extension.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Inspector 检查模式对象](orm/extensions/asyncio.html#asyncio-inspector) - 使用 asyncio
    扩展与 [`inspect()`](core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    的其他示例。'
- en: Core Exception Classes
  id: totrans-825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心异常类
- en: See [Core Exceptions](core/exceptions.html) for Core exception classes.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [核心异常](core/exceptions.html) 以获取核心异常类。
- en: ORM Exception Classes
  id: totrans-827
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM 异常类
- en: See [ORM Exceptions](orm/exceptions.html) for ORM exception classes.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [ORM 异常](orm/exceptions.html) 以获取 ORM 异常类。
- en: Legacy Exceptions
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧版本异常
- en: Exceptions in this section are not generated by current SQLAlchemy versions,
    however are provided here to suit exception message hyperlinks.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的异常不是由当前的 SQLAlchemy 版本生成的，但提供了这些异常以适应异常消息的超链接。
- en: '### The <some function> in SQLAlchemy 2.0 will no longer <something>'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在 SQLAlchemy 2.0 中，<某个函数> 将不再 <某事>'
- en: SQLAlchemy 2.0 represents a major shift for a wide variety of key SQLAlchemy
    usage patterns in both the Core and ORM components. The goal of the 2.0 release
    is to make a slight readjustment in some of the most fundamental assumptions of
    SQLAlchemy since its early beginnings, and to deliver a newly streamlined usage
    model that is hoped to be significantly more minimalist and consistent between
    the Core and ORM components, as well as more capable.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 对于核心和 ORM 组件中的许多关键 SQLAlchemy 使用模式都表示了一个重大转变。2.0 发布的目标是在 SQLAlchemy
    自早期开始以来的一些最基本的假设中进行轻微调整，并提供一个新的简化使用模型，希望它在核心和 ORM 组件之间更加简约一致，并更加强大。
- en: Introduced at [SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html),
    the SQLAlchemy 2.0 project includes a comprehensive future compatibility system
    that’s integrated into the 1.4 series of SQLAlchemy, such that applications will
    have a clear, unambiguous, and incremental upgrade path in order to migrate applications
    to being fully 2.0 compatible. The `RemovedIn20Warning` deprecation warning is
    at the base of this system to provide guidance on what behaviors in an existing
    codebase will need to be modified. An overview of how to enable this warning is
    at [SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode).
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 在[SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html)中介绍的SQLAlchemy 2.0项目包含了一个全面的未来兼容系统，该系统已集成到SQLAlchemy
    1.4系列中，因此应用程序将具有明确、无歧义和逐步的升级路径，以将应用程序迁移到完全兼容2.0的状态。`RemovedIn20Warning`废弃警告是该系统的基础，提供了关于现有代码库中需要修改的行为的指导。如何启用此警告的概述在[SQLAlchemy
    2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)中。
- en: See also
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html) - An
    overview of the upgrade process from the 1.x series, as well as the current goals
    and progress of SQLAlchemy 2.0.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) - 从1.x系列升级过程的概述，以及SQLAlchemy
    2.0的当前目标和进展。'
- en: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - specific guidelines on how to use “2.0 deprecations mode” in SQLAlchemy 1.4.  ###
    Object is being merged into a Session along the backref cascade'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - 关于如何在SQLAlchemy 1.4中使用“2.0废弃模式”的具体指南。### 对象正在被合并到会话中，沿着反向引用级联。'
- en: This message refers to the “backref cascade” behavior of SQLAlchemy, removed
    in version 2.0\. This refers to the action of an object being added into a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as a result of another object that’s already present
    in that session being associated with it. As this behavior has been shown to be
    more confusing than helpful, the [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameters were added, which can be set to `False` to
    disable it, and in SQLAlchemy 2.0 the “cascade backrefs” behavior has been removed
    entirely.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息指的是SQLAlchemy的“backref cascade”行为，在版本2.0中已删除。这指的是将对象添加到[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，因为该会话中已经存在的另一个对象与之关联。由于这种行为被证明比有用更令人困惑，因此添加了[`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")和[`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")参数，可以将其设置为`False`以禁用它，在SQLAlchemy 2.0中完全删除了“cascade backrefs”行为。
- en: For older SQLAlchemy versions, to set [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") to `False` on a backref that is currently configured
    using the [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") string parameter, the backref must be declared
    using the [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    function first so that the [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameter may be passed.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的SQLAlchemy版本，要在当前使用[`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")字符串参数配置的反向引用上设置[`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")为`False`，必须首先使用[`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数声明反向引用，以便可以传递[`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")参数。
- en: Alternatively, the entire “cascade backrefs” behavior can be turned off across
    the board by using the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in “future” mode, by passing `True` for the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") parameter.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过在“未来”模式下使用[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，通过为[`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")参数传递`True`来全面关闭“cascade backrefs”行为。
- en: See also
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](changelog/migration_14.html#change-5150)
    - background on the change for SQLAlchemy 2.0.  ### select() construct created
    in “legacy” mode; keyword arguments, etc.'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '[cascade_backrefs 行为在 2.0 中已弃用](changelog/migration_14.html#change-5150) -
    SQLAlchemy 2.0 的变更背景。  ### 创建在“传统”模式下的 select() 构造；关键字参数等。'
- en: The [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct has been updated as of SQLAlchemy 1.4 to support the newer calling style
    that is standard in SQLAlchemy 2.0\. For backwards compatibility within the 1.4
    series, the construct accepts arguments in both the “legacy” style as well as
    the “new” style.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQLAlchemy 1.4 开始，[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造已经更新为支持 SQLAlchemy 2.0 中标准的新调用风格。为了在 1.4
    系列内保持向后兼容性，该构造在“传统”风格以及“新”风格下都接受参数。
- en: 'The “new” style features that column and table expressions are passed positionally
    to the [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct only; any other modifiers to the object must be passed using subsequent
    method chaining:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: “新”风格的特点是，列和表达式只传递给 [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造；对象的任何其他修饰符必须通过后续的方法链传递：
- en: '[PRE150]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'For comparison, a [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in legacy forms of SQLAlchemy, before methods
    like [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") were even added, would like:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，在 SQLAlchemy 的传统形式中，像 [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 这样的方法甚至还未添加之前，[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 会是这样的：
- en: '[PRE151]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Or even that the “whereclause” would be passed positionally:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至，“whereclause”会被按位置传递：
- en: '[PRE152]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'For some years now, the additional “whereclause” and other arguments that are
    accepted have been removed from most narrative documentation, leading to a calling
    style that is most familiar as the list of column arguments passed as a list,
    but no further arguments:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，大多数叙述性文档中已经删除了接受的额外“whereclause”和其他参数，导致了一种最为熟悉的调用风格，即将列参数作为列表传递，但没有进一步的参数：
- en: '[PRE153]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The document at [select() no longer accepts varied constructor arguments, columns
    are passed positionally](changelog/migration_20.html#migration-20-5284) describes
    this change in terms of [2.0 Migration](changelog/migration_20.html).
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [select() 不再接受多样化的构造函数参数，列是按位置传递的](changelog/migration_20.html#migration-20-5284)
    文档中以 [2.0 迁移](changelog/migration_20.html) 的术语描述了这一变更。
- en: See also
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() 不再接受多样化的构造函数参数，列是按位置传递的](changelog/migration_20.html#migration-20-5284)'
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html)  ###
    A bind was located via legacy bound metadata, but since future=True is set on
    this Session, this bind is ignored.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 重大迁移指南](changelog/migration_20.html)  ### 通过传递 future=True
    到 Session 上，将会忽略通过传统绑定的元数据所定位的绑定。'
- en: The concept of “bound metadata” is present up until SQLAlchemy 1.4; as of SQLAlchemy
    2.0 it’s been removed.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: “绑定元数据”的概念一直存在直到 SQLAlchemy 1.4；截至 SQLAlchemy 2.0，它已被移除。
- en: 'This error refers to the [`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData") parameter on the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that in turn allows objects like the ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to associate a particular mapped class with an `Engine`. In SQLAlchemy 2.0, the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    must be linked to each `Engine` directly. That is, instead of instantiating the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    without any arguments, and associating the [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指的是[`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData")参数，它在ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中允许将特定映射类与`Engine`相关联的[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象上。在SQLAlchemy 2.0中，[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")必须直接链接到每个`Engine`上。也就是说，不能再不带任何参数实例化[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")或[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")，并将[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")与[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")相关联：
- en: '[PRE154]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    must instead be associated directly with the [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object should no longer be associated with any engine:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")必须直接与[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象不应再与任何引擎相关联：'
- en: '[PRE155]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'In SQLAlchemy 1.4, this [2.0 style](glossary.html#term-2.0-style) behavior
    is enabled when the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag is set on [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").  ### This Compiled object is not bound to any Engine
    or Connection'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.4中，当在[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上设置[`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")标志时，启用此[2.0样式](glossary.html#term-2.0-style)行为。###此编译对象未绑定到任何引擎或连接
- en: 'This error refers to the concept of “bound metadata”, which is a legacy SQLAlchemy
    pattern present only in 1.x versions. The issue occurs when one invokes the `Executable.execute()`
    method directly off of a Core expression object that is not associated with any
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误涉及到“绑定元数据”的概念，这是仅存在于1.x版本中的传统SQLAlchemy模式。当直接从未与任何[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联的Core表达式对象上调用`Executable.execute()`方法时会发生此问题：
- en: '[PRE156]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'What the logic is expecting is that the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object has been **bound** to a [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑预期的是[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象已经**绑定**到[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")：
- en: '[PRE157]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Where above, any statement that derives from a [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which in turn derives from that [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will implicitly make use of the given [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in order to invoke the statement.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，从[`Table`](core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")派生的任何语句将隐式使用给定的[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")来调用该语句。
- en: 'Note that the concept of bound metadata is **not present in SQLAlchemy 2.0**.
    The correct way to invoke statements is via the [`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method of a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，绑定元数据的概念**在SQLAlchemy 2.0中不存在**。调用语句的正确方式是通过[`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")方法的[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")：
- en: '[PRE158]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'When using the ORM, a similar facility is available via the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ORM时，通过[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")也可以使用类似的功能：
- en: '[PRE159]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: See also
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Basics of Statement Execution](tutorial/dbapi_transactions.html#tutorial-statement-execution)  ###
    This connection is on an inactive transaction. Please rollback() fully before
    proceeding'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '[语句执行基础知识](tutorial/dbapi_transactions.html#tutorial-statement-execution)###
    此连接处于非活动事务状态。请在继续之前完全回滚()'
- en: This error condition was added to SQLAlchemy as of version 1.4, and does not
    apply to SQLAlchemy 2.0\. The error refers to the state where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is placed into a transaction using a method like
    [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"), and then a further “marker” transaction
    is created within that scope; the “marker” transaction is then rolled back using
    [`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or closed using [`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close"), however the outer transaction is still
    present in an “inactive” state and must be rolled back.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误条件已添加到SQLAlchemy自版本1.4起，不适用于SQLAlchemy 2.0。该错误指的是将[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")放入事务中，使用类似[`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin")的方法创建一个进一步的“标记”事务；然后使用[`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback")回滚或使用[`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close")关闭“标记”事务，但外部事务仍处于“非活动”状态，必须回滚。
- en: 'The pattern looks like:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式如下：
- en: '[PRE160]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Above, `transaction2` is a “marker” transaction, which indicates a logical nesting
    of transactions within an outer one; while the inner transaction can roll back
    the whole transaction via its rollback() method, its commit() method has no effect
    except to close the scope of the “marker” transaction itself. The call to `transaction2.rollback()`
    has the effect of **deactivating** transaction1 which means it is essentially
    rolled back at the database level, however is still present in order to accommodate
    a consistent nesting pattern of transactions.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`transaction2`是一个“标记”事务，表示在外部事务内部的事务逻辑嵌套；虽然内部事务可以通过其rollback()方法回滚整个事务，但其commit()方法除了关闭“标记”事务本身的范围外，没有任何效果。调用`transaction2.rollback()`的效果是**停用**transaction1，这意味着它在数据库级别上基本上被回滚，但仍然存在以适应一致的事务嵌套模式。
- en: 'The correct resolution is to ensure the outer transaction is also rolled back:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的解决方法是确保外部事务也被回滚：
- en: '[PRE161]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: This pattern is not commonly used in Core. Within the ORM, a similar issue can
    occur which is the product of the ORM’s “logical” transaction structure; this
    is described in the FAQ entry at [“This Session’s transaction has been rolled
    back due to a previous exception during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式在Core中并不常用。在ORM中，可能会出现类似的问题，这是ORM的“逻辑”事务结构的产物；这在FAQ条目中有描述[“由于刷新期间的先前异常，此会话的事务已回滚。”（或类似）](faq/sessions.html#faq-session-rollback)。
- en: 'The “subtransaction” pattern is removed in SQLAlchemy 2.0 so that this particular
    programming pattern is no longer be available, preventing this error message.  ###
    The <some function> in SQLAlchemy 2.0 will no longer <something>'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 2.0中，已删除“子事务”模式，因此这种特定的编程模式不再可用，从而避免了这个错误消息。### 在SQLAlchemy 2.0中，<某个函数>将不再<某事>
- en: SQLAlchemy 2.0 represents a major shift for a wide variety of key SQLAlchemy
    usage patterns in both the Core and ORM components. The goal of the 2.0 release
    is to make a slight readjustment in some of the most fundamental assumptions of
    SQLAlchemy since its early beginnings, and to deliver a newly streamlined usage
    model that is hoped to be significantly more minimalist and consistent between
    the Core and ORM components, as well as more capable.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 对于核心和 ORM 组件中的许多关键 SQLAlchemy 使用模式都表示了一个重大转变。2.0 版本的目标是在 SQLAlchemy
    从一开始的基本假设中进行一些轻微调整，并提供一个新的简化的使用模型，希望在核心和 ORM 组件之间更加一致和简约，并且更具有能力。
- en: Introduced at [SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html),
    the SQLAlchemy 2.0 project includes a comprehensive future compatibility system
    that’s integrated into the 1.4 series of SQLAlchemy, such that applications will
    have a clear, unambiguous, and incremental upgrade path in order to migrate applications
    to being fully 2.0 compatible. The `RemovedIn20Warning` deprecation warning is
    at the base of this system to provide guidance on what behaviors in an existing
    codebase will need to be modified. An overview of how to enable this warning is
    at [SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode).
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) 中介绍的 SQLAlchemy 2.0
    项目包括一个综合的未来兼容性系统，该系统集成到 SQLAlchemy 1.4 系列中，以便应用程序能够清晰、明确地、逐步地升级到完全兼容 2.0 版本。`RemovedIn20Warning`
    弃用警告是这个系统的基础，它提供了对现有代码库中需要修改的行为的指导。关于如何启用此警告的概述在 [SQLAlchemy 2.0 弃用模式](changelog/migration_14.html#deprecation-20-mode)
    中。
- en: See also
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html) - An
    overview of the upgrade process from the 1.x series, as well as the current goals
    and progress of SQLAlchemy 2.0.'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](changelog/migration_20.html) - 从 1.x 系列的升级过程的概述，以及
    SQLAlchemy 2.0 的当前目标和进展。'
- en: '[SQLAlchemy 2.0 Deprecations Mode](changelog/migration_14.html#deprecation-20-mode)
    - specific guidelines on how to use “2.0 deprecations mode” in SQLAlchemy 1.4.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 弃用模式](changelog/migration_14.html#deprecation-20-mode) - 如何在
    SQLAlchemy 1.4 中使用“2.0 弃用模式”的具体指南。'
- en: '### Object is being merged into a Session along the backref cascade'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对象正被合并到会话中，沿着反向引用级联'
- en: This message refers to the “backref cascade” behavior of SQLAlchemy, removed
    in version 2.0\. This refers to the action of an object being added into a [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as a result of another object that’s already present
    in that session being associated with it. As this behavior has been shown to be
    more confusing than helpful, the [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameters were added, which can be set to `False` to
    disable it, and in SQLAlchemy 2.0 the “cascade backrefs” behavior has been removed
    entirely.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 此消息指的是 SQLAlchemy 的“backref cascade”行为，在 2.0 版本中已删除。这是指对象作为已经存在于该会话中的另一个对象的关联而被添加到
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中的操作。由于这种行为显示出比有帮助更加令人困惑，添加了 [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") 和 [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") 参数，可以将其设置为 `False` 以禁用它，并且在 SQLAlchemy 2.0 中已完全删除“级联反向引用”行为。
- en: For older SQLAlchemy versions, to set [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") to `False` on a backref that is currently configured
    using the [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") string parameter, the backref must be declared
    using the [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref "sqlalchemy.orm.backref")
    function first so that the [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") parameter may be passed.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的 SQLAlchemy 版本，要在当前使用 [`relationship.backref`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") 字符串参数配置的反向引用上将 [`relationship.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") 设置为 `False`，必须首先使用 [`backref()`](orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") 函数声明反向引用，以便传递 [`backref.cascade_backrefs`](orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") 参数。
- en: Alternatively, the entire “cascade backrefs” behavior can be turned off across
    the board by using the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in “future” mode, by passing `True` for the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") parameter.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过在“未来”模式下使用 [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，将整个“级联反向引用”行为全部关闭，通过为
    [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future "sqlalchemy.orm.Session")
    参数传递 `True`。
- en: See also
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](changelog/migration_14.html#change-5150)
    - background on the change for SQLAlchemy 2.0.'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '[级联反向引用行为在 2.0 中已弃用](changelog/migration_14.html#change-5150) - SQLAlchemy
    2.0 变更的背景。'
- en: '### select() construct created in “legacy” mode; keyword arguments, etc.'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '### 以“传统”模式创建的 select() 构造；关键字参数等。'
- en: The [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct has been updated as of SQLAlchemy 1.4 to support the newer calling style
    that is standard in SQLAlchemy 2.0\. For backwards compatibility within the 1.4
    series, the construct accepts arguments in both the “legacy” style as well as
    the “new” style.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造已在 SQLAlchemy 1.4 中更新，以支持在 SQLAlchemy 2.0 中标准的新调用风格。为了向后兼容 1.4 系列，该构造接受“传统”风格和“新”风格的参数。'
- en: 'The “new” style features that column and table expressions are passed positionally
    to the [`select()`](core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct only; any other modifiers to the object must be passed using subsequent
    method chaining:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: “新”风格的特点是列和表达式仅以位置方式传递给 [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造；对象的任何其他修饰符必须使用后续方法链接传递：
- en: '[PRE162]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'For comparison, a [`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in legacy forms of SQLAlchemy, before methods
    like [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") were even added, would like:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对比，在 SQLAlchemy 的传统形式中，即使在添加像 [`Select.where()`](core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") 这样的方法之前，[`select()`](core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 会像这样：
- en: '[PRE163]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Or even that the “whereclause” would be passed positionally:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至“whereclause”将以位置方式传���：
- en: '[PRE164]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'For some years now, the additional “whereclause” and other arguments that are
    accepted have been removed from most narrative documentation, leading to a calling
    style that is most familiar as the list of column arguments passed as a list,
    but no further arguments:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，大多数叙述性文档中接受的额外“whereclause”和其他参数已被移除，导致调用风格最为熟悉的是作为列参数传递的列表，但没有其他参数：
- en: '[PRE165]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The document at [select() no longer accepts varied constructor arguments, columns
    are passed positionally](changelog/migration_20.html#migration-20-5284) describes
    this change in terms of [2.0 Migration](changelog/migration_20.html).
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284) 中的文档描述了这一变化，涉及 [2.0
    迁移](changelog/migration_20.html)。'
- en: See also
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](changelog/migration_20.html#migration-20-5284)'
- en: '[SQLAlchemy 2.0 - Major Migration Guide](changelog/migration_20.html)'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 重大迁移指南](changelog/migration_20.html)'
- en: '### A bind was located via legacy bound metadata, but since future=True is
    set on this Session, this bind is ignored.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '### 通过传统的绑定元数据找到了一个绑定，但由于此会话设置了future=True，因此会忽略此绑定。'
- en: The concept of “bound metadata” is present up until SQLAlchemy 1.4; as of SQLAlchemy
    2.0 it’s been removed.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: “绑定元数据”的概念一直存在于SQLAlchemy 1.4之前；从SQLAlchemy 2.0开始已将其删除。
- en: 'This error refers to the [`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData") parameter on the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that in turn allows objects like the ORM
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to associate a particular mapped class with an `Engine`. In SQLAlchemy 2.0, the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    must be linked to each `Engine` directly. That is, instead of instantiating the
    [`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    without any arguments, and associating the [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指的是[`MetaData.bind`](core/metadata.html#sqlalchemy.schema.MetaData.params.bind
    "sqlalchemy.schema.MetaData")参数，该参数位于[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象上，该对象允许像ORM [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")这样的对象将特定的映射类与`Engine`关联起来。在SQLAlchemy 2.0中，[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")必须直接与每个`Engine`关联。也就是说，不要实例化[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")或[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")而不带任何参数，并将[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")与[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")关联：
- en: '[PRE166]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    must instead be associated directly with the [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). The [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object should no longer be associated with any engine:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")必须直接与[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联。[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象不应再与任何引擎相关联：
- en: '[PRE167]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: In SQLAlchemy 1.4, this [2.0 style](glossary.html#term-2.0-style) behavior is
    enabled when the [`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag is set on [`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") or [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.4中，当在[`sessionmaker`](orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")或[`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上设置了[`Session.future`](orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")标志时，将启用此[2.0样式](glossary.html#term-2.0-style)行为。
- en: '### This Compiled object is not bound to any Engine or Connection'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '### 此Compiled对象未绑定到任何Engine或Connection'
- en: 'This error refers to the concept of “bound metadata”, which is a legacy SQLAlchemy
    pattern present only in 1.x versions. The issue occurs when one invokes the `Executable.execute()`
    method directly off of a Core expression object that is not associated with any
    [`Engine`](core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine"):'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误指的是“绑定元数据”的概念，这是一个仅在1.x版本中存在的传统SQLAlchemy模式。当直接从未与任何[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联的Core表达式对象上调用`Executable.execute()`方法时，就会出现此问题：
- en: '[PRE168]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'What the logic is expecting is that the [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object has been **bound** to a [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑期望的是[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象已经与[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")**绑定**：
- en: '[PRE169]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Where above, any statement that derives from a [`Table`](core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") which in turn derives from that [`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") will implicitly make use of the given [`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in order to invoke the statement.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，任何从[`Table`](core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")派生的语句，其又派生自[`MetaData`](core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")的语句，将隐式使用给定的[`Engine`](core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")来调用该语句。
- en: 'Note that the concept of bound metadata is **not present in SQLAlchemy 2.0**.
    The correct way to invoke statements is via the [`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method of a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"):'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 SQLAlchemy 2.0 中**不存在**绑定元数据的概念。调用语句的正确方式是通过[`Connection.execute()`](core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")方法的一个[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")：
- en: '[PRE170]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'When using the ORM, a similar facility is available via the [`Session`](orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM 时，可以通过[`Session`](orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")提供类似的功能：
- en: '[PRE171]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: See also
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Basics of Statement Execution](tutorial/dbapi_transactions.html#tutorial-statement-execution)'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '[语句执行基础](tutorial/dbapi_transactions.html#tutorial-statement-execution)'
- en: '### This connection is on an inactive transaction. Please rollback() fully
    before proceeding'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '### 此连接处于非活动事务状态。请在继续之前完全rollback()。'
- en: This error condition was added to SQLAlchemy as of version 1.4, and does not
    apply to SQLAlchemy 2.0\. The error refers to the state where a [`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is placed into a transaction using a method like
    [`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"), and then a further “marker” transaction
    is created within that scope; the “marker” transaction is then rolled back using
    [`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback") or closed using [`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close"), however the outer transaction is still
    present in an “inactive” state and must be rolled back.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误条件已添加到 SQLAlchemy 自 1.4 版本以来，并且不适用于 SQLAlchemy 2.0。该错误是指将[`Connection`](core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")放入事务中，使用类似[`Connection.begin()`](core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin")的方法，然后在该范围内创建一个进一步的“标记”事务；然后使用[`Transaction.rollback()`](core/connections.html#sqlalchemy.engine.Transaction.rollback
    "sqlalchemy.engine.Transaction.rollback")回滚“标记”事务，或使用[`Transaction.close()`](core/connections.html#sqlalchemy.engine.Transaction.close
    "sqlalchemy.engine.Transaction.close")关闭它，但是外部事务仍然以“非活动”状态存在，必须回滚。
- en: 'The pattern looks like:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 模式如下：
- en: '[PRE172]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Above, `transaction2` is a “marker” transaction, which indicates a logical nesting
    of transactions within an outer one; while the inner transaction can roll back
    the whole transaction via its rollback() method, its commit() method has no effect
    except to close the scope of the “marker” transaction itself. The call to `transaction2.rollback()`
    has the effect of **deactivating** transaction1 which means it is essentially
    rolled back at the database level, however is still present in order to accommodate
    a consistent nesting pattern of transactions.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`transaction2` 是一个“标记”事务，它表示外部事务内部的逻辑嵌套；而内部事务可以通过其rollback()方法回滚整个事务，但是其commit()方法除了关闭“标记”事务本身的范围外，并不产生任何效果。调用`transaction2.rollback()`的效果是**停用**transaction1，这意味着它在数据库级别上基本上已被回滚，但仍然存在以适应一致的事务嵌套模式。
- en: 'The correct resolution is to ensure the outer transaction is also rolled back:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的解决方法是确保外部事务也被回滚：
- en: '[PRE173]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This pattern is not commonly used in Core. Within the ORM, a similar issue can
    occur which is the product of the ORM’s “logical” transaction structure; this
    is described in the FAQ entry at [“This Session’s transaction has been rolled
    back due to a previous exception during flush.” (or similar)](faq/sessions.html#faq-session-rollback).
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式在核心中不常用。在 ORM 中，可能会出现类似的问题，这是 ORM 的“逻辑”事务结构的产物；这在常见问题解答条目中有描述：[“此会话的事务由于刷新期间的先前异常而已被回滚。”（或类似）](faq/sessions.html#faq-session-rollback)。
- en: The “subtransaction” pattern is removed in SQLAlchemy 2.0 so that this particular
    programming pattern is no longer be available, preventing this error message.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: “子事务”模式在 SQLAlchemy 2.0 中被移除，因此这种特定的编程模式不再可用，从而防止了这个错误消息的出现。
