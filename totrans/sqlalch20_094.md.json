["```py\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table, Column, Integer, String\n\nmetadata_obj = MetaData()\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_name\", String, primary_key=True),\n    Column(\"email_address\", String(60)),\n)\n```", "```py\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table, Column, Integer, String\nfrom sqlalchemy.dialects.mysql import VARCHAR\n\nmetadata_obj = MetaData()\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_name\", String(100), primary_key=True),\n    Column(\n        \"bio\",\n        String(255).with_variant(VARCHAR(255, charset=\"utf8\"), \"mysql\", \"mariadb\"),\n    ),\n)\n```", "```py\nclass sqlalchemy.types.BigInteger\n```", "```py\nclass sqlalchemy.types.Boolean\n```", "```py\nmethod __init__(create_constraint: bool = False, name: str | None = None, _create_events: bool = True, _adapted_from: SchemaType | None = None)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.Date\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.DateTime\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.Enum\n```", "```py\nimport enum\nfrom sqlalchemy import Enum\n\nclass MyEnum(enum.Enum):\n    one = 1\n    two = 2\n    three = 3\n\nt = Table(\n    'data', MetaData(),\n    Column('value', Enum(MyEnum))\n)\n\nconnection.execute(t.insert(), {\"value\": MyEnum.two})\nassert connection.scalar(t.select()) is MyEnum.two\n```", "```py\nmethod __init__(*enums: object, **kw: Any)\n```", "```py\nmethod create(bind, checkfirst=False)\n```", "```py\nmethod drop(bind, checkfirst=False)\n```", "```py\nclass sqlalchemy.types.Double\n```", "```py\nclass sqlalchemy.types.Float\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.Integer\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.Interval\n```", "```py\nclass Comparator\n```", "```py\nmethod __init__(native: bool = True, second_precision: int | None = None, day_precision: int | None = None)\n```", "```py\nmethod adapt_to_emulated(impltype, **kw)\n```", "```py\nmethod bind_processor(dialect: Dialect) \u2192 _BindProcessorType[dt.timedelta]\n```", "```py\nattribute cache_ok: bool | None = True\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nmethod coerce_compared_value(op, value)\n```", "```py\nattribute comparator_factory\n```", "```py\nattribute impl\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect: Dialect, coltype: Any) \u2192 _ResultProcessorType[dt.timedelta]\n```", "```py\nclass sqlalchemy.types.LargeBinary\n```", "```py\nmethod __init__(length: int | None = None)\n```", "```py\nclass sqlalchemy.types.MatchType\n```", "```py\nclass sqlalchemy.types.Numeric\n```", "```py\nmethod __init__(precision: int | None = None, scale: int | None = None, decimal_return_scale: int | None = None, asdecimal: bool = True)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.PickleType\n```", "```py\nmethod __init__(protocol: int = 5, pickler: Any = None, comparator: Callable[[Any, Any], bool] | None = None, impl: _TypeEngineArgument[Any] | None = None)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nattribute cache_ok: bool | None = True\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nmethod compare_values(x, y)\n```", "```py\nattribute impl\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.SchemaType\n```", "```py\nmethod adapt(cls: Type[TypeEngine | TypeEngineMixin], **kw: Any) \u2192 TypeEngine\n```", "```py\nmethod copy(**kw)\n```", "```py\nmethod create(bind, checkfirst=False)\n```", "```py\nmethod drop(bind, checkfirst=False)\n```", "```py\nattribute name: str | None\n```", "```py\nclass sqlalchemy.types.SmallInteger\n```", "```py\nclass sqlalchemy.types.String\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.Text\n```", "```py\nclass sqlalchemy.types.Time\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.Unicode\n```", "```py\nclass sqlalchemy.types.UnicodeText\n```", "```py\nclass sqlalchemy.types.Uuid\n```", "```py\nimport uuid\n\nfrom sqlalchemy import Uuid\nfrom sqlalchemy import Table, Column, MetaData, String\n\nmetadata_obj = MetaData()\n\nt = Table(\n    \"t\",\n    metadata_obj,\n    Column('uuid_data', Uuid, primary_key=True),\n    Column(\"other_data\", String)\n)\n\nwith engine.begin() as conn:\n    conn.execute(\n        t.insert(),\n        {\"uuid_data\": uuid.uuid4(), \"other_data\", \"some data\"}\n    )\n```", "```py\nmethod __init__(as_uuid: bool = True, native_uuid: bool = True)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod coerce_compared_value(op, value)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.ARRAY\n```", "```py\nmytable = Table(\"mytable\", metadata,\n        Column(\"data\", ARRAY(Integer))\n    )\n```", "```py\nconnection.execute(\n        mytable.insert(),\n        {\"data\": [1,2,3]}\n)\n```", "```py\nmytable = Table(\"mytable\", metadata,\n        Column(\"data\", ARRAY(Integer, dimensions=2))\n    )\n```", "```py\n    >>> expr = table.c.column[5]  # returns ARRAY(Integer, dimensions=1)\n    >>> expr = expr[6]  # returns Integer\n    ```", "```py\nselect(mytable.c.data[5], mytable.c.data[2:7])\n```", "```py\nmytable.update().values({\n    mytable.c.data[5]: 7,\n    mytable.c.data[2:7]: [1, 2, 3]\n})\n```", "```py\nfrom sqlalchemy import ARRAY\nfrom sqlalchemy.ext.mutable import MutableList\n\nclass SomeOrmClass(Base):\n    # ...\n\n    data = Column(MutableList.as_mutable(ARRAY(Integer)))\n```", "```py\nmethod __init__(item_type: _TypeEngineArgument[Any], as_tuple: bool = False, dimensions: int | None = None, zero_indexes: bool = False)\n```", "```py\nColumn('myarray', ARRAY(Integer))\n```", "```py\nclass Comparator\n```", "```py\nmethod contains(*arg, **kw)\n```", "```py\nmethod any(other, operator=None)\n```", "```py\nfrom sqlalchemy.sql import operators\n\nconn.execute(\n    select(table.c.data).where(\n            table.c.data.any(7, operator=operators.lt)\n        )\n)\n```", "```py\nmethod all(other, operator=None)\n```", "```py\nfrom sqlalchemy.sql import operators\n\nconn.execute(\n    select(table.c.data).where(\n            table.c.data.all(7, operator=operators.lt)\n        )\n)\n```", "```py\nclass sqlalchemy.types.BIGINT\n```", "```py\nclass sqlalchemy.types.BINARY\n```", "```py\nclass sqlalchemy.types.BLOB\n```", "```py\nmethod __init__(length: int | None = None)\n```", "```py\nclass sqlalchemy.types.BOOLEAN\n```", "```py\nmethod __init__(create_constraint: bool = False, name: str | None = None, _create_events: bool = True, _adapted_from: SchemaType | None = None)\n```", "```py\nclass sqlalchemy.types.CHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.CLOB\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.DATE\n```", "```py\nclass sqlalchemy.types.DATETIME\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nclass sqlalchemy.types.DECIMAL\n```", "```py\nmethod __init__(precision: int | None = None, scale: int | None = None, decimal_return_scale: int | None = None, asdecimal: bool = True)\n```", "```py\nclass sqlalchemy.types.DOUBLE\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nclass sqlalchemy.types.DOUBLE_PRECISION\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nclass sqlalchemy.types.FLOAT\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nattribute sqlalchemy.types.INT\n```", "```py\nclass sqlalchemy.types.JSON\n```", "```py\ndata_table = Table('data_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', JSON)\n)\n\nwith engine.connect() as conn:\n    conn.execute(\n        data_table.insert(),\n        {\"data\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    )\n```", "```py\n    data_table.c.data['some key']\n    ```", "```py\n    data_table.c.data[3]\n    ```", "```py\n    data_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')]\n    ```", "```py\n    data_table.c.data[\"some key\"].as_integer()\n    ```", "```py\n# integer comparison\ndata_table.c.data[\"some_integer_key\"].as_integer() == 5\n\n# boolean comparison\ndata_table.c.data[\"some_boolean\"].as_boolean() == True\n```", "```py\nfrom sqlalchemy import cast, type_coerce\nfrom sqlalchemy import String, JSON\ncast(\n    data_table.c.data['some_key'], String\n) == type_coerce(55, JSON)\n```", "```py\ndata_table.c.data['some_key'].as_integer() == 5\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"json_value\": null()})\n```", "```py\nconn.execute(table.insert(), {\"json_value\": JSON.NULL})\n```", "```py\nengine = create_engine(\n    \"sqlite://\",\n    json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False))\n```", "```py\nclass Comparator\n```", "```py\nmethod as_boolean()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_boolean()\n).where(\n    mytable.c.json_column['some_data'].as_boolean() == True\n)\n```", "```py\nmethod as_float()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_float()\n).where(\n    mytable.c.json_column['some_data'].as_float() == 29.75\n)\n```", "```py\nmethod as_integer()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_integer()\n).where(\n    mytable.c.json_column['some_data'].as_integer() == 5\n)\n```", "```py\nmethod as_json()\n```", "```py\nstmt = select(mytable.c.json_column['some_data'].as_json())\n```", "```py\nmethod as_numeric(precision, scale, asdecimal=True)\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_numeric(10, 6)\n).where(\n    mytable.c.\n    json_column['some_data'].as_numeric(10, 6) == 29.75\n)\n```", "```py\nmethod as_string()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_string()\n).where(\n    mytable.c.json_column['some_data'].as_string() ==\n    'some string'\n)\n```", "```py\nclass JSONElementType\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nclass JSONIndexType\n```", "```py\nclass JSONIntIndexType\n```", "```py\nclass JSONPathType\n```", "```py\nclass JSONStrIndexType\n```", "```py\nattribute NULL = symbol('JSON_NULL')\n```", "```py\nfrom sqlalchemy import null\nfrom sqlalchemy.dialects.postgresql import JSON\n\n# will *always* insert SQL NULL\nobj1 = MyObject(json_value=null())\n\n# will *always* insert JSON string \"null\"\nobj2 = MyObject(json_value=JSON.NULL)\n\nsession.add_all([obj1, obj2])\nsession.commit()\n```", "```py\nTable(\n    'my_table', metadata,\n    Column('json_data', JSON, default=text(\"'null'\"))\n)\n```", "```py\nmethod __init__(none_as_null: bool = False)\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"data\": null()})\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nattribute comparator_factory\n```", "```py\nattribute hashable = False\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nattribute should_evaluate_none: bool\n```", "```py\nclass sqlalchemy.types.INTEGER\n```", "```py\nclass sqlalchemy.types.NCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.NVARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.NUMERIC\n```", "```py\nmethod __init__(precision: int | None = None, scale: int | None = None, decimal_return_scale: int | None = None, asdecimal: bool = True)\n```", "```py\nclass sqlalchemy.types.REAL\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nclass sqlalchemy.types.SMALLINT\n```", "```py\nclass sqlalchemy.types.TEXT\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.TIME\n```", "```py\nclass sqlalchemy.types.TIMESTAMP\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nclass sqlalchemy.types.UUID\n```", "```py\nmethod __init__(as_uuid: bool = True)\n```", "```py\nclass sqlalchemy.types.VARBINARY\n```", "```py\nclass sqlalchemy.types.VARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table, Column, Integer, String\n\nmetadata_obj = MetaData()\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_name\", String, primary_key=True),\n    Column(\"email_address\", String(60)),\n)\n```", "```py\nfrom sqlalchemy import MetaData\nfrom sqlalchemy import Table, Column, Integer, String\nfrom sqlalchemy.dialects.mysql import VARCHAR\n\nmetadata_obj = MetaData()\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_name\", String(100), primary_key=True),\n    Column(\n        \"bio\",\n        String(255).with_variant(VARCHAR(255, charset=\"utf8\"), \"mysql\", \"mariadb\"),\n    ),\n)\n```", "```py\nclass sqlalchemy.types.BigInteger\n```", "```py\nclass sqlalchemy.types.Boolean\n```", "```py\nmethod __init__(create_constraint: bool = False, name: str | None = None, _create_events: bool = True, _adapted_from: SchemaType | None = None)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.Date\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.DateTime\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.Enum\n```", "```py\nimport enum\nfrom sqlalchemy import Enum\n\nclass MyEnum(enum.Enum):\n    one = 1\n    two = 2\n    three = 3\n\nt = Table(\n    'data', MetaData(),\n    Column('value', Enum(MyEnum))\n)\n\nconnection.execute(t.insert(), {\"value\": MyEnum.two})\nassert connection.scalar(t.select()) is MyEnum.two\n```", "```py\nmethod __init__(*enums: object, **kw: Any)\n```", "```py\nmethod create(bind, checkfirst=False)\n```", "```py\nmethod drop(bind, checkfirst=False)\n```", "```py\nclass sqlalchemy.types.Double\n```", "```py\nclass sqlalchemy.types.Float\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.Integer\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.Interval\n```", "```py\nclass Comparator\n```", "```py\nmethod __init__(native: bool = True, second_precision: int | None = None, day_precision: int | None = None)\n```", "```py\nmethod adapt_to_emulated(impltype, **kw)\n```", "```py\nmethod bind_processor(dialect: Dialect) \u2192 _BindProcessorType[dt.timedelta]\n```", "```py\nattribute cache_ok: bool | None = True\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nmethod coerce_compared_value(op, value)\n```", "```py\nattribute comparator_factory\n```", "```py\nattribute impl\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect: Dialect, coltype: Any) \u2192 _ResultProcessorType[dt.timedelta]\n```", "```py\nclass sqlalchemy.types.LargeBinary\n```", "```py\nmethod __init__(length: int | None = None)\n```", "```py\nclass sqlalchemy.types.MatchType\n```", "```py\nclass sqlalchemy.types.Numeric\n```", "```py\nmethod __init__(precision: int | None = None, scale: int | None = None, decimal_return_scale: int | None = None, asdecimal: bool = True)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.PickleType\n```", "```py\nmethod __init__(protocol: int = 5, pickler: Any = None, comparator: Callable[[Any, Any], bool] | None = None, impl: _TypeEngineArgument[Any] | None = None)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nattribute cache_ok: bool | None = True\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nmethod compare_values(x, y)\n```", "```py\nattribute impl\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.SchemaType\n```", "```py\nmethod adapt(cls: Type[TypeEngine | TypeEngineMixin], **kw: Any) \u2192 TypeEngine\n```", "```py\nmethod copy(**kw)\n```", "```py\nmethod create(bind, checkfirst=False)\n```", "```py\nmethod drop(bind, checkfirst=False)\n```", "```py\nattribute name: str | None\n```", "```py\nclass sqlalchemy.types.SmallInteger\n```", "```py\nclass sqlalchemy.types.String\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.Text\n```", "```py\nclass sqlalchemy.types.Time\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nclass sqlalchemy.types.Unicode\n```", "```py\nclass sqlalchemy.types.UnicodeText\n```", "```py\nclass sqlalchemy.types.Uuid\n```", "```py\nimport uuid\n\nfrom sqlalchemy import Uuid\nfrom sqlalchemy import Table, Column, MetaData, String\n\nmetadata_obj = MetaData()\n\nt = Table(\n    \"t\",\n    metadata_obj,\n    Column('uuid_data', Uuid, primary_key=True),\n    Column(\"other_data\", String)\n)\n\nwith engine.begin() as conn:\n    conn.execute(\n        t.insert(),\n        {\"uuid_data\": uuid.uuid4(), \"other_data\", \"some data\"}\n    )\n```", "```py\nmethod __init__(as_uuid: bool = True, native_uuid: bool = True)\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod coerce_compared_value(op, value)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nclass sqlalchemy.types.ARRAY\n```", "```py\nmytable = Table(\"mytable\", metadata,\n        Column(\"data\", ARRAY(Integer))\n    )\n```", "```py\nconnection.execute(\n        mytable.insert(),\n        {\"data\": [1,2,3]}\n)\n```", "```py\nmytable = Table(\"mytable\", metadata,\n        Column(\"data\", ARRAY(Integer, dimensions=2))\n    )\n```", "```py\n    >>> expr = table.c.column[5]  # returns ARRAY(Integer, dimensions=1)\n    >>> expr = expr[6]  # returns Integer\n    ```", "```py\nselect(mytable.c.data[5], mytable.c.data[2:7])\n```", "```py\nmytable.update().values({\n    mytable.c.data[5]: 7,\n    mytable.c.data[2:7]: [1, 2, 3]\n})\n```", "```py\nfrom sqlalchemy import ARRAY\nfrom sqlalchemy.ext.mutable import MutableList\n\nclass SomeOrmClass(Base):\n    # ...\n\n    data = Column(MutableList.as_mutable(ARRAY(Integer)))\n```", "```py\nmethod __init__(item_type: _TypeEngineArgument[Any], as_tuple: bool = False, dimensions: int | None = None, zero_indexes: bool = False)\n```", "```py\nColumn('myarray', ARRAY(Integer))\n```", "```py\nclass Comparator\n```", "```py\nmethod contains(*arg, **kw)\n```", "```py\nmethod any(other, operator=None)\n```", "```py\nfrom sqlalchemy.sql import operators\n\nconn.execute(\n    select(table.c.data).where(\n            table.c.data.any(7, operator=operators.lt)\n        )\n)\n```", "```py\nmethod all(other, operator=None)\n```", "```py\nfrom sqlalchemy.sql import operators\n\nconn.execute(\n    select(table.c.data).where(\n            table.c.data.all(7, operator=operators.lt)\n        )\n)\n```", "```py\nclass sqlalchemy.types.BIGINT\n```", "```py\nclass sqlalchemy.types.BINARY\n```", "```py\nclass sqlalchemy.types.BLOB\n```", "```py\nmethod __init__(length: int | None = None)\n```", "```py\nclass sqlalchemy.types.BOOLEAN\n```", "```py\nmethod __init__(create_constraint: bool = False, name: str | None = None, _create_events: bool = True, _adapted_from: SchemaType | None = None)\n```", "```py\nclass sqlalchemy.types.CHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.CLOB\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.DATE\n```", "```py\nclass sqlalchemy.types.DATETIME\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nclass sqlalchemy.types.DECIMAL\n```", "```py\nmethod __init__(precision: int | None = None, scale: int | None = None, decimal_return_scale: int | None = None, asdecimal: bool = True)\n```", "```py\nclass sqlalchemy.types.DOUBLE\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nclass sqlalchemy.types.DOUBLE_PRECISION\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nclass sqlalchemy.types.FLOAT\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nattribute sqlalchemy.types.INT\n```", "```py\nclass sqlalchemy.types.JSON\n```", "```py\ndata_table = Table('data_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', JSON)\n)\n\nwith engine.connect() as conn:\n    conn.execute(\n        data_table.insert(),\n        {\"data\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    )\n```", "```py\n    data_table.c.data['some key']\n    ```", "```py\n    data_table.c.data[3]\n    ```", "```py\n    data_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')]\n    ```", "```py\n    data_table.c.data[\"some key\"].as_integer()\n    ```", "```py\n# integer comparison\ndata_table.c.data[\"some_integer_key\"].as_integer() == 5\n\n# boolean comparison\ndata_table.c.data[\"some_boolean\"].as_boolean() == True\n```", "```py\nfrom sqlalchemy import cast, type_coerce\nfrom sqlalchemy import String, JSON\ncast(\n    data_table.c.data['some_key'], String\n) == type_coerce(55, JSON)\n```", "```py\ndata_table.c.data['some_key'].as_integer() == 5\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"json_value\": null()})\n```", "```py\nconn.execute(table.insert(), {\"json_value\": JSON.NULL})\n```", "```py\nengine = create_engine(\n    \"sqlite://\",\n    json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False))\n```", "```py\nclass Comparator\n```", "```py\nmethod as_boolean()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_boolean()\n).where(\n    mytable.c.json_column['some_data'].as_boolean() == True\n)\n```", "```py\nmethod as_float()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_float()\n).where(\n    mytable.c.json_column['some_data'].as_float() == 29.75\n)\n```", "```py\nmethod as_integer()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_integer()\n).where(\n    mytable.c.json_column['some_data'].as_integer() == 5\n)\n```", "```py\nmethod as_json()\n```", "```py\nstmt = select(mytable.c.json_column['some_data'].as_json())\n```", "```py\nmethod as_numeric(precision, scale, asdecimal=True)\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_numeric(10, 6)\n).where(\n    mytable.c.\n    json_column['some_data'].as_numeric(10, 6) == 29.75\n)\n```", "```py\nmethod as_string()\n```", "```py\nstmt = select(\n    mytable.c.json_column['some_data'].as_string()\n).where(\n    mytable.c.json_column['some_data'].as_string() ==\n    'some string'\n)\n```", "```py\nclass JSONElementType\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nmethod literal_processor(dialect)\n```", "```py\nclass JSONIndexType\n```", "```py\nclass JSONIntIndexType\n```", "```py\nclass JSONPathType\n```", "```py\nclass JSONStrIndexType\n```", "```py\nattribute NULL = symbol('JSON_NULL')\n```", "```py\nfrom sqlalchemy import null\nfrom sqlalchemy.dialects.postgresql import JSON\n\n# will *always* insert SQL NULL\nobj1 = MyObject(json_value=null())\n\n# will *always* insert JSON string \"null\"\nobj2 = MyObject(json_value=JSON.NULL)\n\nsession.add_all([obj1, obj2])\nsession.commit()\n```", "```py\nTable(\n    'my_table', metadata,\n    Column('json_data', JSON, default=text(\"'null'\"))\n)\n```", "```py\nmethod __init__(none_as_null: bool = False)\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"data\": null()})\n```", "```py\nmethod bind_processor(dialect)\n```", "```py\nattribute comparator_factory\n```", "```py\nattribute hashable = False\n```", "```py\nattribute python_type\n```", "```py\nmethod result_processor(dialect, coltype)\n```", "```py\nattribute should_evaluate_none: bool\n```", "```py\nclass sqlalchemy.types.INTEGER\n```", "```py\nclass sqlalchemy.types.NCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.NVARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.NUMERIC\n```", "```py\nmethod __init__(precision: int | None = None, scale: int | None = None, decimal_return_scale: int | None = None, asdecimal: bool = True)\n```", "```py\nclass sqlalchemy.types.REAL\n```", "```py\nmethod __init__(precision: int | None = None, asdecimal: bool = False, decimal_return_scale: int | None = None)\n```", "```py\n    from sqlalchemy import Column\n    from sqlalchemy import Float\n    from sqlalchemy.dialects import oracle\n\n    Column(\n        \"float_data\",\n        Float(5).with_variant(oracle.FLOAT(binary_precision=16), \"oracle\")\n    )\n    ```", "```py\nclass sqlalchemy.types.SMALLINT\n```", "```py\nclass sqlalchemy.types.TEXT\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.types.TIME\n```", "```py\nclass sqlalchemy.types.TIMESTAMP\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nmethod get_dbapi_type(dbapi)\n```", "```py\nclass sqlalchemy.types.UUID\n```", "```py\nmethod __init__(as_uuid: bool = True)\n```", "```py\nclass sqlalchemy.types.VARBINARY\n```", "```py\nclass sqlalchemy.types.VARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```"]