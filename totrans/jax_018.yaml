- en: How to Think in JAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/notebooks/thinking_in_jax.html`](https://jax.readthedocs.io/en/latest/notebooks/thinking_in_jax.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/thinking_in_jax.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/thinking_in_jax.ipynb)'
  prefs: []
  type: TYPE_IMG
- en: JAX provides a simple and powerful API for writing accelerated numerical code,
    but working effectively in JAX sometimes requires extra consideration. This document
    is meant to help build a ground-up understanding of how JAX operates, so that
    you can use it more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: JAX vs. NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key Concepts:**'
  prefs: []
  type: TYPE_NORMAL
- en: JAX provides a NumPy-inspired interface for convenience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through duck-typing, JAX arrays can often be used as drop-in replacements of
    NumPy arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike NumPy arrays, JAX arrays are always immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NumPy provides a well-known, powerful API for working with numerical data.
    For convenience, JAX provides `jax.numpy` which closely mirrors the numpy API
    and provides easy entry into JAX. Almost anything that can be done with `numpy`
    can be done with `jax.numpy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/a5186b574da824b332762dc6cb1c9829034a3a27f1f5dc7ba79658eb4c9e3715.png](img/6eb981014c27d82251fc8cff5e846ec1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/4d0f0e6e14cb62a4e3105aeb1c1f8fe608774b82fd3073f26a9813de35f414eb.png](img/1d7910ee9627b0211663f6cac235493b.png)'
  prefs: []
  type: TYPE_IMG
- en: The code blocks are identical aside from replacing `np` with `jnp`, and the
    results are the same. As we can see, JAX arrays can often be used directly in
    place of NumPy arrays for things like plotting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrays themselves are implemented as different Python types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Python’s [duck-typing](https://en.wikipedia.org/wiki/Duck_typing) allows JAX
    arrays and NumPy arrays to be used interchangeably in many places.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one important difference between JAX and NumPy arrays: JAX
    arrays are immutable, meaning that once created their contents cannot be changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of mutating an array in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent in JAX results in an error, as JAX arrays are immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For updating individual elements, JAX provides an [indexed update syntax](https://jax.readthedocs.io/en/latest/jax.ops.html#indexed-update-operators)
    that returns an updated copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy, lax & XLA: JAX API layering'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key Concepts:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`jax.numpy` is a high-level wrapper that provides a familiar interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jax.lax` is a lower-level API that is stricter and often more powerful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All JAX operations are implemented in terms of operations in [XLA](https://www.tensorflow.org/xla/)
    – the Accelerated Linear Algebra compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the source of `jax.numpy`, you’ll see that all the operations
    are eventually expressed in terms of functions defined in `jax.lax`. You can think
    of `jax.lax` as a stricter, but often more powerful, API for working with multi-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while `jax.numpy` will implicitly promote arguments to allow operations
    between mixed data types, `jax.lax` will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If using `jax.lax` directly, you’ll have to do type promotion explicitly in
    such cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Along with this strictness, `jax.lax` also provides efficient APIs for some
    more general operations than are supported by NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a 1D convolution, which can be expressed in NumPy this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, this NumPy operation is translated to a much more general convolution
    implemented by [`lax.conv_general_dilated`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.conv_general_dilated.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is a batched convolution operation designed to be efficient for the types
    of convolutions often used in deep neural nets. It requires much more boilerplate,
    but is far more flexible and scalable than the convolution provided by NumPy (See
    [Convolutions in JAX](https://jax.readthedocs.io/en/latest/notebooks/convolutions.html)
    for more detail on JAX convolutions).
  prefs: []
  type: TYPE_NORMAL
- en: At their heart, all `jax.lax` operations are Python wrappers for operations
    in XLA; here, for example, the convolution implementation is provided by [XLA:ConvWithGeneralPadding](https://www.tensorflow.org/xla/operation_semantics#convwithgeneralpadding_convolution).
    Every JAX operation is eventually expressed in terms of these fundamental XLA
    operations, which is what enables just-in-time (JIT) compilation.
  prefs: []
  type: TYPE_NORMAL
- en: To JIT or not to JIT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key Concepts:**'
  prefs: []
  type: TYPE_NORMAL
- en: By default JAX executes operations one at a time, in sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a just-in-time (JIT) compilation decorator, sequences of operations can
    be optimized together and run at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all JAX code can be JIT compiled, as it requires array shapes to be static
    & known at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that all JAX operations are expressed in terms of XLA allows JAX to
    use the XLA compiler to execute blocks of code very efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this function that normalizes the rows of a 2D matrix,
    expressed in terms of `jax.numpy` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A just-in-time compiled version of the function can be created using the `jax.jit`
    transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the same results as the original, up to standard floating-point
    accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But due to the compilation (which includes fusing of operations, avoidance
    of allocating temporary arrays, and a host of other tricks), execution times can
    be orders of magnitude faster in the JIT-compiled case (note the use of `block_until_ready()`
    to account for JAX’s [asynchronous dispatch](https://jax.readthedocs.io/en/latest/async_dispatch.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That said, `jax.jit` does have limitations: in particular, it requires all
    arrays to have static shapes. That means that some JAX operations are incompatible
    with JIT compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this operation can be executed in op-by-op mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But it returns an error if you attempt to execute it in jit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the function generates an array whose shape is not known at
    compile time: the size of the output depends on the values of the input array,
    and so it is not compatible with JIT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JIT mechanics: tracing and static variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key Concepts:**'
  prefs: []
  type: TYPE_NORMAL
- en: JIT and other JAX transforms work by *tracing* a function to determine its effect
    on inputs of a specific shape and type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables that you don’t want to be traced can be marked as *static*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use `jax.jit` effectively, it is useful to understand how it works. Let’s
    put a few `print()` statements within a JIT-compiled function and then call the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the print statements execute, but rather than printing the data
    we passed to the function, though, it prints *tracer* objects that stand-in for
    them.
  prefs: []
  type: TYPE_NORMAL
- en: These tracer objects are what `jax.jit` uses to extract the sequence of operations
    specified by the function. Basic tracers are stand-ins that encode the **shape**
    and **dtype** of the arrays, but are agnostic to the values. This recorded sequence
    of computations can then be efficiently applied within XLA to new inputs with
    the same shape and dtype, without having to re-execute the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the compiled function again on matching inputs, no re-compilation
    is required and nothing is printed because the result is computed in compiled
    XLA rather than in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The extracted sequence of operations is encoded in a JAX expression, or *jaxpr*
    for short. You can view the jaxpr using the `jax.make_jaxpr` transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note one consequence of this: because JIT compilation is done *without* information
    on the content of the array, control flow statements in the function cannot depend
    on traced values. For example, this fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are variables that you would not like to be traced, they can be marked
    as static for the purposes of JIT compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that calling a JIT-compiled function with a different static argument
    results in re-compilation, so the function still works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Understanding which values and operations will be static and which will be traced
    is a key part of using `jax.jit` effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Static vs Traced Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key Concepts:**'
  prefs: []
  type: TYPE_NORMAL
- en: Just as values can be either static or traced, operations can be static or traced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static operations are evaluated at compile-time in Python; traced operations
    are compiled & evaluated at run-time in XLA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `numpy` for operations that you want to be static; use `jax.numpy` for operations
    that you want to be traced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This distinction between static and traced values makes it important to think
    about how to keep a static value static. Consider this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This fails with an error specifying that a tracer was found instead of a 1D
    sequence of concrete values of integer type. Let’s add some print statements to
    the function to understand why this is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that although `x` is traced, `x.shape` is a static value. However, when
    we use `jnp.array` and `jnp.prod` on this static value, it becomes a traced value,
    at which point it cannot be used in a function like `reshape()` that requires
    a static input (recall: array shapes must be static).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful pattern is to use `numpy` for operations that should be static (i.e.
    done at compile-time), and use `jax.numpy` for operations that should be traced
    (i.e. compiled and executed at run-time). For this function, it might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, a standard convention in JAX programs is to `import numpy as
    np` and `import jax.numpy as jnp` so that both interfaces are available for finer
    control over whether operations are performed in a static matter (with `numpy`,
    once at compile-time) or a traced manner (with `jax.numpy`, optimized at run-time).
  prefs: []
  type: TYPE_NORMAL
