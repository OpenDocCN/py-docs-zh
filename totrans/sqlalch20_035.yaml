- en: Configuring how Relationship Joins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置关系连接
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/join_conditions.html](https://docs.sqlalchemy.org/en/20/orm/join_conditions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/join_conditions.html](https://docs.sqlalchemy.org/en/20/orm/join_conditions.html)
- en: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    will normally create a join between two tables by examining the foreign key relationship
    between the two tables to determine which columns should be compared. There are
    a variety of situations where this behavior needs to be customized.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")通常会通过检查两个表之间的外键关系来创建两个表之间的连接，以确定应该比较哪些列。有各种情况需要定制此行为。'
- en: '## Handling Multiple Join Paths'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '## 处理多个连接路径'
- en: One of the most common situations to deal with is when there are more than one
    foreign key path between two tables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的最常见情况之一是两个表之间存在多个外键路径时。
- en: 'Consider a `Customer` class that contains two foreign keys to an `Address`
    class:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含两个外键到`Address`类的`Customer`类：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above mapping, when we attempt to use it, will produce the error:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用上述映射时，将产生错误：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The above message is pretty long. There are many potential messages that [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") can return, which have been carefully tailored
    to detect a variety of common configurational issues; most will suggest the additional
    configuration that’s needed to resolve the ambiguity or other missing information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上述消息相当长。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")可以返回许多潜在消息，这些消息已经被精心设计用于检测各种常见的配置问题；大多数都会建议需要哪些额外配置来解决模糊或其他缺失的信息。
- en: 'In this case, the message wants us to qualify each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") by instructing for each one which foreign key column
    should be considered, and the appropriate form is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息希望我们通过为每个指定的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")指定应该考虑哪个外键列来修饰每一个，并且适当的形式如下：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Above, we specify the `foreign_keys` argument, which is a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or list of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects which indicate those columns to be considered
    “foreign”, or in other words, the columns that contain a value referring to a
    parent table. Loading the `Customer.billing_address` relationship from a `Customer`
    object will use the value present in `billing_address_id` in order to identify
    the row in `Address` to be loaded; similarly, `shipping_address_id` is used for
    the `shipping_address` relationship. The linkage of the two columns also plays
    a role during persistence; the newly generated primary key of a just-inserted
    `Address` object will be copied into the appropriate foreign key column of an
    associated `Customer` object during a flush.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们指定了`foreign_keys`参数，它是一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的列表，指示要考虑的“外键”列，或者换句话说，包含引用父表的值的列。从`Customer`对象加载`Customer.billing_address`关系将使用`billing_address_id`中的值来标识要加载的`Address`行；类似地，`shipping_address_id`用于`shipping_address`关系。这两列的关联在持久性期间也起到了作用；刚刚插入的`Address`对象的新生成的主键将在刷新期间复制到关联的`Customer`对象的适当外键列中。
- en: 'When specifying `foreign_keys` with Declarative, we can also use string names
    to specify, however it is important that if using a list, the **list is part of
    the string**:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Declarative指定`foreign_keys`时，我们还可以使用字符串名称进行指定，但是如果使用列表，**列表应该是字符串的一部分**是很重要的：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this specific example, the list is not necessary in any case as there’s
    only one [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    we need:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体的例子中，在任何情况下列表都是不必要的，因为我们只需要一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'When passed as a Python-evaluable string, the [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function. **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**. See [Evaluation of relationship
    arguments](extensions/declarative/relationships.html#declarative-relationship-eval)
    for details on declarative evaluation of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments.  ## Specifying Alternate Join Conditions'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为 Python 可执行字符串传递时，[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") 参数将使用 Python 的 `eval()` 函数进行解释。**请勿将不受信任的输入传递给此字符串**。详细信息请参见[关系参数的评估](extensions/declarative/relationships.html#declarative-relationship-eval)。
- en: The default behavior of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") when constructing a join is that it equates the
    value of primary key columns on one side to that of foreign-key-referring columns
    on the other. We can change this criterion to be anything we’d like using the
    [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") argument, as well as the [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") argument in the case when a “secondary” table is
    used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    在构建连接时的默认行为是将一侧的主键列的值等同于另一侧的外键引用列的值。我们可以使用 [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 参数来更改此条件，以及在使用“次要”表时，还可以使用 [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") 参数。'
- en: 'In the example below, using the `User` class as well as an `Address` class
    which stores a street address, we create a relationship `boston_addresses` which
    will only load those `Address` objects which specify a city of “Boston”:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用 `User` 类以及存储街道地址的 `Address` 类来创建一个关系 `boston_addresses`，它将仅加载指定城市为“波士顿”的
    `Address` 对象：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within this string SQL expression, we made use of the [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") conjunction construct to establish two distinct
    predicates for the join condition - joining both the `User.id` and `Address.user_id`
    columns to each other, as well as limiting rows in `Address` to just `city='Boston'`.
    When using Declarative, rudimentary SQL functions like [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") are automatically available in the evaluated
    namespace of a string [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") argument.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在此字符串 SQL 表达式中，我们使用了 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") 连接构造来为连接条件建立两个不同的谓词 - 将 `User.id` 和 `Address.user_id`
    列相互连接，同时将 `Address` 中的行限制为只有 `city='Boston'`。在使用声明式时，诸如 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") 这样的基本 SQL 函数会自动在字符串 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 参数的评估命名空间中可用。
- en: Warning
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a Python-evaluable string, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function. **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**. See [Evaluation of relationship
    arguments](extensions/declarative/relationships.html#declarative-relationship-eval)
    for details on declarative evaluation of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为 Python 可执行字符串传递时，[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 参数将使用 Python 的 `eval()` 函数进行解释。**请勿将不受信任的输入传递给此字符串**。详细信息请参见[关系参数的评估](extensions/declarative/relationships.html#declarative-relationship-eval)。
- en: 'The custom criteria we use in a [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") is generally only significant when SQLAlchemy is
    rendering SQL in order to load or represent this relationship. That is, it’s used
    in the SQL statement that’s emitted in order to perform a per-attribute lazy load,
    or when a join is constructed at query time, such as via `Select.join()`, or via
    the eager “joined” or “subquery” styles of loading. When in-memory objects are
    being manipulated, we can place any `Address` object we’d like into the `boston_addresses`
    collection, regardless of what the value of the `.city` attribute is. The objects
    will remain present in the collection until the attribute is expired and re-loaded
    from the database where the criterion is applied. When a flush occurs, the objects
    inside of `boston_addresses` will be flushed unconditionally, assigning value
    of the primary key `user.id` column onto the foreign-key-holding `address.user_id`
    column for each row. The `city` criteria has no effect here, as the flush process
    only cares about synchronizing primary key values into referencing foreign key
    values.  ## Creating Custom Foreign Conditions'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")中使用的自定义标准通常只在SQLAlchemy渲染SQL以加载或表示此关系时才重要。也就是说，它用于在执行每个属性的延迟加载时发出的SQL语句中，或者在查询时构造联接时，例如通过`Select.join()`或通过渴望的“joined”或“subquery”加载样式。当操作内存中的对象时，我们可以将任何我们想要的`Address`对象放入`boston_addresses`集合中，而不管`.city`属性的值是什么。这些对象将一直保留在集合中，直到属性过期并重新从应用准则的数据库中加载为止。当发生刷新时，`boston_addresses`内的对象将被无条件地刷新，将主键`user.id`列的值分配给每一行的持有外键的`address.user_id`列。在这里，`city`标准没有影响，因为刷新过程只关心将主键值同步到引用外键值中。##
    创建自定义外键条件
- en: Another element of the primary join condition is how those columns considered
    “foreign” are determined. Usually, some subset of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will specify [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), or otherwise be part of a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that’s relevant to the join condition.
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    looks to this foreign key status as it decides how it should load and persist
    data for this relationship. However, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") argument can be used to create a join condition
    that doesn’t involve any “schema” level foreign keys. We can combine [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") along with [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") and [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship") explicitly in order to establish such a join.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 主要连接条件的另一个元素是如何确定那些被认为是“外部”的列的。通常，一些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的子集将指定[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")，或者否则将是与连接条件相关的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")的一部分。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")查找此外键状态，因为它决定了它应该如何加载和持久化此关系的数据。然而，[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")参数可以用来创建不涉及任何“架构”级外键的连接条件。我们可以结合[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")以及[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")和[`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship")显式地建立这样一个连接。
- en: 'Below, a class `HostEntry` joins to itself, equating the string `content` column
    to the `ip_address` column, which is a PostgreSQL type called `INET`. We need
    to use [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    in order to cast one side of the join to the type of the other:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，一个名为`HostEntry`的类与自身连接，将字符串`content`列与`ip_address`列相等，后者是一种名为`INET`的PostgreSQL类型。我们需要使用[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")来将连接的一侧转换为另一侧的类型：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The above relationship will produce a join like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述关系将产生如下连接：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An alternative syntax to the above is to use the [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") [annotations](../glossary.html#term-annotations), inline
    within the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression. This syntax represents the annotations
    that [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    normally applies by itself to the join condition given the [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") and [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship") arguments. These functions may be more succinct
    when an explicit join condition is present, and additionally serve to mark exactly
    the column that is “foreign” or “remote” independent of whether that column is
    stated multiple times or within complex SQL expressions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的另一种替代语法是在[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")表达式内联使用[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")和[`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")[注释](../glossary.html#term-annotations)。此语法表示了[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")通常自动应用于连接条件的注释，给定了[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")和[`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship")参数。当存在显式连接条件时，这些函数可能更加简洁，并且还标记了“外键”或“远程”列的确切位置，无论该列是否多次声明或在复杂的SQL表达式中声明：
- en: '[PRE8]  ## Using custom operators in join conditions'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]  ## 在连接条件中使用自定义运算符'
- en: 'Another use case for relationships is the use of custom operators, such as
    PostgreSQL’s “is contained within” `<<` operator when joining with types such
    as [`INET`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INET "sqlalchemy.dialects.postgresql.INET")
    and [`CIDR`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.CIDR "sqlalchemy.dialects.postgresql.CIDR").
    For custom boolean operators we use the [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于关系的另一个用例是使用自定义运算符，例如在与[`INET`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET")和[`CIDR`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR")等类型结合时，使用PostgreSQL的“包含于”`<<`运算符。对于自定义布尔运算符，我们使用[`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")函数：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A comparison like the above may be used directly with [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") when constructing a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类似上述的比较可以直接在构建[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，与[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")一起使用：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Above, a query such as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询如下：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Will render as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE12]  ## Custom operators based on SQL functions'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]  ## 基于SQL函数的自定义运算符'
- en: 'A variant to the use case for [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") is when we aren’t using an operator,
    but a SQL function. The typical example of this use case is the PostgreSQL PostGIS
    functions however any SQL function on any database that resolves to a binary condition
    may apply. To suit this use case, the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") method can modify any
    SQL function, such as those invoked from the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace, to indicate to the ORM that the function
    produces a comparison of two expressions. The below example illustrates this with
    the [Geoalchemy2](https://geoalchemy-2.readthedocs.io/) library:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op")的用例的一种变体是当我们不使用运算符，而是使用SQL函数时。这种用例的典型示例是PostgreSQL
    PostGIS函数，但任何数据库中解析为二进制条件的SQL函数都可以应用。为了适应这种用例，[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison")方法可以修改任何SQL函数，例如从[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")命名空间调用的函数，以指示ORM函数生成两个表达式的比较。下面的示例用[Geoalchemy2](https://geoalchemy-2.readthedocs.io/)库说明了这一点：'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Above, the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") indicates that the `func.ST_Contains()`
    SQL function is comparing the `Polygon.geom` and `Point.geom` expressions. The
    [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign "sqlalchemy.orm.foreign")
    annotation additionally notes which column takes on the “foreign key” role in
    this particular relationship.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison")表明`func.ST_Contains()`
    SQL函数正在比较`Polygon.geom`和`Point.geom`表达式。[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")注释另外指出了在此特定关系中哪个列承担“外键”角色。
- en: 'New in version 1.3: Added [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison").  ## Overlapping Foreign
    Keys'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3版本中的新增功能：添加了[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison")。## 重叠的外键
- en: A rare scenario can arise when composite foreign keys are used, such that a
    single column may be the subject of more than one column referred to via foreign
    key constraint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用复合外键时，可能会出现罕见的情况，使得单个列可能是通过外键约束引用的多个列的主题。
- en: 'Consider an (admittedly complex) mapping such as the `Magazine` object, referred
    to both by the `Writer` object and the `Article` object using a composite primary
    key scheme that includes `magazine_id` for both; then to make `Article` refer
    to `Writer` as well, `Article.magazine_id` is involved in two separate relationships;
    `Article.magazine` and `Article.writer`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个（诚然复杂的）映射，如`Magazine`对象，由`Writer`对象和`Article`对象使用包含`magazine_id`的复合主键方案引用；然后为了使`Article`也引用`Writer`，`Article.magazine_id`涉及到两个单独的关系；`Article.magazine`和`Article.writer`：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the above mapping is configured, we will see this warning emitted:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 配置上述映射后，我们将看到发出此警告：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What this refers to originates from the fact that `Article.magazine_id` is the
    subject of two different foreign key constraints; it refers to `Magazine.id` directly
    as a source column, but also refers to `Writer.magazine_id` as a source column
    in the context of the composite key to `Writer`. If we associate an `Article`
    with a particular `Magazine`, but then associate the `Article` with a `Writer`
    that’s associated with a *different* `Magazine`, the ORM will overwrite `Article.magazine_id`
    non-deterministically, silently changing which magazine to which we refer; it
    may also attempt to place NULL into this column if we de-associate a `Writer`
    from an `Article`. The warning lets us know this is the case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是`Article.magazine_id`是两个不同外键约束的主题的事实；它直接引用`Magazine.id`作为源列，但也在`Writer`的复合键的上下文中引用`Writer.magazine_id`作为源列。如果我们将`Article`与特定的`Magazine`关联起来，然后将`Article`与与*不同*`Magazine`关联的`Writer`关联起来，ORM将非确定性地覆盖`Article.magazine_id`，在不通知的情况下更改我们引用的杂志；如果我们将`Writer`从`Article`中解除关联，它还可能尝试将NULL放入此列。警告让我们知道这是这种情况。
- en: 'To solve this, we need to break out the behavior of `Article` to include all
    three of the following features:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要将`Article`的行为分解，包括以下三个特性：
- en: '`Article` first and foremost writes to `Article.magazine_id` based on data
    persisted in the `Article.magazine` relationship only, that is a value copied
    from `Magazine.id`.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`Article`根据仅在`Article.magazine`关系中持久化的数据写入`Article.magazine_id`，即从`Magazine.id`复制的值。
- en: '`Article` can write to `Article.writer_id` on behalf of data persisted in the
    `Article.writer` relationship, but only the `Writer.id` column; the `Writer.magazine_id`
    column should not be written into `Article.magazine_id` as it ultimately is sourced
    from `Magazine.id`.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Article`可以代表在`Article.writer`关系中持久化的数据写入`Article.writer_id`，但仅限于`Writer.id`列；`Writer.magazine_id`列不应写入`Article.magazine_id`，因为它最终源自`Magazine.id`。'
- en: '`Article` takes `Article.magazine_id` into account when loading `Article.writer`,
    even though it *doesn’t* write to it on behalf of this relationship.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当加载`Article.writer`时，`Article`会考虑`Article.magazine_id`，尽管它在此关系中*不会*向其写入。
- en: 'To get just #1 and #2, we could specify only `Article.writer_id` as the “foreign
    keys” for `Article.writer`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得仅#1和#2，我们可以仅指定`Article.writer_id`作为`Article.writer`的“外键”：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, this has the effect of `Article.writer` not taking `Article.magazine_id`
    into account when querying against `Writer`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致`Article.writer`在与`Writer`查询时不考虑`Article.magazine_id`：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Therefore, to get at all of #1, #2, and #3, we express the join condition as
    well as which columns to be written by combining [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") fully, along with either the [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") argument, or more succinctly by annotating with
    [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign "sqlalchemy.orm.foreign"):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得所有#1、#2和#3，我们通过完全组合[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")参数，或者更简洁地通过用[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")注释来表达连接条件以及要写入的列：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Non-relational Comparisons / Materialized Path
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系对比/实现路径
- en: Warning
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: this section details an experimental feature.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分详细介绍了一个实验性功能。
- en: Using custom expressions means we can produce unorthodox join conditions that
    don’t obey the usual primary/foreign key model. One such example is the materialized
    path pattern, where we compare strings for overlapping path tokens in order to
    produce a tree structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义表达式意味着我们可以生成不遵循通常的主键/外键模型的非正统连接条件。其中一个例子是实现路径模式，其中我们比较字符串以产生重叠路径标记，以便生成树结构。
- en: 'Through careful use of [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote"), we can build a relationship that effectively produces
    a rudimentary materialized path system. Essentially, when [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") are on the *same* side of the comparison expression,
    the relationship is considered to be “one to many”; when they are on *different*
    sides, the relationship is considered to be “many to one”. For the comparison
    we’ll use here, we’ll be dealing with collections so we keep things configured
    as “one to many”:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精心使用[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign "sqlalchemy.orm.foreign")和[`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")，我们可以构建一个有效地产生基本的物化路径系统的关系。基本上，当[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")和[`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")在*相同*的比较表达式的一侧时，关系被视为“一对多”；当它们在*不同*的一侧时，关系被视为“多对一”。对于我们将在此处使用的比较，我们将处理集合，因此保持配置为“一对多”：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Above, if given an `Element` object with a path attribute of `"/foo/bar2"`,
    we seek for a load of `Element.descendants` to look like:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况下，如果给定一个具有路径属性为`"/foo/bar2"`的`Element`对象，我们寻求加载`Element.descendants`以如下形式：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '## Self-Referential Many-to-Many Relationship'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '## 自引用多对多关系'
- en: See also
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: This section documents a two-table variant of the “adjacency list” pattern,
    which is documented at [Adjacency List Relationships](self_referential.html#self-referential).
    Be sure to review the self-referential querying patterns in subsections [Self-Referential
    Query Strategies](self_referential.html#self-referential-query) and [Configuring
    Self-Referential Eager Loading](self_referential.html#self-referential-eager-loading)
    which apply equally well to the mapping pattern discussed here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节记录了“邻接列表”模式的两表变体，该模式在[邻接列表关系](self_referential.html#self-referential)有所描述。务必查看子节[自引用查询策略](self_referential.html#self-referential-query)和[配置自引用急切加载](self_referential.html#self-referential-eager-loading)，这两者同样适用于此处讨论的映射模式。
- en: 'Many to many relationships can be customized by one or both of [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") - the latter is significant for a relationship
    that specifies a many-to-many reference using the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument. A common situation which involves the
    usage of [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") is when establishing a many-to-many relationship
    from a class to itself, as shown below:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系可以通过[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")中的一个或两个进行自定义 - 后者对于使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数指定多对多引用的关系非常重要。一个常见的情况涉及使用[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")来建立从一个类到自身的多对多关系，如下所示：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Where above, SQLAlchemy can’t know automatically which columns should connect
    to which for the `right_nodes` and `left_nodes` relationships. The [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments establish how we’d like to join to the
    association table. In the Declarative form above, as we are declaring these conditions
    within the Python block that corresponds to the `Node` class, the `id` variable
    is available directly as the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object we wish to join with.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，SQLAlchemy 无法自动知道哪些列应该连接到`right_nodes`和`left_nodes`关系。[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数确定我们希望如何连接到关联表。在上面的声明形式中，由于我们正在声明这些条件，因此`id`变量直接可用作我们希望与之连接的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。
- en: 'Alternatively, we can define the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments using strings, which is suitable in the
    case that our configuration does not have either the `Node.id` column object available
    yet or the `node_to_node` table perhaps isn’t yet available. When referring to
    a plain [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object in a declarative string, we use the string name of the table as it is present
    in the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData"):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用字符串来定义[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数，这在我们的配置中可能没有`Node.id`列对象可用，或者`node_to_node`表可能还没有可用时很合适。当在声明字符串中引用普通的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象时，我们使用表的字符串名称，就像它在[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")中一样：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Warning
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a Python-evaluable string, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments are interpreted using Python’s `eval()`
    function. **DO NOT PASS UNTRUSTED INPUT TO THESE STRINGS**. See [Evaluation of
    relationship arguments](extensions/declarative/relationships.html#declarative-relationship-eval)
    for details on declarative evaluation of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为 Python 可评估字符串传递时，[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数使用 Python 的`eval()`函数进行解释。**不要将不受信任的输入传递给这些字符串**。有关声明式评估[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")参数的详细信息，请参阅[关系参数的评估](extensions/declarative/relationships.html#declarative-relationship-eval)。
- en: 'A classical mapping situation here is similar, where `node_to_node` can be
    joined to `node.c.id`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处的经典映射情况类似，其中`node_to_node`可以连接到`node.c.id`：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that in both examples, the [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") keyword specifies a `left_nodes` backref - when
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    creates the second relationship in the reverse direction, it’s smart enough to
    reverse the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在两个示例中，[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")关键字指定了一个`left_nodes`的backref - 当[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")在相反方向创建第二个关系时，它足够智能以反转[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数。
- en: See also
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Adjacency List Relationships](self_referential.html#self-referential) - single
    table version'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[邻接列表关系](self_referential.html#self-referential) - 单表版本'
- en: '[Self-Referential Query Strategies](self_referential.html#self-referential-query)
    - tips on querying with self-referential mappings'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自引用查询策略](self_referential.html#self-referential-query) - 关于使用自引用映射进行查询的提示'
- en: '[Configuring Self-Referential Eager Loading](self_referential.html#self-referential-eager-loading)
    - tips on eager loading with self- referential mapping  ## Composite “Secondary”
    Joins'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[配置自引用急切加载](self_referential.html#self-referential-eager-loading) - 使用自引用映射进行急切加载的提示  ##
    复合“次要”连接'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section features far edge cases that are somewhat supported by SQLAlchemy,
    however it is recommended to solve problems like these in simpler ways whenever
    possible, by using reasonable relational layouts and / or [in-Python attributes](mapped_attributes.html#mapper-hybrids).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了SQLAlchemy支持的一些边缘案例，但建议尽可能以更简单的方式解决这类问题，例如使用合理的关系布局和/或[Python属性内部](mapped_attributes.html#mapper-hybrids)。
- en: Sometimes, when one seeks to build a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") between two tables there is a need for more than
    just two or three tables to be involved in order to join them. This is an area
    of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    where one seeks to push the boundaries of what’s possible, and often the ultimate
    solution to many of these exotic use cases needs to be hammered out on the SQLAlchemy
    mailing list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当需要在两个表之间建立[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，需要涉及更多的表才能将它们连接起来。这是一种[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的领域，人们试图推动可能性的边界，而这类奇特用例的最终解决方案通常需要在SQLAlchemy邮件列表上讨论出来。
- en: 'In more recent versions of SQLAlchemy, the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter can be used in some of these cases in
    order to provide a composite target consisting of multiple tables. Below is an
    example of such a join condition (requires version 0.9.2 at least to function
    as is):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的SQLAlchemy版本中，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数可以在某些情况下使用，以提供由多个表组成的复合目标。下面是这种连接条件的示例（至少需要版本0.9.2才能正常运行）：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the above example, we provide all three of [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"), [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship"), and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship"), in the declarative style referring to the named
    tables `a`, `b`, `c`, `d` directly. A query from `A` to `D` looks like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们直接引用了命名为`a`、`b`、`c`、`d`的表，提供了[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")、[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")这三个声明式样式的参数。从`A`到`D`的查询如下所示：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above example, we take advantage of being able to stuff multiple tables
    into a “secondary” container, so that we can join across many tables while still
    keeping things “simple” for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), in that there’s just “one” table on both the “left”
    and the “right” side; the complexity is kept within the middle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们利用能够将多个表放入“secondary”容器的优势，以便我们可以跨多个表进行连接，同时保持对[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的“简化”，在这种情况下，“左”和“右”两侧都只有“一个”表；复杂性保持在中间。
- en: Warning
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: A relationship like the above is typically marked as `viewonly=True`, using
    [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship"), and should be considered as read-only. While there
    are sometimes ways to make relationships like the above writable, this is generally
    complicated and error prone.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像上面的关系通常标记为`viewonly=True`，使用[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")，应视为只读。虽然有时可以使类似上面的关系可写，但这通常很复杂且容易出错。
- en: See also
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Notes on using the viewonly relationship parameter](#relationship-viewonly-notes)  ##
    Relationship to Aliased Class'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用viewonly关系参数的注意事项](#relationship-viewonly-notes)  ## 别名类的关系'
- en: In the previous section, we illustrated a technique where we used [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") in order to place additional tables within a join
    condition. There is one complex join case where even this technique is not sufficient;
    when we seek to join from `A` to `B`, making use of any number of `C`, `D`, etc.
    in between, however there are also join conditions between `A` and `B` *directly*.
    In this case, the join from `A` to `B` may be difficult to express with just a
    complex [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") condition, as the intermediary tables may need
    special handling, and it is also not expressible with a [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") object, since the `A->secondary->B` pattern does
    not support any references between `A` and `B` directly. When this **extremely
    advanced** case arises, we can resort to creating a second mapping as a target
    for the relationship. This is where we use [`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") in order to make a mapping to a class that
    includes all the additional tables we need for this join. In order to produce
    this mapper as an “alternative” mapping for our class, we use the [`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function to produce the new construct, then use [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") against the object as though it were a plain mapped
    class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们介绍了一种技术，其中我们使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")来在连接条件中放置额外的表。有一种复杂的连接情况，即使使用这种技术也不够；当我们试图从`A`连接到`B`，并在其中使用任意数量的`C`、`D`等，但`A`和`B`之间也直接有连接条件时。在这种情况下，仅仅使用一个复杂的[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")条件可能难以表达从`A`到`B`的连接，因为中间表可能需要特殊处理，并且也不能用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")对象来表达，因为`A->secondary->B`模式不支持`A`和`B`之间的任何引用。当出现这种**极其复杂**的情况时，我们可以采用创建第二个映射作为关系目标的方法。这就是我们使用[`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")来制作一个包含我们所需的所有额外表的类的映射。为了将此映射作为我们类的“替代”映射生成，我们使用[`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")函数生成新的构造，然后针对该对象使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，就像它是一个普通的映射类一样。
- en: 'Below illustrates a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") with a simple join from `A` to `B`, however the
    primaryjoin condition is augmented with two additional entities `C` and `D`, which
    also must have rows that line up with the rows in both `A` and `B` simultaneously:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面说明了一个从`A`到`B`的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，其中主要连接条件增加了两个额外的实体`C`和`D`，这两个实体必须同时与`A`和`B`中的行对齐：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the above mapping, a simple join looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，简单的连接如下所示：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Integrating AliasedClass Mappings with Typing and Avoiding Early Mapper Configuration
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将别名类映射与类型和避免早期映射器配置集成
- en: The creation of the [`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct against a mapped class forces the [`configure_mappers()`](mapping_api.html#sqlalchemy.orm.configure_mappers
    "sqlalchemy.orm.configure_mappers") step to proceed, which will resolve all current
    classes and their relationships. This may be problematic if unrelated mapped classes
    needed by the current mappings have not yet been declared, or if the configuration
    of the relationship itself needs access to as-yet undeclared classes. Additionally,
    SQLAlchemy’s Declarative pattern works with Python typing most effectively when
    relationships are declared up front.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对映射类使用[`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")构造会强制执行[`configure_mappers()`](mapping_api.html#sqlalchemy.orm.configure_mappers
    "sqlalchemy.orm.configure_mappers")步骤，该步骤将解析所有当前类及其关系。如果当前映射需要但尚未声明的不相关映射类，或者如果关系本身的配置需要访问尚未声明的类，则可能会出现问题。此外，当关系提前声明时，SQLAlchemy的声明模式与Python类型最有效地配合使用。
- en: 'To organize the construction of the relationship to work with these issues,
    a configure level event hook like [`MapperEvents.before_mapper_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured") may be used, which will
    invoke the configuration code only when all mappings are ready for configuration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织关系的构建以解决这些问题，可以使用像[`MapperEvents.before_mapper_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured")这样的配置级事件钩子，该钩子仅在所有映射准备好进行配置时才会调用配置代码：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Above, the function `_configure_ab_relationship()` will be invoked only when
    a fully configured version of `A` is requested, at which point the classes `B`,
    `D` and `C` would be available.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，函数`_configure_ab_relationship()`仅在请求完全配置的`A`版本时调用，此时类`B`、`D`和`C`将可用。
- en: 'For an approach that integrates with inline typing, a similar technique can
    be used to effectively generate a “singleton” creation pattern for the aliased
    class where it is late-initialized as a global variable, which can then be used
    in the relationship inline:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与内联类型配合使用的方法，可以使用类似的技术有效地生成用于别名类的“单例”创建模式，其中它作为全局变量进行了延迟初始化，然后可以在关系内联中使用：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the AliasedClass target in Queries
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在查询中使用AliasedClass目标
- en: 'In the previous example, the `A.b` relationship refers to the `B_viacd` entity
    as the target, and **not** the `B` class directly. To add additional criteria
    involving the `A.b` relationship, it’s typically necessary to reference the `B_viacd`
    directly rather than using `B`, especially in a case where the target entity of
    `A.b` is to be transformed into an alias or a subquery. Below illustrates the
    same relationship using a subquery, rather than a join:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`A.b`关系指的是`B_viacd`实体作为目标，而**不是**直接的`B`类。要添加涉及`A.b`关系的额外条件，通常需要直接引用`B_viacd`，而不是使用`B`，特别是在`A.b`的目标实体要转换为别名或子查询的情况下。下面用子查询而不是连接说明了相同的关系：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A query using the above `A.b` relationship will render a subquery:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述`A.b`关系的查询将呈现为一个子查询：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to add additional criteria based on the `A.b` join, we must do so
    in terms of `B_viacd_subquery` rather than `B` directly:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要基于`A.b`连接添加额外的条件，则必须根据`B_viacd_subquery`而不是直接根据`B`来做：
- en: '[PRE32]  ## Row-Limited Relationships with Window Functions'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]  ## 使用窗口函数限制行关系'
- en: 'Another interesting use case for relationships to [`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") objects are situations where the relationship
    needs to join to a specialized SELECT of any form. One scenario is when the use
    of a window function is desired, such as to limit how many rows should be returned
    for a relationship. The example below illustrates a non-primary mapper relationship
    that will load the first ten items for each collection:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与[`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass "sqlalchemy.orm.util.AliasedClass")对象关系的有趣用例是在关系需要连接到任意形式的专门
    SELECT 的情况下。一种情况是当需要使用窗口函数时，例如限制应返回多少行以供关系使用。下面的示例说明了一个非主映射器关系，它将为每个集合加载前十个项目：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use the above `partitioned_bs` relationship with most of the loader
    strategies, such as [`selectinload()`](queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将上述`partitioned_bs`关系与大多数加载器策略一起使用，例如[`selectinload()`](queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Where above, the “selectinload” query looks like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，"selectinload" 查询如下所示：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Above, for each matching primary key in “a”, we will get the first ten “bs”
    as ordered by “b.id”. By partitioning on “a_id” we ensure that each “row number”
    is local to the parent “a_id”.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况下，对于“a”中的每个匹配主键，我们将按“b.id”排序获取前十个“bs”。通过在“a_id”上进行分区，我们确保每个“行号”都是相对于父“a_id”的局部的。
- en: 'Such a mapping would ordinarily also include a “plain” relationship from “A”
    to “B”, for persistence operations as well as when the full set of “B” objects
    per “A” is desired.  ## Building Query-Enabled Properties'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的映射通常也会包括从“A”到“B”的“普通”关系，用于持久性操作以及当需要每个“A”的完整“B”对象集合时。## 构建查询可用的属性
- en: 'Very ambitious custom join conditions may fail to be directly persistable,
    and in some cases may not even load correctly. To remove the persistence part
    of the equation, use the flag [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), which establishes it as a read-only attribute
    (data written to the collection will be ignored on flush()). However, in extreme
    cases, consider using a regular Python property in conjunction with [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 非常雄心勃勃的自定义连接条件可能无法直接持久化，并且在某些情况下甚至可能无法正确加载。要删除等式的持久性部分，请在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上使用标志[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")，将其建立为只读属性（写入到集合的数据将在刷新时被忽略）。然而，在极端情况下，考虑与[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")一起使用普通的 Python 属性，如下所示：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In other cases, the descriptor can be built to make use of existing in-Python
    data. See the section on [Using Descriptors and Hybrids](mapped_attributes.html#mapper-hybrids)
    for more general discussion of special Python attributes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，描述符可以构建以利用现有的 Python 数据。有关使用描述符和混合体的更一般讨论，请参见[使用描述符和混合体](mapped_attributes.html#mapper-hybrids)部分。
- en: See also
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Using Descriptors and Hybrids](mapped_attributes.html#mapper-hybrids)  ##
    Notes on using the viewonly relationship parameter'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用描述符和混合体](mapped_attributes.html#mapper-hybrids)  ## 关于使用 viewonly 关系参数的注意事项'
- en: The [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") parameter when applied to a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct indicates that this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") will not take part in any ORM [unit of work](../glossary.html#term-unit-of-work)
    operations, and additionally that the attribute does not expect to participate
    within in-Python mutations of its represented collection. This means that while
    the viewonly relationship may refer to a mutable Python collection like a list
    or set, making changes to that list or set as present on a mapped instance will
    have **no effect** on the ORM flush process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")构造时，[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")参数指示这个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")不会参与任何ORM [工作单元](../glossary.html#term-unit-of-work)操作，并且该属性不希望在其表示的集合的Python变异中参与。这意味着虽然只读关系可能引用一个可变的Python集合，如列表或集合，但对该列表或集合进行更改，如在映射实例上存在的那样，对ORM刷新过程**没有影响**。
- en: 'To explore this scenario consider this mapping:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索这种情况，请考虑这种映射：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The following sections will note different aspects of this configuration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将注意这种配置的不同方面。
- en: In-Python mutations including backrefs are not appropriate with viewonly=True
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包括反向引用的Python中的变异与viewonly=True不适用
- en: 'The above mapping targets the `User.current_week_tasks` viewonly relationship
    as the [backref](../glossary.html#term-backref) target of the `Task.user` attribute.
    This is not currently flagged by SQLAlchemy’s ORM configuration process, however
    is a configuration error. Changing the `.user` attribute on a `Task` will not
    affect the `.current_week_tasks` attribute:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将`User.current_week_tasks`只读关系作为`Task.user`属性的[反向引用](../glossary.html#term-backref)目标。这目前并未被SQLAlchemy的ORM配置过程标记，但这是一个配置错误。改变`Task`上的`.user`属性不会影响`.current_week_tasks`属性：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is another parameter called [`relationship.sync_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.sync_backrefs
    "sqlalchemy.orm.relationship") which can be turned on here to allow `.current_week_tasks`
    to be mutated in this case, however this is not considered to be a best practice
    with a viewonly relationship, which instead should not be relied upon for in-Python
    mutations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个参数叫做[`relationship.sync_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.sync_backrefs
    "sqlalchemy.orm.relationship")，可以在这里打开，以允许在这种情况下对`.current_week_tasks`进行变异，然而这并不被认为是最佳实践，对于一个只读关系，不应该依赖于Python中的变异。
- en: In this mapping, backrefs can be configured between `User.all_tasks` and `Task.user`,
    as these are both not viewonly and will synchronize normally.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种映射中，可以在`User.all_tasks`和`Task.user`之间配置反向引用，因为这两者都不是只读的，将正常同步。
- en: Beyond the issue of backref mutations being disabled for viewonly relationships,
    plain changes to the `User.all_tasks` collection in Python are also not reflected
    in the `User.current_week_tasks` collection until changes have been flushed to
    the database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了禁用只读关系的反向引用变异问题外，Python中对`User.all_tasks`集合的普通更改也不会反映在`User.current_week_tasks`集合中，直到更改已刷新到数据库。
- en: 'Overall, for a use case where a custom collection should respond immediately
    to in-Python mutations, the viewonly relationship is generally not appropriate.
    A better approach is to use the [Hybrid Attributes](extensions/hybrid.html) feature
    of SQLAlchemy, or for instance-only cases to use a Python `@property`, where a
    user-defined collection that is generated in terms of the current Python instance
    can be implemented. To change our example to work this way, we repair the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter on `Task.user` to reference `User.all_tasks`,
    and then illustrate a simple `@property` that will deliver results in terms of
    the immediate `User.all_tasks` collection:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，对于一个需要立即响应Python中的变异的自定义集合的用例，只读关系通常不合适。更好的方法是使用SQLAlchemy的[混合属性](extensions/hybrid.html)功能，或者对于仅实例情况，使用Python的`@property`，其中可以实现一个根据当前Python实例生成的用户定义集合。要将我们的示例更改为这种方式工作，我们修复`Task.user`上的[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数，引用`User.all_tasks`，然后演示一个简单的`@property`，将以立即`User.all_tasks`集合的形式提供结果：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using an in-Python collection calculated on the fly each time, we are guaranteed
    to have the correct answer at all times, without the need to use a database at
    all:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在 Python 中每次动态计算的集合，我们保证始终有正确的答案，而无需使用数据库：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: viewonly=True collections / attributes do not get re-queried until expired
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: viewonly=True 的集合/属性直到过期才会重新查询
- en: Continuing with the original viewonly attribute, if we do in fact make changes
    to the `User.all_tasks` collection on a [persistent](../glossary.html#term-persistent)
    object, the viewonly collection can only show the net result of this change after
    **two** things occur. The first is that the change to `User.all_tasks` is [flushed](../glossary.html#term-flushed),
    so that the new data is available in the database, at least within the scope of
    the local transaction. The second is that the `User.current_week_tasks` attribute
    is [expired](../glossary.html#term-expired) and reloaded via a new SQL query to
    the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用原始的 viewonly 属性，如果我们确实对 [persistent](../glossary.html#term-persistent) 对象上的
    `User.all_tasks` 集合进行更改，则在 **两个** 事情发生之后，viewonly 集合只能显示此更改的净结果。第一个是将更改刷新到 `User.all_tasks`
    中，以便新数据在数据库中可用，至少在本地事务的范围内是如此。第二个是 `User.current_week_tasks` 属性被 [expired](../glossary.html#term-expired)
    并通过对数据库进行新的 SQL 查询重新加载。
- en: 'To support this requirement, the simplest flow to use is one where the **viewonly
    relationship is consumed only in operations that are primarily read only to start
    with**. Such as below, if we retrieve a `User` fresh from the database, the collection
    will be current:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一需求，最简单的流程是仅在主要是只读操作中使用 **viewonly 关系**。例如，如果我们从数据库中检索到一个新的 `User`，那么集合将是当前的：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we make modifications to `u1.all_tasks`, if we want to see these changes
    reflected in the `u1.current_week_tasks` viewonly relationship, these changes
    need to be flushed and the `u1.current_week_tasks` attribute needs to be expired,
    so that it will [lazy load](../glossary.html#term-lazy-load) on next access. The
    simplest approach to this is to use [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), keeping the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter set at its default of `True`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对 `u1.all_tasks` 进行修改时，如果想要在 `u1.current_week_tasks` 视图关系中看到这些更改，这些更改需要被刷新，并且
    `u1.current_week_tasks` 属性需要过期，以便在下一次访问时进行 [惰性加载](../glossary.html#term-lazy-load)。最简单的方法是使用
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")，保持
    [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") 参数设置为其默认值 `True`：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Above, the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") flushed the changes to `u1.all_tasks` to the
    database, then expired all objects, so that when we accessed `u1.current_week_tasks`,
    a :term:` lazy load` occurred which fetched the contents for this attribute freshly
    from the database.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，对 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    的调用将更改刷新到了数据库中的 `u1.all_tasks`，然后使所有对象过期，因此当我们访问 `u1.current_week_tasks` 时，会发生
    :term:`惰性加载`，从数据库中新鲜获取此属性的内容。
- en: 'To intercept operations without actually committing the transaction, the attribute
    needs to be explicitly [expired](../glossary.html#term-expired) first. A simplistic
    way to do this is to just call it directly. In the example below, [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") sends pending changes to the database, then [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") is used to expire the `u1.current_week_tasks`
    collection so that it re-fetches on next access:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截操作而不实际提交事务，需要先显式 [expired](../glossary.html#term-expired) 该属性。一种简单的方法是直接调用它。在下面的示例中，[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 将挂起的更改发送到数据库，然后使用 [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 来过期 `u1.current_week_tasks` 集合，以便在下一次访问时重新获取：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can in fact skip the call to [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush"), assuming a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that keeps [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") at its default value of `True`, as the expired `current_week_tasks`
    attribute will trigger autoflush when accessed after expiration:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以跳过对[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")的调用，假设一个保持[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")为其默认值`True`的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，因为过期的`current_week_tasks`属性在过期后访问时将触发自动刷新：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Continuing with the above approach to something more elaborate, we can apply
    the expiration programmatically when the related `User.all_tasks` collection changes,
    using [event hooks](../core/event.html). This an **advanced technique**, where
    simpler architectures like `@property` or sticking to read-only use cases should
    be examined first. In our simple example, this would be configured as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用上述方法进行更详细的处理，我们可以在相关的`User.all_tasks`集合发生变化时通过[event hooks](../core/event.html)进行程序化过期。这是一种**高级技术**，应该首先检查更简单的架构，比如`@property`或坚持只读用例。在我们简单的示例中，这将被配置为：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the above hooks, mutation operations are intercepted and result in the
    `User.current_week_tasks` collection to be expired automatically:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述钩子，突变操作被拦截并导致`User.current_week_tasks`集合自动过期：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The [`AttributeEvents`](events.html#sqlalchemy.orm.AttributeEvents "sqlalchemy.orm.AttributeEvents")
    event hooks used above are also triggered by backref mutations, so with the above
    hooks a change to `Task.user` is also intercepted:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述使用的[`AttributeEvents`](events.html#sqlalchemy.orm.AttributeEvents "sqlalchemy.orm.AttributeEvents")事件钩子也会被backref突变触发，因此，使用上述钩子会拦截对`Task.user`的更改：
- en: '[PRE47]  ## Handling Multiple Join Paths'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]  ## 处理多个连接路径'
- en: One of the most common situations to deal with is when there are more than one
    foreign key path between two tables.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的最常见情况之一是两个表之间存在多个外键路径。
- en: 'Consider a `Customer` class that contains two foreign keys to an `Address`
    class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含对`Address`类的两个外键的`Customer`类：
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The above mapping, when we attempt to use it, will produce the error:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射，在我们尝试使用它时，会产生错误：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The above message is pretty long. There are many potential messages that [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") can return, which have been carefully tailored
    to detect a variety of common configurational issues; most will suggest the additional
    configuration that’s needed to resolve the ambiguity or other missing information.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述消息相当长。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")可能返回许多潜在消息，这些消息经过精心设计，以检测各种常见的配置问题；大多数消息都会建议需要解决模糊性或其他缺失信息的附加配置。
- en: 'In this case, the message wants us to qualify each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") by instructing for each one which foreign key column
    should be considered, and the appropriate form is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息希望我们为每个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")进行限定，指示每个外键列应该被考虑，并且适当的形式如下：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Above, we specify the `foreign_keys` argument, which is a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or list of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects which indicate those columns to be considered
    “foreign”, or in other words, the columns that contain a value referring to a
    parent table. Loading the `Customer.billing_address` relationship from a `Customer`
    object will use the value present in `billing_address_id` in order to identify
    the row in `Address` to be loaded; similarly, `shipping_address_id` is used for
    the `shipping_address` relationship. The linkage of the two columns also plays
    a role during persistence; the newly generated primary key of a just-inserted
    `Address` object will be copied into the appropriate foreign key column of an
    associated `Customer` object during a flush.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们指定了`foreign_keys`参数，它是一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象列表，指示要考虑的“外键”列，或者换句话说，包含指向父表的值的列。从`Customer`对象加载`Customer.billing_address`关系将使用`billing_address_id`中存在的值来标识要加载的`Address`行；类似地，`shipping_address_id`用于`shipping_address`关系。这两列的关联在持久化过程中也起着作用；刚插入的`Address`对象的新生成的主键将在刷新期间被复制到关联的`Customer`对象的适当外键列中。
- en: 'When specifying `foreign_keys` with Declarative, we can also use string names
    to specify, however it is important that if using a list, the **list is part of
    the string**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Declarative 指定`foreign_keys`时，我们还可以使用字符串名称进行指定，但是重要的是，如果使用列表，**列表是字符串的一部分**：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this specific example, the list is not necessary in any case as there’s
    only one [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    we need:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个具体的例子中，在任何情况下列表都是不必要的，因为我们只需要一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Warning
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a Python-evaluable string, the [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function. **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**. See [Evaluation of relationship
    arguments](extensions/declarative/relationships.html#declarative-relationship-eval)
    for details on declarative evaluation of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为 Python 可评估字符串传递时，[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") 参数将使用 Python 的 `eval()` 函数进行解释。**请勿将不受信任的输入传递给此字符串**。详情请参阅[关系参数的评估](extensions/declarative/relationships.html#declarative-relationship-eval)以了解有关[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 参数的声明性评估的详细信息。
- en: '## Specifying Alternate Join Conditions'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '## 指定备用连接条件'
- en: The default behavior of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") when constructing a join is that it equates the
    value of primary key columns on one side to that of foreign-key-referring columns
    on the other. We can change this criterion to be anything we’d like using the
    [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") argument, as well as the [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") argument in the case when a “secondary” table is
    used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建连接时，[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的默认行为是将一侧的主键列的值等同于另一侧的外键引用列的值。我们可以使用[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")参数来更改此标准为任何我们喜欢的内容，以及在使用“次要”表时，在使用[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数。
- en: 'In the example below, using the `User` class as well as an `Address` class
    which stores a street address, we create a relationship `boston_addresses` which
    will only load those `Address` objects which specify a city of “Boston”:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用`User`类以及一个存储街道地址的`Address`类，我们创建了一个关系`boston_addresses`，它只会加载那些指定城市为“Boston”的`Address`对象：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Within this string SQL expression, we made use of the [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") conjunction construct to establish two distinct
    predicates for the join condition - joining both the `User.id` and `Address.user_id`
    columns to each other, as well as limiting rows in `Address` to just `city='Boston'`.
    When using Declarative, rudimentary SQL functions like [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") are automatically available in the evaluated
    namespace of a string [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") argument.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字符串的 SQL 表达式中，我们使用了 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") 连接构造来建立两个不同的谓词，用于连接 `User.id` 和 `Address.user_id`
    列，以及将 `Address` 中的行限制为只有 `city='Boston'`。当使用声明式时，类似 [`and_()`](../core/sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") 这样的基本 SQL 函数会自动在字符串 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 参数的计算命名空间中可用。
- en: Warning
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a Python-evaluable string, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") argument is interpreted using Python’s `eval()`
    function. **DO NOT PASS UNTRUSTED INPUT TO THIS STRING**. See [Evaluation of relationship
    arguments](extensions/declarative/relationships.html#declarative-relationship-eval)
    for details on declarative evaluation of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为 Python 可评估字符串传递时，[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 参数是使用 Python 的 `eval()` 函数解释的。**不要将不受信任的输入传递给此字符串**。有关声明式评估
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    参数的详细信息，请参阅 [关系参数的评估](extensions/declarative/relationships.html#declarative-relationship-eval)。
- en: The custom criteria we use in a [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") is generally only significant when SQLAlchemy is
    rendering SQL in order to load or represent this relationship. That is, it’s used
    in the SQL statement that’s emitted in order to perform a per-attribute lazy load,
    or when a join is constructed at query time, such as via `Select.join()`, or via
    the eager “joined” or “subquery” styles of loading. When in-memory objects are
    being manipulated, we can place any `Address` object we’d like into the `boston_addresses`
    collection, regardless of what the value of the `.city` attribute is. The objects
    will remain present in the collection until the attribute is expired and re-loaded
    from the database where the criterion is applied. When a flush occurs, the objects
    inside of `boston_addresses` will be flushed unconditionally, assigning value
    of the primary key `user.id` column onto the foreign-key-holding `address.user_id`
    column for each row. The `city` criteria has no effect here, as the flush process
    only cares about synchronizing primary key values into referencing foreign key
    values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 中使用的自定义条件通常只在 SQLAlchemy 渲染 SQL 以加载或表示此关系时才重要。也就是说，在执行每个属性的惰性加载的
    SQL 语句中使用它，或者在查询时构造连接，例如通过 `Select.join()` 或通过急切的“连接”或“子查询”加载样式。当操作内存中的对象时，我们可以将任何我们想要的
    `Address` 对象放入 `boston_addresses` 集合中，而不管 `.city` 属性的值是什么。这些对象将保留在集合中，直到属性过期并重新从应用条件的数据库中加载为止。当执行刷新时，`boston_addresses`
    中的对象将被无条件地刷新，将主键 `user.id` 列的值分配到每行的持有外键 `address.user_id` 列。这里的 `city` 条件没有效果，因为刷新过程只关心将主键值同步到引用外键值。
- en: '## Creating Custom Foreign Conditions'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '## 创建自定义外键条件'
- en: Another element of the primary join condition is how those columns considered
    “foreign” are determined. Usually, some subset of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will specify [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), or otherwise be part of a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") that’s relevant to the join condition.
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    looks to this foreign key status as it decides how it should load and persist
    data for this relationship. However, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") argument can be used to create a join condition
    that doesn’t involve any “schema” level foreign keys. We can combine [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") along with [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") and [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship") explicitly in order to establish such a join.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 主要连接条件的另一个元素是如何确定那些被认为是“外部”的列的。通常，一些 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的子集将指定 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")，或者是 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 的一部分，这与连接条件相关。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 查看这个外键状态，以确定它应该如何为这个关系加载和持久化数据。然而，[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 参数可以用来创建一个不涉及任何“模式”级外键的连接条件。我们可以显式地结合 [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 以及 [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") 和 [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship") 来建立这样一个连接。
- en: 'Below, a class `HostEntry` joins to itself, equating the string `content` column
    to the `ip_address` column, which is a PostgreSQL type called `INET`. We need
    to use [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    in order to cast one side of the join to the type of the other:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，一个 `HostEntry` 类与自身连接，将字符串 `content` 列等同于 `ip_address` 列，这是一个名为 `INET` 的
    PostgreSQL 类型。我们需要使用 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") 来将连接的一侧转换为另一侧的类型：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The above relationship will produce a join like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述关系将产生类似以下的连接：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'An alternative syntax to the above is to use the [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") [annotations](../glossary.html#term-annotations), inline
    within the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression. This syntax represents the annotations
    that [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    normally applies by itself to the join condition given the [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") and [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship") arguments. These functions may be more succinct
    when an explicit join condition is present, and additionally serve to mark exactly
    the column that is “foreign” or “remote” independent of whether that column is
    stated multiple times or within complex SQL expressions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以上的另一种语法是在 [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 表达式内联使用 [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") 和 [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") [annotations](../glossary.html#term-annotations)。这种语法表示了
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    通常自己应用于连接条件的注释，考虑到 [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") 和 [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship") 参数。当存在明确的连接条件时，这些函数可能更简洁，并且还可以标记出“外部”或“远程”的确切列，而不管该列是否在多次声明或在复杂的
    SQL 表达式中：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '## Using custom operators in join conditions'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '## 在连接条件中使用自定义运算符'
- en: 'Another use case for relationships is the use of custom operators, such as
    PostgreSQL’s “is contained within” `<<` operator when joining with types such
    as [`INET`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INET "sqlalchemy.dialects.postgresql.INET")
    and [`CIDR`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.CIDR "sqlalchemy.dialects.postgresql.CIDR").
    For custom boolean operators we use the [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关系的用例是使用自定义运算符，比如 PostgreSQL 的“包含在内” `<<` 运算符，当与诸如 [`INET`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET") 和 [`CIDR`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR") 这样的类型连接时。对于自定义布尔运算符，我们使用 [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") 函数：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A comparison like the above may be used directly with [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") when constructing a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 像上面的比较可以直接用于构造 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 中的 [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Above, a query such as:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，像这样的查询：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Will render as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示为：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '## Custom operators based on SQL functions'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '## 基于 SQL 函数的自定义运算符'
- en: 'A variant to the use case for [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") is when we aren’t using an operator,
    but a SQL function. The typical example of this use case is the PostgreSQL PostGIS
    functions however any SQL function on any database that resolves to a binary condition
    may apply. To suit this use case, the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") method can modify any
    SQL function, such as those invoked from the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace, to indicate to the ORM that the function
    produces a comparison of two expressions. The below example illustrates this with
    the [Geoalchemy2](https://geoalchemy-2.readthedocs.io/) library:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`Operators.op.is_comparison`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") 用例的变体是当我们不是使用运算符，而是使用 SQL 函数。这种用例的典型例子是
    PostgreSQL PostGIS 函数，但任何解析为二进制条件的任何数据库上的 SQL 函数都可能适用。为适应这种用例，[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") 方法可以修改任何 SQL 函数，例如从
    [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    命名空间调用的函数，以指示 ORM 该函数生成了两个表达式的比较。下面的例子使用了 [Geoalchemy2](https://geoalchemy-2.readthedocs.io/)
    库说明了这一点：
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Above, the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") indicates that the `func.ST_Contains()`
    SQL function is comparing the `Polygon.geom` and `Point.geom` expressions. The
    [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign "sqlalchemy.orm.foreign")
    annotation additionally notes which column takes on the “foreign key” role in
    this particular relationship.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") 表示 `func.ST_Contains()`
    SQL 函数正在比较 `Polygon.geom` 和 `Point.geom` 表达式。[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") 注释另外指出了在这种特定关系中扮演“外键”角色的列。
- en: 'New in version 1.3: Added [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison").'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.3 中新增了 [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison")。
- en: '## Overlapping Foreign Keys'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '## 重叠的外键'
- en: A rare scenario can arise when composite foreign keys are used, such that a
    single column may be the subject of more than one column referred to via foreign
    key constraint.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 很少见的情况可能会出现，即使用复合外键，以便单个列可能是通过外键约束引用的多个列的主题。
- en: 'Consider an (admittedly complex) mapping such as the `Magazine` object, referred
    to both by the `Writer` object and the `Article` object using a composite primary
    key scheme that includes `magazine_id` for both; then to make `Article` refer
    to `Writer` as well, `Article.magazine_id` is involved in two separate relationships;
    `Article.magazine` and `Article.writer`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个（诚然复杂的）映射，例如`Magazine`对象，使用包括`magazine_id`的复合主键方案，分别由`Writer`对象和`Article`对象引用；然后，为了使`Article`也引用`Writer`，`Article.magazine_id`涉及到两个不同的关系；`Article.magazine`和`Article.writer`：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When the above mapping is configured, we will see this warning emitted:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述映射被配置时，我们将看到此警告被发出：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: What this refers to originates from the fact that `Article.magazine_id` is the
    subject of two different foreign key constraints; it refers to `Magazine.id` directly
    as a source column, but also refers to `Writer.magazine_id` as a source column
    in the context of the composite key to `Writer`. If we associate an `Article`
    with a particular `Magazine`, but then associate the `Article` with a `Writer`
    that’s associated with a *different* `Magazine`, the ORM will overwrite `Article.magazine_id`
    non-deterministically, silently changing which magazine to which we refer; it
    may also attempt to place NULL into this column if we de-associate a `Writer`
    from an `Article`. The warning lets us know this is the case.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是`Article.magazine_id`是两个不同外键约束的主体；它直接引用`Magazine.id`作为源列，但在与`Writer`的复合键上下文中，也引用`Writer.magazine_id`作为源列。如果我们将`Article`与特定的`Magazine`关联起来，但然后将`Article`与另一个与*不同*`Magazine`关联的`Writer`关联起来，ORM会非确定性地覆盖`Article.magazine_id`，悄悄地改变我们所引用的杂志；如果我们将`Writer`从`Article`中取消关联，它还可能尝试将NULL放入此列。警告让我们知道这种情况。
- en: 'To solve this, we need to break out the behavior of `Article` to include all
    three of the following features:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要打破`Article`的行为，包括以下三个功能：
- en: '`Article` first and foremost writes to `Article.magazine_id` based on data
    persisted in the `Article.magazine` relationship only, that is a value copied
    from `Magazine.id`.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`Article`根据仅在`Article.magazine`关系中持久化的数据来写入`Article.magazine_id`，即从`Magazine.id`复制的值。
- en: '`Article` can write to `Article.writer_id` on behalf of data persisted in the
    `Article.writer` relationship, but only the `Writer.id` column; the `Writer.magazine_id`
    column should not be written into `Article.magazine_id` as it ultimately is sourced
    from `Magazine.id`.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Article`可以代表在`Article.writer`关系中持久化的数据写入`Article.writer_id`，但只能写入`Writer.id`列；`Writer.magazine_id`列不应写入`Article.magazine_id`，因为它最终来自`Magazine.id`。'
- en: '`Article` takes `Article.magazine_id` into account when loading `Article.writer`,
    even though it *doesn’t* write to it on behalf of this relationship.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当加载`Article.writer`时，`Article`考虑了`Article.magazine_id`，即使在此关系中并不代表它。
- en: 'To get just #1 and #2, we could specify only `Article.writer_id` as the “foreign
    keys” for `Article.writer`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取只有#1和#2，我们可以将`Article.writer_id`指定为`Article.writer`的“外键”：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, this has the effect of `Article.writer` not taking `Article.magazine_id`
    into account when querying against `Writer`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会导致`Article.writer`在与`Writer`进行查询时不考虑`Article.magazine_id`：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Therefore, to get at all of #1, #2, and #3, we express the join condition as
    well as which columns to be written by combining [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") fully, along with either the [`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship") argument, or more succinctly by annotating with
    [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign "sqlalchemy.orm.foreign"):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要获取#1、#2和#3的所有内容，我们需要通过完全组合[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")来表达连接条件，以及要写入的列，同时使用[`relationship.foreign_keys`](relationship_api.html#sqlalchemy.orm.relationship.params.foreign_keys
    "sqlalchemy.orm.relationship")参数，或者更简洁地使用[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")进行注释：
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Non-relational Comparisons / Materialized Path
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系比较 / 材料化路径
- en: Warning
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: this section details an experimental feature.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了一个实验性功能。
- en: Using custom expressions means we can produce unorthodox join conditions that
    don’t obey the usual primary/foreign key model. One such example is the materialized
    path pattern, where we compare strings for overlapping path tokens in order to
    produce a tree structure.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义表达式意味着我们可以生成不遵循通常的主键/外键模型的非正统连接条件。其中一个例子是材料化路径模式，我们在比较字符串以产生重叠路径标记时，以便生成树结构。
- en: 'Through careful use of [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote"), we can build a relationship that effectively produces
    a rudimentary materialized path system. Essentially, when [`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") are on the *same* side of the comparison expression,
    the relationship is considered to be “one to many”; when they are on *different*
    sides, the relationship is considered to be “many to one”. For the comparison
    we’ll use here, we’ll be dealing with collections so we keep things configured
    as “one to many”:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过谨慎使用[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign "sqlalchemy.orm.foreign")和[`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")，我们可以构建一个有效地生成基本材料化路径系统的关系。基本上，当[`foreign()`](relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")和[`remote()`](relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")在*相同*的比较表达式一侧时，关系被认为是“一对多”；当它们在*不同*的一侧时，关系被认为是“多对一”。对于我们将在此处使用的比较，我们将处理集合，所以我们保持事物配置为“一对多”：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Above, if given an `Element` object with a path attribute of `"/foo/bar2"`,
    we seek for a load of `Element.descendants` to look like:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上文中，如果给定具有`"/foo/bar2"`路径属性的`Element`对象，则我们寻找对`Element.descendants`的加载应如下所示：
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '## Self-Referential Many-to-Many Relationship'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '## 自我引用多对多关系'
- en: See also
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This section documents a two-table variant of the “adjacency list” pattern,
    which is documented at [Adjacency List Relationships](self_referential.html#self-referential).
    Be sure to review the self-referential querying patterns in subsections [Self-Referential
    Query Strategies](self_referential.html#self-referential-query) and [Configuring
    Self-Referential Eager Loading](self_referential.html#self-referential-eager-loading)
    which apply equally well to the mapping pattern discussed here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节记录了“邻接列表”模式的两个表变体，该模式在[邻接列表关系](self_referential.html#self-referential)中有所记录。务必查看自我引用查询模式的子部分[自我引用查询策略](self_referential.html#self-referential-query)和[配置自我引用急加载](self_referential.html#self-referential-eager-loading)，它们同样适用于此处讨论的映射模式。
- en: 'Many to many relationships can be customized by one or both of [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") - the latter is significant for a relationship
    that specifies a many-to-many reference using the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") argument. A common situation which involves the
    usage of [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") is when establishing a many-to-many relationship
    from a class to itself, as shown below:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系可以通过[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和/或[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")中的一个或两个进行自定义 - 后者对于使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数指定多对多引用的关系非常重要。涉及使用[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")的常见情况是在从一个类到自身建立多对多关系时，如下所示：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Where above, SQLAlchemy can’t know automatically which columns should connect
    to which for the `right_nodes` and `left_nodes` relationships. The [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments establish how we’d like to join to the
    association table. In the Declarative form above, as we are declaring these conditions
    within the Python block that corresponds to the `Node` class, the `id` variable
    is available directly as the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object we wish to join with.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，SQLAlchemy无法自动知道哪些列应该连接到`right_nodes`和`left_nodes`关系的哪些列上。[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数建立了我们希望如何加入关联表的方式。在上面的声明形式中，由于我们在对应于`Node`类的Python块中声明了这些条件，因此`id`变量直接作为我们希望与之连接的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象是可用的。
- en: 'Alternatively, we can define the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments using strings, which is suitable in the
    case that our configuration does not have either the `Node.id` column object available
    yet or the `node_to_node` table perhaps isn’t yet available. When referring to
    a plain [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object in a declarative string, we use the string name of the table as it is present
    in the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData"):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用字符串定义[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数，在我们的配置中可能还没有`Node.id`列对象可用，或者`node_to_node`表可能还不可用的情况下非常适用。当在声明字符串中引用普通的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象时，我们使用表的字符串名称，就像在[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")中一样：
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Warning
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When passed as a Python-evaluable string, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments are interpreted using Python’s `eval()`
    function. **DO NOT PASS UNTRUSTED INPUT TO THESE STRINGS**. See [Evaluation of
    relationship arguments](extensions/declarative/relationships.html#declarative-relationship-eval)
    for details on declarative evaluation of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为Python可评估字符串传递时，[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship")参数使用Python的`eval()`函数解释。**不要将不受信任的输入传递给这些字符串**。有关声明性[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")参数的评估详细信息，请参阅[关系参数的评估](extensions/declarative/relationships.html#declarative-relationship-eval)。
- en: 'A classical mapping situation here is similar, where `node_to_node` can be
    joined to `node.c.id`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的经典映射情况中，`node_to_node`可以连接到`node.c.id`：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that in both examples, the [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") keyword specifies a `left_nodes` backref - when
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    creates the second relationship in the reverse direction, it’s smart enough to
    reverse the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") arguments.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两个示例中，[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") 关键字都指定了一个 `left_nodes` 回引 - 当[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")在反向创建第二个关系时，它足够聪明地反转了[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 和 [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") 参数。
- en: See also
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Adjacency List Relationships](self_referential.html#self-referential) - single
    table version'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[邻接列表关系](self_referential.html#self-referential) - 单表版本'
- en: '[Self-Referential Query Strategies](self_referential.html#self-referential-query)
    - tips on querying with self-referential mappings'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自引用查询策略](self_referential.html#self-referential-query) - 使用自引用映射查询的技巧'
- en: '[Configuring Self-Referential Eager Loading](self_referential.html#self-referential-eager-loading)
    - tips on eager loading with self- referential mapping'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[配置自引用预加载](self_referential.html#self-referential-eager-loading) - 使用自引用映射预加载的技巧'
- en: '## Composite “Secondary” Joins'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '## 复合“次要”连接'
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section features far edge cases that are somewhat supported by SQLAlchemy,
    however it is recommended to solve problems like these in simpler ways whenever
    possible, by using reasonable relational layouts and / or [in-Python attributes](mapped_attributes.html#mapper-hybrids).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了一些在某种程度上受SQLAlchemy支持的边缘案例，但建议尽可能在可能的情况下通过使用合理的关系布局和/或[Python内的属性](mapped_attributes.html#mapper-hybrids)来解决类似问题。
- en: Sometimes, when one seeks to build a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") between two tables there is a need for more than
    just two or three tables to be involved in order to join them. This is an area
    of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    where one seeks to push the boundaries of what’s possible, and often the ultimate
    solution to many of these exotic use cases needs to be hammered out on the SQLAlchemy
    mailing list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当一个人试图在两个表之间建立一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，需要涉及更多的表，而不仅仅是两个或三个表。这是一个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的领域，在这个领域，人们试图推动可能性的边界，并且通常对许多这些奇特用例的最终解决方案需要在SQLAlchemy邮件列表上讨论。
- en: 'In more recent versions of SQLAlchemy, the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter can be used in some of these cases in
    order to provide a composite target consisting of multiple tables. Below is an
    example of such a join condition (requires version 0.9.2 at least to function
    as is):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新版本的SQLAlchemy中，[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 参数可用于某些情况，以提供由多个表组成的复合目标。以下是这种连接条件的示例（至少需要版本0.9.2才能正常运行）：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the above example, we provide all three of [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"), [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship"), and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship"), in the declarative style referring to the named
    tables `a`, `b`, `c`, `d` directly. A query from `A` to `D` looks like:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们提供了[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")、[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") 和[`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship") 这三个参数，在声明样式中直接引用了命名表 `a`、`b`、`c`、`d`。从 `A` 到 `D`
    的查询如下：
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the above example, we take advantage of being able to stuff multiple tables
    into a “secondary” container, so that we can join across many tables while still
    keeping things “simple” for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), in that there’s just “one” table on both the “left”
    and the “right” side; the complexity is kept within the middle.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们利用能够将多个表填入“次要”容器的优势，这样我们就可以跨多个表进行连接，同时保持对[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的“简单”使用，因为“左”和“右”两侧只有“一个”表；复杂性被保留在中间。
- en: Warning
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: A relationship like the above is typically marked as `viewonly=True`, using
    [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship"), and should be considered as read-only. While there
    are sometimes ways to make relationships like the above writable, this is generally
    complicated and error prone.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类似上述的关系通常标记为`viewonly=True`，使用[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")，应当被视为只读。虽然有时可以使类似上述的关系可写，但这通常是复杂且容易出错的。
- en: See also
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Notes on using the viewonly relationship parameter](#relationship-viewonly-notes)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于使用只读关系参数的注意事项](#relationship-viewonly-notes)'
- en: '## Relationship to Aliased Class'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '## 别名类的关系'
- en: In the previous section, we illustrated a technique where we used [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") in order to place additional tables within a join
    condition. There is one complex join case where even this technique is not sufficient;
    when we seek to join from `A` to `B`, making use of any number of `C`, `D`, etc.
    in between, however there are also join conditions between `A` and `B` *directly*.
    In this case, the join from `A` to `B` may be difficult to express with just a
    complex [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") condition, as the intermediary tables may need
    special handling, and it is also not expressible with a [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") object, since the `A->secondary->B` pattern does
    not support any references between `A` and `B` directly. When this **extremely
    advanced** case arises, we can resort to creating a second mapping as a target
    for the relationship. This is where we use [`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") in order to make a mapping to a class that
    includes all the additional tables we need for this join. In order to produce
    this mapper as an “alternative” mapping for our class, we use the [`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") function to produce the new construct, then use [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") against the object as though it were a plain mapped
    class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们说明了一种技术，在这种技术中，我们使用了[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")来将额外的表放置在连接条件中。有一种复杂的连接情况，即使使用这种技术也不足够；当我们试图从`A`连接到`B`时，中间可能会使用任意数量的`C`、`D`等，但是在`A`和`B`之间也有直接的连接条件。在这种情况下，仅使用复杂的[`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")条件可能难以表达，因为中间表可能需要特殊处理，而且也不能使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")对象来表达，因为`A->secondary->B`模式不支持`A`和`B`之间的任何引用。当出现这种**极其高级**的情况时，我们可以采用创建第二个映射作为关系的目标。这就是我们使用[`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")来创建一个包含我们所需的所有额外表的类的映射。为了将这个映射作为我们类的“替代”映射生成，我们使用[`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")函数来生成新的结构，然后针对该对象使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，就像它是一个普通的映射类一样。
- en: 'Below illustrates a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") with a simple join from `A` to `B`, however the
    primaryjoin condition is augmented with two additional entities `C` and `D`, which
    also must have rows that line up with the rows in both `A` and `B` simultaneously:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面演示了从 `A` 到 `B` 的简单连接的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，但是主连接条件增加了另外两个实体 `C` 和 `D`，这两个实体必须同时与 `A` 和 `B`
    中的行对应起来：
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With the above mapping, a simple join looks like:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，简单连接如下所示：
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Integrating AliasedClass Mappings with Typing and Avoiding Early Mapper Configuration
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将别名类映射与类型化结合，并避免早期映射器配置
- en: The creation of the [`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct against a mapped class forces the [`configure_mappers()`](mapping_api.html#sqlalchemy.orm.configure_mappers
    "sqlalchemy.orm.configure_mappers") step to proceed, which will resolve all current
    classes and their relationships. This may be problematic if unrelated mapped classes
    needed by the current mappings have not yet been declared, or if the configuration
    of the relationship itself needs access to as-yet undeclared classes. Additionally,
    SQLAlchemy’s Declarative pattern works with Python typing most effectively when
    relationships are declared up front.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造对映射类的创建强制执行 [`configure_mappers()`](mapping_api.html#sqlalchemy.orm.configure_mappers
    "sqlalchemy.orm.configure_mappers") 步骤，该步骤将解析所有当前类及其关系。如果当前映射所需的不相关映射类尚未声明，或者如果关系本身的配置需要访问尚未声明的类，则可能会出现问题。此外，当关系在前面声明时，SQLAlchemy
    的声明模式与 Python 类型化的协作效果最佳。'
- en: 'To organize the construction of the relationship to work with these issues,
    a configure level event hook like [`MapperEvents.before_mapper_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured") may be used, which will
    invoke the configuration code only when all mappings are ready for configuration:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织关系的构建以解决这些问题，可以使用配置级别的事件钩子，如 [`MapperEvents.before_mapper_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured")，该钩子将仅在所有映射准备好配置时调用配置代码：
- en: '[PRE76]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Above, the function `_configure_ab_relationship()` will be invoked only when
    a fully configured version of `A` is requested, at which point the classes `B`,
    `D` and `C` would be available.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，当请求完全配置的 `A` 版本时，函数 `_configure_ab_relationship()` 将被调用，此时类 `B`、`D`
    和 `C` 将可用。
- en: 'For an approach that integrates with inline typing, a similar technique can
    be used to effectively generate a “singleton” creation pattern for the aliased
    class where it is late-initialized as a global variable, which can then be used
    in the relationship inline:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与内联类型化集成的方法，可以使用类似的技术来有效地生成别名类的“单例”创建模式，其中它作为全局变量进行延迟初始化，然后可以在关系内联中使用它：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Using the AliasedClass target in Queries
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在查询中使用别名类目标
- en: 'In the previous example, the `A.b` relationship refers to the `B_viacd` entity
    as the target, and **not** the `B` class directly. To add additional criteria
    involving the `A.b` relationship, it’s typically necessary to reference the `B_viacd`
    directly rather than using `B`, especially in a case where the target entity of
    `A.b` is to be transformed into an alias or a subquery. Below illustrates the
    same relationship using a subquery, rather than a join:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`A.b` 关系将 `B_viacd` 实体作为目标，而 **不是** 直接的 `B` 类。要添加涉及 `A.b` 关系的附加条件，通常需要直接引用
    `B_viacd` 而不是使用 `B`，特别是在将 `A.b` 的目标实体转换为别名或子查询的情况下。下面演示了使用子查询而不是连接的相同关系：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A query using the above `A.b` relationship will render a subquery:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述 `A.b` 关系的查询将呈现一个子查询：
- en: '[PRE79]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we want to add additional criteria based on the `A.b` join, we must do so
    in terms of `B_viacd_subquery` rather than `B` directly:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据 `A.b` 连接添加额外的条件，必须以 `B_viacd_subquery` 而不是直接以 `B` 的形式添加：
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Integrating AliasedClass Mappings with Typing and Avoiding Early Mapper Configuration
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将别名类映射与类型化结合，并避免早期映射器配置
- en: The creation of the [`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct against a mapped class forces the [`configure_mappers()`](mapping_api.html#sqlalchemy.orm.configure_mappers
    "sqlalchemy.orm.configure_mappers") step to proceed, which will resolve all current
    classes and their relationships. This may be problematic if unrelated mapped classes
    needed by the current mappings have not yet been declared, or if the configuration
    of the relationship itself needs access to as-yet undeclared classes. Additionally,
    SQLAlchemy’s Declarative pattern works with Python typing most effectively when
    relationships are declared up front.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对映射类创建 [`aliased()`](queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造会强制进行 [`configure_mappers()`](mapping_api.html#sqlalchemy.orm.configure_mappers
    "sqlalchemy.orm.configure_mappers") 步骤，这将解析所有当前的类及其关系。如果当前映射需要未声明的不相关的映射类，或者如果关系的配置本身需要访问尚未声明的类，则可能会出现问题。另外，当关系提前声明时，SQLAlchemy
    的声明式模式与 Python 类型的工作方式最有效。
- en: 'To organize the construction of the relationship to work with these issues,
    a configure level event hook like [`MapperEvents.before_mapper_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured") may be used, which will
    invoke the configuration code only when all mappings are ready for configuration:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要组织关系构建以处理这些问题，可以使用一个配置级别的事件钩子，比如 [`MapperEvents.before_mapper_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured")，它只有在所有映射都准备好配置时才会调用配置代码：
- en: '[PRE81]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Above, the function `_configure_ab_relationship()` will be invoked only when
    a fully configured version of `A` is requested, at which point the classes `B`,
    `D` and `C` would be available.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数 `_configure_ab_relationship()` 只有在请求一个完全配置好的 `A` 版本时才会被调用，在这时 `B`、`D` 和
    `C` 类会被加载。
- en: 'For an approach that integrates with inline typing, a similar technique can
    be used to effectively generate a “singleton” creation pattern for the aliased
    class where it is late-initialized as a global variable, which can then be used
    in the relationship inline:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与内联类型集成的方法，可以使用类似的技术有效地为别名类生成“单例”创建模式，在其中作为全局变量进行延迟初始化，然后可以在关系中使用：
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Using the AliasedClass target in Queries
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在查询中使用 AliasedClass 目标
- en: 'In the previous example, the `A.b` relationship refers to the `B_viacd` entity
    as the target, and **not** the `B` class directly. To add additional criteria
    involving the `A.b` relationship, it’s typically necessary to reference the `B_viacd`
    directly rather than using `B`, especially in a case where the target entity of
    `A.b` is to be transformed into an alias or a subquery. Below illustrates the
    same relationship using a subquery, rather than a join:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`A.b` 关系将 `B_viacd` 实体作为目标，而**不是**直接使用 `B` 类。要添加涉及 `A.b` 关系的额外条件，通常需要直接引用
    `B_viacd` 而不是使用 `B`，特别是在目标实体 `A.b` 需要转换为别名或子查询的情况下。以下是使用子查询而不是连接的相同关系的示例：
- en: '[PRE83]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A query using the above `A.b` relationship will render a subquery:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述 `A.b` 关系的查询将呈现一个子查询：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If we want to add additional criteria based on the `A.b` join, we must do so
    in terms of `B_viacd_subquery` rather than `B` directly:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要根据 `A.b` 连接添加额外的条件，必须以 `B_viacd_subquery` 而不是直接使用 `B`：
- en: '[PRE85]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '## Row-Limited Relationships with Window Functions'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '## 带窗口函数的行限制关系'
- en: 'Another interesting use case for relationships to [`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") objects are situations where the relationship
    needs to join to a specialized SELECT of any form. One scenario is when the use
    of a window function is desired, such as to limit how many rows should be returned
    for a relationship. The example below illustrates a non-primary mapper relationship
    that will load the first ten items for each collection:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关系到 [`AliasedClass`](queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") 对象的有趣用例是关系需要连接到任何形式的专门 SELECT 时。一种情况是当需要使用窗口函数时，例如限制返回的行数。下面的示例说明了一个非主映射器关系，该关系将为每个集合加载前十个项目：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can use the above `partitioned_bs` relationship with most of the loader
    strategies, such as [`selectinload()`](queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用上述 `partitioned_bs` 关系与大多数加载器策略，例如 [`selectinload()`](queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload"):'
- en: '[PRE87]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Where above, the “selectinload” query looks like:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，“selectinload”查询如下所示：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Above, for each matching primary key in “a”, we will get the first ten “bs”
    as ordered by “b.id”. By partitioning on “a_id” we ensure that each “row number”
    is local to the parent “a_id”.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，对于“a”中的每个匹配的主键，我们将按照“b.id”的顺序获取前十个“bs”。通过在“a_id”上分区，我们确保每个“行号”都局限于父“a_id”。
- en: Such a mapping would ordinarily also include a “plain” relationship from “A”
    to “B”, for persistence operations as well as when the full set of “B” objects
    per “A” is desired.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的映射通常还会包括从“A”到“B”的“普通”关系，用于持久性操作以及当需要“A”每个对象的完整集合时。
- en: '## Building Query-Enabled Properties'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '## 构建查询可用的属性'
- en: 'Very ambitious custom join conditions may fail to be directly persistable,
    and in some cases may not even load correctly. To remove the persistence part
    of the equation, use the flag [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), which establishes it as a read-only attribute
    (data written to the collection will be ignored on flush()). However, in extreme
    cases, consider using a regular Python property in conjunction with [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 非常雄心勃勃的自定义连接条件可能无法直接持久化，有些情况下甚至可能无法正确加载。要消除持久性方程式的部分，使用标志[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上，将其建立为只读属性（写入到集合的数据将在flush()时被忽略）。但是，在极端情况下，请考虑与[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")一起使用常规的Python属性，如下所示：
- en: '[PRE89]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In other cases, the descriptor can be built to make use of existing in-Python
    data. See the section on [Using Descriptors and Hybrids](mapped_attributes.html#mapper-hybrids)
    for more general discussion of special Python attributes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，可以构建描述符来利用现有的Python数据。有关更一般的Python属性的特殊讨论，请参阅[使用描述符和混合](mapped_attributes.html#mapper-hybrids)部分。
- en: See also
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using Descriptors and Hybrids](mapped_attributes.html#mapper-hybrids)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用描述符和混合](mapped_attributes.html#mapper-hybrids)'
- en: '## Notes on using the viewonly relationship parameter'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用viewonly关系参数的注意事项'
- en: The [`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") parameter when applied to a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct indicates that this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") will not take part in any ORM [unit of work](../glossary.html#term-unit-of-work)
    operations, and additionally that the attribute does not expect to participate
    within in-Python mutations of its represented collection. This means that while
    the viewonly relationship may refer to a mutable Python collection like a list
    or set, making changes to that list or set as present on a mapped instance will
    have **no effect** on the ORM flush process.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")构造时，[`relationship.viewonly`](relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")参数指示此[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")不会参与任何ORM [工作单元](../glossary.html#term-unit-of-work)操作，此外，该属性也不会参与其表示的集合的Python变异。这意味着虽然viewonly关系可能引用可变的Python集合，如列表或集合，但对在映射实例上存在的该列表或集合进行更改对ORM
    flush过程没有影响。
- en: 'To explore this scenario consider this mapping:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索这种情景，请考虑以下映射：
- en: '[PRE90]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The following sections will note different aspects of this configuration.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将说明此配置的不同方面。
- en: In-Python mutations including backrefs are not appropriate with viewonly=True
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中，包括backrefs在内的变异操作不适用于viewonly=True
- en: 'The above mapping targets the `User.current_week_tasks` viewonly relationship
    as the [backref](../glossary.html#term-backref) target of the `Task.user` attribute.
    This is not currently flagged by SQLAlchemy’s ORM configuration process, however
    is a configuration error. Changing the `.user` attribute on a `Task` will not
    affect the `.current_week_tasks` attribute:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射针对`User.current_week_tasks`视图关系，作为`Task.user`属性的[backref](../glossary.html#term-backref)目标。目前，SQLAlchemy的ORM配置过程尚未标记此项，但这是配置错误。更改`Task`上的`.user`属性不会影响`.current_week_tasks`属性：
- en: '[PRE91]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: There is another parameter called [`relationship.sync_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.sync_backrefs
    "sqlalchemy.orm.relationship") which can be turned on here to allow `.current_week_tasks`
    to be mutated in this case, however this is not considered to be a best practice
    with a viewonly relationship, which instead should not be relied upon for in-Python
    mutations.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个称为[`relationship.sync_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.sync_backrefs
    "sqlalchemy.orm.relationship")的参数，可以在这里打开，以允许在这种情况下对`.current_week_tasks`进行突变，但是这并不被认为是`viewonly`关系的最佳实践，其不应该依赖于Python中的突变。
- en: In this mapping, backrefs can be configured between `User.all_tasks` and `Task.user`,
    as these are both not viewonly and will synchronize normally.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在此映射中，可以在`User.all_tasks`和`Task.user`之间配置反向引用，因为它们都不是`viewonly`并且将正常同步。
- en: Beyond the issue of backref mutations being disabled for viewonly relationships,
    plain changes to the `User.all_tasks` collection in Python are also not reflected
    in the `User.current_week_tasks` collection until changes have been flushed to
    the database.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了禁用`viewonly`关系的反向引用突变之外，Python中对`User.all_tasks`集合的普通更改也不会反映在`User.current_week_tasks`集合中，直到更改已刷新到数据库中。
- en: 'Overall, for a use case where a custom collection should respond immediately
    to in-Python mutations, the viewonly relationship is generally not appropriate.
    A better approach is to use the [Hybrid Attributes](extensions/hybrid.html) feature
    of SQLAlchemy, or for instance-only cases to use a Python `@property`, where a
    user-defined collection that is generated in terms of the current Python instance
    can be implemented. To change our example to work this way, we repair the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter on `Task.user` to reference `User.all_tasks`,
    and then illustrate a simple `@property` that will deliver results in terms of
    the immediate `User.all_tasks` collection:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，对于一个自定义集合应该立即响应Python中突变的用例，`viewonly`关系通常不合适。更好的方法是使用SQLAlchemy的[Hybrid
    Attributes](extensions/hybrid.html)功能，或者仅对于实例化的情况使用Python的`@property`，在这种情况下，可以实现一个用户定义的集合，该集合是以当前Python实例为基础生成的。要将我们的示例更改为这种工作方式，我们修复`Task.user`上的[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数，以引用`User.all_tasks`，然后说明一个简单的`@property`，该`@property`将以`User.all_tasks`集合的立即结果的形式提供结果：
- en: '[PRE92]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Using an in-Python collection calculated on the fly each time, we are guaranteed
    to have the correct answer at all times, without the need to use a database at
    all:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在Python中计算的集合，我们都能保证始终得到正确的答案，而无需使用数据库：
- en: '[PRE93]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: viewonly=True collections / attributes do not get re-queried until expired
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`viewonly=True`的集合/属性在过期之前不会被重新查询'
- en: Continuing with the original viewonly attribute, if we do in fact make changes
    to the `User.all_tasks` collection on a [persistent](../glossary.html#term-persistent)
    object, the viewonly collection can only show the net result of this change after
    **two** things occur. The first is that the change to `User.all_tasks` is [flushed](../glossary.html#term-flushed),
    so that the new data is available in the database, at least within the scope of
    the local transaction. The second is that the `User.current_week_tasks` attribute
    is [expired](../glossary.html#term-expired) and reloaded via a new SQL query to
    the database.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始的`viewonly`属性，如果我们确实对`User.all_tasks`集合进行了更改，那么在**两**个事件发生后，`viewonly`集合才能显示这些更改的最终结果。第一个是将`User.all_tasks`的更改[flushed](../glossary.html#term-flushed)，以便新数据在数据库中可用，至少在本地事务范围内可用。第二个是`User.current_week_tasks`属性被[expired](../glossary.html#term-expired)，并通过新的SQL查询重新加载到数据库。
- en: 'To support this requirement, the simplest flow to use is one where the **viewonly
    relationship is consumed only in operations that are primarily read only to start
    with**. Such as below, if we retrieve a `User` fresh from the database, the collection
    will be current:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一要求，使用的最简单的流程是**只在主要是只读操作中使用`viewonly`关系**。比如下面，如果我们从数据库中检索到一个新的`User`，集合将是当前的：
- en: '[PRE94]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When we make modifications to `u1.all_tasks`, if we want to see these changes
    reflected in the `u1.current_week_tasks` viewonly relationship, these changes
    need to be flushed and the `u1.current_week_tasks` attribute needs to be expired,
    so that it will [lazy load](../glossary.html#term-lazy-load) on next access. The
    simplest approach to this is to use [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), keeping the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter set at its default of `True`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对`u1.all_tasks`进行修改时，如果我们希望在`u1.current_week_tasks`的viewonly关系中看到这些更改反映出来，这些更改需要被刷新，并且`u1.current_week_tasks`属性需要过期，以便在下次访问时[懒加载](../glossary.html#term-lazy-load)。这样做的最简单方法是使用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，保持[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")参数设置为其默认值`True`：
- en: '[PRE95]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Above, the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") flushed the changes to `u1.all_tasks` to the
    database, then expired all objects, so that when we accessed `u1.current_week_tasks`,
    a :term:` lazy load` occurred which fetched the contents for this attribute freshly
    from the database.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上述，对[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")的调用将更改刷新到数据库的`u1.all_tasks`，然后过期所有对象，因此当我们访问`u1.current_week_tasks`时，将从数据库中新鲜地获取此属性的内容，触发了一个：term:`懒加载`。
- en: 'To intercept operations without actually committing the transaction, the attribute
    needs to be explicitly [expired](../glossary.html#term-expired) first. A simplistic
    way to do this is to just call it directly. In the example below, [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") sends pending changes to the database, then [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") is used to expire the `u1.current_week_tasks`
    collection so that it re-fetches on next access:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截操作而不实际提交事务，必须首先显式地[过期](../glossary.html#term-expired)属性。这样做的简单方法就是直接调用它。在下面的例子中，[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")发送挂起的更改到数据库，然后使用[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")来过期`u1.current_week_tasks`集合，以便在下次访问时重新获取：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can in fact skip the call to [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush"), assuming a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that keeps [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") at its default value of `True`, as the expired `current_week_tasks`
    attribute will trigger autoflush when accessed after expiration:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以跳过对[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")的调用，假设[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")保持其默认值为`True`的[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")，因为过期的`current_week_tasks`属性将在过期后在访问时触发自动刷新：
- en: '[PRE97]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Continuing with the above approach to something more elaborate, we can apply
    the expiration programmatically when the related `User.all_tasks` collection changes,
    using [event hooks](../core/event.html). This an **advanced technique**, where
    simpler architectures like `@property` or sticking to read-only use cases should
    be examined first. In our simple example, this would be configured as:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步发展上述方法，我们可以在相关的`User.all_tasks`集合发生变化时，通过[事件钩子](../core/event.html)来以编程方式应用过期。这是一种**高级技术**，应该首先检查像`@property`这样的更简单的架构或者坚持只读用例。在我们的简单示例中，配置如下：
- en: '[PRE98]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'With the above hooks, mutation operations are intercepted and result in the
    `User.current_week_tasks` collection to be expired automatically:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述钩子，突变操作被拦截，并导致`User.current_week_tasks`集合自动过期：
- en: '[PRE99]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The [`AttributeEvents`](events.html#sqlalchemy.orm.AttributeEvents "sqlalchemy.orm.AttributeEvents")
    event hooks used above are also triggered by backref mutations, so with the above
    hooks a change to `Task.user` is also intercepted:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上面使用的[`AttributeEvents`](events.html#sqlalchemy.orm.AttributeEvents "sqlalchemy.orm.AttributeEvents")事件钩子也会被后向引用突变触发，因此通过上面的钩子也会拦截对`Task.user`的更改：
- en: '[PRE100]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In-Python mutations including backrefs are not appropriate with viewonly=True
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用viewonly=True的In-Python突变不合适
- en: 'The above mapping targets the `User.current_week_tasks` viewonly relationship
    as the [backref](../glossary.html#term-backref) target of the `Task.user` attribute.
    This is not currently flagged by SQLAlchemy’s ORM configuration process, however
    is a configuration error. Changing the `.user` attribute on a `Task` will not
    affect the `.current_week_tasks` attribute:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将`User.current_week_tasks`视图关系作为`Task.user`属性的[backref](../glossary.html#term-backref)目标。这目前并未被SQLAlchemy的ORM配置过程标记，但这是一个配置错误。更改`Task`上的`.user`属性不会影响`.current_week_tasks`属性：
- en: '[PRE101]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: There is another parameter called [`relationship.sync_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.sync_backrefs
    "sqlalchemy.orm.relationship") which can be turned on here to allow `.current_week_tasks`
    to be mutated in this case, however this is not considered to be a best practice
    with a viewonly relationship, which instead should not be relied upon for in-Python
    mutations.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个参数叫做[`relationship.sync_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.sync_backrefs
    "sqlalchemy.orm.relationship")，可以在这里打开，允许在这种情况下对`.current_week_tasks`进行变异，然而这并不被认为是最佳实践，对于只读关系，不应依赖于Python中的变异。
- en: In this mapping, backrefs can be configured between `User.all_tasks` and `Task.user`,
    as these are both not viewonly and will synchronize normally.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种映射中，可以在`User.all_tasks`和`Task.user`之间配置反向引用，因为这两者都不是只读的，将正常同步。
- en: Beyond the issue of backref mutations being disabled for viewonly relationships,
    plain changes to the `User.all_tasks` collection in Python are also not reflected
    in the `User.current_week_tasks` collection until changes have been flushed to
    the database.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对于只读关系禁用反向引用变异的问题外，Python中对`User.all_tasks`集合的普通更改也不会反映在`User.current_week_tasks`集合中，直到更改已刷新到数据库。
- en: 'Overall, for a use case where a custom collection should respond immediately
    to in-Python mutations, the viewonly relationship is generally not appropriate.
    A better approach is to use the [Hybrid Attributes](extensions/hybrid.html) feature
    of SQLAlchemy, or for instance-only cases to use a Python `@property`, where a
    user-defined collection that is generated in terms of the current Python instance
    can be implemented. To change our example to work this way, we repair the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter on `Task.user` to reference `User.all_tasks`,
    and then illustrate a simple `@property` that will deliver results in terms of
    the immediate `User.all_tasks` collection:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，对于一个自定义集合应立即响应Python中的变异的用例，只读关系通常不合适。更好的方法是使用SQLAlchemy的[Hybrid Attributes](extensions/hybrid.html)功能，或者对于仅实例情况，使用Python的`@property`，其中可以实现以当前Python实例为基础生成的用户定义集合。要将我们的示例更改为这种方式工作，我们修复`Task.user`上的[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数，引用`User.all_tasks`，然后演示一个简单的`@property`，将以即时`User.all_tasks`集合的结果为基础提供结果。
- en: '[PRE102]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Using an in-Python collection calculated on the fly each time, we are guaranteed
    to have the correct answer at all times, without the need to use a database at
    all:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每次都在Python中计算的即时集合，我们保证始终具有正确答案，而无需使用数据库：
- en: '[PRE103]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: viewonly=True collections / attributes do not get re-queried until expired
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: viewonly=True集合/属性在过期之前不会重新查询
- en: Continuing with the original viewonly attribute, if we do in fact make changes
    to the `User.all_tasks` collection on a [persistent](../glossary.html#term-persistent)
    object, the viewonly collection can only show the net result of this change after
    **two** things occur. The first is that the change to `User.all_tasks` is [flushed](../glossary.html#term-flushed),
    so that the new data is available in the database, at least within the scope of
    the local transaction. The second is that the `User.current_week_tasks` attribute
    is [expired](../glossary.html#term-expired) and reloaded via a new SQL query to
    the database.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用原始的只读属性，如果实际上对持久对象上的`User.all_tasks`集合进行更改，那么只有在发生**两个**事情之后，只读集合才能显示这种更改的净结果。第一是刷新对`User.all_tasks`的更改，以便新数据在数据库中可用，至少在本地事务范围内。第二是`User.current_week_tasks`属性被[过期](../glossary.html#term-expired)并通过对数据库的新SQL查询重新加载。
- en: 'To support this requirement, the simplest flow to use is one where the **viewonly
    relationship is consumed only in operations that are primarily read only to start
    with**. Such as below, if we retrieve a `User` fresh from the database, the collection
    will be current:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个要求，使用最简单的流程是仅在主要是只读操作中使用**仅视图关系**。比如，如果我们从数据库中获取一个新的`User`，那么集合将是当前的：
- en: '[PRE104]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When we make modifications to `u1.all_tasks`, if we want to see these changes
    reflected in the `u1.current_week_tasks` viewonly relationship, these changes
    need to be flushed and the `u1.current_week_tasks` attribute needs to be expired,
    so that it will [lazy load](../glossary.html#term-lazy-load) on next access. The
    simplest approach to this is to use [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), keeping the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter set at its default of `True`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对`u1.all_tasks`进行修改时，如果我们希望在`u1.current_week_tasks`视图关系中看到这些更改的反映，这些更改需要被刷新，并且`u1.current_week_tasks`属性需要过期，这样它将在下一次访问时进行[延迟加载](../glossary.html#term-lazy-load)。最简单的方法是使用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，保持[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")参数设置为其默认值`True`：
- en: '[PRE105]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Above, the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") flushed the changes to `u1.all_tasks` to the
    database, then expired all objects, so that when we accessed `u1.current_week_tasks`,
    a :term:` lazy load` occurred which fetched the contents for this attribute freshly
    from the database.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，对[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")的调用将更改刷新到数据库中，然后使所有对象过期，这样当我们访问`u1.current_week_tasks`时，一个:term:`延迟加载`会发生，从数据库中重新获取该属性的内容。
- en: 'To intercept operations without actually committing the transaction, the attribute
    needs to be explicitly [expired](../glossary.html#term-expired) first. A simplistic
    way to do this is to just call it directly. In the example below, [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") sends pending changes to the database, then [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") is used to expire the `u1.current_week_tasks`
    collection so that it re-fetches on next access:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截操作而不实际提交事务，需要首先显式地将属性[过期](../glossary.html#term-expired)。一个简单的方法是直接调用它。在下面的示例中，[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")将挂起的更改发送到数据库，然后使用[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")使`u1.current_week_tasks`集合过期，以便在下一次访问时重新获取：
- en: '[PRE106]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can in fact skip the call to [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush"), assuming a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that keeps [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") at its default value of `True`, as the expired `current_week_tasks`
    attribute will trigger autoflush when accessed after expiration:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以跳过对[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")的调用，假设一个保持[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")值为默认值`True`的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，因为过期的`current_week_tasks`属性在过期后被访问时会触发自动刷新：
- en: '[PRE107]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Continuing with the above approach to something more elaborate, we can apply
    the expiration programmatically when the related `User.all_tasks` collection changes,
    using [event hooks](../core/event.html). This an **advanced technique**, where
    simpler architectures like `@property` or sticking to read-only use cases should
    be examined first. In our simple example, this would be configured as:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上述方法到更复杂的内容，当相关的`User.all_tasks`集合发生变化时，我们可以在程序上应用过期，使用[event hooks](../core/event.html)。这是一种**高级技术**，应该首先检查简单的体系结构，比如`@property`或者坚持只读用例。在我们的简单示例中，这将配置为：
- en: '[PRE108]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'With the above hooks, mutation operations are intercepted and result in the
    `User.current_week_tasks` collection to be expired automatically:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述钩子，变更操作将被拦截，并导致`User.current_week_tasks`集合自动过期：
- en: '[PRE109]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The [`AttributeEvents`](events.html#sqlalchemy.orm.AttributeEvents "sqlalchemy.orm.AttributeEvents")
    event hooks used above are also triggered by backref mutations, so with the above
    hooks a change to `Task.user` is also intercepted:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 上面使用的[`AttributeEvents`](events.html#sqlalchemy.orm.AttributeEvents "sqlalchemy.orm.AttributeEvents")事件钩子也会被反向引用的变化触发，因此通过上述钩子，对`Task.user`的更改也会被拦截：
- en: '[PRE110]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
