- en: Mapper Configuration with Declarative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/declarative_config.html](https://docs.sqlalchemy.org/en/20/orm/declarative_config.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The section [Mapped Class Essential Components](mapping_styles.html#orm-mapper-configuration-overview)
    discusses the general configurational elements of a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") construct, which is the structure that defines how a
    particular user defined class is mapped to a database table or other SQL construct.
    The following sections describe specific details about how the declarative system
    goes about constructing the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper").
  prefs: []
  type: TYPE_NORMAL
- en: '## Defining Mapped Properties with Declarative'
  prefs: []
  type: TYPE_NORMAL
- en: The examples given at [Table Configuration with Declarative](declarative_tables.html)
    illustrate mappings against table-bound columns, using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct. There are several other varieties of
    ORM mapped constructs that may be configured besides table-bound columns, the
    most common being the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. Other kinds of properties include SQL
    expressions that are defined using the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") construct and multiple-column mappings using
    the [`composite()`](composites.html#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: While an [imperative mapping](mapping_styles.html#orm-imperative-mapping) makes
    use of the [properties](mapping_styles.html#orm-mapping-properties) dictionary
    to establish all the mapped class attributes, in the declarative mapping, these
    properties are all specified inline with the class definition, which in the case
    of a declarative table mapping are inline with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that will be used to generate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the example mapping of `User` and `Address`, we may illustrate
    a declarative table mapping that includes not just [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects but also relationships and SQL expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above declarative table mapping features two tables, each with a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") referring to the other, as well as a simple SQL
    expression mapped by [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"), and an additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that indicates loading should be on a “deferred”
    basis as defined by the [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") keyword. More documentation on these particular
    concepts may be found at [Basic Relationship Patterns](basic_relationships.html#relationship-patterns),
    [Using column_property](mapped_sql_expr.html#mapper-column-property-sql-expressions),
    and [Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral).
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties may be specified with a declarative mapping as above using “hybrid
    table” style as well; the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are directly part of a table move into
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    definition but everything else, including composed SQL expressions, would still
    be inline with the class definition. Constructs that need to refer to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly would reference it in terms of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. To illustrate the above mapping using hybrid
    table style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note above:'
  prefs: []
  type: TYPE_NORMAL
- en: The address [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    contains a column called `address_statistics`, however we re-map this column under
    the same attribute name to be under the control of a [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With both declararative table and hybrid table mappings, when we define a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") construct, we always name the target table using
    the **table name**, and not the mapped class name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we define [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, as these constructs create a linkage
    between two mapped classes where one necessarily is defined before the other,
    we can refer to the remote class using its string name. This functionality also
    extends into the area of other arguments specified on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") such as the “primary join” and “order by” arguments.
    See the section [Late-Evaluation of Relationship Arguments](basic_relationships.html#orm-declarative-relationship-eval)
    for details on this.  ## Mapper Configuration Options with Declarative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all mapping forms, the mapping of the class is configured through parameters
    that become part of the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object. The function which ultimately receives these arguments is the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") function, and are delivered to it from one of the front-facing
    mapping functions defined on the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the declarative form of mapping, mapper arguments are specified using the
    `__mapper_args__` declarative class variable, which is a dictionary that is passed
    as keyword arguments to the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") function. Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map Specific Primary Key Columns**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates Declarative-level settings for the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, which establishes particular columns as part
    of what the ORM should consider to be a primary key for the class, independently
    of schema-level primary key constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping to an Explicit Set of Primary Key Columns](declarative_tables.html#mapper-primary-key)
    - further background on ORM mapping of explicit columns as primary key columns'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version ID Column**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates Declarative-level settings for the [`Mapper.version_id_col`](mapping_api.html#sqlalchemy.orm.Mapper.params.version_id_col
    "sqlalchemy.orm.Mapper") and [`Mapper.version_id_generator`](mapping_api.html#sqlalchemy.orm.Mapper.params.version_id_generator
    "sqlalchemy.orm.Mapper") parameters, which configure an ORM-maintained version
    counter that is updated and checked within the [unit of work](../glossary.html#term-unit-of-work)
    flush process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring a Version Counter](versioning.html#mapper-version-counter) - background
    on the ORM version counter feature'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Table Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates Declarative-level settings for the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") and [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameters, which are used when configuring a single-table
    inheritance mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Single Table Inheritance](inheritance.html#single-inheritance) - background
    on the ORM single table inheritance mapping feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing mapper arguments dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__mapper_args__` dictionary may be generated from a class-bound descriptor
    method rather than from a fixed dictionary by making use of the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") construct. This is useful to create arguments
    for mappers that are programmatically derived from the table configuration or
    other aspects of the mapped class. A dynamic `__mapper_args__` attribute will
    typically be useful when using a Declarative Mixin or abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to omit from the mapping any columns that have a special [`Column.info`](../core/metadata.html#sqlalchemy.schema.Column.info
    "sqlalchemy.schema.Column.info") value, a mixin can use a `__mapper_args__` method
    that scans for these columns from the `cls.__table__` attribute and passes them
    to the [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `ExcludeColsWFlag` mixin provides a per-class `__mapper_args__`
    hook that will scan for [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include the key/value `''exclude'': True`
    passed to the [`Column.info`](../core/metadata.html#sqlalchemy.schema.Column.params.info
    "sqlalchemy.schema.Column") parameter, and then add their string “key” name to
    the [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") collection which will prevent the resulting [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") from considering these columns for any SQL operations.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Composing Mapped Hierarchies with Mixins](declarative_mixins.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Other Declarative Mapping Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`__declare_last__()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `__declare_last__()` hook allows definition of a class level function that
    is automatically called by the [`MapperEvents.after_configured()`](events.html#sqlalchemy.orm.MapperEvents.after_configured
    "sqlalchemy.orm.MapperEvents.after_configured") event, which occurs after mappings
    are assumed to be completed and the ‘configure’ step has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`__declare_first__()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like `__declare_last__()`, but is called at the beginning of mapper configuration
    via the [`MapperEvents.before_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_configured
    "sqlalchemy.orm.MapperEvents.before_configured") event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '### `metadata`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection normally used to assign a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is the `registry.metadata` attribute associated with
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object in use. When using a declarative base class such as that produced by the
    [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    superclass, as well as legacy functions such as [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") and [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"), this [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") is also normally present as an attribute named `.metadata`
    that’s directly on the base class, and thus also on the mapped class via inheritance.
    Declarative uses this attribute, when present, in order to determine the target
    [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection, or if not present, uses the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") associated directly with the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry").
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute may also be assigned towards in order to affect the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection to be used on a per-mapped-hierarchy
    basis for a single base and/or [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"). This takes effect whether a declarative base class
    is used or if the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator is used directly, thus allowing patterns
    such as the metadata-per-abstract base example in the next section, [__abstract__](#declarative-abstract).
    A similar pattern can be illustrated using [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[__abstract__](#declarative-abstract)  ### `__abstract__`'
  prefs: []
  type: TYPE_NORMAL
- en: '`__abstract__` causes declarative to skip the production of a table or mapper
    for the class entirely. A class can be added within a hierarchy in the same way
    as mixin (see [Mixin and Custom Base Classes](extensions/declarative/mixins.html#declarative-mixins)),
    allowing subclasses to extend just from the special class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible use of `__abstract__` is to use a distinct [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") for different bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, classes which inherit from `DefaultBase` will use one [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") as the registry of tables, and those which inherit
    from `OtherBase` will use a different one. The tables themselves can then be created
    perhaps within distinct databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building Deeper Hierarchies with polymorphic_abstract](inheritance.html#orm-inheritance-abstract-poly)
    - an alternative form of “abstract” mapped class that is appropriate for inheritance
    hierarchies.  ### `__table_cls__`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allows the callable / class used to generate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to be customized. This is a very open-ended hook that
    can allow special customizations to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that one generates here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The above mixin would cause all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects generated to include the prefix `"my_"`, followed
    by the name normally specified using the `__tablename__` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`__table_cls__` also supports the case of returning `None`, which causes the
    class to be considered as single-table inheritance vs. its subclass. This may
    be useful in some customization schemes to determine that single-table inheritance
    should take place based on the arguments for the table itself, such as, define
    as single-inheritance if there is no primary key present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `Employee` class would be mapped as single-table inheritance against
    `Person`; the `employee_name` column would be added as a member of the `Person`
    table.  ## Defining Mapped Properties with Declarative'
  prefs: []
  type: TYPE_NORMAL
- en: The examples given at [Table Configuration with Declarative](declarative_tables.html)
    illustrate mappings against table-bound columns, using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct. There are several other varieties of
    ORM mapped constructs that may be configured besides table-bound columns, the
    most common being the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct. Other kinds of properties include SQL
    expressions that are defined using the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") construct and multiple-column mappings using
    the [`composite()`](composites.html#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: While an [imperative mapping](mapping_styles.html#orm-imperative-mapping) makes
    use of the [properties](mapping_styles.html#orm-mapping-properties) dictionary
    to establish all the mapped class attributes, in the declarative mapping, these
    properties are all specified inline with the class definition, which in the case
    of a declarative table mapping are inline with the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that will be used to generate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the example mapping of `User` and `Address`, we may illustrate
    a declarative table mapping that includes not just [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects but also relationships and SQL expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The above declarative table mapping features two tables, each with a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") referring to the other, as well as a simple SQL
    expression mapped by [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"), and an additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that indicates loading should be on a “deferred”
    basis as defined by the [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") keyword. More documentation on these particular
    concepts may be found at [Basic Relationship Patterns](basic_relationships.html#relationship-patterns),
    [Using column_property](mapped_sql_expr.html#mapper-column-property-sql-expressions),
    and [Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral).
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties may be specified with a declarative mapping as above using “hybrid
    table” style as well; the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are directly part of a table move into
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    definition but everything else, including composed SQL expressions, would still
    be inline with the class definition. Constructs that need to refer to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directly would reference it in terms of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object. To illustrate the above mapping using hybrid
    table style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to note above:'
  prefs: []
  type: TYPE_NORMAL
- en: The address [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    contains a column called `address_statistics`, however we re-map this column under
    the same attribute name to be under the control of a [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") construct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With both declararative table and hybrid table mappings, when we define a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") construct, we always name the target table using
    the **table name**, and not the mapped class name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we define [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs, as these constructs create a linkage
    between two mapped classes where one necessarily is defined before the other,
    we can refer to the remote class using its string name. This functionality also
    extends into the area of other arguments specified on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") such as the “primary join” and “order by” arguments.
    See the section [Late-Evaluation of Relationship Arguments](basic_relationships.html#orm-declarative-relationship-eval)
    for details on this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Mapper Configuration Options with Declarative'
  prefs: []
  type: TYPE_NORMAL
- en: With all mapping forms, the mapping of the class is configured through parameters
    that become part of the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object. The function which ultimately receives these arguments is the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") function, and are delivered to it from one of the front-facing
    mapping functions defined on the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the declarative form of mapping, mapper arguments are specified using the
    `__mapper_args__` declarative class variable, which is a dictionary that is passed
    as keyword arguments to the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") function. Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map Specific Primary Key Columns**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates Declarative-level settings for the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, which establishes particular columns as part
    of what the ORM should consider to be a primary key for the class, independently
    of schema-level primary key constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping to an Explicit Set of Primary Key Columns](declarative_tables.html#mapper-primary-key)
    - further background on ORM mapping of explicit columns as primary key columns'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version ID Column**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates Declarative-level settings for the [`Mapper.version_id_col`](mapping_api.html#sqlalchemy.orm.Mapper.params.version_id_col
    "sqlalchemy.orm.Mapper") and [`Mapper.version_id_generator`](mapping_api.html#sqlalchemy.orm.Mapper.params.version_id_generator
    "sqlalchemy.orm.Mapper") parameters, which configure an ORM-maintained version
    counter that is updated and checked within the [unit of work](../glossary.html#term-unit-of-work)
    flush process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring a Version Counter](versioning.html#mapper-version-counter) - background
    on the ORM version counter feature'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Table Inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates Declarative-level settings for the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") and [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameters, which are used when configuring a single-table
    inheritance mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Single Table Inheritance](inheritance.html#single-inheritance) - background
    on the ORM single table inheritance mapping feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing mapper arguments dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__mapper_args__` dictionary may be generated from a class-bound descriptor
    method rather than from a fixed dictionary by making use of the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") construct. This is useful to create arguments
    for mappers that are programmatically derived from the table configuration or
    other aspects of the mapped class. A dynamic `__mapper_args__` attribute will
    typically be useful when using a Declarative Mixin or abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to omit from the mapping any columns that have a special [`Column.info`](../core/metadata.html#sqlalchemy.schema.Column.info
    "sqlalchemy.schema.Column.info") value, a mixin can use a `__mapper_args__` method
    that scans for these columns from the `cls.__table__` attribute and passes them
    to the [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `ExcludeColsWFlag` mixin provides a per-class `__mapper_args__`
    hook that will scan for [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include the key/value `''exclude'': True`
    passed to the [`Column.info`](../core/metadata.html#sqlalchemy.schema.Column.params.info
    "sqlalchemy.schema.Column") parameter, and then add their string “key” name to
    the [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") collection which will prevent the resulting [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") from considering these columns for any SQL operations.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Composing Mapped Hierarchies with Mixins](declarative_mixins.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Constructing mapper arguments dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__mapper_args__` dictionary may be generated from a class-bound descriptor
    method rather than from a fixed dictionary by making use of the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") construct. This is useful to create arguments
    for mappers that are programmatically derived from the table configuration or
    other aspects of the mapped class. A dynamic `__mapper_args__` attribute will
    typically be useful when using a Declarative Mixin or abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to omit from the mapping any columns that have a special [`Column.info`](../core/metadata.html#sqlalchemy.schema.Column.info
    "sqlalchemy.schema.Column.info") value, a mixin can use a `__mapper_args__` method
    that scans for these columns from the `cls.__table__` attribute and passes them
    to the [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `ExcludeColsWFlag` mixin provides a per-class `__mapper_args__`
    hook that will scan for [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include the key/value `''exclude'': True`
    passed to the [`Column.info`](../core/metadata.html#sqlalchemy.schema.Column.params.info
    "sqlalchemy.schema.Column") parameter, and then add their string “key” name to
    the [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") collection which will prevent the resulting [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") from considering these columns for any SQL operations.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Composing Mapped Hierarchies with Mixins](declarative_mixins.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Other Declarative Mapping Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`__declare_last__()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `__declare_last__()` hook allows definition of a class level function that
    is automatically called by the [`MapperEvents.after_configured()`](events.html#sqlalchemy.orm.MapperEvents.after_configured
    "sqlalchemy.orm.MapperEvents.after_configured") event, which occurs after mappings
    are assumed to be completed and the ‘configure’ step has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`__declare_first__()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like `__declare_last__()`, but is called at the beginning of mapper configuration
    via the [`MapperEvents.before_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_configured
    "sqlalchemy.orm.MapperEvents.before_configured") event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '### `metadata`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection normally used to assign a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is the `registry.metadata` attribute associated with
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object in use. When using a declarative base class such as that produced by the
    [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    superclass, as well as legacy functions such as [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") and [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"), this [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") is also normally present as an attribute named `.metadata`
    that’s directly on the base class, and thus also on the mapped class via inheritance.
    Declarative uses this attribute, when present, in order to determine the target
    [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection, or if not present, uses the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") associated directly with the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry").
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute may also be assigned towards in order to affect the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection to be used on a per-mapped-hierarchy
    basis for a single base and/or [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"). This takes effect whether a declarative base class
    is used or if the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator is used directly, thus allowing patterns
    such as the metadata-per-abstract base example in the next section, [__abstract__](#declarative-abstract).
    A similar pattern can be illustrated using [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[__abstract__](#declarative-abstract)  ### `__abstract__`'
  prefs: []
  type: TYPE_NORMAL
- en: '`__abstract__` causes declarative to skip the production of a table or mapper
    for the class entirely. A class can be added within a hierarchy in the same way
    as mixin (see [Mixin and Custom Base Classes](extensions/declarative/mixins.html#declarative-mixins)),
    allowing subclasses to extend just from the special class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible use of `__abstract__` is to use a distinct [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") for different bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, classes which inherit from `DefaultBase` will use one [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") as the registry of tables, and those which inherit
    from `OtherBase` will use a different one. The tables themselves can then be created
    perhaps within distinct databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building Deeper Hierarchies with polymorphic_abstract](inheritance.html#orm-inheritance-abstract-poly)
    - an alternative form of “abstract” mapped class that is appropriate for inheritance
    hierarchies.  ### `__table_cls__`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allows the callable / class used to generate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to be customized. This is a very open-ended hook that
    can allow special customizations to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that one generates here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The above mixin would cause all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects generated to include the prefix `"my_"`, followed
    by the name normally specified using the `__tablename__` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`__table_cls__` also supports the case of returning `None`, which causes the
    class to be considered as single-table inheritance vs. its subclass. This may
    be useful in some customization schemes to determine that single-table inheritance
    should take place based on the arguments for the table itself, such as, define
    as single-inheritance if there is no primary key present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The above `Employee` class would be mapped as single-table inheritance against
    `Person`; the `employee_name` column would be added as a member of the `Person`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '`__declare_last__()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `__declare_last__()` hook allows definition of a class level function that
    is automatically called by the [`MapperEvents.after_configured()`](events.html#sqlalchemy.orm.MapperEvents.after_configured
    "sqlalchemy.orm.MapperEvents.after_configured") event, which occurs after mappings
    are assumed to be completed and the ‘configure’ step has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`__declare_first__()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like `__declare_last__()`, but is called at the beginning of mapper configuration
    via the [`MapperEvents.before_configured()`](events.html#sqlalchemy.orm.MapperEvents.before_configured
    "sqlalchemy.orm.MapperEvents.before_configured") event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '### `metadata`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection normally used to assign a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is the `registry.metadata` attribute associated with
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object in use. When using a declarative base class such as that produced by the
    [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    superclass, as well as legacy functions such as [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") and [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"), this [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") is also normally present as an attribute named `.metadata`
    that’s directly on the base class, and thus also on the mapped class via inheritance.
    Declarative uses this attribute, when present, in order to determine the target
    [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection, or if not present, uses the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") associated directly with the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry").
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute may also be assigned towards in order to affect the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection to be used on a per-mapped-hierarchy
    basis for a single base and/or [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"). This takes effect whether a declarative base class
    is used or if the [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") decorator is used directly, thus allowing patterns
    such as the metadata-per-abstract base example in the next section, [__abstract__](#declarative-abstract).
    A similar pattern can be illustrated using [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[__abstract__](#declarative-abstract)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `__abstract__`'
  prefs: []
  type: TYPE_NORMAL
- en: '`__abstract__` causes declarative to skip the production of a table or mapper
    for the class entirely. A class can be added within a hierarchy in the same way
    as mixin (see [Mixin and Custom Base Classes](extensions/declarative/mixins.html#declarative-mixins)),
    allowing subclasses to extend just from the special class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible use of `__abstract__` is to use a distinct [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") for different bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, classes which inherit from `DefaultBase` will use one [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") as the registry of tables, and those which inherit
    from `OtherBase` will use a different one. The tables themselves can then be created
    perhaps within distinct databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building Deeper Hierarchies with polymorphic_abstract](inheritance.html#orm-inheritance-abstract-poly)
    - an alternative form of “abstract” mapped class that is appropriate for inheritance
    hierarchies.'
  prefs: []
  type: TYPE_NORMAL
- en: '### `__table_cls__`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allows the callable / class used to generate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to be customized. This is a very open-ended hook that
    can allow special customizations to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that one generates here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The above mixin would cause all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects generated to include the prefix `"my_"`, followed
    by the name normally specified using the `__tablename__` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`__table_cls__` also supports the case of returning `None`, which causes the
    class to be considered as single-table inheritance vs. its subclass. This may
    be useful in some customization schemes to determine that single-table inheritance
    should take place based on the arguments for the table itself, such as, define
    as single-inheritance if there is no primary key present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The above `Employee` class would be mapped as single-table inheritance against
    `Person`; the `employee_name` column would be added as a member of the `Person`
    table.
  prefs: []
  type: TYPE_NORMAL
