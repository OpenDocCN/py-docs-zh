["```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import create_engine\n\nBase = automap_base()\n\n# engine, suppose it has two tables 'user' and 'address' set up\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# reflect the tables\nBase.prepare(autoload_with=engine)\n\n# mapped classes are now created with names by default\n# matching that of the table name.\nUser = Base.classes.user\nAddress = Base.classes.address\n\nsession = Session(engine)\n\n# rudimentary relationships are produced\nsession.add(Address(email_address=\"foo@bar.com\", user=User(name=\"foo\")))\nsession.commit()\n\n# collection-based relationships are by default named\n# \"<classname>_collection\"\nu1 = session.query(User).first()\nprint(u1.address_collection)\n```", "```py\nfrom sqlalchemy import create_engine, MetaData, Table, Column, ForeignKey\nfrom sqlalchemy.ext.automap import automap_base\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# produce our own MetaData object\nmetadata = MetaData()\n\n# we can reflect it ourselves from a database, using options\n# such as 'only' to limit what tables we look at...\nmetadata.reflect(engine, only=[\"user\", \"address\"])\n\n# ... or just define our own Table objects with it (or combine both)\nTable(\n    \"user_order\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"user_id\", ForeignKey(\"user.id\")),\n)\n\n# we can then produce a set of mappings from this MetaData.\nBase = automap_base(metadata=metadata)\n\n# calling prepare() just sets up mapped classes and relationships.\nBase.prepare()\n\n# mapped classes are ready\nUser = Base.classes.user\nAddress = Base.classes.address\nOrder = Base.classes.user_order\n```", "```py\ne = create_engine(\"postgresql://scott:tiger@localhost/test\")\n\nBase.metadata.create_all(e)\n\nBase = automap_base()\n\nBase.prepare(e)\nBase.prepare(e, schema=\"test_schema\")\nBase.prepare(e, schema=\"test_schema_2\")\n```", "```py\ne = create_engine(\"postgresql://scott:tiger@localhost/test\")\n\nBase.metadata.create_all(e)\n\ndef module_name_for_table(cls, tablename, table):\n    if table.schema is not None:\n        return f\"mymodule.{table.schema}\"\n    else:\n        return f\"mymodule.default\"\n\nBase = automap_base()\n\nBase.prepare(e, modulename_for_table=module_name_for_table)\nBase.prepare(e, schema=\"test_schema\", modulename_for_table=module_name_for_table)\nBase.prepare(e, schema=\"test_schema_2\", modulename_for_table=module_name_for_table)\n```", "```py\nBase.by_module.mymodule.default.accounts\nBase.by_module.mymodule.test_schema.accounts\nBase.by_module.mymodule.test_schema_2.accounts\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import create_engine\n\n# automap base\nBase = automap_base()\n\n# pre-declare User for the 'user' table\nclass User(Base):\n    __tablename__ = \"user\"\n\n    # override schema elements like Columns\n    user_name = Column(\"name\", String)\n\n    # override relationships too, if desired.\n    # we must use the same name that automap would use for the\n    # relationship, and also must refer to the class name that automap will\n    # generate for \"address\"\n    address_collection = relationship(\"address\", collection_class=set)\n\n# reflect\nengine = create_engine(\"sqlite:///mydatabase.db\")\nBase.prepare(autoload_with=engine)\n\n# we still have Address generated from the tablename \"address\",\n# but User is the same as Base.classes.User now\n\nAddress = Base.classes.address\n\nu1 = session.query(User).first()\nprint(u1.address_collection)\n\n# the backref is still there:\na1 = session.query(Address).first()\nprint(a1.user)\n```", "```py\nimport re\nimport inflect\n\ndef camelize_classname(base, tablename, table):\n    \"Produce a 'camelized' class name, e.g.\"\n    \"'words_and_underscores' -> 'WordsAndUnderscores'\"\n\n    return str(\n        tablename[0].upper()\n        + re.sub(\n            r\"_([a-z])\",\n            lambda m: m.group(1).upper(),\n            tablename[1:],\n        )\n    )\n\n_pluralizer = inflect.engine()\n\ndef pluralize_collection(base, local_cls, referred_cls, constraint):\n    \"Produce an 'uncamelized', 'pluralized' class name, e.g.\"\n    \"'SomeTerm' -> 'some_terms'\"\n\n    referred_name = referred_cls.__name__\n    uncamelized = re.sub(\n        r\"[A-Z]\",\n        lambda m: \"_%s\" % m.group(0).lower(),\n        referred_name,\n    )[1:]\n    pluralized = _pluralizer.plural(uncamelized)\n    return pluralized\n\nfrom sqlalchemy.ext.automap import automap_base\n\nBase = automap_base()\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\nBase.prepare(\n    autoload_with=engine,\n    classname_for_table=camelize_classname,\n    name_for_collection_relationship=pluralize_collection,\n)\n```", "```py\nUser, Address = Base.classes.User, Base.classes.Address\n\nu1 = User(addresses=[Address(email=\"foo@bar.com\")])\n```", "```py\nfrom sqlalchemy.ext.automap import generate_relationship\nfrom sqlalchemy.orm import interfaces\n\ndef _gen_relationship(\n    base, direction, return_fn, attrname, local_cls, referred_cls, **kw\n):\n    if direction is interfaces.ONETOMANY:\n        kw[\"cascade\"] = \"all, delete-orphan\"\n        kw[\"passive_deletes\"] = True\n    # make use of the built-in function to actually return\n    # the result.\n    return generate_relationship(\n        base, direction, return_fn, attrname, local_cls, referred_cls, **kw\n    )\n\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import create_engine\n\n# automap base\nBase = automap_base()\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\nBase.prepare(autoload_with=engine, generate_relationship=_gen_relationship)\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String(50))\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Engineer(Employee):\n    __tablename__ = \"engineer\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"engineer\",\n    }\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String(50))\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Engineer(Employee):\n    __tablename__ = \"engineer\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n    favorite_employee_id = Column(Integer, ForeignKey(\"employee.id\"))\n\n    favorite_employee = relationship(Employee, foreign_keys=favorite_employee_id)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"engineer\",\n        \"inherit_condition\": id == Employee.id,\n    }\n```", "```py\nCREATE  TABLE  table_a  (\n  id  INTEGER  PRIMARY  KEY\n);\n\nCREATE  TABLE  table_b  (\n  id  INTEGER  PRIMARY  KEY,\n  table_a  INTEGER,\n  FOREIGN  KEY(table_a)  REFERENCES  table_a(id)\n);\n```", "```py\ndef name_for_scalar_relationship(base, local_cls, referred_cls, constraint):\n    name = referred_cls.__name__.lower()\n    local_table = local_cls.__table__\n    if name in local_table.columns:\n        newname = name + \"_\"\n        warnings.warn(\"Already detected name %s present.  using %s\" % (name, newname))\n        return newname\n    return name\n\nBase.prepare(\n    autoload_with=engine,\n    name_for_scalar_relationship=name_for_scalar_relationship,\n)\n```", "```py\nBase = automap_base()\n\nclass TableB(Base):\n    __tablename__ = \"table_b\"\n    _table_a = Column(\"table_a\", ForeignKey(\"table_a.id\"))\n\nBase.prepare(autoload_with=engine)\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import Column, Integer, String, ForeignKey\n\nBase = automap_base()\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n    user_id = Column(ForeignKey(\"user.id\"))\n\n# produce relationships\nBase.prepare()\n\n# mapping is complete, with \"address_collection\" and\n# \"user\" relationships\na1 = Address(email=\"u1\")\na2 = Address(email=\"u2\")\nu1 = User(address_collection=[a1, a2])\nassert a1.user is u1\n```", "```py\n@event.listens_for(Base.metadata, \"column_reflect\")\ndef column_reflect(inspector, table, column_info):\n    # set column.key = \"attr_<lower_case_name>\"\n    column_info[\"key\"] = \"attr_%s\" % column_info[\"name\"].lower()\n\n# run reflection\nBase.prepare(autoload_with=engine)\n```", "```py\nfunction sqlalchemy.ext.automap.automap_base(declarative_base: Type[Any] | None = None, **kw: Any) \u2192 Any\n```", "```py\nclass sqlalchemy.ext.automap.AutomapBase\n```", "```py\nattribute by_module: ClassVar[ByModuleProperties]\n```", "```py\nUser = Base.by_module.sqlalchemy.ext.automap.User\n```", "```py\nMyClass = Base.by_module.mymodule.account.MyClass\n```", "```py\nattribute classes: ClassVar[Properties[Type[Any]]]\n```", "```py\nBase = automap_base()\nBase.prepare(autoload_with=some_engine)\n\nUser, Address = Base.classes.User, Base.classes.Address\n```", "```py\nItem = Base.classes[\"items\"]\n```", "```py\nattribute metadata: ClassVar[MetaData]\n```", "```py\nclassmethod prepare(autoload_with: Engine | None = None, engine: Any | None = None, reflect: bool = False, schema: str | None = None, classname_for_table: PythonNameForTableType | None = None, modulename_for_table: PythonNameForTableType | None = None, collection_class: Any | None = None, name_for_scalar_relationship: NameForScalarRelationshipType | None = None, name_for_collection_relationship: NameForCollectionRelationshipType | None = None, generate_relationship: GenerateRelationshipType | None = None, reflection_options: Dict[_KT, _VT] | immutabledict[_KT, _VT] = {}) \u2192 None\n```", "```py\nfunction sqlalchemy.ext.automap.classname_for_table(base: Type[Any], tablename: str, table: Table) \u2192 str\n```", "```py\nreturn str(tablename)\n```", "```py\nfunction sqlalchemy.ext.automap.name_for_scalar_relationship(base: Type[Any], local_cls: Type[Any], referred_cls: Type[Any], constraint: ForeignKeyConstraint) \u2192 str\n```", "```py\nreturn referred_cls.__name__.lower()\n```", "```py\nfunction sqlalchemy.ext.automap.name_for_collection_relationship(base: Type[Any], local_cls: Type[Any], referred_cls: Type[Any], constraint: ForeignKeyConstraint) \u2192 str\n```", "```py\nreturn referred_cls.__name__.lower() + \"_collection\"\n```", "```py\nfunction sqlalchemy.ext.automap.generate_relationship(base: Type[Any], direction: RelationshipDirection, return_fn: Callable[..., Relationship[Any]] | Callable[..., ORMBackrefArgument], attrname: str, local_cls: Type[Any], referred_cls: Type[Any], **kw: Any) \u2192 Relationship[Any] | ORMBackrefArgument\n```", "```py\nif return_fn is backref:\n    return return_fn(attrname, **kw)\nelif return_fn is relationship:\n    return return_fn(referred_cls, **kw)\nelse:\n    raise TypeError(\"Unknown relationship function: %s\" % return_fn)\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import create_engine\n\nBase = automap_base()\n\n# engine, suppose it has two tables 'user' and 'address' set up\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# reflect the tables\nBase.prepare(autoload_with=engine)\n\n# mapped classes are now created with names by default\n# matching that of the table name.\nUser = Base.classes.user\nAddress = Base.classes.address\n\nsession = Session(engine)\n\n# rudimentary relationships are produced\nsession.add(Address(email_address=\"foo@bar.com\", user=User(name=\"foo\")))\nsession.commit()\n\n# collection-based relationships are by default named\n# \"<classname>_collection\"\nu1 = session.query(User).first()\nprint(u1.address_collection)\n```", "```py\nfrom sqlalchemy import create_engine, MetaData, Table, Column, ForeignKey\nfrom sqlalchemy.ext.automap import automap_base\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\n# produce our own MetaData object\nmetadata = MetaData()\n\n# we can reflect it ourselves from a database, using options\n# such as 'only' to limit what tables we look at...\nmetadata.reflect(engine, only=[\"user\", \"address\"])\n\n# ... or just define our own Table objects with it (or combine both)\nTable(\n    \"user_order\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"user_id\", ForeignKey(\"user.id\")),\n)\n\n# we can then produce a set of mappings from this MetaData.\nBase = automap_base(metadata=metadata)\n\n# calling prepare() just sets up mapped classes and relationships.\nBase.prepare()\n\n# mapped classes are ready\nUser = Base.classes.user\nAddress = Base.classes.address\nOrder = Base.classes.user_order\n```", "```py\ne = create_engine(\"postgresql://scott:tiger@localhost/test\")\n\nBase.metadata.create_all(e)\n\nBase = automap_base()\n\nBase.prepare(e)\nBase.prepare(e, schema=\"test_schema\")\nBase.prepare(e, schema=\"test_schema_2\")\n```", "```py\ne = create_engine(\"postgresql://scott:tiger@localhost/test\")\n\nBase.metadata.create_all(e)\n\ndef module_name_for_table(cls, tablename, table):\n    if table.schema is not None:\n        return f\"mymodule.{table.schema}\"\n    else:\n        return f\"mymodule.default\"\n\nBase = automap_base()\n\nBase.prepare(e, modulename_for_table=module_name_for_table)\nBase.prepare(e, schema=\"test_schema\", modulename_for_table=module_name_for_table)\nBase.prepare(e, schema=\"test_schema_2\", modulename_for_table=module_name_for_table)\n```", "```py\nBase.by_module.mymodule.default.accounts\nBase.by_module.mymodule.test_schema.accounts\nBase.by_module.mymodule.test_schema_2.accounts\n```", "```py\ne = create_engine(\"postgresql://scott:tiger@localhost/test\")\n\nBase.metadata.create_all(e)\n\ndef module_name_for_table(cls, tablename, table):\n    if table.schema is not None:\n        return f\"mymodule.{table.schema}\"\n    else:\n        return f\"mymodule.default\"\n\nBase = automap_base()\n\nBase.prepare(e, modulename_for_table=module_name_for_table)\nBase.prepare(e, schema=\"test_schema\", modulename_for_table=module_name_for_table)\nBase.prepare(e, schema=\"test_schema_2\", modulename_for_table=module_name_for_table)\n```", "```py\nBase.by_module.mymodule.default.accounts\nBase.by_module.mymodule.test_schema.accounts\nBase.by_module.mymodule.test_schema_2.accounts\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import create_engine\n\n# automap base\nBase = automap_base()\n\n# pre-declare User for the 'user' table\nclass User(Base):\n    __tablename__ = \"user\"\n\n    # override schema elements like Columns\n    user_name = Column(\"name\", String)\n\n    # override relationships too, if desired.\n    # we must use the same name that automap would use for the\n    # relationship, and also must refer to the class name that automap will\n    # generate for \"address\"\n    address_collection = relationship(\"address\", collection_class=set)\n\n# reflect\nengine = create_engine(\"sqlite:///mydatabase.db\")\nBase.prepare(autoload_with=engine)\n\n# we still have Address generated from the tablename \"address\",\n# but User is the same as Base.classes.User now\n\nAddress = Base.classes.address\n\nu1 = session.query(User).first()\nprint(u1.address_collection)\n\n# the backref is still there:\na1 = session.query(Address).first()\nprint(a1.user)\n```", "```py\nimport re\nimport inflect\n\ndef camelize_classname(base, tablename, table):\n    \"Produce a 'camelized' class name, e.g.\"\n    \"'words_and_underscores' -> 'WordsAndUnderscores'\"\n\n    return str(\n        tablename[0].upper()\n        + re.sub(\n            r\"_([a-z])\",\n            lambda m: m.group(1).upper(),\n            tablename[1:],\n        )\n    )\n\n_pluralizer = inflect.engine()\n\ndef pluralize_collection(base, local_cls, referred_cls, constraint):\n    \"Produce an 'uncamelized', 'pluralized' class name, e.g.\"\n    \"'SomeTerm' -> 'some_terms'\"\n\n    referred_name = referred_cls.__name__\n    uncamelized = re.sub(\n        r\"[A-Z]\",\n        lambda m: \"_%s\" % m.group(0).lower(),\n        referred_name,\n    )[1:]\n    pluralized = _pluralizer.plural(uncamelized)\n    return pluralized\n\nfrom sqlalchemy.ext.automap import automap_base\n\nBase = automap_base()\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\n\nBase.prepare(\n    autoload_with=engine,\n    classname_for_table=camelize_classname,\n    name_for_collection_relationship=pluralize_collection,\n)\n```", "```py\nUser, Address = Base.classes.User, Base.classes.Address\n\nu1 = User(addresses=[Address(email=\"foo@bar.com\")])\n```", "```py\nfrom sqlalchemy.ext.automap import generate_relationship\nfrom sqlalchemy.orm import interfaces\n\ndef _gen_relationship(\n    base, direction, return_fn, attrname, local_cls, referred_cls, **kw\n):\n    if direction is interfaces.ONETOMANY:\n        kw[\"cascade\"] = \"all, delete-orphan\"\n        kw[\"passive_deletes\"] = True\n    # make use of the built-in function to actually return\n    # the result.\n    return generate_relationship(\n        base, direction, return_fn, attrname, local_cls, referred_cls, **kw\n    )\n\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import create_engine\n\n# automap base\nBase = automap_base()\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\nBase.prepare(autoload_with=engine, generate_relationship=_gen_relationship)\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String(50))\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Engineer(Employee):\n    __tablename__ = \"engineer\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"engineer\",\n    }\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String(50))\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Engineer(Employee):\n    __tablename__ = \"engineer\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n    favorite_employee_id = Column(Integer, ForeignKey(\"employee.id\"))\n\n    favorite_employee = relationship(Employee, foreign_keys=favorite_employee_id)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"engineer\",\n        \"inherit_condition\": id == Employee.id,\n    }\n```", "```py\nCREATE  TABLE  table_a  (\n  id  INTEGER  PRIMARY  KEY\n);\n\nCREATE  TABLE  table_b  (\n  id  INTEGER  PRIMARY  KEY,\n  table_a  INTEGER,\n  FOREIGN  KEY(table_a)  REFERENCES  table_a(id)\n);\n```", "```py\ndef name_for_scalar_relationship(base, local_cls, referred_cls, constraint):\n    name = referred_cls.__name__.lower()\n    local_table = local_cls.__table__\n    if name in local_table.columns:\n        newname = name + \"_\"\n        warnings.warn(\"Already detected name %s present.  using %s\" % (name, newname))\n        return newname\n    return name\n\nBase.prepare(\n    autoload_with=engine,\n    name_for_scalar_relationship=name_for_scalar_relationship,\n)\n```", "```py\nBase = automap_base()\n\nclass TableB(Base):\n    __tablename__ = \"table_b\"\n    _table_a = Column(\"table_a\", ForeignKey(\"table_a.id\"))\n\nBase.prepare(autoload_with=engine)\n```", "```py\nfrom sqlalchemy.ext.automap import generate_relationship\nfrom sqlalchemy.orm import interfaces\n\ndef _gen_relationship(\n    base, direction, return_fn, attrname, local_cls, referred_cls, **kw\n):\n    if direction is interfaces.ONETOMANY:\n        kw[\"cascade\"] = \"all, delete-orphan\"\n        kw[\"passive_deletes\"] = True\n    # make use of the built-in function to actually return\n    # the result.\n    return generate_relationship(\n        base, direction, return_fn, attrname, local_cls, referred_cls, **kw\n    )\n\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import create_engine\n\n# automap base\nBase = automap_base()\n\nengine = create_engine(\"sqlite:///mydatabase.db\")\nBase.prepare(autoload_with=engine, generate_relationship=_gen_relationship)\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String(50))\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Engineer(Employee):\n    __tablename__ = \"engineer\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"engineer\",\n    }\n```", "```py\nclass Employee(Base):\n    __tablename__ = \"employee\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String(50))\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"employee\",\n        \"polymorphic_on\": type,\n    }\n\nclass Engineer(Employee):\n    __tablename__ = \"engineer\"\n    id = Column(Integer, ForeignKey(\"employee.id\"), primary_key=True)\n    favorite_employee_id = Column(Integer, ForeignKey(\"employee.id\"))\n\n    favorite_employee = relationship(Employee, foreign_keys=favorite_employee_id)\n\n    __mapper_args__ = {\n        \"polymorphic_identity\": \"engineer\",\n        \"inherit_condition\": id == Employee.id,\n    }\n```", "```py\nCREATE  TABLE  table_a  (\n  id  INTEGER  PRIMARY  KEY\n);\n\nCREATE  TABLE  table_b  (\n  id  INTEGER  PRIMARY  KEY,\n  table_a  INTEGER,\n  FOREIGN  KEY(table_a)  REFERENCES  table_a(id)\n);\n```", "```py\ndef name_for_scalar_relationship(base, local_cls, referred_cls, constraint):\n    name = referred_cls.__name__.lower()\n    local_table = local_cls.__table__\n    if name in local_table.columns:\n        newname = name + \"_\"\n        warnings.warn(\"Already detected name %s present.  using %s\" % (name, newname))\n        return newname\n    return name\n\nBase.prepare(\n    autoload_with=engine,\n    name_for_scalar_relationship=name_for_scalar_relationship,\n)\n```", "```py\nBase = automap_base()\n\nclass TableB(Base):\n    __tablename__ = \"table_b\"\n    _table_a = Column(\"table_a\", ForeignKey(\"table_a.id\"))\n\nBase.prepare(autoload_with=engine)\n```", "```py\nfrom sqlalchemy.ext.automap import automap_base\nfrom sqlalchemy import Column, Integer, String, ForeignKey\n\nBase = automap_base()\n\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = Column(Integer, primary_key=True)\n    email = Column(String)\n    user_id = Column(ForeignKey(\"user.id\"))\n\n# produce relationships\nBase.prepare()\n\n# mapping is complete, with \"address_collection\" and\n# \"user\" relationships\na1 = Address(email=\"u1\")\na2 = Address(email=\"u2\")\nu1 = User(address_collection=[a1, a2])\nassert a1.user is u1\n```", "```py\n@event.listens_for(Base.metadata, \"column_reflect\")\ndef column_reflect(inspector, table, column_info):\n    # set column.key = \"attr_<lower_case_name>\"\n    column_info[\"key\"] = \"attr_%s\" % column_info[\"name\"].lower()\n\n# run reflection\nBase.prepare(autoload_with=engine)\n```", "```py\nfunction sqlalchemy.ext.automap.automap_base(declarative_base: Type[Any] | None = None, **kw: Any) \u2192 Any\n```", "```py\nclass sqlalchemy.ext.automap.AutomapBase\n```", "```py\nattribute by_module: ClassVar[ByModuleProperties]\n```", "```py\nUser = Base.by_module.sqlalchemy.ext.automap.User\n```", "```py\nMyClass = Base.by_module.mymodule.account.MyClass\n```", "```py\nattribute classes: ClassVar[Properties[Type[Any]]]\n```", "```py\nBase = automap_base()\nBase.prepare(autoload_with=some_engine)\n\nUser, Address = Base.classes.User, Base.classes.Address\n```", "```py\nItem = Base.classes[\"items\"]\n```", "```py\nattribute metadata: ClassVar[MetaData]\n```", "```py\nclassmethod prepare(autoload_with: Engine | None = None, engine: Any | None = None, reflect: bool = False, schema: str | None = None, classname_for_table: PythonNameForTableType | None = None, modulename_for_table: PythonNameForTableType | None = None, collection_class: Any | None = None, name_for_scalar_relationship: NameForScalarRelationshipType | None = None, name_for_collection_relationship: NameForCollectionRelationshipType | None = None, generate_relationship: GenerateRelationshipType | None = None, reflection_options: Dict[_KT, _VT] | immutabledict[_KT, _VT] = {}) \u2192 None\n```", "```py\nfunction sqlalchemy.ext.automap.classname_for_table(base: Type[Any], tablename: str, table: Table) \u2192 str\n```", "```py\nreturn str(tablename)\n```", "```py\nfunction sqlalchemy.ext.automap.name_for_scalar_relationship(base: Type[Any], local_cls: Type[Any], referred_cls: Type[Any], constraint: ForeignKeyConstraint) \u2192 str\n```", "```py\nreturn referred_cls.__name__.lower()\n```", "```py\nfunction sqlalchemy.ext.automap.name_for_collection_relationship(base: Type[Any], local_cls: Type[Any], referred_cls: Type[Any], constraint: ForeignKeyConstraint) \u2192 str\n```", "```py\nreturn referred_cls.__name__.lower() + \"_collection\"\n```", "```py\nfunction sqlalchemy.ext.automap.generate_relationship(base: Type[Any], direction: RelationshipDirection, return_fn: Callable[..., Relationship[Any]] | Callable[..., ORMBackrefArgument], attrname: str, local_cls: Type[Any], referred_cls: Type[Any], **kw: Any) \u2192 Relationship[Any] | ORMBackrefArgument\n```", "```py\nif return_fn is backref:\n    return return_fn(attrname, **kw)\nelif return_fn is relationship:\n    return return_fn(referred_cls, **kw)\nelse:\n    raise TypeError(\"Unknown relationship function: %s\" % return_fn)\n```"]