["```py\nfrom sqlalchemy import *\nfrom sqlalchemy.orm import *\n```", "```py\nmyengine = create_engine(\"sqlite://\")\n\nmeta = MetaData(myengine)\n\nmeta2 = MetaData()\nmeta2.bind = myengine\n\nsession = create_session(bind=myengine)\n\nstatement = select([table], bind=myengine)\n```", "```py\nfrom sqlalchemy import *\n\nclass UTCDateTime(types.TypeDecorator):\n    pass\n```", "```py\nfrom sqlalchemy import *\nfrom sqlalchemy import types\n\nclass UTCDateTime(types.TypeDecorator):\n    pass\n```", "```py\nUser.query.filter_by(**kwargs).first()\n```", "```py\nUser.query.filter_by(**kwargs).all()\n```", "```py\nUser.query.filter(xxx).all()\n```", "```py\nsession.query(User).filter(and_(User.name == \"fred\", User.id > 17))\n```", "```py\n# comparison of scalar relations to an instance\nfilter(Address.user == user)\n\n# return all users who contain a particular address\nfilter(User.addresses.contains(address))\n\n# return all users who *dont* contain the address\nfilter(~User.address.contains(address))\n\n# return all users who contain a particular address with\n# the email_address like '%foo%'\nfilter(User.addresses.any(Address.email_address.like(\"%foo%\")))\n\n# same, email address equals 'foo@bar.com'.  can fall back to keyword\n# args for simple comparisons\nfilter(User.addresses.any(email_address=\"foo@bar.com\"))\n\n# return all Addresses whose user attribute has the username 'ed'\nfilter(Address.user.has(name=\"ed\"))\n\n# return all Addresses whose user attribute has the username 'ed'\n# and an id > 5 (mixing clauses with kwargs)\nfilter(Address.user.has(User.id > 5, name=\"ed\"))\n```", "```py\nsession.query(Order).join(\"items\")\n```", "```py\nsession.query(Order).join(\"items\", aliased=True).filter(Item.name=\"item 1\").join(\n    \"items\", aliased=True\n).filter(Item.name == \"item 3\")\n```", "```py\nsession.query(Order).join(\"items\", id=\"j1\", aliased=True).filter(\n    Item.name == \"item 1\"\n).join(\"items\", aliased=True, id=\"j2\").filter(Item.name == \"item 3\").add_entity(\n    Item, id=\"j1\"\n).add_entity(\n    Item, id=\"j2\"\n)\n```", "```py\n# standard self-referential TreeNode mapper with backref\nmapper(\n    TreeNode,\n    tree_nodes,\n    properties={\n        \"children\": relation(\n            TreeNode, backref=backref(\"parent\", remote_side=tree_nodes.id)\n        )\n    },\n)\n\n# query for node with child containing \"bar\" two levels deep\nsession.query(TreeNode).join([\"children\", \"children\"], aliased=True).filter_by(\n    name=\"bar\"\n)\n```", "```py\n# search for the treenode along the path \"n1/n12/n122\"\n\n# first find a Node with name=\"n122\"\nq = sess.query(Node).filter_by(name=\"n122\")\n\n# then join to parent with \"n12\"\nq = q.join(\"parent\", aliased=True).filter_by(name=\"n12\")\n\n# join again to the next parent with 'n1'.  use 'from_joinpoint'\n# so we join from the previous point, instead of joining off the\n# root table\nq = q.join(\"parent\", aliased=True, from_joinpoint=True).filter_by(name=\"n1\")\n\nnode = q.first()\n```", "```py\nsession.query(Blah).populate_existing().all()\n```", "```py\nmyobject.foo = mytable.c.value + 1\n\nuser.pwhash = func.md5(password)\n\norder.hash = text(\"select hash from hashing_table\")\n```", "```py\nnodes = Table(\n    \"nodes\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"parent_id\", Integer, ForeignKey(\"nodes.id\")),\n    Column(\"name\", String(30)),\n)\n\nclass TreeNode(object):\n    pass\n\nmapper(\n    TreeNode,\n    nodes,\n    properties={\"children\": relation(TreeNode, lazy=False, join_depth=3)},\n)\n```", "```py\ncreate_session().query(TreeNode).all()\n```", "```py\nSELECT\nnodes_3.id  AS  nodes_3_id,  nodes_3.parent_id  AS  nodes_3_parent_id,  nodes_3.name  AS  nodes_3_name,\nnodes_2.id  AS  nodes_2_id,  nodes_2.parent_id  AS  nodes_2_parent_id,  nodes_2.name  AS  nodes_2_name,\nnodes_1.id  AS  nodes_1_id,  nodes_1.parent_id  AS  nodes_1_parent_id,  nodes_1.name  AS  nodes_1_name,\nnodes.id  AS  nodes_id,  nodes.parent_id  AS  nodes_parent_id,  nodes.name  AS  nodes_name\nFROM  nodes  LEFT  OUTER  JOIN  nodes  AS  nodes_1  ON  nodes.id  =  nodes_1.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_2  ON  nodes_1.id  =  nodes_2.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_3  ON  nodes_2.id  =  nodes_3.parent_id\nORDER  BY  nodes.oid,  nodes_1.oid,  nodes_2.oid,  nodes_3.oid\n```", "```py\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __composite_values__(self):\n        return self.x, self.y\n\n    def __eq__(self, other):\n        return other.x == self.x and other.y == self.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\nvertices = Table(\n    \"vertices\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x1\", Integer),\n    Column(\"y1\", Integer),\n    Column(\"x2\", Integer),\n    Column(\"y2\", Integer),\n)\n```", "```py\nclass Vertex(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nmapper(\n    Vertex,\n    vertices,\n    properties={\n        \"start\": composite(Point, vertices.c.x1, vertices.c.y1),\n        \"end\": composite(Point, vertices.c.x2, vertices.c.y2),\n    },\n)\n```", "```py\nv = Vertex(Point(3, 4), Point(26, 15))\nsession.save(v)\nsession.flush()\n\n# works in queries too\nq = session.query(Vertex).filter(Vertex.start == Point(3, 4))\n```", "```py\n# a Document class which uses a composite Version\n# object as primary key\ndocument = query.get(Version(1, \"a\"))\n```", "```py\nmapper(\n    Foo,\n    foo_table,\n    properties={\n        \"bars\": dynamic_loader(\n            Bar,\n            backref=\"foo\",\n            # <other relation() opts>\n        )\n    },\n)\n\nsession = create_session(autoflush=True)\nfoo = session.query(Foo).first()\n\nfoo.bars.append(Bar(name=\"lala\"))\n\nfor bar in foo.bars.filter(Bar.name == \"lala\"):\n    print(bar)\n\nsession.commit()\n```", "```py\nmapper(\n    Class,\n    table,\n    properties={\n        \"foo\": deferred(table.c.foo, group=\"group1\"),\n        \"bar\": deferred(table.c.bar, group=\"group1\"),\n        \"bat\": deferred(table.c.bat, group=\"group1\"),\n    },\n)\n\nsession.query(Class).options(undefer_group(\"group1\")).filter(...).all()\n```", "```py\nmapper(Foo, foo_table, properties={\"bar\": relation(Bar)})\nmapper(Bar, bar_table, properties={\"bat\": relation(Bat)})\nmapper(Bat, bat_table)\n\n# eager load bar and bat\nsession.query(Foo).options(eagerload_all(\"bar.bat\")).filter(...).all()\n```", "```py\n# use a dictionary relation keyed by a column\nrelation(Item, collection_class=column_mapped_collection(items.c.keyword))\n# or named attribute\nrelation(Item, collection_class=attribute_mapped_collection(\"keyword\"))\n# or any function you like\nrelation(Item, collection_class=mapped_collection(lambda entity: entity.a + entity.b))\n```", "```py\nmapper(\n    User,\n    users,\n    properties={\n        \"fullname\": column_property(\n            (users.c.firstname + users.c.lastname).label(\"fullname\")\n        ),\n        \"numposts\": column_property(\n            select([func.count(1)], users.c.id == posts.c.user_id)\n            .correlate(users)\n            .label(\"posts\")\n        ),\n    },\n)\n```", "```py\nSELECT  (SELECT  count(1)  FROM  posts  WHERE  users.id  =  posts.user_id)  AS  count,\nusers.firstname  ||  users.lastname  AS  fullname,\nusers.id  AS  users_id,  users.firstname  AS  users_firstname,  users.lastname  AS  users_lastname\nFROM  users  ORDER  BY  users.oid\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine(\"myengine://\")\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\n# use the new Session() freely\nsess = Session()\nsess.save(someobject)\nsess.flush()\n```", "```py\nSession.configure(bind=create_engine(...))\n```", "```py\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\nSession = scoped_session(sessionmaker(autoflush=True, transactional=True))\nSession.configure(bind=engine)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\nsess.commit()\n\n# Session constructor is thread-locally scoped.  Everyone gets the same\n# Session in the thread when scope=\"thread\".\nsess2 = Session()\nassert sess is sess2\n```", "```py\n# \"assignmapper\"-like functionality available via ScopedSession.mapper\nSession.mapper(User, users_table)\n\nu = User(name=\"wendy\")\n\nSession.commit()\n```", "```py\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\n\n# wendy is flushed, comes right back from a query\nwendy = sess.query(User).filter_by(name=\"wendy\").one()\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nsess = Session()\nsess.begin()\n\n# use the session\n\nsess.commit()  # commit transaction\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nconn = engine.connect()\ntrans = conn.begin()\nsess = Session(bind=conn)\n\n# ... session is transactional\n\n# commit the outermost transaction\ntrans.commit()\n```", "```py\nb = bindparam(\"foo\", type_=String)\n```", "```py\nmy_table.select(my_table.c.id.in_(1, 2, 3))\nmy_table.select(my_table.c.id.in_(*listOfIds))\n```", "```py\nmy_table.select(my_table.c.id.in_([1, 2, 3]))\nmy_table.select(my_table.c.id.in_(listOfIds))\n```", "```py\n+-------------------------------------+-------------------------+\n|If You Had                           | Now Use                 |\n+=====================================+=========================+\n| ``MetaData``                        | ``MetaData``            |\n+-------------------------------------+-------------------------+\n| ``BoundMetaData``                   | ``MetaData``            |\n+-------------------------------------+-------------------------+\n| ``DynamicMetaData`` (with one       | ``MetaData``            |\n| engine or threadlocal=False)        |                         |\n+-------------------------------------+-------------------------+\n| ``DynamicMetaData``                 | ``ThreadLocalMetaData`` |\n| (with different engines per thread) |                         |\n+-------------------------------------+-------------------------+\n```", "```py\n>>> metadata = MetaData(myengine, reflect=True)\n>>> metadata.tables.keys()\n['table_a', 'table_b', 'table_c', '...']\n```", "```py\nresult = engine.execute(\n    text(\n        \"begin foo(:x, :y, :z); end;\",\n        bindparams=[\n            bindparam(\"x\", Numeric),\n            outparam(\"y\", Numeric),\n            outparam(\"z\", Numeric),\n        ],\n    ),\n    x=5,\n)\nassert result.out_parameters == {\"y\": 10, \"z\": 75}\n```", "```py\nconn = engine.connect()\nsess = create_session(bind=conn)\n```", "```py\nfrom sqlalchemy import *\nfrom sqlalchemy.orm import *\n```", "```py\nmyengine = create_engine(\"sqlite://\")\n\nmeta = MetaData(myengine)\n\nmeta2 = MetaData()\nmeta2.bind = myengine\n\nsession = create_session(bind=myengine)\n\nstatement = select([table], bind=myengine)\n```", "```py\nfrom sqlalchemy import *\n\nclass UTCDateTime(types.TypeDecorator):\n    pass\n```", "```py\nfrom sqlalchemy import *\nfrom sqlalchemy import types\n\nclass UTCDateTime(types.TypeDecorator):\n    pass\n```", "```py\nUser.query.filter_by(**kwargs).first()\n```", "```py\nUser.query.filter_by(**kwargs).all()\n```", "```py\nUser.query.filter(xxx).all()\n```", "```py\nsession.query(User).filter(and_(User.name == \"fred\", User.id > 17))\n```", "```py\n# comparison of scalar relations to an instance\nfilter(Address.user == user)\n\n# return all users who contain a particular address\nfilter(User.addresses.contains(address))\n\n# return all users who *dont* contain the address\nfilter(~User.address.contains(address))\n\n# return all users who contain a particular address with\n# the email_address like '%foo%'\nfilter(User.addresses.any(Address.email_address.like(\"%foo%\")))\n\n# same, email address equals 'foo@bar.com'.  can fall back to keyword\n# args for simple comparisons\nfilter(User.addresses.any(email_address=\"foo@bar.com\"))\n\n# return all Addresses whose user attribute has the username 'ed'\nfilter(Address.user.has(name=\"ed\"))\n\n# return all Addresses whose user attribute has the username 'ed'\n# and an id > 5 (mixing clauses with kwargs)\nfilter(Address.user.has(User.id > 5, name=\"ed\"))\n```", "```py\nsession.query(Order).join(\"items\")\n```", "```py\nsession.query(Order).join(\"items\", aliased=True).filter(Item.name=\"item 1\").join(\n    \"items\", aliased=True\n).filter(Item.name == \"item 3\")\n```", "```py\nsession.query(Order).join(\"items\", id=\"j1\", aliased=True).filter(\n    Item.name == \"item 1\"\n).join(\"items\", aliased=True, id=\"j2\").filter(Item.name == \"item 3\").add_entity(\n    Item, id=\"j1\"\n).add_entity(\n    Item, id=\"j2\"\n)\n```", "```py\n# standard self-referential TreeNode mapper with backref\nmapper(\n    TreeNode,\n    tree_nodes,\n    properties={\n        \"children\": relation(\n            TreeNode, backref=backref(\"parent\", remote_side=tree_nodes.id)\n        )\n    },\n)\n\n# query for node with child containing \"bar\" two levels deep\nsession.query(TreeNode).join([\"children\", \"children\"], aliased=True).filter_by(\n    name=\"bar\"\n)\n```", "```py\n# search for the treenode along the path \"n1/n12/n122\"\n\n# first find a Node with name=\"n122\"\nq = sess.query(Node).filter_by(name=\"n122\")\n\n# then join to parent with \"n12\"\nq = q.join(\"parent\", aliased=True).filter_by(name=\"n12\")\n\n# join again to the next parent with 'n1'.  use 'from_joinpoint'\n# so we join from the previous point, instead of joining off the\n# root table\nq = q.join(\"parent\", aliased=True, from_joinpoint=True).filter_by(name=\"n1\")\n\nnode = q.first()\n```", "```py\nsession.query(Blah).populate_existing().all()\n```", "```py\nmyobject.foo = mytable.c.value + 1\n\nuser.pwhash = func.md5(password)\n\norder.hash = text(\"select hash from hashing_table\")\n```", "```py\nnodes = Table(\n    \"nodes\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"parent_id\", Integer, ForeignKey(\"nodes.id\")),\n    Column(\"name\", String(30)),\n)\n\nclass TreeNode(object):\n    pass\n\nmapper(\n    TreeNode,\n    nodes,\n    properties={\"children\": relation(TreeNode, lazy=False, join_depth=3)},\n)\n```", "```py\ncreate_session().query(TreeNode).all()\n```", "```py\nSELECT\nnodes_3.id  AS  nodes_3_id,  nodes_3.parent_id  AS  nodes_3_parent_id,  nodes_3.name  AS  nodes_3_name,\nnodes_2.id  AS  nodes_2_id,  nodes_2.parent_id  AS  nodes_2_parent_id,  nodes_2.name  AS  nodes_2_name,\nnodes_1.id  AS  nodes_1_id,  nodes_1.parent_id  AS  nodes_1_parent_id,  nodes_1.name  AS  nodes_1_name,\nnodes.id  AS  nodes_id,  nodes.parent_id  AS  nodes_parent_id,  nodes.name  AS  nodes_name\nFROM  nodes  LEFT  OUTER  JOIN  nodes  AS  nodes_1  ON  nodes.id  =  nodes_1.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_2  ON  nodes_1.id  =  nodes_2.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_3  ON  nodes_2.id  =  nodes_3.parent_id\nORDER  BY  nodes.oid,  nodes_1.oid,  nodes_2.oid,  nodes_3.oid\n```", "```py\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __composite_values__(self):\n        return self.x, self.y\n\n    def __eq__(self, other):\n        return other.x == self.x and other.y == self.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\nvertices = Table(\n    \"vertices\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x1\", Integer),\n    Column(\"y1\", Integer),\n    Column(\"x2\", Integer),\n    Column(\"y2\", Integer),\n)\n```", "```py\nclass Vertex(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nmapper(\n    Vertex,\n    vertices,\n    properties={\n        \"start\": composite(Point, vertices.c.x1, vertices.c.y1),\n        \"end\": composite(Point, vertices.c.x2, vertices.c.y2),\n    },\n)\n```", "```py\nv = Vertex(Point(3, 4), Point(26, 15))\nsession.save(v)\nsession.flush()\n\n# works in queries too\nq = session.query(Vertex).filter(Vertex.start == Point(3, 4))\n```", "```py\n# a Document class which uses a composite Version\n# object as primary key\ndocument = query.get(Version(1, \"a\"))\n```", "```py\nmapper(\n    Foo,\n    foo_table,\n    properties={\n        \"bars\": dynamic_loader(\n            Bar,\n            backref=\"foo\",\n            # <other relation() opts>\n        )\n    },\n)\n\nsession = create_session(autoflush=True)\nfoo = session.query(Foo).first()\n\nfoo.bars.append(Bar(name=\"lala\"))\n\nfor bar in foo.bars.filter(Bar.name == \"lala\"):\n    print(bar)\n\nsession.commit()\n```", "```py\nmapper(\n    Class,\n    table,\n    properties={\n        \"foo\": deferred(table.c.foo, group=\"group1\"),\n        \"bar\": deferred(table.c.bar, group=\"group1\"),\n        \"bat\": deferred(table.c.bat, group=\"group1\"),\n    },\n)\n\nsession.query(Class).options(undefer_group(\"group1\")).filter(...).all()\n```", "```py\nmapper(Foo, foo_table, properties={\"bar\": relation(Bar)})\nmapper(Bar, bar_table, properties={\"bat\": relation(Bat)})\nmapper(Bat, bat_table)\n\n# eager load bar and bat\nsession.query(Foo).options(eagerload_all(\"bar.bat\")).filter(...).all()\n```", "```py\n# use a dictionary relation keyed by a column\nrelation(Item, collection_class=column_mapped_collection(items.c.keyword))\n# or named attribute\nrelation(Item, collection_class=attribute_mapped_collection(\"keyword\"))\n# or any function you like\nrelation(Item, collection_class=mapped_collection(lambda entity: entity.a + entity.b))\n```", "```py\nmapper(\n    User,\n    users,\n    properties={\n        \"fullname\": column_property(\n            (users.c.firstname + users.c.lastname).label(\"fullname\")\n        ),\n        \"numposts\": column_property(\n            select([func.count(1)], users.c.id == posts.c.user_id)\n            .correlate(users)\n            .label(\"posts\")\n        ),\n    },\n)\n```", "```py\nSELECT  (SELECT  count(1)  FROM  posts  WHERE  users.id  =  posts.user_id)  AS  count,\nusers.firstname  ||  users.lastname  AS  fullname,\nusers.id  AS  users_id,  users.firstname  AS  users_firstname,  users.lastname  AS  users_lastname\nFROM  users  ORDER  BY  users.oid\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine(\"myengine://\")\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\n# use the new Session() freely\nsess = Session()\nsess.save(someobject)\nsess.flush()\n```", "```py\nSession.configure(bind=create_engine(...))\n```", "```py\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\nSession = scoped_session(sessionmaker(autoflush=True, transactional=True))\nSession.configure(bind=engine)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\nsess.commit()\n\n# Session constructor is thread-locally scoped.  Everyone gets the same\n# Session in the thread when scope=\"thread\".\nsess2 = Session()\nassert sess is sess2\n```", "```py\n# \"assignmapper\"-like functionality available via ScopedSession.mapper\nSession.mapper(User, users_table)\n\nu = User(name=\"wendy\")\n\nSession.commit()\n```", "```py\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\n\n# wendy is flushed, comes right back from a query\nwendy = sess.query(User).filter_by(name=\"wendy\").one()\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nsess = Session()\nsess.begin()\n\n# use the session\n\nsess.commit()  # commit transaction\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nconn = engine.connect()\ntrans = conn.begin()\nsess = Session(bind=conn)\n\n# ... session is transactional\n\n# commit the outermost transaction\ntrans.commit()\n```", "```py\nUser.query.filter_by(**kwargs).first()\n```", "```py\nUser.query.filter_by(**kwargs).all()\n```", "```py\nUser.query.filter(xxx).all()\n```", "```py\nsession.query(User).filter(and_(User.name == \"fred\", User.id > 17))\n```", "```py\n# comparison of scalar relations to an instance\nfilter(Address.user == user)\n\n# return all users who contain a particular address\nfilter(User.addresses.contains(address))\n\n# return all users who *dont* contain the address\nfilter(~User.address.contains(address))\n\n# return all users who contain a particular address with\n# the email_address like '%foo%'\nfilter(User.addresses.any(Address.email_address.like(\"%foo%\")))\n\n# same, email address equals 'foo@bar.com'.  can fall back to keyword\n# args for simple comparisons\nfilter(User.addresses.any(email_address=\"foo@bar.com\"))\n\n# return all Addresses whose user attribute has the username 'ed'\nfilter(Address.user.has(name=\"ed\"))\n\n# return all Addresses whose user attribute has the username 'ed'\n# and an id > 5 (mixing clauses with kwargs)\nfilter(Address.user.has(User.id > 5, name=\"ed\"))\n```", "```py\nsession.query(Order).join(\"items\")\n```", "```py\nsession.query(Order).join(\"items\", aliased=True).filter(Item.name=\"item 1\").join(\n    \"items\", aliased=True\n).filter(Item.name == \"item 3\")\n```", "```py\nsession.query(Order).join(\"items\", id=\"j1\", aliased=True).filter(\n    Item.name == \"item 1\"\n).join(\"items\", aliased=True, id=\"j2\").filter(Item.name == \"item 3\").add_entity(\n    Item, id=\"j1\"\n).add_entity(\n    Item, id=\"j2\"\n)\n```", "```py\n# standard self-referential TreeNode mapper with backref\nmapper(\n    TreeNode,\n    tree_nodes,\n    properties={\n        \"children\": relation(\n            TreeNode, backref=backref(\"parent\", remote_side=tree_nodes.id)\n        )\n    },\n)\n\n# query for node with child containing \"bar\" two levels deep\nsession.query(TreeNode).join([\"children\", \"children\"], aliased=True).filter_by(\n    name=\"bar\"\n)\n```", "```py\n# search for the treenode along the path \"n1/n12/n122\"\n\n# first find a Node with name=\"n122\"\nq = sess.query(Node).filter_by(name=\"n122\")\n\n# then join to parent with \"n12\"\nq = q.join(\"parent\", aliased=True).filter_by(name=\"n12\")\n\n# join again to the next parent with 'n1'.  use 'from_joinpoint'\n# so we join from the previous point, instead of joining off the\n# root table\nq = q.join(\"parent\", aliased=True, from_joinpoint=True).filter_by(name=\"n1\")\n\nnode = q.first()\n```", "```py\nsession.query(Blah).populate_existing().all()\n```", "```py\nUser.query.filter_by(**kwargs).first()\n```", "```py\nUser.query.filter_by(**kwargs).all()\n```", "```py\nUser.query.filter(xxx).all()\n```", "```py\nsession.query(User).filter(and_(User.name == \"fred\", User.id > 17))\n```", "```py\n# comparison of scalar relations to an instance\nfilter(Address.user == user)\n\n# return all users who contain a particular address\nfilter(User.addresses.contains(address))\n\n# return all users who *dont* contain the address\nfilter(~User.address.contains(address))\n\n# return all users who contain a particular address with\n# the email_address like '%foo%'\nfilter(User.addresses.any(Address.email_address.like(\"%foo%\")))\n\n# same, email address equals 'foo@bar.com'.  can fall back to keyword\n# args for simple comparisons\nfilter(User.addresses.any(email_address=\"foo@bar.com\"))\n\n# return all Addresses whose user attribute has the username 'ed'\nfilter(Address.user.has(name=\"ed\"))\n\n# return all Addresses whose user attribute has the username 'ed'\n# and an id > 5 (mixing clauses with kwargs)\nfilter(Address.user.has(User.id > 5, name=\"ed\"))\n```", "```py\nsession.query(Order).join(\"items\")\n```", "```py\nsession.query(Order).join(\"items\", aliased=True).filter(Item.name=\"item 1\").join(\n    \"items\", aliased=True\n).filter(Item.name == \"item 3\")\n```", "```py\nsession.query(Order).join(\"items\", id=\"j1\", aliased=True).filter(\n    Item.name == \"item 1\"\n).join(\"items\", aliased=True, id=\"j2\").filter(Item.name == \"item 3\").add_entity(\n    Item, id=\"j1\"\n).add_entity(\n    Item, id=\"j2\"\n)\n```", "```py\n# standard self-referential TreeNode mapper with backref\nmapper(\n    TreeNode,\n    tree_nodes,\n    properties={\n        \"children\": relation(\n            TreeNode, backref=backref(\"parent\", remote_side=tree_nodes.id)\n        )\n    },\n)\n\n# query for node with child containing \"bar\" two levels deep\nsession.query(TreeNode).join([\"children\", \"children\"], aliased=True).filter_by(\n    name=\"bar\"\n)\n```", "```py\n# search for the treenode along the path \"n1/n12/n122\"\n\n# first find a Node with name=\"n122\"\nq = sess.query(Node).filter_by(name=\"n122\")\n\n# then join to parent with \"n12\"\nq = q.join(\"parent\", aliased=True).filter_by(name=\"n12\")\n\n# join again to the next parent with 'n1'.  use 'from_joinpoint'\n# so we join from the previous point, instead of joining off the\n# root table\nq = q.join(\"parent\", aliased=True, from_joinpoint=True).filter_by(name=\"n1\")\n\nnode = q.first()\n```", "```py\nsession.query(Blah).populate_existing().all()\n```", "```py\nmyobject.foo = mytable.c.value + 1\n\nuser.pwhash = func.md5(password)\n\norder.hash = text(\"select hash from hashing_table\")\n```", "```py\nnodes = Table(\n    \"nodes\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"parent_id\", Integer, ForeignKey(\"nodes.id\")),\n    Column(\"name\", String(30)),\n)\n\nclass TreeNode(object):\n    pass\n\nmapper(\n    TreeNode,\n    nodes,\n    properties={\"children\": relation(TreeNode, lazy=False, join_depth=3)},\n)\n```", "```py\ncreate_session().query(TreeNode).all()\n```", "```py\nSELECT\nnodes_3.id  AS  nodes_3_id,  nodes_3.parent_id  AS  nodes_3_parent_id,  nodes_3.name  AS  nodes_3_name,\nnodes_2.id  AS  nodes_2_id,  nodes_2.parent_id  AS  nodes_2_parent_id,  nodes_2.name  AS  nodes_2_name,\nnodes_1.id  AS  nodes_1_id,  nodes_1.parent_id  AS  nodes_1_parent_id,  nodes_1.name  AS  nodes_1_name,\nnodes.id  AS  nodes_id,  nodes.parent_id  AS  nodes_parent_id,  nodes.name  AS  nodes_name\nFROM  nodes  LEFT  OUTER  JOIN  nodes  AS  nodes_1  ON  nodes.id  =  nodes_1.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_2  ON  nodes_1.id  =  nodes_2.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_3  ON  nodes_2.id  =  nodes_3.parent_id\nORDER  BY  nodes.oid,  nodes_1.oid,  nodes_2.oid,  nodes_3.oid\n```", "```py\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __composite_values__(self):\n        return self.x, self.y\n\n    def __eq__(self, other):\n        return other.x == self.x and other.y == self.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\nvertices = Table(\n    \"vertices\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x1\", Integer),\n    Column(\"y1\", Integer),\n    Column(\"x2\", Integer),\n    Column(\"y2\", Integer),\n)\n```", "```py\nclass Vertex(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nmapper(\n    Vertex,\n    vertices,\n    properties={\n        \"start\": composite(Point, vertices.c.x1, vertices.c.y1),\n        \"end\": composite(Point, vertices.c.x2, vertices.c.y2),\n    },\n)\n```", "```py\nv = Vertex(Point(3, 4), Point(26, 15))\nsession.save(v)\nsession.flush()\n\n# works in queries too\nq = session.query(Vertex).filter(Vertex.start == Point(3, 4))\n```", "```py\n# a Document class which uses a composite Version\n# object as primary key\ndocument = query.get(Version(1, \"a\"))\n```", "```py\nmapper(\n    Foo,\n    foo_table,\n    properties={\n        \"bars\": dynamic_loader(\n            Bar,\n            backref=\"foo\",\n            # <other relation() opts>\n        )\n    },\n)\n\nsession = create_session(autoflush=True)\nfoo = session.query(Foo).first()\n\nfoo.bars.append(Bar(name=\"lala\"))\n\nfor bar in foo.bars.filter(Bar.name == \"lala\"):\n    print(bar)\n\nsession.commit()\n```", "```py\nmapper(\n    Class,\n    table,\n    properties={\n        \"foo\": deferred(table.c.foo, group=\"group1\"),\n        \"bar\": deferred(table.c.bar, group=\"group1\"),\n        \"bat\": deferred(table.c.bat, group=\"group1\"),\n    },\n)\n\nsession.query(Class).options(undefer_group(\"group1\")).filter(...).all()\n```", "```py\nmapper(Foo, foo_table, properties={\"bar\": relation(Bar)})\nmapper(Bar, bar_table, properties={\"bat\": relation(Bat)})\nmapper(Bat, bat_table)\n\n# eager load bar and bat\nsession.query(Foo).options(eagerload_all(\"bar.bat\")).filter(...).all()\n```", "```py\n# use a dictionary relation keyed by a column\nrelation(Item, collection_class=column_mapped_collection(items.c.keyword))\n# or named attribute\nrelation(Item, collection_class=attribute_mapped_collection(\"keyword\"))\n# or any function you like\nrelation(Item, collection_class=mapped_collection(lambda entity: entity.a + entity.b))\n```", "```py\nmapper(\n    User,\n    users,\n    properties={\n        \"fullname\": column_property(\n            (users.c.firstname + users.c.lastname).label(\"fullname\")\n        ),\n        \"numposts\": column_property(\n            select([func.count(1)], users.c.id == posts.c.user_id)\n            .correlate(users)\n            .label(\"posts\")\n        ),\n    },\n)\n```", "```py\nSELECT  (SELECT  count(1)  FROM  posts  WHERE  users.id  =  posts.user_id)  AS  count,\nusers.firstname  ||  users.lastname  AS  fullname,\nusers.id  AS  users_id,  users.firstname  AS  users_firstname,  users.lastname  AS  users_lastname\nFROM  users  ORDER  BY  users.oid\n```", "```py\nmyobject.foo = mytable.c.value + 1\n\nuser.pwhash = func.md5(password)\n\norder.hash = text(\"select hash from hashing_table\")\n```", "```py\nnodes = Table(\n    \"nodes\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"parent_id\", Integer, ForeignKey(\"nodes.id\")),\n    Column(\"name\", String(30)),\n)\n\nclass TreeNode(object):\n    pass\n\nmapper(\n    TreeNode,\n    nodes,\n    properties={\"children\": relation(TreeNode, lazy=False, join_depth=3)},\n)\n```", "```py\ncreate_session().query(TreeNode).all()\n```", "```py\nSELECT\nnodes_3.id  AS  nodes_3_id,  nodes_3.parent_id  AS  nodes_3_parent_id,  nodes_3.name  AS  nodes_3_name,\nnodes_2.id  AS  nodes_2_id,  nodes_2.parent_id  AS  nodes_2_parent_id,  nodes_2.name  AS  nodes_2_name,\nnodes_1.id  AS  nodes_1_id,  nodes_1.parent_id  AS  nodes_1_parent_id,  nodes_1.name  AS  nodes_1_name,\nnodes.id  AS  nodes_id,  nodes.parent_id  AS  nodes_parent_id,  nodes.name  AS  nodes_name\nFROM  nodes  LEFT  OUTER  JOIN  nodes  AS  nodes_1  ON  nodes.id  =  nodes_1.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_2  ON  nodes_1.id  =  nodes_2.parent_id\nLEFT  OUTER  JOIN  nodes  AS  nodes_3  ON  nodes_2.id  =  nodes_3.parent_id\nORDER  BY  nodes.oid,  nodes_1.oid,  nodes_2.oid,  nodes_3.oid\n```", "```py\nclass Point(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __composite_values__(self):\n        return self.x, self.y\n\n    def __eq__(self, other):\n        return other.x == self.x and other.y == self.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n```", "```py\nvertices = Table(\n    \"vertices\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x1\", Integer),\n    Column(\"y1\", Integer),\n    Column(\"x2\", Integer),\n    Column(\"y2\", Integer),\n)\n```", "```py\nclass Vertex(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\nmapper(\n    Vertex,\n    vertices,\n    properties={\n        \"start\": composite(Point, vertices.c.x1, vertices.c.y1),\n        \"end\": composite(Point, vertices.c.x2, vertices.c.y2),\n    },\n)\n```", "```py\nv = Vertex(Point(3, 4), Point(26, 15))\nsession.save(v)\nsession.flush()\n\n# works in queries too\nq = session.query(Vertex).filter(Vertex.start == Point(3, 4))\n```", "```py\n# a Document class which uses a composite Version\n# object as primary key\ndocument = query.get(Version(1, \"a\"))\n```", "```py\nmapper(\n    Foo,\n    foo_table,\n    properties={\n        \"bars\": dynamic_loader(\n            Bar,\n            backref=\"foo\",\n            # <other relation() opts>\n        )\n    },\n)\n\nsession = create_session(autoflush=True)\nfoo = session.query(Foo).first()\n\nfoo.bars.append(Bar(name=\"lala\"))\n\nfor bar in foo.bars.filter(Bar.name == \"lala\"):\n    print(bar)\n\nsession.commit()\n```", "```py\nmapper(\n    Class,\n    table,\n    properties={\n        \"foo\": deferred(table.c.foo, group=\"group1\"),\n        \"bar\": deferred(table.c.bar, group=\"group1\"),\n        \"bat\": deferred(table.c.bat, group=\"group1\"),\n    },\n)\n\nsession.query(Class).options(undefer_group(\"group1\")).filter(...).all()\n```", "```py\nmapper(Foo, foo_table, properties={\"bar\": relation(Bar)})\nmapper(Bar, bar_table, properties={\"bat\": relation(Bat)})\nmapper(Bat, bat_table)\n\n# eager load bar and bat\nsession.query(Foo).options(eagerload_all(\"bar.bat\")).filter(...).all()\n```", "```py\n# use a dictionary relation keyed by a column\nrelation(Item, collection_class=column_mapped_collection(items.c.keyword))\n# or named attribute\nrelation(Item, collection_class=attribute_mapped_collection(\"keyword\"))\n# or any function you like\nrelation(Item, collection_class=mapped_collection(lambda entity: entity.a + entity.b))\n```", "```py\nmapper(\n    User,\n    users,\n    properties={\n        \"fullname\": column_property(\n            (users.c.firstname + users.c.lastname).label(\"fullname\")\n        ),\n        \"numposts\": column_property(\n            select([func.count(1)], users.c.id == posts.c.user_id)\n            .correlate(users)\n            .label(\"posts\")\n        ),\n    },\n)\n```", "```py\nSELECT  (SELECT  count(1)  FROM  posts  WHERE  users.id  =  posts.user_id)  AS  count,\nusers.firstname  ||  users.lastname  AS  fullname,\nusers.id  AS  users_id,  users.firstname  AS  users_firstname,  users.lastname  AS  users_lastname\nFROM  users  ORDER  BY  users.oid\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine(\"myengine://\")\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\n# use the new Session() freely\nsess = Session()\nsess.save(someobject)\nsess.flush()\n```", "```py\nSession.configure(bind=create_engine(...))\n```", "```py\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\nSession = scoped_session(sessionmaker(autoflush=True, transactional=True))\nSession.configure(bind=engine)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\nsess.commit()\n\n# Session constructor is thread-locally scoped.  Everyone gets the same\n# Session in the thread when scope=\"thread\".\nsess2 = Session()\nassert sess is sess2\n```", "```py\n# \"assignmapper\"-like functionality available via ScopedSession.mapper\nSession.mapper(User, users_table)\n\nu = User(name=\"wendy\")\n\nSession.commit()\n```", "```py\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\n\n# wendy is flushed, comes right back from a query\nwendy = sess.query(User).filter_by(name=\"wendy\").one()\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nsess = Session()\nsess.begin()\n\n# use the session\n\nsess.commit()  # commit transaction\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nconn = engine.connect()\ntrans = conn.begin()\nsess = Session(bind=conn)\n\n# ... session is transactional\n\n# commit the outermost transaction\ntrans.commit()\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nengine = create_engine(\"myengine://\")\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\n# use the new Session() freely\nsess = Session()\nsess.save(someobject)\nsess.flush()\n```", "```py\nSession.configure(bind=create_engine(...))\n```", "```py\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\nSession = scoped_session(sessionmaker(autoflush=True, transactional=True))\nSession.configure(bind=engine)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\nsess.commit()\n\n# Session constructor is thread-locally scoped.  Everyone gets the same\n# Session in the thread when scope=\"thread\".\nsess2 = Session()\nassert sess is sess2\n```", "```py\n# \"assignmapper\"-like functionality available via ScopedSession.mapper\nSession.mapper(User, users_table)\n\nu = User(name=\"wendy\")\n\nSession.commit()\n```", "```py\nSession = sessionmaker(bind=engine, autoflush=True, transactional=True)\n\nu = User(name=\"wendy\")\n\nsess = Session()\nsess.save(u)\n\n# wendy is flushed, comes right back from a query\nwendy = sess.query(User).filter_by(name=\"wendy\").one()\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nsess = Session()\nsess.begin()\n\n# use the session\n\nsess.commit()  # commit transaction\n```", "```py\nSession = sessionmaker(autoflush=True, transactional=False)\n\nconn = engine.connect()\ntrans = conn.begin()\nsess = Session(bind=conn)\n\n# ... session is transactional\n\n# commit the outermost transaction\ntrans.commit()\n```", "```py\nb = bindparam(\"foo\", type_=String)\n```", "```py\nmy_table.select(my_table.c.id.in_(1, 2, 3))\nmy_table.select(my_table.c.id.in_(*listOfIds))\n```", "```py\nmy_table.select(my_table.c.id.in_([1, 2, 3]))\nmy_table.select(my_table.c.id.in_(listOfIds))\n```", "```py\nb = bindparam(\"foo\", type_=String)\n```", "```py\nmy_table.select(my_table.c.id.in_(1, 2, 3))\nmy_table.select(my_table.c.id.in_(*listOfIds))\n```", "```py\nmy_table.select(my_table.c.id.in_([1, 2, 3]))\nmy_table.select(my_table.c.id.in_(listOfIds))\n```", "```py\n+-------------------------------------+-------------------------+\n|If You Had                           | Now Use                 |\n+=====================================+=========================+\n| ``MetaData``                        | ``MetaData``            |\n+-------------------------------------+-------------------------+\n| ``BoundMetaData``                   | ``MetaData``            |\n+-------------------------------------+-------------------------+\n| ``DynamicMetaData`` (with one       | ``MetaData``            |\n| engine or threadlocal=False)        |                         |\n+-------------------------------------+-------------------------+\n| ``DynamicMetaData``                 | ``ThreadLocalMetaData`` |\n| (with different engines per thread) |                         |\n+-------------------------------------+-------------------------+\n```", "```py\n>>> metadata = MetaData(myengine, reflect=True)\n>>> metadata.tables.keys()\n['table_a', 'table_b', 'table_c', '...']\n```", "```py\n+-------------------------------------+-------------------------+\n|If You Had                           | Now Use                 |\n+=====================================+=========================+\n| ``MetaData``                        | ``MetaData``            |\n+-------------------------------------+-------------------------+\n| ``BoundMetaData``                   | ``MetaData``            |\n+-------------------------------------+-------------------------+\n| ``DynamicMetaData`` (with one       | ``MetaData``            |\n| engine or threadlocal=False)        |                         |\n+-------------------------------------+-------------------------+\n| ``DynamicMetaData``                 | ``ThreadLocalMetaData`` |\n| (with different engines per thread) |                         |\n+-------------------------------------+-------------------------+\n```", "```py\n>>> metadata = MetaData(myengine, reflect=True)\n>>> metadata.tables.keys()\n['table_a', 'table_b', 'table_c', '...']\n```", "```py\nresult = engine.execute(\n    text(\n        \"begin foo(:x, :y, :z); end;\",\n        bindparams=[\n            bindparam(\"x\", Numeric),\n            outparam(\"y\", Numeric),\n            outparam(\"z\", Numeric),\n        ],\n    ),\n    x=5,\n)\nassert result.out_parameters == {\"y\": 10, \"z\": 75}\n```", "```py\nconn = engine.connect()\nsess = create_session(bind=conn)\n```", "```py\nresult = engine.execute(\n    text(\n        \"begin foo(:x, :y, :z); end;\",\n        bindparams=[\n            bindparam(\"x\", Numeric),\n            outparam(\"y\", Numeric),\n            outparam(\"z\", Numeric),\n        ],\n    ),\n    x=5,\n)\nassert result.out_parameters == {\"y\": 10, \"z\": 75}\n```", "```py\nconn = engine.connect()\nsess = create_session(bind=conn)\n```"]