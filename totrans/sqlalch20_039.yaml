- en: Using the legacy ‘backref’ relationship parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/backref.html](https://docs.sqlalchemy.org/en/20/orm/backref.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") keyword should be considered legacy, and use of
    [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") with explicit [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs should be preferred. Using individual
    [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    constructs provides advantages including that both ORM mapped classes will include
    their attributes up front as the class is constructed, rather than as a deferred
    step, and configuration is more straightforward as all arguments are explicit.
    New [**PEP 484**](https://peps.python.org/pep-0484/) features in SQLAlchemy 2.0
    also take advantage of attributes being explicitly present in source code rather
    than using dynamic attribute generation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'For general information about bidirectional relationships, see the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Working with ORM Related Objects](../tutorial/orm_related_objects.html#tutorial-orm-related-objects)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial),
    presents an overview of bi-directional relationship configuration and behaviors
    using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Behavior of save-update cascade with bi-directional relationships](cascades.html#back-populates-cascade)
    - notes on bi-directional [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") behavior regarding [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cascade behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")'
  prefs: []
  type: TYPE_NORMAL
- en: The [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") keyword argument on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct allows the automatic generation of a
    new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    that will be automatically be added to the ORM mapping for the related class.
    It will then be placed into a [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") configuration against the current [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") being configured, with both [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs referring to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above configuration establishes a collection of `Address` objects on `User`
    called `User.addresses`. It also establishes a `.user` attribute on `Address`
    which will refer to the parent `User` object. Using [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") it’s equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of the `User.addresses` and `Address.user` relationships is that
    they now behave in a **bi-directional** way, indicating that changes on one side
    of the relationship impact the other. An example and discussion of this behavior
    is in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)
    at [Working with ORM Related Objects](../tutorial/orm_related_objects.html#tutorial-orm-related-objects).
  prefs: []
  type: TYPE_NORMAL
- en: Backref Default Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") generates a whole new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), the generation process by default will attempt
    to include corresponding arguments in the new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that correspond to the original arguments. As an
    example, below is a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that includes a [custom join condition](join_conditions.html#relationship-configure-joins)
    which also includes the [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the “backref” is generated, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") condition is copied to the new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other arguments that are transferrable include the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter that refers to a many-to-many association
    table, as well as the “join” arguments [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship"); “backref” is smart enough to know that these two
    arguments should also be “reversed” when generating the opposite side.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Backref Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lots of other arguments for a “backref” are not implicit, and include arguments
    like [`relationship.lazy`](relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship"), [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship"), [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") and [`relationship.cascade_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship"). For this case we use the [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function in place of a string; this will store a specific
    set of arguments that will be transferred to the new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") when generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Where above, we placed a `lazy="joined"` directive only on the `Address.user`
    side, indicating that when a query against `Address` is made, a join to the `User`
    entity should be made automatically which will populate the `.user` attribute
    of each returned `Address`. The [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function formatted the arguments we gave it into a form
    that is interpreted by the receiving [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as additional arguments to be applied to the new
    relationship it creates.
  prefs: []
  type: TYPE_NORMAL
- en: Backref Default Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") generates a whole new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), the generation process by default will attempt
    to include corresponding arguments in the new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that correspond to the original arguments. As an
    example, below is a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that includes a [custom join condition](join_conditions.html#relationship-configure-joins)
    which also includes the [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the “backref” is generated, the [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") condition is copied to the new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Other arguments that are transferrable include the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter that refers to a many-to-many association
    table, as well as the “join” arguments [`relationship.primaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") and [`relationship.secondaryjoin`](relationship_api.html#sqlalchemy.orm.relationship.params.secondaryjoin
    "sqlalchemy.orm.relationship"); “backref” is smart enough to know that these two
    arguments should also be “reversed” when generating the opposite side.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Backref Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lots of other arguments for a “backref” are not implicit, and include arguments
    like [`relationship.lazy`](relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship"), [`relationship.remote_side`](relationship_api.html#sqlalchemy.orm.relationship.params.remote_side
    "sqlalchemy.orm.relationship"), [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") and [`relationship.cascade_backrefs`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship"). For this case we use the [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function in place of a string; this will store a specific
    set of arguments that will be transferred to the new [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") when generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Where above, we placed a `lazy="joined"` directive only on the `Address.user`
    side, indicating that when a query against `Address` is made, a join to the `User`
    entity should be made automatically which will populate the `.user` attribute
    of each returned `Address`. The [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function formatted the arguments we gave it into a form
    that is interpreted by the receiving [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as additional arguments to be applied to the new
    relationship it creates.
  prefs: []
  type: TYPE_NORMAL
