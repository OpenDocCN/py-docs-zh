- en: Column Loading Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列加载选项
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/columns.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/columns.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/queryguide/columns.html](https://docs.sqlalchemy.org/en/20/orm/queryguide/columns.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This section presents additional options regarding the loading of columns. The
    mappings used include columns that would store large string values for which we
    may want to limit when they are loaded.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了有关加载列的其他选项。使用的映射包括将存储大字符串值的列，我们可能希望限制它们何时加载。
- en: '[View the ORM setup for this page](_deferred_setup.html). Some of the examples
    below will redefine the `Book` mapper to modify some of the column definitions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[查看此页面的 ORM 设置](_deferred_setup.html)。以下示例中的一些将重新定义 `Book` 映射器以修改某些列定义。'
- en: '## Limiting which Columns Load with Column Deferral'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用列推迟限制加载的列'
- en: '**Column deferral** refers to ORM mapped columns that are omitted from a SELECT
    statement when objects of that type are queried. The general rationale here is
    performance, in cases where tables have seldom-used columns with potentially large
    data values, as fully loading these columns on every query may be time and/or
    memory intensive. SQLAlchemy ORM offers a variety of ways to control the loading
    of columns when entities are loaded.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**列推迟** 指的是在查询该类型的对象时，从 SELECT 语句中省略的 ORM 映射列。这里的一般原理是性能，在表中具有很少使用的列，并且具有潜在的大数据值，因为在每次查询时完全加载这些列可能会耗费时间和/或内存。当实体加载时，SQLAlchemy
    ORM 提供了各种控制列加载的方式。'
- en: Most examples in this section are illustrating **ORM loader options**. These
    are small constructs that are passed to the [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method of the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which are then consumed by the ORM
    when the object is compiled into a SQL string.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节大多数示例演示了**ORM 加载器选项**。这些是传递给 [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") 方法的小构造，该方法是 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象的一部分，当对象编译为 SQL 字符串时，ORM 将使用它们。
- en: '### Using `load_only()` to reduce loaded columns'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `load_only()` 减少加载的列'
- en: 'The [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") loader
    option is the most expedient option to use when loading objects where it is known
    that only a small handful of columns will be accessed. This option accepts a variable
    number of class-bound attribute objects indicating those column-mapped attributes
    that should be loaded, where all other column-mapped attributes outside of the
    primary key will not be part of the columns fetched . In the example below, the
    `Book` class contains columns `.title`, `.summary` and `.cover_photo`. Using [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") we can instruct the ORM to only load the `.title`
    and `.summary` columns up front:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")加载器选项是在加载对象时最为便捷的选项，当已知只有少量列将被访问时，可以使用该选项。该选项接受一个可变数量的类绑定属性对象，指示应该加载的列映射属性，除了主键之外的所有其他列映射属性将不包括在检索的列中。在下面的示例中，`Book`
    类包含列 `.title`、`.summary` 和 `.cover_photo`。使用 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 我们可以指示 ORM 仅预先加载 `.title` 和 `.summary` 列：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Above, the SELECT statement has omitted the `.cover_photo` column and included
    only `.title` and `.summary`, as well as the primary key column `.id`; the ORM
    will typically always fetch the primary key columns as these are required to establish
    the identity for the row.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，SELECT 语句省略了 `.cover_photo` 列，并仅包括 `.title` 和 `.summary`，以及主键列 `.id`；ORM
    通常会始终获取主键列，因为这些列是必需的，以建立行的标识。
- en: 'Once loaded, the object will normally have [lazy loading](../../glossary.html#term-lazy-loading)
    behavior applied to the remaining unloaded attributes, meaning that when any are
    first accessed, a SQL statement will be emitted within the current transaction
    in order to load the value. Below, accessing `.cover_photo` emits a SELECT statement
    to load its value:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，对象通常将对其余未加载属性应用[延迟加载](../../glossary.html#term-lazy-loading)行为，这意味着当首次访问时，将在当前事务中发出一个
    SQL 语句以加载值。在下面的示例中，访问 `.cover_photo` 会发出一个 SELECT 语句来加载其值：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Lazy loads are always emitted using the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to which the object is in the [persistent](../../glossary.html#term-persistent)
    state. If the object is [detached](../../glossary.html#term-detached) from any
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    the operation fails, raising an exception.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性加载始终使用对象处于 [持久](../../glossary.html#term-persistent) 状态的 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 进行。如果对象从任何 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中 [分离](../../glossary.html#term-detached)，操作将失败，引发异常。
- en: As an alternative to lazy loading on access, deferred columns may also be configured
    to raise an informative exception when accessed, regardless of their attachment
    state. When using the [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    construct, this may be indicated using the [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") parameter. See the section [Using raiseload to prevent
    deferred column loads](#orm-queryguide-deferred-raiseload) for background and
    examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在访问时进行惰性加载的替代方法，延迟列还可以配置为在访问时引发信息异常，而不考虑它们的附加状态。当使用 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 构造时，可以使用 [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") 参数来指示此行为。有关背景和示例，请参阅 [使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)
    部分。
- en: Tip
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: as noted elsewhere, lazy loading is not available when using [Asynchronous I/O
    (asyncio)](../extensions/asyncio.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其他地方所指出的，当使用[异步 I/O（asyncio）](../extensions/asyncio.html) 时，惰性加载不可用。
- en: Using `load_only()` with multiple entities
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `load_only()` 处理多个实体
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") limits
    itself to the single entity that is referred towards in its list of attributes
    (passing a list of attributes that span more than a single entity is currently
    disallowed). In the example below, the given [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") option applies only to the `Book` entity. The `User`
    entity that’s also selected is not affected; within the resulting SELECT statement,
    all columns for `user_account` are present, whereas only `book.id` and `book.title`
    are present for the `book` table:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 限制自己仅适用于其属性列表中引用的单个实体（目前不允许传递跨越多个实体的属性列表）。在下面的示例中，给定的
    [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 选项仅适用于 `Book`
    实体。选择的 `User` 实体不受影响；在生成的 SELECT 语句中，所有 `user_account` 列均存在，而 `book` 表仅存在 `book.id`
    和 `book.title`：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we wanted to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    options to both `User` and `Book`, we would make use of two separate options:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    选项应用于 `User` 和 `Book`，我们将使用两个单独的选项：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#### Using `load_only()` on related objects and collections'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 在相关对象和集合上使用 `load_only()`'
- en: 'When using [relationship loaders](relationships.html) to control the loading
    of related objects, the [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") method of any relationship loader may be used
    to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    rules to columns on the sub-entity. In the example below, [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") is used to load the related `books` collection
    on each `User` object. By applying [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") to the resulting option object, when objects
    are loaded for the relationship, the SELECT emitted will only refer to the `title`
    column in addition to primary key column:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[关系加载器](relationships.html)来控制相关对象的加载时，任何关系加载器的 [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") 方法都可以用于将 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 规则应用于子实体上的列。在下面的示例中，[`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 用于在每个 `User` 对象上加载相关的 `books` 集合。通过将 [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") 应用于结果选项对象，当为关系加载对象时，生成的 SELECT 将仅引用 `title` 列以及主键列：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") may also
    be applied to sub-entities without needing to state the style of loading to use
    for the relationship itself. If we didn’t want to change the default loading style
    of `User.books` but still apply load only rules to `Book`, we would link using
    the [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    option, which in this case will retain the default relationship loading style
    of `"lazy"`, and applying our custom [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") rule to the SELECT statement emitted for each `User.books`
    collection:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 也可以应用于子实体，而无需声明要为关系本身使用的加载样式。如果我们不想更改
    `User.books` 的默认加载方式，但仍然要应用于 `Book` 的 load only 规则，我们将使用 [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") 选项进行链接，在这种情况下，它将保留默认关系加载样式 `"lazy"`，并将我们的自定义 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 规则应用于为每个 `User.books` 集合发出的 SELECT 语句：'
- en: '[PRE5]  ### Using `defer()` to omit specific columns'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]  ### 使用 `defer()` 省略特定列'
- en: 'The [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") loader option
    is a more fine grained alternative to [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only"), which allows a single specific column to be marked
    as “dont load”. In the example below, [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    is applied directly to the `.cover_photo` column, leaving the behavior of all
    other columns unchanged:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 加载器选项是 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 的一种更细粒度的替代方案，它允许将单个特定列标记为“不加载”。在下面的示例中，[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 直接应用于 `.cover_photo` 列，而所有其他列的行为保持不变：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As is the case with [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only"),
    unloaded columns by default will load themselves when accessed using [lazy loading](../../glossary.html#term-lazy-loading):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 一样，未加载的列默认情况下会在使用
    [惰性加载](../../glossary.html#term-lazy-loading) 访问时加载自身：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Multiple [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") options may
    be used in one statement in order to mark several columns as deferred.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一条语句中使用多个 [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 选项来标记多个列为延迟加载。
- en: 'As is the case with [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only"),
    the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") option also includes
    the ability to have a deferred attribute raise an exception on access rather than
    lazy loading. This is illustrated in the section [Using raiseload to prevent deferred
    column loads](#orm-queryguide-deferred-raiseload).  ### Using raiseload to prevent
    deferred column loads'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '与 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 一样，[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 选项也包括使延迟属性在访问时引发异常而不是惰性加载的能力。这在部分 [使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)
    中有所说明。 ### 使用 raiseload 防止延迟列加载'
- en: When using the [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    or [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") loader options, attributes
    marked as deferred on an object have the default behavior that when first accessed,
    a SELECT statement will be emitted within the current transaction in order to
    load their value. It is often necessary to prevent this load from occurring, and
    instead raise an exception when the attribute is accessed, indicating that the
    need to query the database for this column was not expected. A typical scenario
    is an operation where objects are loaded with all the columns that are known to
    be required for the operation to proceed, which are then passed onto a view layer.
    Any further SQL operations that emit within the view layer should be caught, so
    that the up-front loading operation can be adjusted to accommodate for that additional
    data up front, rather than incurring additional lazy loading.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 或
    [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 加载器选项时，对于对象上标记为延迟加载的属性，默认行为是在首次访问时，在当前事务中发出
    SELECT 语句以加载它们的值。通常需要防止此加载发生，并在访问属性时引发异常，指示没有预期需要为该列查询数据库。典型的场景是使用已知对操作进行操作所需的所有列加载对象，然后将它们传递到视图层。应该捕获在视图层内部发出的任何进一步的
    SQL 操作，以便可以调整预先加载的操作以适应该额外的数据，而不是产生额外的惰性加载。
- en: 'For this use case the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") options
    include a boolean parameter [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer"), which when set to `True` will cause the affected attributes
    to raise on access. In the example below, the deferred column `.cover_photo` will
    disallow attribute access:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此用例，[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")和[`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")选项包括一个布尔参数[`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")，当设置为`True`时，将导致受影响的属性在访问时引发异常。在下面的示例中，延迟加载的列`.cover_photo`将禁止属性访问：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When using [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    to name a specific set of non-deferred columns, `raiseload` behavior may be applied
    to the remaining columns using the [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") parameter, which will be applied to all deferred attributes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")指定一组非延迟加载列时，可以使用[`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only")参数来应用`raiseload`行为到其余列，该参数将应用于所有延迟属性：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is not yet possible to mix [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") options which refer
    to the same entity together in one statement in order to change the `raiseload`
    behavior of certain attributes; currently, doing so will produce undefined loading
    behavior of attributes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚不可能在一条语句中混合使用指向同一实体的[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")和[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项，以改变某些属性的`raiseload`行为；目前，这样做将产生未定义的属性加载行为。
- en: See also
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload "sqlalchemy.orm.defer")
    feature is the column-level version of the same “raiseload” feature that’s available
    for relationships. For “raiseload” with relationships, see [Preventing unwanted
    lazy loads using raiseload](relationships.html#prevent-lazy-with-raiseload) in
    the [Relationship Loading Techniques](relationships.html) section of this guide.  ##
    Configuring Column Deferral on Mappings'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload "sqlalchemy.orm.defer")功能是与关系可用的相同“raiseload”功能的列级别版本。对于关系的“raiseload”，请参阅本指南的[关系加载技术](relationships.html)部分中的[使用raiseload防止不必要的延迟加载](relationships.html#prevent-lazy-with-raiseload)。  ##
    在映射上配置列延迟加载'
- en: 'The functionality of [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    is available as a default behavior for mapped columns, as may be appropriate for
    columns that should not be loaded unconditionally on every query. To configure,
    use the [`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") parameter of [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"). The example below illustrates a mapping for `Book`
    which applies default column deferral to the `summary` and `cover_photo` columns:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射列，默认情况下，[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")的功能可作为映射列的默认行为，这对于不应在每次查询时无条件加载的列可能是合适的。要配置，请使用[`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column")参数的[`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。下面的示例说明了对`Book`的映射，该示例将默认列延迟应用于`summary`和`cover_photo`列：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the above mapping, queries against `Book` will automatically not include
    the `summary` and `cover_photo` columns:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，针对`Book`的查询将自动不包括`summary`和`cover_photo`列：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As is the case with all deferral, the default behavior when deferred attributes
    on the loaded object are first accessed is that they will [lazy load](../../glossary.html#term-lazy-load)
    their value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有延迟加载一样，当首次访问已加载对象上的延迟属性时，默认行为是它们将[延迟加载](../../glossary.html#term-lazy-load)它们的值：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As is the case with the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") loader
    options, mapper level deferral also includes an option for `raiseload` behavior
    to occur, rather than lazy loading, when no other options are present in a statement.
    This allows a mapping where certain columns will not load by default and will
    also never load lazily without explicit directives used in a statement. See the
    section [Configuring mapper-level “raiseload” behavior](#orm-queryguide-mapper-deferred-raiseload)
    for background on how to configure and use this behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")和[`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")加载器选项一样，映射器级别的延迟加载还包括一个选项，当语句中没有其他选项时，可以发生`raiseload`行为，而不是惰性加载。这允许映射其中某些列默认情况下不加载，并且在语句中不使用明确指令时也永远不会懒加载。有关如何配置和使用此行为的背景信息，请参阅[配置映射器级别的“raiseload”行为](#orm-queryguide-mapper-deferred-raiseload)一节。
- en: '### Using `deferred()` for imperative mappers, mapped SQL expressions'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对于命令式映射器、映射SQL表达式使用`deferred()`'
- en: The [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") function
    is the earlier, more general purpose “deferred column” mapping directive that
    precedes the introduction of the [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct in SQLAlchemy.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")函数是早期的、更通用的“延迟列”映射指令，在引入[`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造之前就存在于SQLAlchemy中。'
- en: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") is used
    when configuring ORM mappers, and accepts arbitrary SQL expressions or [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects. As such it’s suitable to be used with non-declarative
    [imperative mappings](../mapping_styles.html#orm-imperative-mapping), passing
    it to the [`map_imperatively.properties`](../mapping_api.html#sqlalchemy.orm.registry.map_imperatively.params.properties
    "sqlalchemy.orm.registry.map_imperatively") dictionary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置ORM映射器时使用[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")，并接受任意SQL表达式或[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。因此，它适用于非声明式[命令式映射](../mapping_styles.html#orm-imperative-mapping)，将其传递给[`map_imperatively.properties`](../mapping_api.html#sqlalchemy.orm.registry.map_imperatively.params.properties
    "sqlalchemy.orm.registry.map_imperatively")字典：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") may also
    be used in place of [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") when mapped SQL expressions should be loaded
    on a deferred basis:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射的SQL表达式应该延迟加载时，[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")也可以用于替代[`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using column_property](../mapped_sql_expr.html#mapper-column-property-sql-expressions)
    - in the section [SQL Expressions as Mapped Attributes](../mapped_sql_expr.html#mapper-sql-expressions)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用column_property](../mapped_sql_expr.html#mapper-column-property-sql-expressions)
    - 在[SQL表达式作为映射属性](../mapped_sql_expr.html#mapper-sql-expressions)一节中'
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](../declarative_tables.html#orm-imperative-table-column-options)
    - in the section [Table Configuration with Declarative](../declarative_tables.html)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用负载、持久性和映射选项到命令式表列](../declarative_tables.html#orm-imperative-table-column-options)
    - 在[使用声明式配置表](../declarative_tables.html#orm-imperative-table-column-options)一节中'
- en: Using `undefer()` to “eagerly” load deferred columns
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`undefer()`来“急切地”加载延迟列
- en: 'With columns configured on mappings to defer by default, the [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") option will cause any column that is normally deferred
    to be undeferred, that is, to load up front with all the other columns of the
    mapping. For example we may apply [`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    to the `Book.summary` column, which is indicated in the previous mapping as deferred:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认配置为延迟加载的映射上的列，[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")选项将导致任何通常延迟加载的列变为未延迟加载，即与映射的所有其他列一起提前加载。例如，我们可以将[`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")应用于在前述映射中标记为延迟加载的`Book.summary`列：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Book.summary` column was now eagerly loaded, and may be accessed without
    additional SQL being emitted:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Book.summary`列已经被急切地加载，并且可以在不发出额外SQL的情况下访问：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '### Loading deferred columns in groups'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将延迟列分组加载'
- en: 'Normally when a column is mapped with `mapped_column(deferred=True)`, when
    the deferred attribute is accessed on an object, SQL will be emitted to load only
    that specific column and no others, even if the mapping has other columns that
    are also marked as deferred. In the common case that the deferred attribute is
    part of a group of attributes that should all load at once, rather than emitting
    SQL for each attribute individually, the [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") parameter may be used, which accepts an arbitrary
    string which will define a common group of columns to be undeferred:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当列使用 `mapped_column(deferred=True)` 进行映射时，当在对象上访问延迟属性时，将发出 SQL 仅加载该特定列而不加载其他列，即使映射还有其他标记为延迟的列。在延迟属性是应一次性加载的一组属性的常见情况下，而不是为每个属性单独发出
    SQL，可以使用 [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") 参数，该参数接受一个任意字符串，该字符串将定义要取消延迟的一组常见列：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the above mapping, accessing either `summary` or `cover_photo` will load
    both columns at once using just one SELECT statement:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，访问 `summary` 或 `cover_photo` 将同时加载两个列，只需使用一个 SELECT 语句：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Undeferring by group with `undefer_group()`
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `undefer_group()` 按组取消延迟加载
- en: 'If deferred columns are configured with [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") as introduced in the preceding section, the entire
    group may be indicated to load eagerly using the [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group") option, passing the string name of the group to
    be eagerly loaded:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在前一节中引入了 [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") 配置了延迟列，则可以指示整个组使用 [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group") 选项进行急切加载，传递要急切加载的组的字符串名称：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Both `summary` and `cover_photo` are available without additional loads:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary` 和 `cover_photo` 都可以在不加载其他内容的情况下使用：'
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Undeferring on wildcards
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通配符取消延迟加载
- en: 'Most ORM loader options accept a wildcard expression, indicated by `"*"`, which
    indicates that the option should be applied to all relevant attributes. If a mapping
    has a series of deferred columns, all such columns can be undeferred at once,
    without using a group name, by indicating a wildcard:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 ORM 加载器选项接受通配符表达式，由 `"*"` 表示，表示该选项应用于所有相关属性。如果映射具有一系列延迟列，则可以一次性取消所有这些列的延迟，而无需使用组名，只需指定通配符：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '### Configuring mapper-level “raiseload” behavior'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '### 配置映射器级别的“提前加载”行为'
- en: 'The “raiseload” behavior first introduced at [Using raiseload to prevent deferred
    column loads](#orm-queryguide-deferred-raiseload) may also be applied as a default
    mapper-level behavior, using the [`mapped_column.deferred_raiseload`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_raiseload
    "sqlalchemy.orm.mapped_column") parameter of [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"). When using this parameter, the affected columns
    will raise on access in all cases unless explicitly “undeferred” using [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    at query time:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload) 中首次引入的 “raiseload”
    行为也可以作为默认的映射器级别行为应用，使用 [`mapped_column.deferred_raiseload`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_raiseload
    "sqlalchemy.orm.mapped_column") 参数的 [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。当使用此参数时，受影响的列将在所有情况下在访问时引发，除非在查询时显式地使用 [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") 或 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    进行“取消延迟”：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the above mapping, the `.summary` and `.cover_photo` columns are by default
    not loadable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，`.summary` 和 `.cover_photo` 列默认情况下不可加载：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Only by overriding their behavior at query time, typically using [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group"), or less commonly [`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), may the attributes be loaded. The example below applies
    `undefer(''*'')` to undefer all attributes, also making use of [Populate Existing](api.html#orm-queryguide-populate-existing)
    to refresh the already-loaded object’s loader options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在查询时重写它们的行为，通常使用 [`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    或 [`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")，或者更少见的
    [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")，属性才能被加载。下面的示例将 `undefer('*')`
    应用于未延迟加载所有属性，并且还利用了[填充现有对象](api.html#orm-queryguide-populate-existing)来刷新已加载对象的加载器选项：
- en: '[PRE24]  ## Loading Arbitrary SQL Expressions onto Objects'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]  ## 将任意 SQL 表达式加载到对象上'
- en: 'As discussed [Selecting ORM Entities and Attributes](select.html#orm-queryguide-select-columns)
    and elsewhere, the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct may be used to load arbitrary SQL
    expressions in a result set. Such as if we wanted to issue a query that loads
    `User` objects, but also includes a count of how many books each `User` owned,
    we could use `func.count(Book.id)` to add a “count” column to a query which includes
    a JOIN to `Book` as well as a GROUP BY owner id. This will yield [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that each contain two entries, one for `User`
    and one for `func.count(Book.id)`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如[选择 ORM 实体和属性](select.html#orm-queryguide-select-columns)及其他地方所讨论的，可以使用 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 结构在结果集中加载任意 SQL 表达式。比如，如果我们想要发出一个查询，加载 `User`
    对象，但也包括每个 `User` 拥有多少书籍的计数，我们可以使用 `func.count(Book.id)` 将“计数”列添加到一个查询中，该查询包括与
    `Book` 的 JOIN 以及按所有者 id 进行的 GROUP BY。这将产生 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，每个对象包含两个条目，一个是 `User`，一个是 `func.count(Book.id)`：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above example, the `User` entity and the “book count” SQL expression
    are returned separately. However, a popular use case is to produce a query that
    will yield `User` objects alone, which can be iterated for example using [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"), where the result of the `func.count(Book.id)`
    SQL expression is applied *dynamically* to each `User` entity. The end result
    would be similar to the case where an arbitrary SQL expression were mapped to
    the class using [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"), except that the SQL expression can be modified
    at query time. For this use case SQLAlchemy provides the [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option, which when combined with the
    mapper level [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    directive may produce this result.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`User` 实体和“书籍数量”SQL表达式分别返回。然而，一个常见的用例是生成一个查询，仅产生 `User` 对象，可以通过[`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")来迭代，其中 `func.count(Book.id)` SQL 表达式的结果被*动态地*应用到每个
    `User` 实体上。最终结果类似于在类上使用 [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 将任意 SQL 表达式映射到类的情况，只是 SQL 表达式可以在查询时进行修改。对于这种用例，SQLAlchemy
    提供了 [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    加载器选项，当与映射器级别的 [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    指令结合使用时，可以产生这种结果。
- en: 'To apply [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    to a query, the mapped class must have pre-configured an ORM mapped attribute
    using the [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    directive; this directive will produce an attribute on the mapped class that is
    suitable for receiving query-time SQL expressions. Below we add a new attribute
    `User.book_count` to `User`. This ORM mapped attribute is read-only and has no
    default value; accessing it on a loaded instance will normally produce `None`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    应用于查询，映射类必须预先使用 [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    指令配置了一个 ORM 映射属性；这个指令将在映射类上生成一个适合接收查询时 SQL 表达式的属性。下面我们将一个新属性 `User.book_count`
    添加到 `User` 中。这个 ORM 映射属性是只读的，没有默认值；在加载的实例上访问它通常会产生 `None`：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the `User.book_count` attribute configured in our mapping, we may populate
    it with data from a SQL expression using the [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option to apply a custom SQL expression
    to each `User` object as it’s loaded:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们映射中配置的 `User.book_count` 属性，我们可以使用 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 加载器选项，将数据从 SQL 表达式应用到每个 `User` 对象中加载的自定义 SQL
    表达式中：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Above, we moved our `func.count(Book.id)` expression out of the columns argument
    of the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct and into the [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option. The ORM then considers this to
    be a special column load option that’s applied dynamically to the statement.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们将我们的 `func.count(Book.id)` 表达式从 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造的 columns 参数中移出，并将其放入 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 加载器选项中。ORM 然后将其视为一个特殊的列加载选项，动态应用于语句。
- en: 'The [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    mapping has these caveats:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    映射有以下注意事项：'
- en: On an object where [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    were not used to populate the attribute, the attribute on an object instance will
    have the value `None`, unless on the mapping the [`query_expression.default_expr`](#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") parameter is set to a default SQL expression.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未使用 [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    来填充属性的对象上，对象实例上的属性将具有值 `None`，除非在映射上将 [`query_expression.default_expr`](#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") 参数设置为默认的 SQL 表达式。
- en: 'The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    value **does not populate on an object that is already loaded**, unless [Populate
    Existing](api.html#orm-queryguide-populate-existing) is used. The example below
    will **not work**, as the `A` object is already loaded:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    值**不会在已加载的对象上填充**，除非使用了 [Populate Existing](api.html#orm-queryguide-populate-existing)。如下示例**不起作用**，因为
    `A` 对象已经加载：'
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To ensure the attribute is re-loaded on an existing object, use the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option to ensure
    all columns are re-populated:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要确保在现有对象上重新加载属性，请使用 [Populate Existing](api.html#orm-queryguide-populate-existing)
    执行选项以确保重新填充所有列：
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    SQL expression **is lost when the object is expired**. Once the object is expired,
    either via [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") or via the expire_on_commit behavior of [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the SQL expression and its value is no longer
    associated with the attribute and will return `None` on subsequent access.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象过期时，[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    SQL 表达式**会丢失**。一旦对象过期，无论是通过 [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 还是通过 [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 的 expire_on_commit 行为，SQL 表达式及其值将不再与属性关联，并且在后续访问时将返回
    `None`。
- en: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression"),
    as an object loading option, only takes effect on the **outermost part of a query**
    and only for a query against a full entity, and not for arbitrary column selects,
    within subqueries, or the elements of a compound statement such as a UNION. See
    the next section [Using with_expression() with UNIONs, other subqueries](#orm-queryguide-with-expression-unions)
    for an example.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    作为对象加载选项，仅对**查询的最外层部分**以及对完整实体的查询起作用，而不适用于任意列选择、子查询或复合语句的元素，比如 UNION。请参阅下一节 [使用
    with_expression() 与 UNIONs、其他子查询](#orm-queryguide-with-expression-unions) 查看示例。'
- en: 'The mapped attribute **cannot** be applied to other parts of the query, such
    as the WHERE clause, the ORDER BY clause, and make use of the ad-hoc expression;
    that is, this won’t work:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的属性**不能**应用于查询的其他部分，比如 WHERE 子句、ORDER BY 子句，并且使用临时表达式；也就是说，以下示例不起作用：
- en: '[PRE30]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `A.expr` expression will resolve to NULL in the above WHERE clause and
    ORDER BY clause. To use the expression throughout the query, assign to a variable
    and use that:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述 WHERE 子句和 ORDER BY 子句中，`A.expr` 表达式将解析为 NULL。要在整个查询中使用该表达式，请赋值给一个变量然后使用它：
- en: '[PRE31]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    option is a special option used to apply SQL expressions to mapped classes dynamically
    at query time. For ordinary fixed SQL expressions configured on mappers, see the
    section [SQL Expressions as Mapped Attributes](../mapped_sql_expr.html#mapper-sql-expressions).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    选项是一种特殊选项，用于在查询时动态应用 SQL 表达式到映射类。对于在映射器上配置的普通固定 SQL 表达式，请参阅 [SQL 表达式作为映射属性](../mapped_sql_expr.html#mapper-sql-expressions)
    部分。'
- en: '### Using `with_expression()` with UNIONs, other subqueries'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `with_expression()` 与 UNIONs、其他子查询'
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    construct is an ORM loader option, and as such may only be applied to the outermost
    level of a SELECT statement which is to load a particular ORM entity. It does
    not have any effect if used inside of a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") that will then be used as a subquery or as
    an element within a compound statement such as a UNION.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    构造是一种 ORM 加载器选项，因此只能应用于要加载特定 ORM 实体的 SELECT 语句的最外层级。如果在 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 中使用，而后将其用作子查询或作为复合语句中的元素，如 UNION，它将不起作用。'
- en: In order to use arbitrary SQL expressions in subqueries, normal Core-style means
    of adding expressions should be used. To assemble a subquery-derived expression
    onto the ORM entity’s [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") attributes, [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") is used at the top layer of ORM object loading,
    referencing the SQL expression within the subquery.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在子查询中使用任意 SQL 表达式，应使用常规的 Core 风格添加表达式的方法。要将子查询派生的表达式组装到 ORM 实体的 [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") 属性上，应在 ORM 对象加载的顶层使用 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")，引用子查询中的 SQL 表达式。
- en: 'In the example below, two [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are used against the ORM entity
    `A` with an additional SQL expression labeled in `expr`, and combined using [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"). Then, at the topmost layer, the `A` entity
    is SELECTed from this UNION, using the querying technique described at [Selecting
    Entities from UNIONs and other set operations](select.html#orm-queryguide-unions),
    adding an option with [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    to extract this SQL expression onto newly loaded instances of `A`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用两个 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造针对带有额外 SQL 表达式标记为 `expr` 的 ORM 实体 `A`，并使用
    [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") 组合。然后，在最顶层，从此 UNION 中 SELECT `A` 实体，使用在
    [从 UNION 和其他集合操作中选择实体](select.html#orm-queryguide-unions) 中描述的查询技术，添加一个选项，使用 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 提取此 SQL 表达式到新加载的 `A` 实例上：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Column Loading API
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列加载 API
- en: '| Object Name | Description |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [defer](#sqlalchemy.orm.defer)(key, *addl_attrs, [raiseload]) | Indicate
    that the given column-oriented attribute should be deferred, e.g. not loaded until
    accessed. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| [defer](#sqlalchemy.orm.defer)(key, *addl_attrs, [raiseload]) | 指示给定的面向列的属性应该被延迟加载，例如，直到访问时才加载。
    |'
- en: '| [deferred](#sqlalchemy.orm.deferred)(column, *additional_columns, [group,
    raiseload, comparator_factory, init, repr, default, default_factory, compare,
    kw_only, active_history, expire_on_flush, info, doc]) | Indicate a column-based
    mapped attribute that by default will not load unless accessed. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| [deferred](#sqlalchemy.orm.deferred)(column, *additional_columns, [group,
    raiseload, comparator_factory, init, repr, default, default_factory, compare,
    kw_only, active_history, expire_on_flush, info, doc]) | 指示默认情况下不加载的基于列的映射属性。 |'
- en: '| [load_only](#sqlalchemy.orm.load_only)(*attrs, [raiseload]) | Indicate that
    for a particular entity, only the given list of column-based attribute names should
    be loaded; all others will be deferred. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| [load_only](#sqlalchemy.orm.load_only)(*attrs, [raiseload]) | 表示对于特定实体，仅加载给定的列属性名列表；所有其他列将被延迟加载。
    |'
- en: '| [query_expression](#sqlalchemy.orm.query_expression)([default_expr], *, [repr,
    compare, expire_on_flush, info, doc]) | Indicate an attribute that populates from
    a query-time SQL expression. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| [query_expression](#sqlalchemy.orm.query_expression)([default_expr], *, [repr,
    compare, expire_on_flush, info, doc]) | 指示从查询时 SQL 表达式填充的属性。 |'
- en: '| [undefer](#sqlalchemy.orm.undefer)(key, *addl_attrs) | Indicate that the
    given column-oriented attribute should be undeferred, e.g. specified within the
    SELECT statement of the entity as a whole. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| [undefer](#sqlalchemy.orm.undefer)(key, *addl_attrs) | 指示给定的基于列的属性应取消延迟加载，例如，可以在实体的
    SELECT 语句中指定。 |'
- en: '| [undefer_group](#sqlalchemy.orm.undefer_group)(name) | Indicate that columns
    within the given deferred group name should be undeferred. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| [undefer_group](#sqlalchemy.orm.undefer_group)(name) | 指示给定延迟组名中的列应取消延迟加载。
    |'
- en: '| [with_expression](#sqlalchemy.orm.with_expression)(key, expression) | Apply
    an ad-hoc SQL expression to a “deferred expression” attribute. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| [with_expression](#sqlalchemy.orm.with_expression)(key, expression) | 将临时
    SQL 表达式应用于“延迟表达式”属性。 |'
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Indicate that the given column-oriented attribute should be deferred, e.g. not
    loaded until accessed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 指示给定的基于列的属性应延迟加载，例如，直到访问时才加载。
- en: This function is part of the [`Load`](relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") interface and supports both method-chained and standalone
    operation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    接口的一部分，并支持方法链接和独立操作。
- en: 'e.g.:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To specify a deferred load of an attribute on a related class, the path can
    be specified one token at a time, specifying the loading style for each link along
    the chain. To leave the loading style for a link unchanged, use [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload"):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定对相关类的属性进行延迟加载，可以逐个令牌指定路径，并指定沿链的每个链接的加载样式。要保留链接的加载样式不变，请使用 [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Multiple deferral options related to a relationship can be bundled at once
    using [`Load.options()`](relationships.html#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options"):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`Load.options()`](relationships.html#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")
    一次捆绑与关系相关的多个延迟选项：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`key` – Attribute to be deferred.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` – 要延迟加载的属性。'
- en: '`raiseload` – raise [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") rather than lazy loading a value when the
    deferred attribute is accessed. Used to prevent unwanted SQL from being emitted.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` – 在访问延迟属性时，引发 [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") 而不是懒加载值。用于防止生成不需要的 SQL。'
- en: New in version 1.4.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4 中的新功能。
- en: See also
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制哪些列随列延迟加载](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")'
- en: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Indicate a column-based mapped attribute that by default will not load unless
    accessed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表示默认情况下不会加载的基于列的映射属性，除非访问。
- en: When using [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), the same functionality as that of [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") construct is provided by using the [`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") parameter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    时，通过使用 [`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") 参数提供了与 [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 构造相同的功能。
- en: 'Parameters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`*columns` – columns to be mapped. This is typically a single [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, however a collection is supported in order
    to support multiple columns mapped under the same attribute.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*columns` – 要映射的列。通常这是一个单独的 [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，但是为了支持在同一属性下映射多个列，也支持集合。'
- en: '`raiseload` –'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` –'
- en: boolean, if True, indicates an exception should be raised if the load operation
    is to take place.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔值，如果为 True，则表示如果执行加载操作，则应引发异常。
- en: New in version 1.4.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1.4 版中的新内容。
- en: Additional arguments are the same as that of [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property").
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的参数与 [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 相同。
- en: See also
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using deferred() for imperative mappers, mapped SQL expressions](#orm-queryguide-deferred-imperative)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[对命令式映射器、映射的 SQL 表达式使用 deferred()](#orm-queryguide-deferred-imperative)'
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Indicate an attribute that populates from a query-time SQL expression.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 指示从查询时间 SQL 表达式填充的属性。
- en: 'Parameters:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**default_expr** – Optional SQL expression object that will be used in all
    cases if not assigned later with [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression").'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**default_expr** – 可选的 SQL 表达式对象，如果没有后续使用 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 分配，则将在所有情况下使用。'
- en: New in version 1.2.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 版中的新内容。
- en: See also
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Loading Arbitrary SQL Expressions onto Objects](#orm-queryguide-with-expression)
    - background and usage examples'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[将任意 SQL 表达式加载到对象](#orm-queryguide-with-expression) - 背景和用法示例'
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Indicate that for a particular entity, only the given list of column-based attribute
    names should be loaded; all others will be deferred.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 指示对于特定实体，只加载给定的列名列表；所有其他属性将被延迟。
- en: This function is part of the [`Load`](relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") interface and supports both method-chained and standalone
    operation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    接口的一部分，支持方法链接和独立操作。
- en: 'Example - given a class `User`, load only the `name` and `fullname` attributes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 给定一个类 `User`，只加载 `name` 和 `fullname` 属性：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Example - given a relationship `User.addresses -> Address`, specify subquery
    loading for the `User.addresses` collection, but on each `Address` object load
    only the `email_address` attribute:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 给定一个关系 `User.addresses -> Address`，为 `User.addresses` 集合指定子查询加载，但在每个 `Address`
    对象上仅加载 `email_address` 属性：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For a statement that has multiple entities, the lead entity can be specifically
    referred to using the [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    constructor:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个实体的语句，可以使用 [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    构造函数来明确指定引导实体：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When used together with the [populate_existing](api.html#orm-queryguide-populate-existing)
    execution option only the attributes listed will be refreshed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [populate_existing](api.html#orm-queryguide-populate-existing) 执行选项一起使用时，只会刷新列出的属性。
- en: 'Parameters:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`*attrs` – Attributes to be loaded, all others will be deferred.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*attrs` – 要加载的属性，所有其他属性都将延迟。'
- en: '`raiseload` –'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` –'
- en: raise [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") rather than lazy loading a value when a
    deferred attribute is accessed. Used to prevent unwanted SQL from being emitted.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当访问延迟属性时，引发 [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") 而不是惰性加载值。用于防止不必要的 SQL 发出。
- en: New in version 2.0.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版中的新内容。
- en: See also
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制加载的列与列延迟](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: 'Parameters:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`*attrs` – Attributes to be loaded, all others will be deferred.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*attrs` – 要加载的属性，所有其他属性都将延迟。'
- en: '`raiseload` –'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` –'
- en: raise [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") rather than lazy loading a value when a
    deferred attribute is accessed. Used to prevent unwanted SQL from being emitted.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当访问延迟属性时，引发 [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") 而不是惰性加载值。用于防止不必要的 SQL 发出。
- en: New in version 2.0.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版中的新内容。
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Indicate that the given column-oriented attribute should be undeferred, e.g.
    specified within the SELECT statement of the entity as a whole.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 指示给定的基于列的属性应该取消延迟，例如，在整个实体的 SELECT 语句中指定。
- en: The column being undeferred is typically set up on the mapping as a [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") attribute.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在映射上设置未延迟的列作为[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")
    属性。
- en: This function is part of the [`Load`](relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") interface and supports both method-chained and standalone
    operation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    接口的一部分，支持方法链接和独立操作。
- en: 'Examples:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Parameters:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** – Attribute to be undeferred.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** – 要取消延迟的属性。'
- en: See also
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用列推迟限制加载的列](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
- en: '[`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")'
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Indicate that columns within the given deferred group name should be undeferred.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 指示给定延迟组名内的列应取消延迟。
- en: The columns being undeferred are set up on the mapping as [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") attributes and include a “group” name.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正在取消延迟的列在映射上设置为 [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")
    属性，并包括一个“组”名称。
- en: 'E.g:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To undefer a group of attributes on a related entity, the path can be spelled
    out using relationship loader options, such as [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload"):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消相关实体上的一组属性的延迟加载，可以使用关系加载器选项（如[`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")）拼写路径：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用列推迟限制加载的列](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
- en: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Apply an ad-hoc SQL expression to a “deferred expression” attribute.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将临时 SQL 表达式应用于“延迟表达式”属性。
- en: This option is used in conjunction with the [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") mapper-level construct that indicates an attribute
    which should be the target of an ad-hoc SQL expression.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项与[`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    mapper-level 构造一起使用，指示应该是临时 SQL 表达式目标的属性。
- en: 'E.g.:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: New in version 1.2.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.2 中的新增内容。
- en: 'Parameters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`key` – Attribute to be populated'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` – 要填充的属性'
- en: '`expr` – SQL expression to be applied to the attribute.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr` – 要应用于属性的 SQL 表达式。'
- en: See also
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Loading Arbitrary SQL Expressions onto Objects](#orm-queryguide-with-expression)
    - background and usage examples'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[将任意 SQL 表达式加载到对象上](#orm-queryguide-with-expression) - 背景和使用示例'
- en: '## Limiting which Columns Load with Column Deferral'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用列推迟限制加载的列'
- en: '**Column deferral** refers to ORM mapped columns that are omitted from a SELECT
    statement when objects of that type are queried. The general rationale here is
    performance, in cases where tables have seldom-used columns with potentially large
    data values, as fully loading these columns on every query may be time and/or
    memory intensive. SQLAlchemy ORM offers a variety of ways to control the loading
    of columns when entities are loaded.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**列推迟**是指在查询该类型的对象时，ORM 映射的列在 SELECT 语句中被省略的列。 这里的一般原因是性能，在表具有很少使用的列且具有潜在的大数据值的情况下，完全在每次查询时加载这些列可能会耗费时间和/或内存。
    SQLAlchemy ORM 提供了多种控制加载列的方式。'
- en: Most examples in this section are illustrating **ORM loader options**. These
    are small constructs that are passed to the [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method of the [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which are then consumed by the ORM
    when the object is compiled into a SQL string.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的大多数示例都是**ORM 加载器选项**的示例。 这些是小型构造，传递给 [`Select.options()`](../../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") 方法的 [`Select`](../../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象，然后在对象编译为 SQL 字符串时由 ORM 消耗。
- en: '### Using `load_only()` to reduce loaded columns'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `load_only()` 来减少加载的列'
- en: 'The [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") loader
    option is the most expedient option to use when loading objects where it is known
    that only a small handful of columns will be accessed. This option accepts a variable
    number of class-bound attribute objects indicating those column-mapped attributes
    that should be loaded, where all other column-mapped attributes outside of the
    primary key will not be part of the columns fetched . In the example below, the
    `Book` class contains columns `.title`, `.summary` and `.cover_photo`. Using [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") we can instruct the ORM to only load the `.title`
    and `.summary` columns up front:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 加载器选项是在已知只会访问少量列的对象时使用的最快捷的选项。此选项接受一个可变数量的类绑定属性对象，指示应加载的那些列映射属性，其中除主键外的所有其他列映射属性将不会成为被获取的列的一部分。在下面的示例中，`Book`
    类包含列 `.title`、`.summary` 和 `.cover_photo`。使用 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")，我们可以指示 ORM 仅预先加载 `.title` 和 `.summary` 列：'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Above, the SELECT statement has omitted the `.cover_photo` column and included
    only `.title` and `.summary`, as well as the primary key column `.id`; the ORM
    will typically always fetch the primary key columns as these are required to establish
    the identity for the row.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，SELECT 语句省略了 `.cover_photo` 列，并且仅包含了 `.title` 和 `.summary` 列，以及主键列 `.id`；ORM
    通常会始终获取主键列，因为这些列是必需的，用于建立行的标识。
- en: 'Once loaded, the object will normally have [lazy loading](../../glossary.html#term-lazy-loading)
    behavior applied to the remaining unloaded attributes, meaning that when any are
    first accessed, a SQL statement will be emitted within the current transaction
    in order to load the value. Below, accessing `.cover_photo` emits a SELECT statement
    to load its value:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，对象通常会对其余未加载的属性应用[惰性加载](../../glossary.html#term-lazy-loading)行为，这意味着当首次访问任何属性时，将在当前事务中发出
    SQL 语句以加载该值。下面，访问 `.cover_photo` 会发出一个 SELECT 语句来加载其值：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Lazy loads are always emitted using the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to which the object is in the [persistent](../../glossary.html#term-persistent)
    state. If the object is [detached](../../glossary.html#term-detached) from any
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    the operation fails, raising an exception.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性加载始终使用对象处于[持久](../../glossary.html#term-persistent)状态的[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")发出。如果对象已[分离](../../glossary.html#term-detached)于任何[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，操作将失败，引发异常。
- en: As an alternative to lazy loading on access, deferred columns may also be configured
    to raise an informative exception when accessed, regardless of their attachment
    state. When using the [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    construct, this may be indicated using the [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") parameter. See the section [Using raiseload to prevent
    deferred column loads](#orm-queryguide-deferred-raiseload) for background and
    examples.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在访问时惰性加载的替代方案，还可以配置延迟列在访问时引发一个信息性异常，而不考虑它们的附加状态。当使用 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 构造时，可以使用 [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") 参数来指示这一点。有关背景和示例，请参见[使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)部分。
- en: Tip
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: as noted elsewhere, lazy loading is not available when using [Asynchronous I/O
    (asyncio)](../extensions/asyncio.html).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如其他地方所述，在使用[异步 I/O (asyncio)](../extensions/asyncio.html)时，不可用惰性加载。
- en: Using `load_only()` with multiple entities
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `load_only()` 与多个实体
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") limits
    itself to the single entity that is referred towards in its list of attributes
    (passing a list of attributes that span more than a single entity is currently
    disallowed). In the example below, the given [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") option applies only to the `Book` entity. The `User`
    entity that’s also selected is not affected; within the resulting SELECT statement,
    all columns for `user_account` are present, whereas only `book.id` and `book.title`
    are present for the `book` table:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 限制自身仅针对其属性列表中引用的单个实体（目前不允许传递跨越多个实体的属性列表）。在下面的示例中，给定的
    [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 选项仅适用于 `Book`
    实体。也选择的 `User` 实体不受影响；在生成的 SELECT 语句中，`user_account` 的所有列都存在，而 `book` 表只有 `book.id`
    和 `book.title`：'
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we wanted to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    options to both `User` and `Book`, we would make use of two separate options:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    选项应用于 `User` 和 `Book`，我们将使用两个单独的选项：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '#### Using `load_only()` on related objects and collections'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 在相关对象和集合上使用 `load_only()`'
- en: 'When using [relationship loaders](relationships.html) to control the loading
    of related objects, the [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") method of any relationship loader may be used
    to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    rules to columns on the sub-entity. In the example below, [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") is used to load the related `books` collection
    on each `User` object. By applying [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") to the resulting option object, when objects
    are loaded for the relationship, the SELECT emitted will only refer to the `title`
    column in addition to primary key column:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[关系加载器](relationships.html)来控制相关对象的加载时，任何关系加载器的 [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") 方法都可以用于将 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 规则应用于子实体的列。在下面的示例中，使用 [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 来加载每个 `User` 对象上的相关 `books` 集合。通过将 [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") 应用于生成的选项对象，当加载关系的对象时，生成的 SELECT 语句将仅引用 `title`
    列以及主键列：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") may also
    be applied to sub-entities without needing to state the style of loading to use
    for the relationship itself. If we didn’t want to change the default loading style
    of `User.books` but still apply load only rules to `Book`, we would link using
    the [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    option, which in this case will retain the default relationship loading style
    of `"lazy"`, and applying our custom [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") rule to the SELECT statement emitted for each `User.books`
    collection:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 也可以应用于子实体，而无需声明要用于关系本身的加载样式。如果我们不想更改
    `User.books` 的默认加载样式，但仍要对 `Book` 应用仅加载规则，我们将使用 [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") 选项进行链接，在这种情况下，将保留 `"lazy"` 的默认关系加载样式，并将我们的自定义 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 规则应用于为每个 `User.books` 集合发出的 SELECT 语句：'
- en: '[PRE55]  ### Using `defer()` to omit specific columns'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE55]  ### 使用 `defer()` 省略特定列'
- en: 'The [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") loader option
    is a more fine grained alternative to [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only"), which allows a single specific column to be marked
    as “dont load”. In the example below, [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    is applied directly to the `.cover_photo` column, leaving the behavior of all
    other columns unchanged:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 加载选项是对 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 的更精细的替代方案，允许将单个特定列标记为“不加载”。在下面的示例中，[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 直接应用于 `.cover_photo` 列，保持所有其他列的行为不变：'
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As is the case with [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only"),
    unloaded columns by default will load themselves when accessed using [lazy loading](../../glossary.html#term-lazy-loading):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 相同，未加载的列默认情况下将在使用[惰性加载](../../glossary.html#term-lazy-loading)时自行加载：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Multiple [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") options may
    be used in one statement in order to mark several columns as deferred.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一个语句中使用多个 [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 选项来标记多个列为延迟加载。
- en: 'As is the case with [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only"),
    the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") option also includes
    the ability to have a deferred attribute raise an exception on access rather than
    lazy loading. This is illustrated in the section [Using raiseload to prevent deferred
    column loads](#orm-queryguide-deferred-raiseload).  ### Using raiseload to prevent
    deferred column loads'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 相同，[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer") 选项也包括使延迟属性在访问时引发异常而不是惰性加载的功能。这在[使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)一节中进行了说明。###
    使用 raiseload 防止延迟列加载
- en: When using the [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    or [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") loader options, attributes
    marked as deferred on an object have the default behavior that when first accessed,
    a SELECT statement will be emitted within the current transaction in order to
    load their value. It is often necessary to prevent this load from occurring, and
    instead raise an exception when the attribute is accessed, indicating that the
    need to query the database for this column was not expected. A typical scenario
    is an operation where objects are loaded with all the columns that are known to
    be required for the operation to proceed, which are then passed onto a view layer.
    Any further SQL operations that emit within the view layer should be caught, so
    that the up-front loading operation can be adjusted to accommodate for that additional
    data up front, rather than incurring additional lazy loading.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 或
    [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 加载器选项时，对象上标记为延迟的属性具有默认行为，即在首次访问时，将在当前事务中发出
    SELECT 语句以加载其值。通常需要阻止此加载操作，并在访问属性时引发异常，指示不期望为此列查询数据库的需要。典型的情况是加载具有操作所需的所有已知列的对象，然后将它们传递到视图层。视图层中发出的任何进一步的
    SQL 操作都应该被捕获，以便调整前期加载操作以适应那些额外的数据，而不是额外的惰性加载。
- en: 'For this use case the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") options
    include a boolean parameter [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer"), which when set to `True` will cause the affected attributes
    to raise on access. In the example below, the deferred column `.cover_photo` will
    disallow attribute access:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种用例，[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 和 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 选项包括一个布尔参数 [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")，当设置为 `True` 时，将导致受影响的属性在访问时引发异常。在下面的示例中，延迟加载的列 `.cover_photo`
    将禁止属性访问：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When using [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    to name a specific set of non-deferred columns, `raiseload` behavior may be applied
    to the remaining columns using the [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") parameter, which will be applied to all deferred attributes:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 命名一组特定的非延迟加载列时，可以使用
    [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload "sqlalchemy.orm.load_only")
    参数将 `raiseload` 行为应用于其余列，该参数将应用于所有延迟加载属性：
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is not yet possible to mix [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") options which refer
    to the same entity together in one statement in order to change the `raiseload`
    behavior of certain attributes; currently, doing so will produce undefined loading
    behavior of attributes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚不能在一个语句中混合使用指向同一实体的 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    和 [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 选项，以改变某些属性的 `raiseload`
    行为；目前，这样做会产生未定义的属性加载行为。
- en: See also
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'The [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload "sqlalchemy.orm.defer")
    feature is the column-level version of the same “raiseload” feature that’s available
    for relationships. For “raiseload” with relationships, see [Preventing unwanted
    lazy loads using raiseload](relationships.html#prevent-lazy-with-raiseload) in
    the [Relationship Loading Techniques](relationships.html) section of this guide.  ###
    Using `load_only()` to reduce loaded columns'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload "sqlalchemy.orm.defer")
    功能是关系的同一“raiseload”功能的列级版本。有关关系的“raiseload”，请参见本指南的[关系加载技术](relationships.html)部分中的[使用
    `load_only()` 减少加载的列](relationships.html#prevent-lazy-with-raiseload)。'
- en: 'The [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") loader
    option is the most expedient option to use when loading objects where it is known
    that only a small handful of columns will be accessed. This option accepts a variable
    number of class-bound attribute objects indicating those column-mapped attributes
    that should be loaded, where all other column-mapped attributes outside of the
    primary key will not be part of the columns fetched . In the example below, the
    `Book` class contains columns `.title`, `.summary` and `.cover_photo`. Using [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") we can instruct the ORM to only load the `.title`
    and `.summary` columns up front:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当已知只有少数几列将被访问时，[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")加载器选项是最方便的选项。该选项接受一个变量数量的类绑定属性对象，指示应该加载的列映射属性，除了主键之外的所有其他列映射属性都不会成为获取的列的一部分。在下面的示例中，`Book`
    类包含列 `.title`、`.summary` 和 `.cover_photo`。使用[`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")，我们可以指示 ORM 仅预先加载 `.title` 和 `.summary` 列：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Above, the SELECT statement has omitted the `.cover_photo` column and included
    only `.title` and `.summary`, as well as the primary key column `.id`; the ORM
    will typically always fetch the primary key columns as these are required to establish
    the identity for the row.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，SELECT 语句省略了 `.cover_photo` 列，仅包含了 `.title` 和 `.summary`，以及主键列 `.id`；ORM
    通常会获取主键列，因为这些列是必需的，以建立行的标识。
- en: 'Once loaded, the object will normally have [lazy loading](../../glossary.html#term-lazy-loading)
    behavior applied to the remaining unloaded attributes, meaning that when any are
    first accessed, a SQL statement will be emitted within the current transaction
    in order to load the value. Below, accessing `.cover_photo` emits a SELECT statement
    to load its value:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，对象通常将对其余未加载的属性应用[惰性加载](../../glossary.html#term-lazy-loading)行为，这意味着首次访问任何属性时，将在当前事务中发出
    SQL 语句以加载值。下面，访问 `.cover_photo` 会发出一个 SELECT 语句来加载它的值：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Lazy loads are always emitted using the [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to which the object is in the [persistent](../../glossary.html#term-persistent)
    state. If the object is [detached](../../glossary.html#term-detached) from any
    [`Session`](../session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    the operation fails, raising an exception.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性加载始终使用对象所处的处于[持久](../../glossary.html#term-persistent)状态的 [`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 发出。如果对象从任何[`Session`](../session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中[分离](../../glossary.html#term-detached)，操作将失败，引发异常。
- en: As an alternative to lazy loading on access, deferred columns may also be configured
    to raise an informative exception when accessed, regardless of their attachment
    state. When using the [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    construct, this may be indicated using the [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") parameter. See the section [Using raiseload to prevent
    deferred column loads](#orm-queryguide-deferred-raiseload) for background and
    examples.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 作为访问时惰性加载的替代方案，还可以配置延迟列以在访问时引发信息性异常，而不考虑它们的附加状态。在使用[`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")构造时，可以使用[`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only")参数来指示此情况。有关背景和示例，请参阅[使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)部分。
- en: Tip
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: as noted elsewhere, lazy loading is not available when using [Asynchronous I/O
    (asyncio)](../extensions/asyncio.html).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在其他地方所指出的，使用[异步 I/O（asyncio）](../extensions/asyncio.html)时不可用惰性加载。
- en: Using `load_only()` with multiple entities
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `load_only()` 处理多个实体
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") limits
    itself to the single entity that is referred towards in its list of attributes
    (passing a list of attributes that span more than a single entity is currently
    disallowed). In the example below, the given [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") option applies only to the `Book` entity. The `User`
    entity that’s also selected is not affected; within the resulting SELECT statement,
    all columns for `user_account` are present, whereas only `book.id` and `book.title`
    are present for the `book` table:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 限制了其属性列表中所引用的单个实体（当前不允许传递跨越多个实体的属性列表）。在下面的示例中，给定的
    [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 选项仅适用于 `Book`
    实体。被选中的 `User` 实体不受影响；在生成的 SELECT 语句中，`user_account` 的所有列都存在，而 `book` 表只有 `book.id`
    和 `book.title`：'
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we wanted to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    options to both `User` and `Book`, we would make use of two separate options:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要同时将 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    选项应用于 `User` 和 `Book`，我们将使用两个单独的选项：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '#### Using `load_only()` on related objects and collections'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 对相关对象和集合使用 `load_only()`'
- en: 'When using [relationship loaders](relationships.html) to control the loading
    of related objects, the [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") method of any relationship loader may be used
    to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    rules to columns on the sub-entity. In the example below, [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") is used to load the related `books` collection
    on each `User` object. By applying [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") to the resulting option object, when objects
    are loaded for the relationship, the SELECT emitted will only refer to the `title`
    column in addition to primary key column:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [关系加载器](relationships.html) 控制相关对象加载时，任何关系加载器的 [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") 方法都可以用于将 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 规则应用于子实体上的列。在下面的示例中，[`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 用于加载每个 `User` 对象上的相关 `books` 集合。通过将 [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") 应用于结果选项对象，当为关系加载对象时，生成的 SELECT 仅引用 `title` 列以及主键列：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") may also
    be applied to sub-entities without needing to state the style of loading to use
    for the relationship itself. If we didn’t want to change the default loading style
    of `User.books` but still apply load only rules to `Book`, we would link using
    the [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    option, which in this case will retain the default relationship loading style
    of `"lazy"`, and applying our custom [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") rule to the SELECT statement emitted for each `User.books`
    collection:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_only()` 还可以应用于子实体，而无需声明要在关系本身使用的加载样式。如果我们不想改变 `User.books` 的默认加载样式，但仍要对
    `Book` 应用加载规则，我们将使用 [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") 选项进行关联，在这种情况下，将保留默认关系加载样式 `"lazy"`，并将我们的自定义 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 规则应用于为每个 `User.books` 集合发出的 SELECT 语句：'
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using `load_only()` with multiple entities
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `load_only()` 处理多个实体
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") limits
    itself to the single entity that is referred towards in its list of attributes
    (passing a list of attributes that span more than a single entity is currently
    disallowed). In the example below, the given [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") option applies only to the `Book` entity. The `User`
    entity that’s also selected is not affected; within the resulting SELECT statement,
    all columns for `user_account` are present, whereas only `book.id` and `book.title`
    are present for the `book` table:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 限制了其属性列表中所引用的单个实体（当前不允许传递跨越多个实体的属性列表）。在下面的示例中，给定的
    [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 选项仅适用于 `Book`
    实体。被选中的 `User` 实体不受影响；在生成的 SELECT 语句中，`user_account` 的所有列都存在，而 `book` 表只有 `book.id`
    和 `book.title`：'
- en: '[PRE66]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we wanted to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    options to both `User` and `Book`, we would make use of two separate options:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")选项应用于`User`和`Book`，我们将使用两个单独的选项：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '#### Using `load_only()` on related objects and collections'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 在相关对象和集合上使用 `load_only()`'
- en: 'When using [relationship loaders](relationships.html) to control the loading
    of related objects, the [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") method of any relationship loader may be used
    to apply [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    rules to columns on the sub-entity. In the example below, [`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") is used to load the related `books` collection
    on each `User` object. By applying [`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only") to the resulting option object, when objects
    are loaded for the relationship, the SELECT emitted will only refer to the `title`
    column in addition to primary key column:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[关系加载器](relationships.html)来控制相关对象的加载时，可以使用任何关系加载器的[`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only")方法将[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")规则应用于子实体上的列。在下面的示例中，使用[`selectinload()`](relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")加载每个`User`对象上的相关`books`集合。通过将[`Load.load_only()`](relationships.html#sqlalchemy.orm.Load.load_only
    "sqlalchemy.orm.Load.load_only")应用于结果选项对象，当为关系加载对象时，生成的SELECT将仅引用`title`列以及主键列：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") may also
    be applied to sub-entities without needing to state the style of loading to use
    for the relationship itself. If we didn’t want to change the default loading style
    of `User.books` but still apply load only rules to `Book`, we would link using
    the [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload "sqlalchemy.orm.defaultload")
    option, which in this case will retain the default relationship loading style
    of `"lazy"`, and applying our custom [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") rule to the SELECT statement emitted for each `User.books`
    collection:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")也可以应用于子实体，而无需说明用于关系本身的加载样式。如果我们不想更改`User.books`的默认加载样式，但仍要将加载仅规则应用于`Book`，我们将使用[`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")选项进行链接，在这种情况下，将保留默认关系加载样式`"lazy"`，并将我们的自定义[`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")规则应用于为每个`User.books`集合发出的SELECT语句：'
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '### Using `defer()` to omit specific columns'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `defer()` 来省略特定列'
- en: 'The [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") loader option
    is a more fine grained alternative to [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only"), which allows a single specific column to be marked
    as “dont load”. In the example below, [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    is applied directly to the `.cover_photo` column, leaving the behavior of all
    other columns unchanged:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")加载器选项是对[`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only")的更精细的替代，它允许将单个特定列标记为“不加载”。在下面的示例中，直接应用[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")到`.cover_photo`列，保持所有其他列的行为不变：'
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As is the case with [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only"),
    unloaded columns by default will load themselves when accessed using [lazy loading](../../glossary.html#term-lazy-loading):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")一样，默认情况下未加载的列在使用[惰性加载](../../glossary.html#term-lazy-loading)时会自行加载：
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Multiple [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") options may
    be used in one statement in order to mark several columns as deferred.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一条语句中使用多个[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")选项，以将多个列标记为延迟加载。
- en: As is the case with [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only"),
    the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") option also includes
    the ability to have a deferred attribute raise an exception on access rather than
    lazy loading. This is illustrated in the section [Using raiseload to prevent deferred
    column loads](#orm-queryguide-deferred-raiseload).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")一样，[`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项也包括将延迟属性在访问时引发异常而不是惰性加载的能力。这在 [使用raiseload防止延迟列加载](#orm-queryguide-deferred-raiseload)
    部分中有所说明。
- en: '### Using raiseload to prevent deferred column loads'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 raiseload 防止延迟加载列'
- en: When using the [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    or [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") loader options, attributes
    marked as deferred on an object have the default behavior that when first accessed,
    a SELECT statement will be emitted within the current transaction in order to
    load their value. It is often necessary to prevent this load from occurring, and
    instead raise an exception when the attribute is accessed, indicating that the
    need to query the database for this column was not expected. A typical scenario
    is an operation where objects are loaded with all the columns that are known to
    be required for the operation to proceed, which are then passed onto a view layer.
    Any further SQL operations that emit within the view layer should be caught, so
    that the up-front loading operation can be adjusted to accommodate for that additional
    data up front, rather than incurring additional lazy loading.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 或
    [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 加载器选项时，标记为延迟加载的对象属性在首次访问时具有默认行为，即在当前事务中发出
    SELECT 语句以加载其值。通常需要阻止此加载的发生，并在访问属性时引发异常，表示不期望需要查询数据库以获取此列的需求。典型场景是使用已知需要用于操作进行的所有列加载对象，然后将其传递到视图层。应捕获视图层内发出的任何进一步的
    SQL 操作，以便可以调整预先加载的操作以适应该额外的数据，而不是产生额外的惰性加载。
- en: 'For this use case the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") options
    include a boolean parameter [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer"), which when set to `True` will cause the affected attributes
    to raise on access. In the example below, the deferred column `.cover_photo` will
    disallow attribute access:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此用例，[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 和 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 选项包括一个布尔参数 [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")，当设置为 `True` 时，将导致受影响的属性在访问时引发异常。在下面的示例中，延迟列 `.cover_photo`
    将禁止属性访问：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When using [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    to name a specific set of non-deferred columns, `raiseload` behavior may be applied
    to the remaining columns using the [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload
    "sqlalchemy.orm.load_only") parameter, which will be applied to all deferred attributes:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") 命名一组特定的非延迟加载列时，可以使用
    [`load_only.raiseload`](#sqlalchemy.orm.load_only.params.raiseload "sqlalchemy.orm.load_only")
    参数将 `raiseload` 行为应用于其余列，该参数将应用于所有延迟加载的属性：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is not yet possible to mix [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    and [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") options which refer
    to the same entity together in one statement in order to change the `raiseload`
    behavior of certain attributes; currently, doing so will produce undefined loading
    behavior of attributes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还不能混合使用 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    和 [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 选项，这两个选项指向同一个实体，在一个语句中改变某些属性的
    `raiseload` 行为；目前这样做会产生未定义的属性加载行为。
- en: See also
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The [`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload "sqlalchemy.orm.defer")
    feature is the column-level version of the same “raiseload” feature that’s available
    for relationships. For “raiseload” with relationships, see [Preventing unwanted
    lazy loads using raiseload](relationships.html#prevent-lazy-with-raiseload) in
    the [Relationship Loading Techniques](relationships.html) section of this guide.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer.raiseload`](#sqlalchemy.orm.defer.params.raiseload "sqlalchemy.orm.defer")
    特性是与关系对应的相同“raiseload”特性的列级版本。有关关系的“raiseload”，请参见[防止不必要的惰性加载使用 raiseload](relationships.html#prevent-lazy-with-raiseload)
    在本指南的[关系加载技术](relationships.html)部分。'
- en: '## Configuring Column Deferral on Mappings'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '## 配置映射上的列延迟'
- en: 'The functionality of [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    is available as a default behavior for mapped columns, as may be appropriate for
    columns that should not be loaded unconditionally on every query. To configure,
    use the [`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") parameter of [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"). The example below illustrates a mapping for `Book`
    which applies default column deferral to the `summary` and `cover_photo` columns:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 的功能作为映射列的默认行为可用，适用于不应在每次查询时无条件加载的列。要配置，请使用
    [`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column.params.deferred") 参数。下面的示例说明了对 `Book` 应用默认列延迟加载的映射：'
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Using the above mapping, queries against `Book` will automatically not include
    the `summary` and `cover_photo` columns:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，对 `Book` 的查询将自动不包括 `summary` 和 `cover_photo` 列：
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As is the case with all deferral, the default behavior when deferred attributes
    on the loaded object are first accessed is that they will [lazy load](../../glossary.html#term-lazy-load)
    their value:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有延迟加载属性一样，当首次访问加载的对象上的延迟加载属性时，默认行为是它们将 [延迟加载](../../glossary.html#term-lazy-load)
    它们的值：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As is the case with the [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only") loader
    options, mapper level deferral also includes an option for `raiseload` behavior
    to occur, rather than lazy loading, when no other options are present in a statement.
    This allows a mapping where certain columns will not load by default and will
    also never load lazily without explicit directives used in a statement. See the
    section [Configuring mapper-level “raiseload” behavior](#orm-queryguide-mapper-deferred-raiseload)
    for background on how to configure and use this behavior.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer") 和 [`load_only()`](#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only") 加载器选项一样，映射器级别的延迟还包括一个选项，即当语句中没有其他选项时，可以发生 `raiseload`
    行为，而不是延迟加载。这允许某些列不会默认加载，并且也永远不会在语句中使用显式指令时延迟加载。请参阅 [配置映射器级别的“raiseload”行为](#orm-queryguide-mapper-deferred-raiseload)
    部分，了解如何配置和使用此行为的背景信息。
- en: '### Using `deferred()` for imperative mappers, mapped SQL expressions'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `deferred()` 来命令式映射，映射 SQL 表达式'
- en: The [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") function
    is the earlier, more general purpose “deferred column” mapping directive that
    precedes the introduction of the [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct in SQLAlchemy.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") 函数是早期的、更通用的“延迟列”映射指令，在引入
    SQLAlchemy 的 [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造之前就存在。'
- en: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") is used
    when configuring ORM mappers, and accepts arbitrary SQL expressions or [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects. As such it’s suitable to be used with non-declarative
    [imperative mappings](../mapping_styles.html#orm-imperative-mapping), passing
    it to the [`map_imperatively.properties`](../mapping_api.html#sqlalchemy.orm.registry.map_imperatively.params.properties
    "sqlalchemy.orm.registry.map_imperatively") dictionary:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") 在配置 ORM
    映射器时使用，接受任意的 SQL 表达式或 [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象。因此，它适用于非声明性 [命令式映射](../mapping_styles.html#orm-imperative-mapping)，将其传递给
    [`map_imperatively.properties`](../mapping_api.html#sqlalchemy.orm.registry.map_imperatively.params.properties
    "sqlalchemy.orm.registry.map_imperatively") 字典：'
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") may also
    be used in place of [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") when mapped SQL expressions should be loaded
    on a deferred basis:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射的 SQL 表达式应该在延迟加载时，可以使用 [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")
    代替 [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")：
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: See also
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using column_property](../mapped_sql_expr.html#mapper-column-property-sql-expressions)
    - in the section [SQL Expressions as Mapped Attributes](../mapped_sql_expr.html#mapper-sql-expressions)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 column_property](../mapped_sql_expr.html#mapper-column-property-sql-expressions)
    - 在 [SQL 表达式作为映射属性](../mapped_sql_expr.html#mapper-sql-expressions) 部分'
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](../declarative_tables.html#orm-imperative-table-column-options)
    - in the section [Table Configuration with Declarative](../declarative_tables.html)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[对声明性表列应用加载、持久性和映射选项](../declarative_tables.html#orm-imperative-table-column-options)
    - 在[使用声明性进行表配置](../declarative_tables.html)章节中'
- en: Using `undefer()` to “eagerly” load deferred columns
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`undefer()`来“急切地”加载延迟列
- en: 'With columns configured on mappings to defer by default, the [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") option will cause any column that is normally deferred
    to be undeferred, that is, to load up front with all the other columns of the
    mapping. For example we may apply [`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    to the `Book.summary` column, which is indicated in the previous mapping as deferred:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认配置为延迟的映射上的列，[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")选项将导致任何通常延迟的列都会在前端加载，也就是说，与映射的所有其他列一起加载。例如，我们可以对前面映射中标记为延迟的`Book.summary`列应用[`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `Book.summary` column was now eagerly loaded, and may be accessed without
    additional SQL being emitted:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book.summary`列现在已经被急切加载，并且可以在不发出额外SQL的情况下访问：'
- en: '[PRE80]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '### Loading deferred columns in groups'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '### 按组加载延迟列'
- en: 'Normally when a column is mapped with `mapped_column(deferred=True)`, when
    the deferred attribute is accessed on an object, SQL will be emitted to load only
    that specific column and no others, even if the mapping has other columns that
    are also marked as deferred. In the common case that the deferred attribute is
    part of a group of attributes that should all load at once, rather than emitting
    SQL for each attribute individually, the [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") parameter may be used, which accepts an arbitrary
    string which will define a common group of columns to be undeferred:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个列使用`mapped_column(deferred=True)`进行映射时，当在对象上访问延迟属性时，SQL将被发出以仅加载该特定列，而不加载其他列，即使映射还有其他被标记为延迟的列也是如此。在延迟属性是应该一次性加载一组属性的情况下，而不是针对每个属性单独发出SQL时，可以使用[`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column")参数，它接受一个任意字符串，用于定义要取消延迟的列的通用组：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Using the above mapping, accessing either `summary` or `cover_photo` will load
    both columns at once using just one SELECT statement:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，访问`summary`或`cover_photo`将同时使用一个SELECT语句加载两个列：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Undeferring by group with `undefer_group()`
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`undefer_group()`按组取消延迟
- en: 'If deferred columns are configured with [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") as introduced in the preceding section, the entire
    group may be indicated to load eagerly using the [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group") option, passing the string name of the group to
    be eagerly loaded:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟列配置为使用前一节中引入的[`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column")，则可以使用[`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group")选项来急切加载整个组，传递要急切加载的组的字符串名称：
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Both `summary` and `cover_photo` are available without additional loads:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary`和`cover_photo`都可以在不进行额外加载的情况下使用：'
- en: '[PRE84]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Undeferring on wildcards
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通配符上的取消延迟
- en: 'Most ORM loader options accept a wildcard expression, indicated by `"*"`, which
    indicates that the option should be applied to all relevant attributes. If a mapping
    has a series of deferred columns, all such columns can be undeferred at once,
    without using a group name, by indicating a wildcard:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数ORM加载器选项都接受通配符表达式，用`"*"`表示，表示该选项应用于所有相关属性。如果一个映射具有一系列延迟列，那么所有这些列都可以一次性进行取消延迟，而不需要使用组名，只需指定通配符即可：
- en: '[PRE85]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '### Configuring mapper-level “raiseload” behavior'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '### 配置映射级别的“raiseload”行为'
- en: 'The “raiseload” behavior first introduced at [Using raiseload to prevent deferred
    column loads](#orm-queryguide-deferred-raiseload) may also be applied as a default
    mapper-level behavior, using the [`mapped_column.deferred_raiseload`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_raiseload
    "sqlalchemy.orm.mapped_column") parameter of [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"). When using this parameter, the affected columns
    will raise on access in all cases unless explicitly “undeferred” using [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    at query time:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首次引入的“raiseload”行为可用于 [使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)，还可以作为默认的映射器级行为应用，使用
    [`mapped_column.deferred_raiseload`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_raiseload
    "sqlalchemy.orm.mapped_column") 参数传递给 [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。使用此参数时，受影响的列将在所有情况下访问时引发异常，除非在查询时显式“未延迟”使用 [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") 或 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")：
- en: '[PRE86]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using the above mapping, the `.summary` and `.cover_photo` columns are by default
    not loadable:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以上映射，`.summary` 和 `.cover_photo` 列默认情况下不可加载：
- en: '[PRE87]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Only by overriding their behavior at query time, typically using [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group"), or less commonly [`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), may the attributes be loaded. The example below applies
    `undefer(''*'')` to undefer all attributes, also making use of [Populate Existing](api.html#orm-queryguide-populate-existing)
    to refresh the already-loaded object’s loader options:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在查询时覆盖它们的行为，通常使用 [`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    或 [`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")，或者较少使用
    [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")，属性才能被加载。下面的示例将 `undefer('*')`
    应用于取消延迟所有属性，还使用了[填充现有](api.html#orm-queryguide-populate-existing)以刷新已加载对象的加载器选项：
- en: '[PRE88]  ### Using `deferred()` for imperative mappers, mapped SQL expressions'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE88]  ### 使用 `deferred()` 进行命令式映射，映射的 SQL 表达式'
- en: The [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") function
    is the earlier, more general purpose “deferred column” mapping directive that
    precedes the introduction of the [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct in SQLAlchemy.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") 函数是早期的、更通用的“延迟列”映射指令，它在引入
    [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造之前就存在于 SQLAlchemy 中。'
- en: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") is used
    when configuring ORM mappers, and accepts arbitrary SQL expressions or [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects. As such it’s suitable to be used with non-declarative
    [imperative mappings](../mapping_styles.html#orm-imperative-mapping), passing
    it to the [`map_imperatively.properties`](../mapping_api.html#sqlalchemy.orm.registry.map_imperatively.params.properties
    "sqlalchemy.orm.registry.map_imperatively") dictionary:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 ORM 映射器时使用 [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")，它接受任意的
    SQL 表达式或 [`Column`](../../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象。因此，它适用于非声明式的[命令式映射](../mapping_styles.html#orm-imperative-mapping)，可以将其传递给
    [`map_imperatively.properties`](../mapping_api.html#sqlalchemy.orm.registry.map_imperatively.params.properties
    "sqlalchemy.orm.registry.map_imperatively") 字典：
- en: '[PRE89]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred") may also
    be used in place of [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") when mapped SQL expressions should be loaded
    on a deferred basis:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当映射的 SQL 表达式应该以延迟方式加载时，也可以使用 [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")
    替代 [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")：
- en: '[PRE90]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: See also
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Using column_property](../mapped_sql_expr.html#mapper-column-property-sql-expressions)
    - in the section [SQL Expressions as Mapped Attributes](../mapped_sql_expr.html#mapper-sql-expressions)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 column_property](../mapped_sql_expr.html#mapper-column-property-sql-expressions)
    - 在 [SQL 表达式作为映射属性](../mapped_sql_expr.html#mapper-sql-expressions) 部分中'
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](../declarative_tables.html#orm-imperative-table-column-options)
    - in the section [Table Configuration with Declarative](../declarative_tables.html)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用 Imperative 表列的加载、持久化和映射选项](../declarative_tables.html#orm-imperative-table-column-options)
    - 在 [声明式表配置](../declarative_tables.html) 部分中'
- en: Using `undefer()` to “eagerly” load deferred columns
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`undefer()`“急切”加载延迟列
- en: 'With columns configured on mappings to defer by default, the [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") option will cause any column that is normally deferred
    to be undeferred, that is, to load up front with all the other columns of the
    mapping. For example we may apply [`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    to the `Book.summary` column, which is indicated in the previous mapping as deferred:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认延迟列配置的映射上的列，[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")选项将导致通常延迟的任何列被解除延迟，即，与映射的所有其他列一起前端加载。例如，我们可以将[`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")应用于前一映射中指定为延迟的`Book.summary`列：
- en: '[PRE91]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `Book.summary` column was now eagerly loaded, and may be accessed without
    additional SQL being emitted:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book.summary`列现在已经被急切加载，可以在不发出额外 SQL 的情况下访问：'
- en: '[PRE92]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '### Loading deferred columns in groups'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '### 按组加载延迟列'
- en: 'Normally when a column is mapped with `mapped_column(deferred=True)`, when
    the deferred attribute is accessed on an object, SQL will be emitted to load only
    that specific column and no others, even if the mapping has other columns that
    are also marked as deferred. In the common case that the deferred attribute is
    part of a group of attributes that should all load at once, rather than emitting
    SQL for each attribute individually, the [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") parameter may be used, which accepts an arbitrary
    string which will define a common group of columns to be undeferred:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当列被映射为`mapped_column(deferred=True)`时，当在对象上访问延迟属性时，将发出 SQL 仅加载该特定列，而不加载其他列，即使映射还有其他列也被标记为延迟。在常见情况下，延迟属性是一组应该同时加载的属性的一部分时，而不是为每个属性单独发出
    SQL，可以使用[`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column")参数，该参数接受一个任意字符串，该字符串将定义一个通用列组以解除延迟：
- en: '[PRE93]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Using the above mapping, accessing either `summary` or `cover_photo` will load
    both columns at once using just one SELECT statement:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，访问`summary`或`cover_photo`将一次性使用一个 SELECT 语句加载两个列：
- en: '[PRE94]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Undeferring by group with `undefer_group()`
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`undefer_group()`按组解除延迟
- en: 'If deferred columns are configured with [`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column") as introduced in the preceding section, the entire
    group may be indicated to load eagerly using the [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group") option, passing the string name of the group to
    be eagerly loaded:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟列配置为[`mapped_column.deferred_group`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_group
    "sqlalchemy.orm.mapped_column")，如前一节介绍的，可以通过指定要急切加载的组的字符串名称来指示整个组的加载：
- en: '[PRE95]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Both `summary` and `cover_photo` are available without additional loads:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary`和`cover_photo`都可用，无需额外加载：'
- en: '[PRE96]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Undeferring on wildcards
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通配符解除延迟加载
- en: 'Most ORM loader options accept a wildcard expression, indicated by `"*"`, which
    indicates that the option should be applied to all relevant attributes. If a mapping
    has a series of deferred columns, all such columns can be undeferred at once,
    without using a group name, by indicating a wildcard:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 ORM 加载器选项都接受通配符表达式，由 `"*"` 表示，表示该选项应用于所有相关属性。如果映射具有一系列延迟列，则可以通过指定通配符一次性解除所有这些列的延迟，而无需使用组名：
- en: '[PRE97]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '### Configuring mapper-level “raiseload” behavior'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '### 配置映射器级别的“raiseload”行为'
- en: 'The “raiseload” behavior first introduced at [Using raiseload to prevent deferred
    column loads](#orm-queryguide-deferred-raiseload) may also be applied as a default
    mapper-level behavior, using the [`mapped_column.deferred_raiseload`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_raiseload
    "sqlalchemy.orm.mapped_column") parameter of [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"). When using this parameter, the affected columns
    will raise on access in all cases unless explicitly “undeferred” using [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    at query time:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: “raiseload” 行为最初是在[使用 raiseload 防止延迟列加载](#orm-queryguide-deferred-raiseload)中介绍的，也可以作为默认的映射器级行为应用，使用
    [`mapped_column.deferred_raiseload`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred_raiseload
    "sqlalchemy.orm.mapped_column") 参数的 [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。当使用此参数时，受影响的列将在所有情况下在访问时引发异常，除非在查询时显式地使用 [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") 或 [`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")
    进行“取消延迟”：
- en: '[PRE98]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Using the above mapping, the `.summary` and `.cover_photo` columns are by default
    not loadable:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述映射，`.summary` 和 `.cover_photo` 列默认情况下不可加载：
- en: '[PRE99]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Only by overriding their behavior at query time, typically using [`undefer()`](#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or [`undefer_group()`](#sqlalchemy.orm.undefer_group
    "sqlalchemy.orm.undefer_group"), or less commonly [`defer()`](#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"), may the attributes be loaded. The example below applies
    `undefer(''*'')` to undefer all attributes, also making use of [Populate Existing](api.html#orm-queryguide-populate-existing)
    to refresh the already-loaded object’s loader options:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过在查询时覆盖它们的行为，通常使用 [`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    或 [`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")，或者较少使用
    [`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")，属性才能被加载。下面的示例将 `undefer('*')`
    应用于取消延迟加载所有属性，同时还利用[填充现有对象](api.html#orm-queryguide-populate-existing)来刷新已加载对象的加载器选项：
- en: '[PRE100]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '## Loading Arbitrary SQL Expressions onto Objects'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '## 加载任意 SQL 表达式到对象上'
- en: 'As discussed [Selecting ORM Entities and Attributes](select.html#orm-queryguide-select-columns)
    and elsewhere, the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct may be used to load arbitrary SQL
    expressions in a result set. Such as if we wanted to issue a query that loads
    `User` objects, but also includes a count of how many books each `User` owned,
    we could use `func.count(Book.id)` to add a “count” column to a query which includes
    a JOIN to `Book` as well as a GROUP BY owner id. This will yield [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects that each contain two entries, one for `User`
    and one for `func.count(Book.id)`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[选择 ORM 实体和属性](select.html#orm-queryguide-select-columns)和其他地方讨论的，[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造可以用于在结果集中加载任意 SQL 表达式。例如，如果我们想要发出一个查询，加载
    `User` 对象，但还包括每个 `User` 拥有多少书籍的计数，我们可以使用 `func.count(Book.id)` 来向查询中添加一个“计数”列，该查询包括与
    `Book` 的 JOIN 以及按所有者 id 分组。这将产生包含两个条目的 [`Row`](../../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象，一个是 `User`，另一个是 `func.count(Book.id)`：
- en: '[PRE101]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the above example, the `User` entity and the “book count” SQL expression
    are returned separately. However, a popular use case is to produce a query that
    will yield `User` objects alone, which can be iterated for example using [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"), where the result of the `func.count(Book.id)`
    SQL expression is applied *dynamically* to each `User` entity. The end result
    would be similar to the case where an arbitrary SQL expression were mapped to
    the class using [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"), except that the SQL expression can be modified
    at query time. For this use case SQLAlchemy provides the [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option, which when combined with the
    mapper level [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    directive may produce this result.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`User` 实体和 “书籍数量” SQL 表达式是分开返回的。然而，一个常见的用例是生成一个查询，该查询仅返回 `User` 对象，例如可以使用
    [`Session.scalars()`](../session_api.html#sqlalchemy.orm.Session.scalars "sqlalchemy.orm.Session.scalars")
    进行迭代，其中 `func.count(Book.id)` SQL 表达式的结果被 *动态* 应用于每个 `User` 实体。最终结果将类似于使用 [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 将任意 SQL 表达式映射到类的情况，只不过 SQL 表达式可以在查询时修改。对于这种用例，SQLAlchemy
    提供了 [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    加载器选项，当与映射器级别的 [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    指令结合使用时，可能会产生此结果。
- en: 'To apply [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    to a query, the mapped class must have pre-configured an ORM mapped attribute
    using the [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    directive; this directive will produce an attribute on the mapped class that is
    suitable for receiving query-time SQL expressions. Below we add a new attribute
    `User.book_count` to `User`. This ORM mapped attribute is read-only and has no
    default value; accessing it on a loaded instance will normally produce `None`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    应用于查询，映射类必须预先使用 [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    指令配置好一个 ORM 映射属性；此指令将在映射类上生成一个适合接收查询时 SQL 表达式的属性。下面我们向 `User` 添加一个新属性 `User.book_count`。这个
    ORM 映射属性是只读的，没有默认值；在加载的实例上访问它通常会返回 `None`：
- en: '[PRE102]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'With the `User.book_count` attribute configured in our mapping, we may populate
    it with data from a SQL expression using the [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option to apply a custom SQL expression
    to each `User` object as it’s loaded:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的映射中配置了 `User.book_count` 属性后，我们可以使用 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 加载器选项从 SQL 表达式中填充数据，以便在加载每个 `User` 对象时应用自定义
    SQL 表达式：
- en: '[PRE103]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Above, we moved our `func.count(Book.id)` expression out of the columns argument
    of the [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct and into the [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") loader option. The ORM then considers this to
    be a special column load option that’s applied dynamically to the statement.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们将我们的 `func.count(Book.id)` 表达式从 [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造函数的 columns 参数中移出，并将其放入 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 加载器选项中。ORM 然后将其视为一个特殊的列加载选项，该选项动态应用于语句。
- en: 'The [`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    mapping has these caveats:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[`query_expression()`](#sqlalchemy.orm.query_expression "sqlalchemy.orm.query_expression")
    映射有以下注意事项：'
- en: On an object where [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    were not used to populate the attribute, the attribute on an object instance will
    have the value `None`, unless on the mapping the [`query_expression.default_expr`](#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") parameter is set to a default SQL expression.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个对象上，如果没有使用 [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    来填充属性，对象实例上的属性将具有值 `None`，除非在映射上设置了 [`query_expression.default_expr`](#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") 参数为默认 SQL 表达式。
- en: 'The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    value **does not populate on an object that is already loaded**, unless [Populate
    Existing](api.html#orm-queryguide-populate-existing) is used. The example below
    will **not work**, as the `A` object is already loaded:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    值**不会填充已加载的对象**，除非使用 [Populate Existing](api.html#orm-queryguide-populate-existing)。如下示例**不会起作用**，因为
    `A` 对象已经加载：'
- en: '[PRE104]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To ensure the attribute is re-loaded on an existing object, use the [Populate
    Existing](api.html#orm-queryguide-populate-existing) execution option to ensure
    all columns are re-populated:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要确保属性在现有对象上重新加载，请使用[Populate Existing](api.html#orm-queryguide-populate-existing)
    执行选项以确保重新填充所有列：
- en: '[PRE105]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    SQL expression **is lost when the object is expired**. Once the object is expired,
    either via [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") or via the expire_on_commit behavior of [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the SQL expression and its value is no longer
    associated with the attribute and will return `None` on subsequent access.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象过期时，[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    SQL 表达式**会丢失**。一旦对象过期，无论是通过 [`Session.expire()`](../session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 还是通过 [`Session.commit()`](../session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 的 expire_on_commit 行为，SQL 表达式及其值将不再与属性关联，并且在后续访问时将返回
    `None`。
- en: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression"),
    as an object loading option, only takes effect on the **outermost part of a query**
    and only for a query against a full entity, and not for arbitrary column selects,
    within subqueries, or the elements of a compound statement such as a UNION. See
    the next section [Using with_expression() with UNIONs, other subqueries](#orm-queryguide-with-expression-unions)
    for an example.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    作为对象加载选项，只对查询的最外层部分生效，并且仅适用于对完整实体进行的查询，而不适用于子查询中的任意列选择或复合语句（如 UNION）的元素。请参阅下一节[使用
    `with_expression()` 与 UNIONs、其他子查询](#orm-queryguide-with-expression-unions)中的示例。'
- en: 'The mapped attribute **cannot** be applied to other parts of the query, such
    as the WHERE clause, the ORDER BY clause, and make use of the ad-hoc expression;
    that is, this won’t work:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射属性**无法**应用于查询的其他部分，例如 WHERE 子句、ORDER BY 子句，并利用临时表达式；也就是说，以下方式行不通：
- en: '[PRE106]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `A.expr` expression will resolve to NULL in the above WHERE clause and
    ORDER BY clause. To use the expression throughout the query, assign to a variable
    and use that:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述的 WHERE 子句和 ORDER BY 子句中，`A.expr` 表达式将会解析为 NULL。要在整个查询中使用该表达式，请将其赋值给一个变量并使用它：
- en: '[PRE107]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: See also
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    option is a special option used to apply SQL expressions to mapped classes dynamically
    at query time. For ordinary fixed SQL expressions configured on mappers, see the
    section [SQL Expressions as Mapped Attributes](../mapped_sql_expr.html#mapper-sql-expressions).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    选项是一种特殊选项，用于在查询时动态地将 SQL 表达式应用于映射类。对于在映射器上配置的普通固定 SQL 表达式，请参阅[作为映射属性的 SQL 表达式](../mapped_sql_expr.html#mapper-sql-expressions)部分。'
- en: '### Using `with_expression()` with UNIONs, other subqueries'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `with_expression()` 与 UNIONs、其他子查询'
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    construct is an ORM loader option, and as such may only be applied to the outermost
    level of a SELECT statement which is to load a particular ORM entity. It does
    not have any effect if used inside of a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") that will then be used as a subquery or as
    an element within a compound statement such as a UNION.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    构造是一个 ORM 加载器选项，因此只能应用于用于加载特定 ORM 实体的 SELECT 语句的最外层级别。如果在后续用作子查询或复合语句（如 UNION）中使用，它将不起作用。'
- en: In order to use arbitrary SQL expressions in subqueries, normal Core-style means
    of adding expressions should be used. To assemble a subquery-derived expression
    onto the ORM entity’s [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") attributes, [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") is used at the top layer of ORM object loading,
    referencing the SQL expression within the subquery.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在子查询中使用任意的 SQL 表达式，应该使用正常的 Core 风格添加表达式的方法。要将子查询派生的表达式组装到 ORM 实体的[`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression")属性上，需要在 ORM 对象加载的顶层使用[`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")，引用子查询中的 SQL 表达式。
- en: 'In the example below, two [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are used against the ORM entity
    `A` with an additional SQL expression labeled in `expr`, and combined using [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"). Then, at the topmost layer, the `A` entity
    is SELECTed from this UNION, using the querying technique described at [Selecting
    Entities from UNIONs and other set operations](select.html#orm-queryguide-unions),
    adding an option with [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    to extract this SQL expression onto newly loaded instances of `A`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，针对 ORM 实体 `A` 使用了两个[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造，其中包含一个标记为 `expr` 的额外 SQL 表达式，并使用[`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all") 进行组合。然后，在最顶层，从这个 UNION 中选择了 `A` 实体，使用了在[从
    UNIONs 和其他集合操作中选择实体](select.html#orm-queryguide-unions)中描述的查询技术，添加了一个使用[`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")的选项，以将这个 SQL 表达式提取到新加载的 `A` 实例中：
- en: '[PRE108]  ### Using `with_expression()` with UNIONs, other subqueries'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE108]  ### 使用 `with_expression()` 与 UNIONs，其他子查询'
- en: The [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    construct is an ORM loader option, and as such may only be applied to the outermost
    level of a SELECT statement which is to load a particular ORM entity. It does
    not have any effect if used inside of a [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") that will then be used as a subquery or as
    an element within a compound statement such as a UNION.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    构造是一个 ORM 加载器选项，因此只能应用于要加载特定 ORM 实体的 SELECT 语句的最外层级别。如果在将用作子查询或作为联合等复合语句中的元素的[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")内部使用，则不会产生任何效果。'
- en: In order to use arbitrary SQL expressions in subqueries, normal Core-style means
    of adding expressions should be used. To assemble a subquery-derived expression
    onto the ORM entity’s [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") attributes, [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") is used at the top layer of ORM object loading,
    referencing the SQL expression within the subquery.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在子查询中使用任意的 SQL 表达式，应该使用正常的 Core 风格添加表达式的方法。要将子查询派生的表达式组装到 ORM 实体的[`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression")属性上，需要在 ORM 对象加载的顶层使用[`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")，引用子查询中的 SQL 表达式。
- en: 'In the example below, two [`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs are used against the ORM entity
    `A` with an additional SQL expression labeled in `expr`, and combined using [`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all"). Then, at the topmost layer, the `A` entity
    is SELECTed from this UNION, using the querying technique described at [Selecting
    Entities from UNIONs and other set operations](select.html#orm-queryguide-unions),
    adding an option with [`with_expression()`](#sqlalchemy.orm.with_expression "sqlalchemy.orm.with_expression")
    to extract this SQL expression onto newly loaded instances of `A`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用两个[`select()`](../../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造针对 ORM 实体 `A`，并在`expr`中标记了一个额外的 SQL 表达式，并使用[`union_all()`](../../core/selectable.html#sqlalchemy.sql.expression.union_all
    "sqlalchemy.sql.expression.union_all")将它们组合起来。然后，在最顶层，使用查询技术描述的 [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")从这个 UNION 中选择 `A` 实体，以将此 SQL 表达式提取到新加载的 `A` 实例上：
- en: '[PRE109]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Column Loading API
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列加载 API
- en: '| Object Name | Description |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [defer](#sqlalchemy.orm.defer)(key, *addl_attrs, [raiseload]) | Indicate
    that the given column-oriented attribute should be deferred, e.g. not loaded until
    accessed. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| [defer](#sqlalchemy.orm.defer)(key, *addl_attrs, [raiseload]) | 指示给定的面向列的属性应该延迟加载，例如在访问之前不加载。
    |'
- en: '| [deferred](#sqlalchemy.orm.deferred)(column, *additional_columns, [group,
    raiseload, comparator_factory, init, repr, default, default_factory, compare,
    kw_only, active_history, expire_on_flush, info, doc]) | Indicate a column-based
    mapped attribute that by default will not load unless accessed. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| [deferred](#sqlalchemy.orm.deferred)(column, *additional_columns, [group,
    raiseload, comparator_factory, init, repr, default, default_factory, compare,
    kw_only, active_history, expire_on_flush, info, doc]) | 表示默认情况下不加载的基于列的映射属性。 |'
- en: '| [load_only](#sqlalchemy.orm.load_only)(*attrs, [raiseload]) | Indicate that
    for a particular entity, only the given list of column-based attribute names should
    be loaded; all others will be deferred. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| [load_only](#sqlalchemy.orm.load_only)(*attrs, [raiseload]) | 表示对于特定实体，只应加载给定列表的基于列的属性名称；所有其他属性都将被延迟加载。
    |'
- en: '| [query_expression](#sqlalchemy.orm.query_expression)([default_expr], *, [repr,
    compare, expire_on_flush, info, doc]) | Indicate an attribute that populates from
    a query-time SQL expression. |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| [query_expression](#sqlalchemy.orm.query_expression)([default_expr], *, [repr,
    compare, expire_on_flush, info, doc]) | 表示从查询时 SQL 表达式填充的属性。 |'
- en: '| [undefer](#sqlalchemy.orm.undefer)(key, *addl_attrs) | Indicate that the
    given column-oriented attribute should be undeferred, e.g. specified within the
    SELECT statement of the entity as a whole. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| [undefer](#sqlalchemy.orm.undefer)(key, *addl_attrs) | 指示给定的面向列的属性应该取消延迟加载，例如在整个实体的
    SELECT 语句中指定。 |'
- en: '| [undefer_group](#sqlalchemy.orm.undefer_group)(name) | Indicate that columns
    within the given deferred group name should be undeferred. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| [undefer_group](#sqlalchemy.orm.undefer_group)(name) | 表示给定延迟组名内的列应该取消延迟加载。
    |'
- en: '| [with_expression](#sqlalchemy.orm.with_expression)(key, expression) | Apply
    an ad-hoc SQL expression to a “deferred expression” attribute. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| [with_expression](#sqlalchemy.orm.with_expression)(key, expression) | 将特定的
    SQL 表达式应用于“延迟表达式”属性。 |'
- en: '[PRE110]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Indicate that the given column-oriented attribute should be deferred, e.g. not
    loaded until accessed.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 指示给定的面向列的属性应该延迟加载，例如在访问之前不加载。
- en: This function is part of the [`Load`](relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") interface and supports both method-chained and standalone
    operation.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链和独立操作。
- en: 'e.g.:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE111]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'To specify a deferred load of an attribute on a related class, the path can
    be specified one token at a time, specifying the loading style for each link along
    the chain. To leave the loading style for a link unchanged, use [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload"):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定相关类上属性的延迟加载，可以逐个指定路径，沿着链指定每个链接的加载样式。要保持链接的加载样式不变，请使用[`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload")：
- en: '[PRE112]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Multiple deferral options related to a relationship can be bundled at once
    using [`Load.options()`](relationships.html#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options"):'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Load.options()`](relationships.html#sqlalchemy.orm.Load.options "sqlalchemy.orm.Load.options")一次捆绑多个与关系相关的延迟选项。
- en: '[PRE113]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Parameters:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`key` – Attribute to be deferred.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` – 要延迟加载的属性。'
- en: '`raiseload` – raise [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") rather than lazy loading a value when the
    deferred attribute is accessed. Used to prevent unwanted SQL from being emitted.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` – 当访问延迟属性时引发[`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError")而不是惰性加载值。用于防止发出不必要的SQL。'
- en: New in version 1.4.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.4中的新功能。
- en: See also
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制使用列延迟加载](#orm-queryguide-column-deferral) - 在[ORM查询指南](index.html)中'
- en: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[`load_only()`](#sqlalchemy.orm.load_only "sqlalchemy.orm.load_only")'
- en: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
- en: '[PRE114]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Indicate a column-based mapped attribute that by default will not load unless
    accessed.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 指示一个基于列的映射属性，默认情况下不会加载，除非访问。
- en: When using [`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), the same functionality as that of [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") construct is provided by using the [`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") parameter.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`mapped_column()`](../mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")时，通过使用[`mapped_column.deferred`](../mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column")参数，提供了与[`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")构造相同的功能。
- en: 'Parameters:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`*columns` – columns to be mapped. This is typically a single [`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, however a collection is supported in order
    to support multiple columns mapped under the same attribute.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*columns` – 要映射的列。通常是单个[`Column`](../../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，但为了支持在同一属性下映射多个列，也支持集合。'
- en: '`raiseload` –'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` –'
- en: boolean, if True, indicates an exception should be raised if the load operation
    is to take place.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: boolean，如果为True，则表示在执行加载操作时应引发异常。
- en: New in version 1.4.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 版本1.4中的新功能。
- en: Additional arguments are the same as that of [`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property").
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数与[`column_property()`](../mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")相同。
- en: See also
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using deferred() for imperative mappers, mapped SQL expressions](#orm-queryguide-deferred-imperative)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用deferred()为命令式映射器、映射的SQL表达式](#orm-queryguide-deferred-imperative)'
- en: '[PRE115]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Indicate an attribute that populates from a query-time SQL expression.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 指示从查询时SQL表达式填充的属性。
- en: 'Parameters:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**default_expr** – Optional SQL expression object that will be used in all
    cases if not assigned later with [`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression").'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**default_expr** – 可选的SQL表达式对象，如果未使用[`with_expression()`](#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")分配，则将在所有情况下使用。'
- en: New in version 1.2.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.2中的新功能。
- en: See also
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Loading Arbitrary SQL Expressions onto Objects](#orm-queryguide-with-expression)
    - background and usage examples'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[将任意SQL表达式加载到对象上](#orm-queryguide-with-expression) - 背景和使用示例'
- en: '[PRE116]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Indicate that for a particular entity, only the given list of column-based attribute
    names should be loaded; all others will be deferred.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 指示对于特定实体，只应加载给定的列名列表的基于列的属性；所有其他属性将被延迟加载。
- en: This function is part of the [`Load`](relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") interface and supports both method-chained and standalone
    operation.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是[`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")接口的一部分，支持方法链接和独立操作。
- en: 'Example - given a class `User`, load only the `name` and `fullname` attributes:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 给定一个类`User`，仅加载`name`和`fullname`属性：
- en: '[PRE117]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Example - given a relationship `User.addresses -> Address`, specify subquery
    loading for the `User.addresses` collection, but on each `Address` object load
    only the `email_address` attribute:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 - 给定一个关系`User.addresses -> Address`，为`User.addresses`集合指定子查询加载，但在每个`Address`对象上仅加载`email_address`属性：
- en: '[PRE118]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'For a statement that has multiple entities, the lead entity can be specifically
    referred to using the [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    constructor:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个实体的语句，可以使用[`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")构造函数来特定引用主实体：
- en: '[PRE119]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: When used together with the [populate_existing](api.html#orm-queryguide-populate-existing)
    execution option only the attributes listed will be refreshed.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [populate_existing](api.html#orm-queryguide-populate-existing) 执行选项一起使用时，只会刷新列出的属性。
- en: 'Parameters:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`*attrs` – Attributes to be loaded, all others will be deferred.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*attrs` – 需要加载的属性，其他所有属性都将被延迟加载。'
- en: '`raiseload` –'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` –'
- en: raise [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") rather than lazy loading a value when a
    deferred attribute is accessed. Used to prevent unwanted SQL from being emitted.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当访问延迟属性时引发 [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") 而不是懒加载值。用于防止不必要的 SQL 发出。
- en: New in version 2.0.
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版本中新增。
- en: See also
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制加载哪些列与列延迟](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: 'Parameters:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`*attrs` – Attributes to be loaded, all others will be deferred.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*attrs` – 需要加载的属性，其他所有属性都将被延迟加载。'
- en: '`raiseload` –'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`raiseload` –'
- en: raise [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") rather than lazy loading a value when a
    deferred attribute is accessed. Used to prevent unwanted SQL from being emitted.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当访问延迟属性时引发 [`InvalidRequestError`](../../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") 而不是懒加载值。用于防止不必要的 SQL 发出。
- en: New in version 2.0.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.0 版本中新增。
- en: '[PRE120]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Indicate that the given column-oriented attribute should be undeferred, e.g.
    specified within the SELECT statement of the entity as a whole.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 表示给定的面向列的属性应该取消延迟加载，例如在整个实体的 SELECT 语句中指定。
- en: The column being undeferred is typically set up on the mapping as a [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") attribute.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在映射上设置的列作为 [`deferred()`](#sqlalchemy.orm.deferred "sqlalchemy.orm.deferred")
    属性。
- en: This function is part of the [`Load`](relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") interface and supports both method-chained and standalone
    operation.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数是 [`Load`](relationships.html#sqlalchemy.orm.Load "sqlalchemy.orm.Load")
    接口的一部分，支持方法链接和独立操作。
- en: 'Examples:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE121]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Parameters:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** – Attribute to be undeferred.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** – 需要取消延迟加载的属性。'
- en: See also
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制加载哪些列与列延迟](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
- en: '[`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[`undefer_group()`](#sqlalchemy.orm.undefer_group "sqlalchemy.orm.undefer_group")'
- en: '[PRE122]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Indicate that columns within the given deferred group name should be undeferred.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 表示给定延迟组名称内的列应取消延迟加载。
- en: The columns being undeferred are set up on the mapping as [`deferred()`](#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") attributes and include a “group” name.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 正在取消延迟加载的列设置在映射上作为[`deferred()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")属性，并包括一个“组”名称。
- en: 'E.g:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE123]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To undefer a group of attributes on a related entity, the path can be spelled
    out using relationship loader options, such as [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload"):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '要在相关实体上取消一组属性的延迟加载，可以使用关系加载器选项拼写出路径，例如 [`defaultload()`](relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload"):'
- en: '[PRE124]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: See also
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Limiting which Columns Load with Column Deferral](#orm-queryguide-column-deferral)
    - in the [ORM Querying Guide](index.html)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[限制加载哪些列与列延迟](#orm-queryguide-column-deferral) - 在 [ORM 查询指南](index.html) 中'
- en: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[`defer()`](#sqlalchemy.orm.defer "sqlalchemy.orm.defer")'
- en: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[`undefer()`](#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")'
- en: '[PRE125]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Apply an ad-hoc SQL expression to a “deferred expression” attribute.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 对“延迟表达式”属性应用临时 SQL 表达式。
- en: This option is used in conjunction with the [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") mapper-level construct that indicates an attribute
    which should be the target of an ad-hoc SQL expression.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项与指示应该成为临时 SQL 表达式目标的属性的 [`query_expression()`](#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") 映射器级构造一起使用。
- en: 'E.g.:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE126]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: New in version 1.2.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 版本中新增。
- en: 'Parameters:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`key` – Attribute to be populated'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` – 需要填充的属性'
- en: '`expr` – SQL expression to be applied to the attribute.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr` – 应用于属性的 SQL 表达式。'
- en: See also
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Loading Arbitrary SQL Expressions onto Objects](#orm-queryguide-with-expression)
    - background and usage examples'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '[将任意的 SQL 表达式加载到对象上](#orm-queryguide-with-expression) - 背景和使用示例'
