["```py\nclass sqlalchemy.orm.AttributeState\n```", "```py\nfrom sqlalchemy import inspect\n\ninsp = inspect(some_mapped_object)\nattr_state = insp.attrs.some_attribute\n```", "```py\nattribute history\n```", "```py\nmethod load_history() \u2192 History\n```", "```py\nattribute loaded_value\n```", "```py\nattribute value\n```", "```py\nclass sqlalchemy.orm.CascadeOptions\n```", "```py\nclass sqlalchemy.orm.ClassManager\n```", "```py\nattribute deferred_scalar_loader\n```", "```py\nattribute expired_attribute_loader: _ExpiredAttributeLoaderProto\n```", "```py\nmethod has_parent(state: InstanceState[_O], key: str, optimistic: bool = False) \u2192 bool\n```", "```py\nmethod manage()\n```", "```py\nmethod state_getter()\n```", "```py\nmethod unregister() \u2192 None\n```", "```py\nclass sqlalchemy.orm.ColumnProperty\n```", "```py\nclass Comparator\n```", "```py\nattribute expressions: Sequence[NamedColumn[Any]]\n```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nattribute columns_to_assign\n```", "```py\nmethod declarative_scan(decl_scan: _ClassScanMapperConfig, registry: _RegistryType, cls: Type[Any], originating_module: str | None, key: str, mapped_container: Type[Mapped[Any]] | None, annotation: _AnnotationScanType | None, extracted_mapped_annotation: _AnnotationScanType | None, is_dataclass_field: bool) \u2192 None\n```", "```py\nmethod do_init() \u2192 None\n```", "```py\nattribute expression\n```", "```py\nclass File(Base):\n    # ...\n\n    name = Column(String(64))\n    extension = Column(String(8))\n    filename = column_property(name + '.' + extension)\n    path = column_property('C:/' + filename.expression)\n```", "```py\nmethod instrument_class(mapper: Mapper[Any]) \u2192 None\n```", "```py\nattribute mapper_property_to_assign\n```", "```py\nmethod merge(session: Session, source_state: InstanceState[Any], source_dict: _InstanceDict, dest_state: InstanceState[Any], dest_dict: _InstanceDict, load: bool, _recursive: Dict[Any, object], _resolve_conflict_map: Dict[_IdentityKeyType[Any], object]) \u2192 None\n```", "```py\nclass sqlalchemy.orm.Composite\n```", "```py\nclass sqlalchemy.orm.CompositeProperty\n```", "```py\nclass Comparator\n```", "```py\nclass CompositeBundle\n```", "```py\nmethod create_row_processor(query: Select[Any], procs: Sequence[Callable[[Row[Any]], Any]], labels: Sequence[str]) \u2192 Callable[[Row[Any]], Any]\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n        'Override create_row_processor to return values as\n        dictionaries'\n\n        def proc(row):\n            return dict(\n                zip(labels, (proc(row) for proc in procs))\n            )\n        return proc\n```", "```py\nbn = DictBundle('mybundle', MyClass.data1, MyClass.data2)\nfor row in session.execute(select(bn)).where(bn.c.data1 == 'd1'):\n    print(row.mybundle['data1'], row.mybundle['data2'])\n```", "```py\nattribute columns_to_assign\n```", "```py\nmethod declarative_scan(decl_scan: _ClassScanMapperConfig, registry: _RegistryType, cls: Type[Any], originating_module: str | None, key: str, mapped_container: Type[Mapped[Any]] | None, annotation: _AnnotationScanType | None, extracted_mapped_annotation: _AnnotationScanType | None, is_dataclass_field: bool) \u2192 None\n```", "```py\nmethod do_init() \u2192 None\n```", "```py\nmethod get_history(state: InstanceState[Any], dict_: _InstanceDict, passive: PassiveFlag = symbol('PASSIVE_OFF')) \u2192 History\n```", "```py\nmethod instrument_class(mapper: Mapper[Any]) \u2192 None\n```", "```py\nattribute mapper_property_to_assign\n```", "```py\nclass sqlalchemy.orm.AttributeEventToken\n```", "```py\nclass sqlalchemy.orm.IdentityMap\n```", "```py\nmethod check_modified() \u2192 bool\n```", "```py\nclass sqlalchemy.orm.InspectionAttr\n```", "```py\nattribute extension_type: InspectionAttrExtensionType = 'not_extension'\n```", "```py\nattribute is_aliased_class = False\n```", "```py\nattribute is_attribute = False\n```", "```py\nattribute is_bundle = False\n```", "```py\nattribute is_clause_element = False\n```", "```py\nattribute is_instance = False\n```", "```py\nattribute is_mapper = False\n```", "```py\nattribute is_property = False\n```", "```py\nattribute is_selectable = False\n```", "```py\nclass sqlalchemy.orm.InspectionAttrInfo\n```", "```py\nattribute info\n```", "```py\nclass sqlalchemy.orm.InstanceState\n```", "```py\n>>> from sqlalchemy import inspect\n>>> insp = inspect(some_mapped_object)\n>>> insp.attrs.nickname.history\nHistory(added=['new nickname'], unchanged=(), deleted=['nickname'])\n```", "```py\nattribute async_session\n```", "```py\nattribute attrs\n```", "```py\nattribute callables: Dict[str, Callable[[InstanceState[_O], PassiveFlag], Any]] = {}\n```", "```py\nattribute deleted\n```", "```py\nattribute detached\n```", "```py\nattribute dict\n```", "```py\nattribute expired_attributes: Set[str]\n```", "```py\nattribute has_identity\n```", "```py\nattribute identity\n```", "```py\nattribute identity_key\n```", "```py\nattribute is_instance: bool = True\n```", "```py\nattribute mapper\n```", "```py\nattribute object\n```", "```py\nattribute pending\n```", "```py\nattribute persistent\n```", "```py\nattribute session\n```", "```py\nattribute transient\n```", "```py\nattribute unloaded\n```", "```py\nattribute unloaded_expirable\n```", "```py\nattribute unmodified\n```", "```py\nmethod unmodified_intersection(keys: Iterable[str]) \u2192 Set[str]\n```", "```py\nattribute was_deleted\n```", "```py\nclass sqlalchemy.orm.InstrumentedAttribute\n```", "```py\nclass sqlalchemy.orm.LoaderCallableStatus\n```", "```py\nattribute ATTR_EMPTY = 3\n```", "```py\nattribute ATTR_WAS_SET = 2\n```", "```py\nattribute NEVER_SET = 4\n```", "```py\nattribute NO_VALUE = 4\n```", "```py\nattribute PASSIVE_CLASS_MISMATCH = 1\n```", "```py\nattribute PASSIVE_NO_RESULT = 0\n```", "```py\nclass sqlalchemy.orm.Mapped\n```", "```py\nclass sqlalchemy.orm.MappedColumn\n```", "```py\nclass sqlalchemy.orm.MapperProperty\n```", "```py\nmethod cascade_iterator(type_: str, state: InstanceState[Any], dict_: _InstanceDict, visited_states: Set[InstanceState[Any]], halt_on: Callable[[InstanceState[Any]], bool] | None = None) \u2192 Iterator[Tuple[object, Mapper[Any], InstanceState[Any], _InstanceDict]]\n```", "```py\nattribute class_attribute\n```", "```py\nreturn getattr(self.parent.class_, self.key)\n```", "```py\n>>> from sqlalchemy import inspect\n>>> mapper = inspect(User)\n>>> addresses_property = mapper.attrs.addresses\n>>> addresses_property.class_attribute is User.addresses\nTrue\n>>> User.addresses.property is addresses_property\nTrue\n```", "```py\nattribute comparator: PropComparator[_T]\n```", "```py\nmethod create_row_processor(context: ORMCompileState, query_entity: _MapperEntity, path: AbstractEntityRegistry, mapper: Mapper[Any], result: Result[Any], adapter: ORMAdapter | None, populators: _PopulatorDict) \u2192 None\n```", "```py\nmethod do_init() \u2192 None\n```", "```py\nattribute doc: str | None\n```", "```py\nattribute info: _InfoType\n```", "```py\nmethod init() \u2192 None\n```", "```py\nmethod instrument_class(mapper: Mapper[Any]) \u2192 None\n```", "```py\nattribute is_property = True\n```", "```py\nattribute key: str\n```", "```py\nmethod merge(session: Session, source_state: InstanceState[Any], source_dict: _InstanceDict, dest_state: InstanceState[Any], dest_dict: _InstanceDict, load: bool, _recursive: Dict[Any, object], _resolve_conflict_map: Dict[_IdentityKeyType[Any], object]) \u2192 None\n```", "```py\nattribute parent: Mapper[Any]\n```", "```py\nmethod post_instrument_class(mapper: Mapper[Any]) \u2192 None\n```", "```py\nmethod set_parent(parent: Mapper[Any], init: bool) \u2192 None\n```", "```py\nmethod setup(context: ORMCompileState, query_entity: _MapperEntity, path: AbstractEntityRegistry, adapter: ORMAdapter | None, **kwargs: Any) \u2192 None\n```", "```py\nclass sqlalchemy.orm.MappedSQLExpression\n```", "```py\nclass sqlalchemy.orm.InspectionAttrExtensionType\n```", "```py\nclass sqlalchemy.orm.NotExtension\n```", "```py\nattribute NOT_EXTENSION = 'not_extension'\n```", "```py\nfunction sqlalchemy.orm.merge_result(query: Query[Any], iterator: FrozenResult | Iterable[Sequence[Any]] | Iterable[object], load: bool = True) \u2192 FrozenResult | Iterable[Any]\n```", "```py\nfunction sqlalchemy.orm.merge_frozen_result(session, statement, frozen_result, load=True)\n```", "```py\nclass sqlalchemy.orm.PropComparator\n```", "```py\n# definition of custom PropComparator subclasses\n\nfrom sqlalchemy.orm.properties import \\\n                        ColumnProperty,\\\n                        Composite,\\\n                        Relationship\n\nclass MyColumnComparator(ColumnProperty.Comparator):\n    def __eq__(self, other):\n        return self.__clause_element__() == other\n\nclass MyRelationshipComparator(Relationship.Comparator):\n    def any(self, expression):\n        \"define the 'any' operation\"\n        # ...\n\nclass MyCompositeComparator(Composite.Comparator):\n    def __gt__(self, other):\n        \"redefine the 'greater than' operation\"\n\n        return sql.and_(*[a>b for a, b in\n                          zip(self.__clause_element__().clauses,\n                              other.__composite_values__())])\n\n# application of custom PropComparator subclasses\n\nfrom sqlalchemy.orm import column_property, relationship, composite\nfrom sqlalchemy import Column, String\n\nclass SomeMappedClass(Base):\n    some_column = column_property(Column(\"some_column\", String),\n                        comparator_factory=MyColumnComparator)\n\n    some_relationship = relationship(SomeOtherClass,\n                        comparator_factory=MyRelationshipComparator)\n\n    some_composite = composite(\n            Column(\"a\", String), Column(\"b\", String),\n            comparator_factory=MyCompositeComparator\n        )\n```", "```py\nmethod __eq__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __le__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __lt__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __ne__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod adapt_to_entity(adapt_to_entity: AliasedInsp[Any]) \u2192 PropComparator[_T_co]\n```", "```py\nattribute adapter\n```", "```py\nmethod all_() \u2192 ColumnOperators\n```", "```py\nmethod and_(*criteria: _ColumnExpressionArgument[bool]) \u2192 PropComparator[bool]\n```", "```py\nstmt = select(User).join(\n    User.addresses.and_(Address.email_address != 'foo')\n)\n\nstmt = select(User).options(\n    joinedload(User.addresses.and_(Address.email_address != 'foo'))\n)\n```", "```py\nmethod any(criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) \u2192 ColumnElement[bool]\n```", "```py\nmethod any_() \u2192 ColumnOperators\n```", "```py\nmethod asc() \u2192 ColumnOperators\n```", "```py\nmethod between(cleft: Any, cright: Any, symmetric: bool = False) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_and(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_lshift(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_not() \u2192 ColumnOperators\n```", "```py\nmethod bitwise_or(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_rshift(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_xor(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bool_op(opstring: str, precedence: int = 0, python_impl: Callable[[...], Any] | None = None) \u2192 Callable[[Any], Operators]\n```", "```py\nmethod collate(collation: str) \u2192 ColumnOperators\n```", "```py\nmethod concat(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod contains(other: Any, **kw: Any) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE '%' || <other> || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.contains(\"foobar\"))\n```", "```py\n    somecolumn.contains(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE '%' || :param || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.contains(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE '%' || :param || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.contains(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod desc() \u2192 ColumnOperators\n```", "```py\nmethod distinct() \u2192 ColumnOperators\n```", "```py\nmethod endswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE '%' || <other>\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.endswith(\"foobar\"))\n```", "```py\n    somecolumn.endswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE '%' || :param ESCAPE '/'\n    ```", "```py\n    somecolumn.endswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE '%' || :param ESCAPE '^'\n    ```", "```py\n    somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod has(criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) \u2192 ColumnElement[bool]\n```", "```py\nmethod icontains(other: Any, **kw: Any) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE '%' || lower(<other>) || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.icontains(\"foobar\"))\n```", "```py\n    somecolumn.icontains(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.icontains(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.icontains(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod iendswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE '%' || lower(<other>)\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.iendswith(\"foobar\"))\n```", "```py\n    somecolumn.iendswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '/'\n    ```", "```py\n    somecolumn.iendswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '^'\n    ```", "```py\n    somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod ilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nlower(a) LIKE lower(other)\n```", "```py\na ILIKE other\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.ilike(\"%foobar%\"))\n```", "```py\n    somecolumn.ilike(\"foo/%bar\", escape=\"/\")\n    ```", "```py\nmethod in_(other: Any) \u2192 ColumnOperators\n```", "```py\n    stmt.where(column.in_([1, 2, 3]))\n    ```", "```py\n    WHERE COL IN (?, ?, ?)\n    ```", "```py\n    from sqlalchemy import tuple_\n    stmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))\n    ```", "```py\n    stmt.where(column.in_([]))\n    ```", "```py\n    WHERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)\n    ```", "```py\n    stmt.where(column.in_(bindparam('value', expanding=True)))\n    ```", "```py\n    WHERE COL IN ([EXPANDING_value])\n    ```", "```py\n    connection.execute(stmt, {\"value\": [1, 2, 3]})\n    ```", "```py\n    WHERE COL IN (?, ?, ?)\n    ```", "```py\n    WHERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)\n    ```", "```py\n    stmt.where(\n        column.in_(\n            select(othertable.c.y).\n            where(table.c.x == othertable.c.x)\n        )\n    )\n    ```", "```py\n    WHERE COL IN (SELECT othertable.y\n    FROM othertable WHERE othertable.x = table.x)\n    ```", "```py\nmethod is_(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_not(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_not_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod isnot(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod isnot_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod istartswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE lower(<other>) || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.istartswith(\"foobar\"))\n```", "```py\n    somecolumn.istartswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.istartswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.istartswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod like(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\na LIKE other\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.like(\"%foobar%\"))\n```", "```py\n    somecolumn.like(\"foo/%bar\", escape=\"/\")\n    ```", "```py\nmethod match(other: Any, **kwargs: Any) \u2192 ColumnOperators\n```", "```py\nmethod not_ilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod not_in(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod not_like(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod notilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod notin_(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod notlike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod nulls_first() \u2192 ColumnOperators\n```", "```py\nmethod nulls_last() \u2192 ColumnOperators\n```", "```py\nmethod nullsfirst() \u2192 ColumnOperators\n```", "```py\nmethod nullslast() \u2192 ColumnOperators\n```", "```py\nmethod of_type(class_: _EntityType[Any]) \u2192 PropComparator[_T_co]\n```", "```py\nquery.join(Company.employees.of_type(Engineer)).\\\n   filter(Engineer.name=='foo')\n```", "```py\nmethod op(opstring: str, precedence: int = 0, is_comparison: bool = False, return_type: Type[TypeEngine[Any]] | TypeEngine[Any] | None = None, python_impl: Callable[..., Any] | None = None) \u2192 Callable[[Any], Operators]\n```", "```py\nsomecolumn.op(\"*\")(5)\n```", "```py\nsomecolumn * 5\n```", "```py\nsomecolumn.op('&')(0xff)\n```", "```py\n    >>> expr = column('x').op('+', python_impl=lambda a, b: a + b)('y')\n    ```", "```py\n    >>> expr.operator(5, 10)\n    15\n    ```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 Operators\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nattribute property\n```", "```py\nmethod regexp_match(pattern: Any, flags: str | None = None) \u2192 ColumnOperators\n```", "```py\nstmt = select(table.c.some_column).where(\n    table.c.some_column.regexp_match('^(b|c)')\n)\n```", "```py\nmethod regexp_replace(pattern: Any, replacement: Any, flags: str | None = None) \u2192 ColumnOperators\n```", "```py\nstmt = select(\n    table.c.some_column.regexp_replace(\n        'b(..)',\n        'XY',\n        flags='g'\n    )\n)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 Operators\n```", "```py\nmethod startswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE <other> || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.startswith(\"foobar\"))\n```", "```py\n    somecolumn.startswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE :param || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.startswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE :param || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.startswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute timetuple: Literal[None] = None\n```", "```py\nclass sqlalchemy.orm.Relationship\n```", "```py\nclass sqlalchemy.orm.RelationshipDirection\n```", "```py\nattribute MANYTOMANY = 3\n```", "```py\nattribute MANYTOONE = 2\n```", "```py\nattribute ONETOMANY = 1\n```", "```py\nclass sqlalchemy.orm.RelationshipProperty\n```", "```py\nclass Comparator\n```", "```py\nmethod __eq__(other: Any) \u2192 ColumnElement[bool]\n```", "```py\nMyClass.some_prop == <some object>\n```", "```py\nmytable.related_id == <some id>\n```", "```py\nmethod __init__(prop: RelationshipProperty[_PT], parentmapper: _InternalEntityType[Any], adapt_to_entity: AliasedInsp[Any] | None = None, of_type: _EntityType[_PT] | None = None, extra_criteria: Tuple[ColumnElement[bool], ...] = ())\n```", "```py\nmethod __ne__(other: Any) \u2192 ColumnElement[bool]\n```", "```py\nMyClass.some_prop != <some object>\n```", "```py\nmytable.related_id != <some id>\n```", "```py\nmethod adapt_to_entity(adapt_to_entity: AliasedInsp[Any]) \u2192 RelationshipProperty.Comparator[Any]\n```", "```py\nmethod and_(*criteria: _ColumnExpressionArgument[bool]) \u2192 PropComparator[Any]\n```", "```py\nmethod any(criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) \u2192 ColumnElement[bool]\n```", "```py\nsession.query(MyClass).filter(\n    MyClass.somereference.any(SomeRelated.x==2)\n)\n```", "```py\nSELECT * FROM my_table WHERE\nEXISTS (SELECT 1 FROM related WHERE related.my_id=my_table.id\nAND related.x=2)\n```", "```py\nsession.query(MyClass).filter(\n    ~MyClass.somereference.any()\n)\n```", "```py\nSELECT * FROM my_table WHERE\nNOT (EXISTS (SELECT 1 FROM related WHERE\nrelated.my_id=my_table.id))\n```", "```py\nmethod contains(other: _ColumnExpressionArgument[Any], **kwargs: Any) \u2192 ColumnElement[bool]\n```", "```py\nMyClass.contains(other)\n```", "```py\nmytable.id == <some id>\n```", "```py\nquery(MyClass).filter(MyClass.contains(other))\n```", "```py\nSELECT * FROM my_table, my_association_table AS\nmy_association_table_1 WHERE\nmy_table.id = my_association_table_1.parent_id\nAND my_association_table_1.child_id = <some id>\n```", "```py\nattribute entity: _InternalEntityType[_PT]\n```", "```py\nmethod has(criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) \u2192 ColumnElement[bool]\n```", "```py\nsession.query(MyClass).filter(\n    MyClass.somereference.has(SomeRelated.x==2)\n)\n```", "```py\nSELECT * FROM my_table WHERE\nEXISTS (SELECT 1 FROM related WHERE\nrelated.id==my_table.related_id AND related.x=2)\n```", "```py\nmethod in_(other: Any) \u2192 NoReturn\n```", "```py\nattribute mapper: Mapper[_PT]\n```", "```py\nmethod of_type(class_: _EntityType[Any]) \u2192 PropComparator[_PT]\n```", "```py\nattribute cascade\n```", "```py\nmethod cascade_iterator(type_: str, state: InstanceState[Any], dict_: _InstanceDict, visited_states: Set[InstanceState[Any]], halt_on: Callable[[InstanceState[Any]], bool] | None = None) \u2192 Iterator[Tuple[Any, Mapper[Any], InstanceState[Any], _InstanceDict]]\n```", "```py\nmethod declarative_scan(decl_scan: _ClassScanMapperConfig, registry: _RegistryType, cls: Type[Any], originating_module: str | None, key: str, mapped_container: Type[Mapped[Any]] | None, annotation: _AnnotationScanType | None, extracted_mapped_annotation: _AnnotationScanType | None, is_dataclass_field: bool) \u2192 None\n```", "```py\nmethod do_init() \u2192 None\n```", "```py\nattribute entity\n```", "```py\nmethod instrument_class(mapper: Mapper[Any]) \u2192 None\n```", "```py\nattribute mapper\n```", "```py\nmethod merge(session: Session, source_state: InstanceState[Any], source_dict: _InstanceDict, dest_state: InstanceState[Any], dest_dict: _InstanceDict, load: bool, _recursive: Dict[Any, object], _resolve_conflict_map: Dict[_IdentityKeyType[Any], object]) \u2192 None\n```", "```py\nclass sqlalchemy.orm.SQLORMExpression\n```", "```py\nclass sqlalchemy.orm.Synonym\n```", "```py\nclass sqlalchemy.orm.SynonymProperty\n```", "```py\nattribute doc: str | None\n```", "```py\nattribute info: _InfoType\n```", "```py\nattribute key: str\n```", "```py\nattribute parent: Mapper[Any]\n```", "```py\nmethod set_parent(parent: Mapper[Any], init: bool) \u2192 None\n```", "```py\nattribute uses_objects\n```", "```py\nclass sqlalchemy.orm.QueryContext\n```", "```py\nclass default_load_options\n```", "```py\nclass sqlalchemy.orm.QueryableAttribute\n```", "```py\nmethod adapt_to_entity(adapt_to_entity: AliasedInsp[Any]) \u2192 Self\n```", "```py\nmethod and_(*clauses: _ColumnExpressionArgument[bool]) \u2192 QueryableAttribute[bool]\n```", "```py\nstmt = select(User).join(\n    User.addresses.and_(Address.email_address != 'foo')\n)\n\nstmt = select(User).options(\n    joinedload(User.addresses.and_(Address.email_address != 'foo'))\n)\n```", "```py\nattribute expression: ColumnElement[_T_co]\n```", "```py\nattribute info\n```", "```py\nattribute is_attribute = True\n```", "```py\nmethod of_type(entity: _EntityType[Any]) \u2192 QueryableAttribute[_T]\n```", "```py\nquery.join(Company.employees.of_type(Engineer)).\\\n   filter(Engineer.name=='foo')\n```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nattribute parent: _InternalEntityType[Any]\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nclass sqlalchemy.orm.UOWTransaction\n```", "```py\nmethod filter_states_for_dep(dep, states)\n```", "```py\nmethod finalize_flush_changes() \u2192 None\n```", "```py\nmethod get_attribute_history(state, key, passive=symbol('PASSIVE_NO_INITIALIZE'))\n```", "```py\nmethod is_deleted(state)\n```", "```py\nmethod remove_state_actions(state)\n```", "```py\nmethod was_already_deleted(state)\n```"]