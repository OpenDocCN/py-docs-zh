["```py\nclass sqlalchemy.sql.expression.CacheKey\n```", "```py\nattribute bindparams: Sequence[BindParameter[Any]]\n```", "```py\nattribute key: Tuple[Any, ...]\n```", "```py\nmethod to_offline_string(statement_cache: MutableMapping[Any, str], statement: ClauseElement, parameters: _CoreSingleExecuteParams) \u2192 str\n```", "```py\nclass sqlalchemy.sql.expression.ClauseElement\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod params(_ClauseElement__optionaldict: Mapping[str, Any] | None = None, **kwargs: Any) \u2192 Self\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod unique_params(_ClauseElement__optionaldict: Dict[str, Any] | None = None, **kwargs: Any) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.base.DialectKWArgs\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.sql.traversals.HasCacheKey\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nclass sqlalchemy.sql.expression.LambdaElement\n```", "```py\nstmt = select(table).where(lambda: table.c.col == parameter)\n```", "```py\nclass sqlalchemy.sql.expression.StatementLambdaElement\n```", "```py\nfrom sqlalchemy import lambda_stmt\n\nstmt = lambda_stmt(lambda: select(table))\n```", "```py\nstmt += lambda s: s.where(table.c.col == parameter)\n```", "```py\nmethod add_criteria(other: Callable[[Any], Any], enable_tracking: bool = True, track_on: Any | None = None, track_closure_variables: bool = True, track_bound_values: bool = True) \u2192 StatementLambdaElement\n```", "```py\n>>> def my_stmt(parameter):\n...     stmt = lambda_stmt(\n...         lambda: select(table.c.x, table.c.y),\n...     )\n...     stmt = stmt.add_criteria(\n...         lambda: table.c.x > parameter\n...     )\n...     return stmt\n```", "```py\n>>> def my_stmt(self, foo):\n...     stmt = lambda_stmt(\n...         lambda: select(func.max(foo.x, foo.y)),\n...         track_closure_variables=False\n...     )\n...     stmt = stmt.add_criteria(\n...         lambda: self.where_criteria,\n...         track_on=[self]\n...     )\n...     return stmt\n```", "```py\nattribute is_delete\n```", "```py\nattribute is_dml\n```", "```py\nattribute is_insert\n```", "```py\nattribute is_select\n```", "```py\nattribute is_text\n```", "```py\nattribute is_update\n```", "```py\nmethod spoil() \u2192 NullLambdaStatement\n```"]