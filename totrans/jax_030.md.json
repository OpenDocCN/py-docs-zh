["```py\n[1, \"a\", object()]  # 3 leaves\n\n(1, (2, 3), ())  # 3 leaves\n\n[1, {\"k1\": 2, \"k2\": (3, 4)}, 5]  # 5 leaves \n```", "```py\n(a1, {\"k1\": a2, \"k2\": a3}) \n```", "```py\n(None, {\"k1\": None, \"k2\": 0}) \n```", "```py\n(None, 0)  # equivalent to (None, {\"k1\": 0, \"k2\": 0}) \n```", "```py\n0 \n```", "```py\nfrom jax.tree_util import tree_structure\nprint(tree_structure(object)) \n```", "```py\nfrom jax.tree_util import tree_flatten, tree_unflatten\nimport jax.numpy as jnp\n\n# The structured value to be transformed\nvalue_structured = [1., (2., 3.)]\n\n# The leaves in value_flat correspond to the `*` markers in value_tree\nvalue_flat, value_tree = tree_flatten(value_structured)\nprint(f\"{value_flat=}\\n{value_tree=}\")\n\n# Transform the flat value list using an element-wise numeric transformer\ntransformed_flat = list(map(lambda v: v * 2., value_flat))\nprint(f\"{transformed_flat=}\")\n\n# Reconstruct the structured output, using the original\ntransformed_structured = tree_unflatten(value_tree, transformed_flat)\nprint(f\"{transformed_structured=}\") \n```", "```py\nvalue_flat=[1.0, 2.0, 3.0]\nvalue_tree=PyTreeDef([*, (*, *)])\ntransformed_flat=[2.0, 4.0, 6.0]\ntransformed_structured=[2.0, (4.0, 6.0)] \n```", "```py\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\n\nexample_containers = [\n    (1., [2., 3.]),\n    (1., {'b': 2., 'a': 3.}),\n    1.,\n    None,\n    jnp.zeros(2),\n    Point(1., 2.)\n]\ndef show_example(structured):\n  flat, tree = tree_flatten(structured)\n  unflattened = tree_unflatten(tree, flat)\n  print(f\"{structured=}\\n  {flat=}\\n  {tree=}\\n  {unflattened=}\")\n\nfor structured in example_containers:\n  show_example(structured) \n```", "```py\nstructured=(1.0, [2.0, 3.0])\n  flat=[1.0, 2.0, 3.0]\n  tree=PyTreeDef((*, [*, *]))\n  unflattened=(1.0, [2.0, 3.0])\nstructured=(1.0, {'b': 2.0, 'a': 3.0})\n  flat=[1.0, 3.0, 2.0]\n  tree=PyTreeDef((*, {'a': *, 'b': *}))\n  unflattened=(1.0, {'a': 3.0, 'b': 2.0})\nstructured=1.0\n  flat=[1.0]\n  tree=PyTreeDef(*)\n  unflattened=1.0\nstructured=None\n  flat=[]\n  tree=PyTreeDef(None)\n  unflattened=None\nstructured=Array([0., 0.], dtype=float32)\n  flat=[Array([0., 0.], dtype=float32)]\n  tree=PyTreeDef(*)\n  unflattened=Array([0., 0.], dtype=float32)\nstructured=Point(x=1.0, y=2.0)\n  flat=[1.0, 2.0]\n  tree=PyTreeDef(CustomNode(namedtuple[Point], [*, *]))\n  unflattened=Point(x=1.0, y=2.0) \n```", "```py\nclass Special(object):\n  def __init__(self, x, y):\n    self.x = x\n    self.y = y\n\n  def __repr__(self):\n    return \"Special(x={}, y={})\".format(self.x, self.y)\n\nshow_example(Special(1., 2.)) \n```", "```py\nstructured=Special(x=1.0, y=2.0)\n  flat=[Special(x=1.0, y=2.0)]\n  tree=PyTreeDef(*)\n  unflattened=Special(x=1.0, y=2.0) \n```", "```py\nfrom jax.tree_util import register_pytree_node\n\nclass RegisteredSpecial(Special):\n  def __repr__(self):\n    return \"RegisteredSpecial(x={}, y={})\".format(self.x, self.y)\n\ndef special_flatten(v):\n  \"\"\"Specifies a flattening recipe.\n\n Params:\n v: the value of registered type to flatten.\n Returns:\n a pair of an iterable with the children to be flattened recursively,\n and some opaque auxiliary data to pass back to the unflattening recipe.\n The auxiliary data is stored in the treedef for use during unflattening.\n The auxiliary data could be used, e.g., for dictionary keys.\n \"\"\"\n  children = (v.x, v.y)\n  aux_data = None\n  return (children, aux_data)\n\ndef special_unflatten(aux_data, children):\n  \"\"\"Specifies an unflattening recipe.\n\n Params:\n aux_data: the opaque data that was specified during flattening of the\n current treedef.\n children: the unflattened children\n\n Returns:\n a re-constructed object of the registered type, using the specified\n children and auxiliary data.\n \"\"\"\n  return RegisteredSpecial(*children)\n\n# Global registration\nregister_pytree_node(\n    RegisteredSpecial,\n    special_flatten,    # tell JAX what are the children nodes\n    special_unflatten   # tell JAX how to pack back into a RegisteredSpecial\n)\n\nshow_example(RegisteredSpecial(1., 2.)) \n```", "```py\nstructured=RegisteredSpecial(x=1.0, y=2.0)\n  flat=[1.0, 2.0]\n  tree=PyTreeDef(CustomNode(RegisteredSpecial[None], [*, *]))\n  unflattened=RegisteredSpecial(x=1.0, y=2.0) \n```", "```py\nfrom jax.tree_util import register_pytree_node_class\n\n@register_pytree_node_class\nclass RegisteredSpecial2(Special):\n  def __repr__(self):\n    return \"RegisteredSpecial2(x={}, y={})\".format(self.x, self.y)\n\n  def tree_flatten(self):\n    children = (self.x, self.y)\n    aux_data = None\n    return (children, aux_data)\n\n  @classmethod\n  def tree_unflatten(cls, aux_data, children):\n    return cls(*children)\n\nshow_example(RegisteredSpecial2(1., 2.)) \n```", "```py\nstructured=RegisteredSpecial2(x=1.0, y=2.0)\n  flat=[1.0, 2.0]\n  tree=PyTreeDef(CustomNode(RegisteredSpecial2[None], [*, *]))\n  unflattened=RegisteredSpecial2(x=1.0, y=2.0) \n```", "```py\nclass MyTree:\n  def __init__(self, a):\n    self.a = jnp.asarray(a)\n\nregister_pytree_node(MyTree, lambda tree: ((tree.a,), None),\n    lambda _, args: MyTree(*args))\n\ntree = MyTree(jnp.arange(5.0))\n\njax.vmap(lambda x: x)(tree)      # Error because object() is passed to MyTree.\njax.jacobian(lambda x: x)(tree)  # Error because MyTree(...) is passed to MyTree \n```", "```py\nclass MyTree:\n  def __init__(self, a):\n    if not (type(a) is object or a is None or isinstance(a, MyTree)):\n      a = jnp.asarray(a)\n    self.a = a \n```", "```py\ndef tree_unflatten(aux_data, children):\n  del aux_data  # unused in this class\n  obj = object.__new__(MyTree)\n  obj.a = a\n  return obj \n```"]