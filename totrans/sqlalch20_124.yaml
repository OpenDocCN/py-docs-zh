- en: SQLAlchemy 2.0 - Major Migration Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_20.html](https://docs.sqlalchemy.org/en/20/changelog/migration_20.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note for Readers
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 2.0’s transition documents are separated into **two** documents
    - one which details major API shifts from the 1.x to 2.x series, and the other
    which details new features and behaviors relative to SQLAlchemy 1.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](#) - this document, 1.x to 2.x API
    shifts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What’s New in SQLAlchemy 2.0?](whatsnew_20.html) - new features and behaviors
    for SQLAlchemy 2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers who have already updated their 1.4 application to follow SQLAlchemy
    2.0 engine and ORM conventions may navigate to [What’s New in SQLAlchemy 2.0?](whatsnew_20.html)
    for an overview of new features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: About this document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 1.4 and SQLAlchemy
    version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 presents a major shift for a wide variety of key SQLAlchemy usage
    patterns in both the Core and ORM components. The goal of this release is to make
    a slight readjustment in some of the most fundamental assumptions of SQLAlchemy
    since its early beginnings, and to deliver a newly streamlined usage model that
    is hoped to be significantly more minimalist and consistent between the Core and
    ORM components, as well as more capable. The move of Python to be Python 3 only
    as well as the emergence of gradual typing systems for Python 3 are the initial
    inspirations for this shift, as is the changing nature of the Python community
    which now includes not just hardcore database programmers but a vast new community
    of data scientists and students of many different disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy started with Python 2.3 which had no context managers, no function
    decorators, Unicode as a second class feature, and a variety of other shortcomings
    that would be unknown today. The biggest changes in SQLAlchemy 2.0 are targeting
    the residual assumptions left over from this early period in SQLAlchemy’s development
    as well as the leftover artifacts resulting from the incremental introduction
    of key API features such as [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.query.Query") and Declarative. It also hopes standardize some
    newer capabilities that have proven to be very effective.
  prefs: []
  type: TYPE_NORMAL
- en: The 1.4->2.0 Migration Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most prominent architectural features and API changes that are considered
    to be “SQLAlchemy 2.0” were in fact released as fully available within the 1.4
    series, to provide for a clean upgrade path from the 1.x to the 2.x series as
    well as to serve as a beta platform for the features themselves. These changes
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[New ORM statement paradigm](migration_14.html#change-5159)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL caching throughout Core and ORM](migration_14.html#change-4639)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[New Declarative features, ORM integration](migration_14.html#change-5508)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[New Result object](migration_14.html#change-result-14-core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[select() / case() Accept Positional Expressions](migration_14.html#change-5284)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asyncio support for Core and ORM](migration_14.html#change-3414)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above bullets link to the description of these new paradigms as introduced
    in SQLAlchemy 1.4\. in the [What’s New in SQLAlchemy 1.4?](migration_14.html)
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQLAlchemy 2.0, all API features and behaviors that were marked as [deprecated
    for 2.0](migration_14.html#deprecation-20-mode) are now finalized; in particular,
    major APIs that are **no longer present** include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bound MetaData and connectionless execution](#migration-20-implicit-execution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Emulated autocommit on Connection](#migration-20-autocommit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Session.autocommit parameter / mode](#migration-20-session-autocommit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List / keyword arguments to select()](#migration-20-5284)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above bullets refer to the most prominent fully backwards-incompatible changes
    that are finalized in the 2.0 release. The migration path for applications to
    accommodate for these changes as well as others is framed as a transition path
    first into the 1.4 series of SQLAlchemy where the “future” APIs are available
    to provide for the “2.0” way of working, and then to the 2.0 series where the
    no-longer-used APIs above and others are removed.
  prefs: []
  type: TYPE_NORMAL
- en: The complete steps for this migration path are later in this document at [1.x
    -> 2.x Migration Overview](#migration-20-overview).
  prefs: []
  type: TYPE_NORMAL
- en: '## 1.x -> 2.x Migration Overview'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy 2.0 transition presents itself in the SQLAlchemy 1.4 release
    as a series of steps that allow an application of any size or complexity to be
    migrated to SQLAlchemy 2.0 using a gradual, iterative process. Lessons learned
    from the Python 2 to Python 3 transition have inspired a system that intends to
    as great a degree as possible to not require any “breaking” changes, or any change
    that would need to be made universally or not at all.
  prefs: []
  type: TYPE_NORMAL
- en: As a means of both proving the 2.0 architecture as well as allowing a fully
    iterative transition environment, the entire scope of 2.0’s new APIs and features
    are present and available within the 1.4 series; this includes major new areas
    of functionality such as the SQL caching system, the new ORM statement execution
    model, new transactional paradigms for both ORM and Core, a new ORM declarative
    system that unifies classical and declarative mapping, support for Python dataclasses,
    and asyncio support for Core and ORM.
  prefs: []
  type: TYPE_NORMAL
- en: The steps to achieve 2.0 migration are in the following subsections; overall,
    the general strategy is that once an application runs on 1.4 with all warning
    flags turned on and does not emit any 2.0-deprecation warnings, it is now **mostly**
    cross-compatible with SQLAlchemy 2.0\. **Please note there may be additional API
    and behavioral changes that may behave differently when running against SQLAlchemy
    2.0; always test code against an actual SQLAlchemy 2.0 release as the final step
    in migrating**.
  prefs: []
  type: TYPE_NORMAL
- en: First Prerequisite, step one - A Working 1.3 Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is getting an existing application onto 1.4, in the case of a
    typical non trivial application, is to ensure it runs on SQLAlchemy 1.3 with no
    deprecation warnings. Release 1.4 does have a few changes linked to conditions
    that warn in previous version, including some warnings that were introduced in
    1.3, in particular some changes to the behavior of the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") and [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flags.
  prefs: []
  type: TYPE_NORMAL
- en: For best results, the application should be able to run, or pass all of its
    tests, with the latest SQLAlchemy 1.3 release with no SQLAlchemy deprecation warnings;
    these are warnings emitted for the [`SADeprecationWarning`](../core/exceptions.html#sqlalchemy.exc.SADeprecationWarning
    "sqlalchemy.exc.SADeprecationWarning") class.
  prefs: []
  type: TYPE_NORMAL
- en: First Prerequisite, step two - A Working 1.4 Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the application is good to go on SQLAlchemy 1.3, the next step is to get
    it running on SQLAlchemy 1.4\. In the vast majority of cases, applications should
    run without problems from SQLAlchemy 1.3 to 1.4\. However, it’s always the case
    between any 1.x and 1.y release, APIs and behaviors have changed either subtly
    or in some cases a little less subtly, and the SQLAlchemy project always gets
    a good deal of regression reports for the first few months.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 1.x->1.y release process usually has a few changes around the margins that
    are a little bit more dramatic and are based around use cases that are expected
    to be very seldom if at all used. For 1.4, the changes identified as being in
    this realm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The URL object is now immutable](migration_14.html#change-5526) - this impacts
    code that would be manipulating the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object and may impact code that makes use of the [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") extension point. This is an uncommon case
    but may affect in particular some test suites that are making use of special database
    provisioning logic. A github search for code that uses the relatively new and
    little-known [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") class found two projects that were unaffected
    by the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](migration_14.html#change-4617)
    - this change may impact code that was somehow relying upon behavior that was
    mostly unusable in the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, where it would create unnamed subqueries
    that were usually confusing and non-working. These subqueries would be rejected
    by most databases in any case as a name is usually required except on SQLite,
    however it is possible some applications will need to adjust some queries that
    are inadvertently relying upon this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[select().join() and outerjoin() add JOIN criteria to the current query, rather
    than creating a subquery](migration_14.html#change-select-join) - somewhat related,
    the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    class featured `.join()` and `.outerjoin()` methods that implicitly created a
    subquery and then returned a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct, which again would be mostly useless
    and produced lots of confusion. The decision was made to move forward with the
    vastly more useful 2.0-style join-building approach where these methods now work
    the same way as the ORM [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Many Core and ORM statement objects now perform much of their construction
    and validation in the compile phase](migration_14.html#change-deferred-construction)
    - some error messages related to construction of a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") or [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") may not be emitted until compilation / execution,
    rather than at construction time. This might impact some test suites that are
    testing against failure modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full overview of SQLAlchemy 1.4 changes, see the [What’s New in SQLAlchemy
    1.4?](migration_14.html) document.
  prefs: []
  type: TYPE_NORMAL
- en: Migration to 2.0 Step One - Python 3 only (Python 3.7 minimum for 2.0 compatibility)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 was first inspired by the fact that Python 2’s EOL was in 2020.
    SQLAlchemy is taking a longer period of time than other major projects to drop
    Python 2.7 support. However, in order to use SQLAlchemy 2.0, the application will
    need to be runnable on at least **Python 3.7**. SQLAlchemy 1.4 supports Python
    3.6 or newer within the Python 3 series; throughout the 1.4 series, the application
    can remain running on Python 2.7 or on at least Python 3.6\. Version 2.0 however
    starts at Python 3.7.
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Two - Turn on RemovedIn20Warnings'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 features a conditional deprecation warning system inspired by
    the Python “-3” flag that would indicate legacy patterns in a running application.
    For SQLAlchemy 1.4, the `RemovedIn20Warning` deprecation class is emitted only
    when an environment variable `SQLALCHEMY_WARN_20` is set to either of `true` or
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the example program below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program uses several patterns that many users will already identify
    as “legacy”, namely the use of the `Engine.execute()` method that’s part of the
    “connectionless execution” API. When we run the above program against 1.4, it
    returns a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable “2.0 deprecations mode”, we enable the `SQLALCHEMY_WARN_20=1` variable,
    and additionally ensure that a [warnings filter](https://docs.python.org/3/library/warnings.html#the-warnings-filter)
    that will not suppress any warnings is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the reported warning location is not always in the correct place, locating
    the offending code may be difficult without the full stacktrace. This can be achieved
    by transforming the warnings to exceptions by specifying the `error` warning filter,
    using Python option `-W error::DeprecationWarning`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With warnings turned on, our program now has a lot to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above guidance, we can migrate our program to use 2.0 styles, and
    as a bonus our program is much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The goal of “2.0 deprecations mode” is that a program which runs with no `RemovedIn20Warning`
    warnings with “2.0 deprecations mode” turned on is then ready to run in SQLAlchemy
    2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Migration to 2.0 Step Three - Resolve all RemovedIn20Warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Code can be developed iteratively to resolve these warnings. Within the SQLAlchemy
    project itself, the approach taken is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: enable the `SQLALCHEMY_WARN_20=1` environment variable in the test suite, for
    SQLAlchemy this is in the tox.ini file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the setup for the test suite, set up a series of warnings filters that
    will select for particular subsets of warnings to either raise an exception, or
    to be ignored (or logged). Work with just one subgroup of warnings at a time.
    Below, a warnings filter is configured for an application where the change to
    the Core level `.execute()` calls will be needed in order for all tests to pass,
    but all other 2.0-style warnings will be suppressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As each sub-category of warnings are resolved in the application, new warnings
    that are caught by the “always” filter can be added to the list of “errors” to
    be resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once no more warnings are emitted, the filter can be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migration to 2.0 Step Four - Use the `future` flag on Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object features an updated transaction-level API in version 2.0\. In 1.4, this
    new API is available by passing the flag `future=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag is used, the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects support the 2.0 API fully and not at all
    any legacy features, including the new argument format for [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), the removal of “implicit autocommit”,
    string statements require the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct unless the [`Connection.exec_driver_sql()`](../core/connections.html#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method is used, and connectionless
    execution from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is removed.
  prefs: []
  type: TYPE_NORMAL
- en: If all `RemovedIn20Warning` warnings have been resolved regarding use of the
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    then the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag may be enabled and there should be no errors
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new engine is described at [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which delivers a new [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. In addition to the above changes, the,
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object features [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, to support the new “commit-as-you-go”
    mode of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Migration to 2.0 Step Five - Use the `future` flag on Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object also features an updated transaction/connection level API in version 2.0\.
    This API is available in 1.4 using the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag on [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or on [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker").
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object supports “future” mode in place, and involves these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer supports “bound metadata” when it resolves the engine to be used for
    connectivity. This means that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object **must** be passed to the constructor (this
    may be either a legacy or future style object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.begin.subtransactions`](../orm/session_api.html#sqlalchemy.orm.Session.begin.params.subtransactions
    "sqlalchemy.orm.Session.begin") flag is no longer supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method always emits a COMMIT to the database,
    rather than attempting to reconcile “subtransactions”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method always rolls back the full stack of
    transactions at once, rather than attempting to keep “subtransactions” in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    also supports more flexible creational patterns in 1.4 which are now closely matched
    to the patterns used by the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. Highlights include that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") object supports a [`sessionmaker.begin()`](../orm/session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") context manager that will create a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and begin /commit a transaction in one block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Session-level vs. Engine level transaction control](../orm/session_transaction.html#orm-session-vs-engine)
    for a comparison of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") creational patterns compared to those of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: Once the application passes all tests/ runs with `SQLALCHEMY_WARN_20=1` and
    all `exc.RemovedIn20Warning` occurrences set to raise an error, **the application
    is ready!**.
  prefs: []
  type: TYPE_NORMAL
- en: The sections that follow will detail the specific changes to make for all major
    API modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Six - Add `__allow_unmapped__` to explicitly typed
    ORM models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 has new support for runtime interpretation of [**PEP 484**](https://peps.python.org/pep-0484/)
    typing annotations on ORM models. A requirement of these annotations is that they
    must make use of the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    generic container. Annotations which don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") which link to constructs such as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") will raise errors in Python, as they suggest mis-configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to these errors, as
    would occur in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Foo.bars` and `Bar.foo` [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations will raise an error at class construction
    time because they don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") (by contrast, the annotations that use [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") are ignored by 2.0, as these are able to be recognized
    as a legacy configuration style). To allow all annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to pass without error, the `__allow_unmapped__` attribute
    may be used on the class or any subclasses, which will cause the annotations in
    these cases to be ignored completely by the new Declarative system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `__allow_unmapped__` directive applies **only** to the *runtime* behavior
    of the ORM. It does not affect the behavior of Mypy, and the above mapping as
    written still requires that the Mypy plugin be installed. For fully 2.0 style
    ORM models that will type correctly under Mypy *without* a plugin, follow the
    migration steps at [Migrating an Existing Mapping](whatsnew_20.html#whatsnew-20-orm-typing-migration).
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates the application of `__allow_unmapped__` to the
    Declarative `Base` class, where it will take effect for all classes that descend
    from `Base`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0beta3: - improved the `__allow_unmapped__` attribute
    support to allow for 1.4-style explicit annotated relationships that don’t use
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    to remain usable.  ### Migration to 2.0 Step Seven - Test against a SQLAlchemy
    2.0 Release'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, SQLAlchemy 2.0 has additional API and behavioral changes
    that are intended to be backwards compatible, however may introduce some incompatibilities
    nonetheless. Therefore after the overall porting process is complete, the final
    step is to test against the most recent release of SQLAlchemy 2.0 to correct for
    any remaining issues that might be present.
  prefs: []
  type: TYPE_NORMAL
- en: The guide at [What’s New in SQLAlchemy 2.0?](whatsnew_20.html) provides an overview
    of new features and behaviors for SQLAlchemy 2.0 which extend beyond the base
    set of 1.4->2.0 API changes.
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - Core Connection / Transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Library-level (but not driver level) “Autocommit” removed from both Core
    and ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy 1.x, the following statements will automatically commit the underlying
    DBAPI transaction, but in SQLAlchemy 2.0 this will not occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Nor will this autocommit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The common workaround for custom DML that requires commit, the “autocommit”
    execution option, will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that is cross-compatible with [1.x style](../glossary.html#term-1.x-style)
    and [2.0 style](../glossary.html#term-2.0-style) execution is to make use of the
    [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or the [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When using [2.0 style](../glossary.html#term-2.0-style) with the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag, “commit as you go” style may also be used, as
    the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    features **autobegin** behavior, which takes place when a statement is first invoked
    in the absence of an explicit call to [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When [2.0 deprecations mode](#migration-20-deprecations-mode) is enabled, a
    warning will emit when the deprecated “autocommit” feature takes place, indicating
    those places where an explicit transaction should be noted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s first releases were at odds with the spirit of the Python DBAPI
    ([**PEP 249**](https://peps.python.org/pep-0249/)) in that it tried to hide [**PEP
    249**](https://peps.python.org/pep-0249/)’s emphasis on “implicit begin” and “explicit
    commit” of transactions. Fifteen years later we now see this was essentially a
    mistake, as SQLAlchemy’s many patterns that attempt to “hide” the presence of
    a transaction make for a more complex API which works inconsistently and is extremely
    confusing to especially those users who are new to relational databases and ACID
    transactions in general. SQLAlchemy 2.0 will do away with all attempts to implicitly
    commit transactions, and usage patterns will always require that the user demarcate
    the “beginning” and the “end” of a transaction in some way, in the same way as
    reading or writing to a file in Python has a “beginning” and an “end”.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of autocommit for a pure textual statement, there is actually a
    regular expression that parses every statement in order to detect autocommit!
    Not surprisingly, this regex is continuously failing to accommodate for various
    kinds of statements and stored procedures that imply a “write” to the database,
    leading to ongoing confusion as some statements produce results in the database
    and others don’t. By preventing the user from being aware of the transactional
    concept, we get a lot of bug reports on this one because users don’t understand
    that databases always use a transaction, whether or not some layer is autocommitting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 2.0 will require that all database actions at every level be explicit
    as to how the transaction should be used. For the vast majority of Core use cases,
    it’s the pattern that is already recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For “commit as you go, or rollback instead” usage, which resembles how the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is normally used today, the “future” version of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which is the one that is returned from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that was created using the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag, includes new [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, which act upon a transaction
    that is now begun automatically when a statement is first invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `engine.connect()` method will return a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that features **autobegin**, meaning the `begin()`
    event is emitted when the execute method is first used (note however that there
    is no actual “BEGIN” in the Python DBAPI). “autobegin” is a new pattern in SQLAlchemy
    1.4 that is featured both by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as well as the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; autobegin allows that the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method may be called explicitly when the
    object is first acquired, for schemes that wish to demarcate the beginning of
    the transaction, but if the method is not called, then it occurs implicitly when
    work is first done on the object.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of “autocommit” is closely related to the removal of “connectionless”
    execution discussed at [“Implicit” and “Connectionless” execution, “bound metadata”
    removed](#migration-20-implicit-execution). All of these legacy patterns built
    up from the fact that Python did not have context managers or decorators when
    SQLAlchemy was first created, so there were no convenient idiomatic patterns for
    demarcating the use of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Driver-level autocommit remains available
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'True “autocommit” behavior is now widely available with most DBAPI implementations,
    and is supported by SQLAlchemy via the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter as discussed at [Setting
    Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).
    True autocommit is treated as an “isolation level” so that the structure of application
    code does not change when autocommit is used; the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") context manager as well as methods like
    [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") may still be used, they are simply no-ops
    at the database driver level when DBAPI-level autocommit is turned on.  ### “Implicit”
    and “Connectionless” execution, “bound metadata” removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to associate an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, which then makes available a range of so-called
    “connectionless” execution patterns, is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For schema level patterns, explicit use of an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is required. The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") may still be used directly as the source of connectivity
    for a [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") operation or autoload operation. For
    executing statements, only the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object has a [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method (in addition to the ORM-level [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The Core documentation has already standardized on the desired pattern here,
    so it is likely that most modern applications would not have to change much in
    any case, however there are likely many applications that still rely upon `engine.execute()`
    calls that will need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '“Connectionless” execution refers to the still fairly popular pattern of invoking
    `.execute()` from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The above operation implicitly procures a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, and runs the `.execute()` method on it.
    While this appears to be a simple convenience feature, it has been shown to give
    rise to several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Programs that feature extended strings of `engine.execute()` calls have become
    prevalent, overusing a feature that was intended to be seldom used and leading
    to inefficient non-transactional applications. New users are confused as to the
    difference between `engine.execute()` and `connection.execute()` and the nuance
    between these two approaches is often not understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The feature relies upon the “application level autocommit” feature in order
    to make sense, which itself is also being removed as it is also [inefficient and
    misleading](#migration-20-autocommit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to handle result sets, `Engine.execute` returns a result object with
    unconsumed cursor results. This cursor result necessarily still links to the DBAPI
    connection which remains in an open transaction, all of which is released once
    the result set has fully consumed the rows waiting within the cursor. This means
    that `Engine.execute` does not actually close out the connection resources that
    it claims to be managing when the call is complete. SQLAlchemy’s “autoclose” behavior
    is well-tuned enough that users don’t generally report any negative effects from
    this system, however it remains an overly implicit and inefficient system left
    over from SQLAlchemy’s earliest releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The removal of “connectionless” execution then leads to the removal of an even
    more legacy pattern, that of “implicit, connectionless” execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The above pattern has all the issues of “connectionless” execution, plus it
    relies upon the “bound metadata” pattern, which SQLAlchemy has tried to de-emphasize
    for many years. This was SQLAlchemy’s very first advertised usage model in version
    0.1, which became obsolete almost immediately when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object was introduced and later Python context
    managers provided a better pattern for using resources within a fixed scope.
  prefs: []
  type: TYPE_NORMAL
- en: With implicit execution removed, “bound metadata” itself also no longer has
    a purpose within this system. In modern use “bound metadata” tends to still be
    somewhat convenient for working within [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") calls as well as with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects, however having these functions receive an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") explicitly provides for clearer application design.
  prefs: []
  type: TYPE_NORMAL
- en: Many Choices becomes One Choice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Overall, the above executional patterns were introduced in SQLAlchemy’s very
    first 0.1 release before the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object even existed. After many years of de-emphasizing
    these patterns, “implicit, connectionless” execution and “bound metadata” are
    no longer as widely used so in 2.0 we seek to finally reduce the number of choices
    for how to execute a statement in Core from “many choices”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'to “one choice”, where by “one choice” we mean “explicit connection with explicit
    transaction”; there are still a few ways to demarcate transaction blocks depending
    on need. The “one choice” is to procure a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and then to explicitly demarcate the transaction,
    in the case that the operation is a write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: execute() method more strict, execution options are more prominent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument patterns that may be used with the [`sqlalchemy.engine.Connection()`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") execute method in SQLAlchemy 2.0 are highly simplified,
    removing many previously available argument patterns. The new API in the 1.4 series
    is described at [`sqlalchemy.engine.Connection()`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). The examples below illustrate the patterns that
    require modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method now accepts a subset of the argument
    styles that are accepted by the 1.x [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, so the following code is cross-compatible
    between 1.x and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `*args` and `**kwargs` has been removed both to remove the complexity
    of guessing what kind of arguments were passed to the method, as well as to make
    room for other options, namely the [`Connection.execute.execution_options`](../core/connections.html#sqlalchemy.engine.Connection.execute.params.execution_options
    "sqlalchemy.engine.Connection.execute") dictionary that is now available to provide
    options on a per statement basis. The method is also modified so that its use
    pattern matches that of the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which is a much more prominent API in
    2.0 style.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of direct string SQL is to resolve an inconsistency between [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") and [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), where in the former case the string is passed
    to the driver raw, and in the latter case it is first converted to a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct. By allowing only [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") this also limits the accepted parameter format
    to “named” and not “positional”. Finally, the string SQL use case is becoming
    more subject to scrutiny from a security perspective, and the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct has come to represent an explicit
    boundary into the textual SQL realm where attention to untrusted user input must
    be given.
  prefs: []
  type: TYPE_NORMAL
- en: '### Result rows act like named tuples'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 1.4 introduces an [all new Result object](migration_14.html#change-result-14-core)
    that in turn returns [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, which behave like named tuples when using “future” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Application code or test suites that are testing for a particular key being
    present in a row would need to test the `row.keys()` collection instead. This
    is however an unusual use case as a result row is typically used by code that
    already knows what columns are present within it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: Already part of 1.4, the previous `KeyedTuple` class that was used when selecting
    rows from the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has been replaced by the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class, which is the base of the same [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") that comes back with Core statement results when using
    the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag with [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") (when the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag is not set, Core result sets use the `LegacyRow`
    subclass, which maintains backwards-compatible behaviors for the `__contains__()`
    method; ORM exclusively uses the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class directly).
  prefs: []
  type: TYPE_NORMAL
- en: This [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    behaves like a named tuple, in that it acts as a sequence but also supports attribute
    name access, e.g. `row.some_column`. However, it also provides the previous “mapping”
    behavior via the special attribute `row._mapping`, which produces a Python mapping
    such that keyed access such as `row["some_column"]` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to receive results as mappings up front, the `mappings()` modifier
    on the result can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class as used by the ORM also supports access via entity or attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](migration_14.html#change-4710-core)'
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - Core Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### select() no longer accepts varied constructor arguments, columns are passed
    positionally'
  prefs: []
  type: TYPE_NORMAL
- en: '**synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct as well as the related method [`FromClause.select()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.select
    "sqlalchemy.sql.expression.FromClause.select") will no longer accept keyword arguments
    to build up elements such as the WHERE clause, FROM list and ORDER BY. The list
    of columns may now be sent positionally, rather than as a list. Additionally,
    the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    construct now accepts its WHEN criteria positionally, rather than as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the “generative” style of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") will be supported. The list of columns / tables
    to SELECT from should be passed positionally. The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct in SQLAlchemy 1.4 accepts both the
    legacy styles and the new styles using an auto-detection scheme, so the code below
    is cross-compatible with 1.4 and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has for many years developed a convention for SQL constructs accepting
    an argument either as a list or as positional arguments. This convention states
    that **structural** elements, those that form the structure of a SQL statement,
    should be passed **positionally**. Conversely, **data** elements, those that form
    the parameterized data of a SQL statement, should be passed **as lists**. For
    many years, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct could not participate in this convention
    smoothly because of the very legacy calling pattern where the “WHERE” clause would
    be passed positionally. SQLAlchemy 2.0 finally resolves this by changing the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to only accept the “generative”
    style that has for many years been the only documented style in the Core tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of “structural” vs. “data” elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[select(), case() now accept positional expressions](migration_14.html#change-5284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[select() construct created in “legacy” mode; keyword arguments, etc.](../errors.html#error-c9ae)'
  prefs: []
  type: TYPE_NORMAL
- en: insert/update/delete DML no longer accept keyword constructor arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way as to the previous change to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), the constructor arguments to [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") other than the table argument are essentially
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples illustrate generative method use for the above examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The API and internals is being simplified for the DML constructs in a similar
    manner as that of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - ORM Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declarative becomes a first class API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlalchemy.ext.declarative` package is mostly, with some exceptions, moved
    to the `sqlalchemy.orm` package. The [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") and [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions are present without any behavioral changes.
    A new super-implementation of [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") known as [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") now serves as the top-level ORM configurational construct,
    which also provides for decorator-based declarative and new support for classical
    mappings that integrate with the declarative registry.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: After ten years or so of popularity, the `sqlalchemy.ext.declarative` package
    is now integrated into the `sqlalchemy.orm` namespace, with the exception of the
    declarative “extension” classes which remain as Declarative extensions. The change
    is detailed further in the 1.4 migration guide at [Declarative is now integrated
    into the ORM with new features](migration_14.html#change-5508).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html) - all new unified documentation
    for Declarative, classical mapping, dataclasses, attrs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative is now integrated into the ORM with new features](migration_14.html#change-5508)'
  prefs: []
  type: TYPE_NORMAL
- en: The original “mapper()” function now a core element of Declarative, renamed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlalchemy.orm.mapper()` standalone function moves behind the scenes to
    be invoked by higher level APIs. The new version of this function is the method
    [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") taken from a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code that works with classical mappings should change imports and code from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To work from a central [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    is also the source for declarative mappings, and classical mappings now have access
    to this registry including string-based configuration on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: By popular demand, “classical mapping” is staying around, however the new form
    of it is based off of the [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object and is available as [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the primary rationale used for “classical mapping” is that of keeping
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    setup distinct from the class. Declarative has always allowed this style using
    so-called [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration).
    However, to remove the base class requirement, a first class [decorator](../orm/declarative_mapping.html)
    form has been added.
  prefs: []
  type: TYPE_NORMAL
- en: As yet another separate but related enhancement, support for [Python dataclasses](../orm/dataclasses.html#orm-declarative-dataclasses)
    is added as well to both declarative decorator and classical mapping forms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html) - all new unified documentation
    for Declarative, classical mapping, dataclasses, attrs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 2.0 Migration - ORM Usage'
  prefs: []
  type: TYPE_NORMAL
- en: The biggest visible change in SQLAlchemy 2.0 is the use of [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in conjunction with [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") to run ORM queries, instead of using [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query"). As mentioned elsewhere, there is no plan to actually
    remove the [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query") API itself, as it is now implemented by using
    the new API internally it will remain as a legacy API, and both APIs can be used
    freely.
  prefs: []
  type: TYPE_NORMAL
- en: The table below provides an introduction to the general change in calling form
    with links to documentation for each technique presented. The individual migration
    notes are in the embedded sections following the table, and may include additional
    notes not summarized here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of Major ORM Querying Patterns**'
  prefs: []
  type: TYPE_NORMAL
- en: '| [1.x style](../glossary.html#term-1.x-style) form | [2.0 style](../glossary.html#term-2.0-style)
    form | See Also |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query - get() method moves to Session](#migration-20-get-to-session)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[`Result.first()`](../core/connections.html#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Rows not uniquified by default](#joinedload-not-uniqued) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| [Getting ORM Results from Textual Statements](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Execution Options](../orm/queryguide/api.html#orm-queryguide-execution-options)[Populate
    Existing](../orm/queryguide/api.html#orm-queryguide-populate-existing) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM-Enabled INSERT, UPDATE, and DELETE statements](../orm/queryguide/dml.html#orm-expression-update-delete)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '| [`Session.scalar()`](../orm/session_api.html#sqlalchemy.orm.Session.scalar
    "sqlalchemy.orm.Session.scalar") |'
  prefs: []
  type: TYPE_TB
- en: '### ORM Query Unified with Core Select'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object (as well as the [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") and [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extensions) become long term legacy
    objects, replaced by the direct usage of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct in conjunction with the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. Results that are returned from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in the form of lists of objects or tuples, or as scalar
    ORM objects are returned from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") uniformly as [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, which feature an interface consistent with
    that of Core execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Legacy code examples are illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Because the vast majority of an ORM application is expected to make use of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects as well as that the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") interface being available does not impact the new interface,
    the object will stay around in 2.0 but will no longer be part of documentation
    nor will it be supported for the most part. The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct now suits both the Core and ORM
    use cases, which when invoked via the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method will return ORM-oriented results, that
    is, ORM objects if that’s what was requested.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Select()`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct **adds many new methods** for compatibility with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Select.filter()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter
    "sqlalchemy.sql.expression.Select.filter") [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by"), newly reworked [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") methods, [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options"), etc. Other more supplemental methods
    of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    such as [`Query.populate_existing()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") are implemented via execution options.
  prefs: []
  type: TYPE_NORMAL
- en: Return results are in terms of a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, the new version of the SQLAlchemy `ResultProxy`
    object, which also adds many new methods for compatibility with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one"), [`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all
    "sqlalchemy.engine.Result.all"), [`Result.first()`](../core/connections.html#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first"), [`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object however does require some different calling patterns, in that when first
    returned it will **always return tuples** and it will **not deduplicate results
    in memory**. In order to return single ORM objects the way [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") does, the [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") modifier must be called first. In order to
    return uniqued objects, as is necessary when using joined eager loading, the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") modifier must be called first.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for all new features of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") including execution options, etc. are at [ORM
    Querying Guide](../orm/queryguide/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below are some examples of how to migrate to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that SQLAlchemy has both a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct as well as a separate [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object that features an extremely similar, but fundamentally
    incompatible interface is likely the greatest inconsistency in SQLAlchemy, one
    that arose as a result of small incremental additions over time that added up
    to two major APIs that are divergent.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy’s first releases, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object didn’t exist at all. The original idea was that
    the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct itself would be able to select rows, and that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not classes, would be used to create the various
    criteria in a Core-style approach. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") came along some months / years into SQLAlchemy’s history
    as a user proposal for a new, “buildable” querying object originally called `SelectResults`
    was accepted. Concepts like a `.where()` method, which `SelectResults` called
    `.filter()`, were not present in SQLAlchemy previously, and the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct used only the “all-at-once” construction
    style that’s now deprecated at [select() no longer accepts varied constructor
    arguments, columns are passed positionally](#migration-20-5284).
  prefs: []
  type: TYPE_NORMAL
- en: As the new approach took off, the object evolved into the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as new features such as being able to select individual
    columns, being able to select multiple entities at once, being able to build subqueries
    from a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object rather than from a [`select`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object were added. The goal became that [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should have the full functionality of [`select`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in that it could be composed to build SELECT
    statements fully with no explicit use of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") needed. At the same time, [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") had also evolved “generative” methods like
    [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  prefs: []
  type: TYPE_NORMAL
- en: In modern SQLAlchemy, this goal has been achieved and the two objects are now
    completely overlapping in functionality. The major challenge to unifying these
    objects was that the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object needed to remain **completely agnostic
    of the ORM**. To achieve this, the vast majority of logic from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") has been moved into the SQL compile phase, where ORM-specific
    compiler plugins receive the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct and interpret its contents in terms
    of an ORM-style query, before passing off to the core-level compiler in order
    to create a SQL string. With the advent of the new [SQL compilation caching system](migration_14.html#change-4639),
    the majority of this ORM logic is also cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query is internally unified with select, update, delete; 2.0 style execution
    available](migration_14.html#change-5159)  ### ORM Query - get() method moves
    to Session'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get "sqlalchemy.orm.Query.get")
    method remains for legacy purposes, but the primary interface is now the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1.4 / 2.0, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object adds a new [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object is to be a legacy object in 2.0, as ORM queries are now available using
    the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    object. As the [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get
    "sqlalchemy.orm.Query.get") method defines a special interaction with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and does not necessarily even emit a query, it’s more
    appropriate that it be part of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where it is similar to other “identity” methods such
    as [`refresh`](../orm/session_api.html#sqlalchemy.orm.Session.refresh "sqlalchemy.orm.Session.refresh")
    and [`merge`](../orm/session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge").
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy originally included “get()” to resemble the Hibernate `Session.load()`
    method. As is so often the case, we got it slightly wrong as this method is really
    more about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    than with writing a SQL query.  ### ORM Query - Joining / loading on relationships
    uses attributes, not strings'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This refers to patterns such as that of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") as well as query options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") which currently accept a mixture of string attribute
    names or actual class attributes. The string forms will all be removed in 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern SQLAlchemy 1.x versions support the recommended technique which is to
    use mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The same techniques apply to [2.0-style](../glossary.html#term-1) style use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The string calling form is ambiguous and requires that the internals do extra
    work to determine the appropriate path and retrieve the correct mapped property.
    By passing the ORM mapped attribute directly, not only is the necessary information
    passed up front, the attribute is also typed and is more potentially compatible
    with IDEs and pep-484 integrations.
  prefs: []
  type: TYPE_NORMAL
- en: ORM Query - Chaining using lists of attributes, rather than individual calls,
    removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: '“Chained” forms of joining and loader options which accept multiple mapped
    attributes in a list will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use individual calls to [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") for 1.x /2.0 cross compatible use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For [2.0-style](../glossary.html#term-1) use, [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") has the same behavior of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), and also features a new [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method that allows an explicit left
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the chaining of attributes is in line with simplifying the calling
    interface of methods such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Query - join(…, aliased=True), from_joinpoint removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aliased=True` option on [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is removed, as is the `from_joinpoint` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use explicit aliases instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The `aliased=True` option on [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is another feature that seems to be almost never
    used, based on extensive code searches to find actual use of this feature. The
    internal complexity that the `aliased=True` flag requires is **enormous**, and
    will be going away in 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Most users aren’t familiar with this flag, however it allows for automatic aliasing
    of elements along a join, which then applies automatic aliasing to filter conditions.
    The original use case was to assist in long chains of self-referential joins,
    as in the example shown above. However, the automatic adaption of the filter criteria
    is enormously complicated internally and almost never used in real world applications.
    The pattern also leads to issues such as if filter criteria need to be added at
    each link in the chain; the pattern then must use the `from_joinpoint` flag which
    SQLAlchemy developers could absolutely find no occurrence of this parameter ever
    being used in real world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aliased=True` and `from_joinpoint` parameters were developed at a time
    when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object didn’t yet have good capabilities regarding joining along relationship
    attributes, functions like [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") did not exist, and the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct itself didn’t exist early on.  ### Using DISTINCT
    with additional columns, but only select the entity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    will automatically add columns in the ORDER BY when distinct is used. The following
    query will select from all User columns as well as “address.email_address” but
    only return User objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In version 2.0, the “email_address” column will not be automatically added to
    the columns clause, and the above query will fail, since relational databases
    won’t allow you to ORDER BY “address.email_address” when using DISTINCT if it
    isn’t also in the columns clause.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2.0, the column must be added explicitly. To resolve the issue of only returning
    the main entity object, and not the extra column, use the [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: This case is an example of the limited flexibility of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") leading to the case where implicit, “magical” behavior
    needed to be added; the “email_address” column is implicitly added to the columns
    clause, then additional internal logic would omit that column from the actual
    results returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new approach simplifies the interaction and makes what’s going on explicit,
    while still making it possible to fulfill the original use case without inconvenience.  ###
    Selecting from the query itself as a subquery, e.g. “from_self()”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query.from_self()` method will be removed from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct may be used to emit ORM queries against an entity that is in terms of
    any arbitrary selectable. It has been enhanced in version 1.4 to smoothly accommodate
    being used multiple times against the same subquery for different entities as
    well. This can be used in [1.x style](../glossary.html#term-1.x-style) with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") as below; note that since the final query wants to query
    in terms of both the `User` and `Address` entities, two separate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The same form may be used in [2.0 style](../glossary.html#term-2.0-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Query.from_self()` method is a very complicated method that is rarely used.
    The purpose of this method is to convert a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") into a subquery, then return a new [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") which SELECTs from that subquery. The elaborate aspect
    of this method is that the returned query applies automatic translation of ORM
    entities and columns to be stated in the SELECT in terms of the subquery, as well
    as that it allows the entities and columns to be SELECTed from to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Because `Query.from_self()` packs an intense amount of implicit translation
    into the SQL it produces, while it does allow a certain kind of pattern to be
    executed very succinctly, real world use of this method is infrequent as it is
    not simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The new approach makes use of the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct so that the ORM internals don’t need to guess
    which entities and columns should be adapted and in what way; in the example above,
    the `ua` and `aa` objects, both of which are `AliasedClass` instances, provide
    to the internals an unambiguous marker as to where the subquery should be referenced
    as well as what entity column or relationship is being considered for a given
    component of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.4 also features an improved labeling style that no longer requires
    the use of long labels that include the table name in order to disambiguate columns
    of same names from different tables. In the above examples, even if our `User`
    and `Address` entities have overlapping column names, we can select from both
    entities at once without having to specify any particular labeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query will disambiguate the `.id` column of `User` and `Address`,
    where `Address.id` is rendered and tracked as `id_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[#5221](https://www.sqlalchemy.org/trac/ticket/5221)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting entities from alternative selectables; Query.select_entity_from()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query.select_entity_from()` method will be removed in 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case described at [Selecting from the query itself as a subquery,
    e.g. “from_self()”](#migration-20-query-from-self), the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object provides a single place that operations like
    “select entity from a subquery” may be achieved. Using [1.x style](../glossary.html#term-1.x-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Using [2.0 style](../glossary.html#term-2.0-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The points here are basically the same as those discussed at [Selecting from
    the query itself as a subquery, e.g. “from_self()”](#migration-20-query-from-self).
    The `Query.select_from_entity()` method was another way to instruct the query
    to load rows for a particular ORM mapped entity from an alternate selectable,
    which involved having the ORM apply automatic aliasing to that entity wherever
    it was used in the query later on, such as in the WHERE clause or ORDER BY. This
    intensely complex feature is seldom used in this way, where as was the case with
    `Query.from_self()`, it’s much easier to follow what’s going on when using an
    explicit [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, both from a user point of view as well as how the internals of the SQLAlchemy
    ORM must handle it.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Rows not uniquified by default'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM rows returned by `session.execute(stmt)` are no longer automatically “uniqued”.
    This will normally be a welcome change, except in the case where the “joined eager
    loading” loader strategy is used with collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '**Migrating to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a joined load of a collection, it’s required that the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method is called. The ORM will actually set
    a default row handler that will raise an error if this is not done, to ensure
    that a joined eager load collection does not return duplicate rows while still
    maintaining explicitness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The situation here is a little bit unusual, in that SQLAlchemy is requiring
    that a method be invoked that it is in fact entirely capable of doing automatically.
    The reason for requiring that the method be called is to ensure the developer
    is “opting in” to the use of the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method, such that they will not be confused
    when a straight count of rows does not conflict with the count of records in the
    actual result set, which has been a long running source of user confusion and
    bug reports for many years. That the uniquifying is not happening in any other
    case by default will improve performance and also improve clarity in those cases
    where automatic uniquing was causing confusing results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the degree that having to call [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") when joined eager load collections are used
    is inconvenient, in modern SQLAlchemy the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") strategy presents a collection-oriented eager loader
    that is superior in most respects to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and should be preferred.  ### “Dynamic” relationship
    loaders superseded by “Write Only”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `lazy="dynamic"` relationship loader strategy, discussed at [Dynamic Relationship
    Loaders](../orm/large_collections.html#dynamic-relationship), makes use of the
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object which is legacy in 2.0\. The “dynamic” relationship is not directly compatible
    with asyncio without workarounds, and additionally it does not fulfill its original
    purpose of preventing iteration of large collections as it has several behaviors
    where this iteration occurs implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A new loader strategy known as `lazy="write_only"` is introduced, which through
    the [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") collection class provides a very strict
    “no implicit iteration” API and additionally integrates with 2.0 style statement
    execution, supporting asyncio as well as direct integrations with the new [ORM-enabled
    Bulk DML](whatsnew_20.html#change-8360) featureset.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, `lazy="dynamic"` remains **fully supported** in version 2.0;
    applications can delay migrating this particular pattern until they are fully
    on the 2.0 series.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: The new “write only” feature is only available in SQLAlchemy 2.0, and is not
    part of 1.4\. At the same time, the `lazy="dynamic"` loader strategy remains fully
    supported in version 2.0, and even includes new pep-484 and annotated mapping
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore the best strategy for migrating from “dynamic” is to **wait until
    the application is fully running on 2.0**, then migrate directly from [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery"), which is the collection type used by the “dynamic”
    strategy, to [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection"), which is the collection type used by hte
    “write_only” strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some techniques are available to use `lazy="dynamic"` under 1.4 in a more “2.0”
    style however. There are two ways to achieve 2.0 style querying that’s in terms
    of a specific relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make use of the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") attribute on an existing `lazy="dynamic"` relationship.
    We can use methods like [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") with the dynamic loader straight away as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") function to construct a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The original idea was that the [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") function should be sufficient, however continuing
    to make use of special attributes on the relationship itself remains appealing,
    and there’s no reason a 2.0 style construct can’t be made to work here as well.
  prefs: []
  type: TYPE_NORMAL
- en: The new “write_only” loader strategy provides a new kind of collection which
    does not support implicit iteration or item access. Instead, reading the contents
    of the collection is performed by calling upon its `.select()` method to help
    construct an appropriate SELECT statement. The collection also includes methods
    `.insert()`, `.update()`, `.delete()` which may be used to emit bulk DML statements
    for the items in the collection. In a manner similar to that of the “dynamic”
    feature, there are also methods `.add()`, `.add_all()` and `.remove()` which queue
    individual members for addition or removal using the unit of work process. An
    introduction to the new feature is as [New “Write Only” relationship strategy
    supersedes “dynamic”](whatsnew_20.html#change-7123).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[New “Write Only” relationship strategy supersedes “dynamic”](whatsnew_20.html#change-7123)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)  ###
    Autocommit mode removed from Session; autobegin support added'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will no longer support “autocommit” mode, that is, this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in “autocommit” mode is so that the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is available, so that framework integrations
    and event hooks can control when this event happens. In 1.4, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now features [autobegin behavior](migration_14.html#change-5074)
    which resolves this issue; the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method may now be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “autocommit” mode is another holdover from the first versions of SQLAlchemy.
    The flag has stayed around mostly in support of allowing explicit use of [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"), which is now solved by 1.4, as well as to allow
    the use of “subtransactions”, which are also removed in 2.0.  ### Session “subtransaction”
    behavior removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The “subtransaction” pattern that was often used with autocommit mode is also
    deprecated in 1.4\. This pattern allowed the use of the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method when a transaction were already begun,
    resulting in a construct called a “subtransaction”, which was essentially a block
    that would prevent the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method from actually committing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide backwards compatibility for applications that make use of this pattern,
    the following context manager or a similar implementation based on a decorator
    may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The above context manager may be used in the same way the “subtransaction”
    flag works, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare towards the preferred idiomatic pattern, the begin block should
    be at the outermost level. This removes the need for individual functions or methods
    to be concerned with the details of transaction demarcation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern has been shown to be confusing in real world applications, and
    it is preferable for an application to ensure that the top-most level of database
    operations are performed with a single begin/commit pair.
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - ORM Extension and Recipe Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dogpile cache recipe and Horizontal Sharding uses new Session API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object becomes legacy, these two recipes which previously relied upon subclassing
    of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object now make use of the [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook. See the section [Re-Executing
    Statements](../orm/session_events.html#do-orm-execute-re-executing) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Baked Query Extension Superseded by built-in caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The baked query extension is superseded by the built in caching system and is
    no longer used by the ORM internals.
  prefs: []
  type: TYPE_NORMAL
- en: See [SQL Compilation Caching](../core/connections.html#sql-caching) for full
    background on the new caching system.
  prefs: []
  type: TYPE_NORMAL
- en: Asyncio Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 includes asyncio support for both Core and ORM. The new API exclusively
    makes use of the “future” patterns noted above. See [Asynchronous IO Support for
    Core and ORM](migration_14.html#change-3414) for background.
  prefs: []
  type: TYPE_NORMAL
- en: The 1.4->2.0 Migration Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most prominent architectural features and API changes that are considered
    to be “SQLAlchemy 2.0” were in fact released as fully available within the 1.4
    series, to provide for a clean upgrade path from the 1.x to the 2.x series as
    well as to serve as a beta platform for the features themselves. These changes
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[New ORM statement paradigm](migration_14.html#change-5159)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL caching throughout Core and ORM](migration_14.html#change-4639)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[New Declarative features, ORM integration](migration_14.html#change-5508)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[New Result object](migration_14.html#change-result-14-core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[select() / case() Accept Positional Expressions](migration_14.html#change-5284)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asyncio support for Core and ORM](migration_14.html#change-3414)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above bullets link to the description of these new paradigms as introduced
    in SQLAlchemy 1.4\. in the [What’s New in SQLAlchemy 1.4?](migration_14.html)
    document.
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQLAlchemy 2.0, all API features and behaviors that were marked as [deprecated
    for 2.0](migration_14.html#deprecation-20-mode) are now finalized; in particular,
    major APIs that are **no longer present** include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bound MetaData and connectionless execution](#migration-20-implicit-execution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Emulated autocommit on Connection](#migration-20-autocommit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Session.autocommit parameter / mode](#migration-20-session-autocommit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List / keyword arguments to select()](#migration-20-5284)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2 support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above bullets refer to the most prominent fully backwards-incompatible changes
    that are finalized in the 2.0 release. The migration path for applications to
    accommodate for these changes as well as others is framed as a transition path
    first into the 1.4 series of SQLAlchemy where the “future” APIs are available
    to provide for the “2.0” way of working, and then to the 2.0 series where the
    no-longer-used APIs above and others are removed.
  prefs: []
  type: TYPE_NORMAL
- en: The complete steps for this migration path are later in this document at [1.x
    -> 2.x Migration Overview](#migration-20-overview).
  prefs: []
  type: TYPE_NORMAL
- en: '## 1.x -> 2.x Migration Overview'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy 2.0 transition presents itself in the SQLAlchemy 1.4 release
    as a series of steps that allow an application of any size or complexity to be
    migrated to SQLAlchemy 2.0 using a gradual, iterative process. Lessons learned
    from the Python 2 to Python 3 transition have inspired a system that intends to
    as great a degree as possible to not require any “breaking” changes, or any change
    that would need to be made universally or not at all.
  prefs: []
  type: TYPE_NORMAL
- en: As a means of both proving the 2.0 architecture as well as allowing a fully
    iterative transition environment, the entire scope of 2.0’s new APIs and features
    are present and available within the 1.4 series; this includes major new areas
    of functionality such as the SQL caching system, the new ORM statement execution
    model, new transactional paradigms for both ORM and Core, a new ORM declarative
    system that unifies classical and declarative mapping, support for Python dataclasses,
    and asyncio support for Core and ORM.
  prefs: []
  type: TYPE_NORMAL
- en: The steps to achieve 2.0 migration are in the following subsections; overall,
    the general strategy is that once an application runs on 1.4 with all warning
    flags turned on and does not emit any 2.0-deprecation warnings, it is now **mostly**
    cross-compatible with SQLAlchemy 2.0\. **Please note there may be additional API
    and behavioral changes that may behave differently when running against SQLAlchemy
    2.0; always test code against an actual SQLAlchemy 2.0 release as the final step
    in migrating**.
  prefs: []
  type: TYPE_NORMAL
- en: First Prerequisite, step one - A Working 1.3 Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is getting an existing application onto 1.4, in the case of a
    typical non trivial application, is to ensure it runs on SQLAlchemy 1.3 with no
    deprecation warnings. Release 1.4 does have a few changes linked to conditions
    that warn in previous version, including some warnings that were introduced in
    1.3, in particular some changes to the behavior of the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") and [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flags.
  prefs: []
  type: TYPE_NORMAL
- en: For best results, the application should be able to run, or pass all of its
    tests, with the latest SQLAlchemy 1.3 release with no SQLAlchemy deprecation warnings;
    these are warnings emitted for the [`SADeprecationWarning`](../core/exceptions.html#sqlalchemy.exc.SADeprecationWarning
    "sqlalchemy.exc.SADeprecationWarning") class.
  prefs: []
  type: TYPE_NORMAL
- en: First Prerequisite, step two - A Working 1.4 Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the application is good to go on SQLAlchemy 1.3, the next step is to get
    it running on SQLAlchemy 1.4\. In the vast majority of cases, applications should
    run without problems from SQLAlchemy 1.3 to 1.4\. However, it’s always the case
    between any 1.x and 1.y release, APIs and behaviors have changed either subtly
    or in some cases a little less subtly, and the SQLAlchemy project always gets
    a good deal of regression reports for the first few months.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 1.x->1.y release process usually has a few changes around the margins that
    are a little bit more dramatic and are based around use cases that are expected
    to be very seldom if at all used. For 1.4, the changes identified as being in
    this realm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The URL object is now immutable](migration_14.html#change-5526) - this impacts
    code that would be manipulating the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object and may impact code that makes use of the [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") extension point. This is an uncommon case
    but may affect in particular some test suites that are making use of special database
    provisioning logic. A github search for code that uses the relatively new and
    little-known [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") class found two projects that were unaffected
    by the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](migration_14.html#change-4617)
    - this change may impact code that was somehow relying upon behavior that was
    mostly unusable in the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, where it would create unnamed subqueries
    that were usually confusing and non-working. These subqueries would be rejected
    by most databases in any case as a name is usually required except on SQLite,
    however it is possible some applications will need to adjust some queries that
    are inadvertently relying upon this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[select().join() and outerjoin() add JOIN criteria to the current query, rather
    than creating a subquery](migration_14.html#change-select-join) - somewhat related,
    the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    class featured `.join()` and `.outerjoin()` methods that implicitly created a
    subquery and then returned a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct, which again would be mostly useless
    and produced lots of confusion. The decision was made to move forward with the
    vastly more useful 2.0-style join-building approach where these methods now work
    the same way as the ORM [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Many Core and ORM statement objects now perform much of their construction
    and validation in the compile phase](migration_14.html#change-deferred-construction)
    - some error messages related to construction of a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") or [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") may not be emitted until compilation / execution,
    rather than at construction time. This might impact some test suites that are
    testing against failure modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full overview of SQLAlchemy 1.4 changes, see the [What’s New in SQLAlchemy
    1.4?](migration_14.html) document.
  prefs: []
  type: TYPE_NORMAL
- en: Migration to 2.0 Step One - Python 3 only (Python 3.7 minimum for 2.0 compatibility)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 was first inspired by the fact that Python 2’s EOL was in 2020.
    SQLAlchemy is taking a longer period of time than other major projects to drop
    Python 2.7 support. However, in order to use SQLAlchemy 2.0, the application will
    need to be runnable on at least **Python 3.7**. SQLAlchemy 1.4 supports Python
    3.6 or newer within the Python 3 series; throughout the 1.4 series, the application
    can remain running on Python 2.7 or on at least Python 3.6\. Version 2.0 however
    starts at Python 3.7.
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Two - Turn on RemovedIn20Warnings'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 features a conditional deprecation warning system inspired by
    the Python “-3” flag that would indicate legacy patterns in a running application.
    For SQLAlchemy 1.4, the `RemovedIn20Warning` deprecation class is emitted only
    when an environment variable `SQLALCHEMY_WARN_20` is set to either of `true` or
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the example program below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program uses several patterns that many users will already identify
    as “legacy”, namely the use of the `Engine.execute()` method that’s part of the
    “connectionless execution” API. When we run the above program against 1.4, it
    returns a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable “2.0 deprecations mode”, we enable the `SQLALCHEMY_WARN_20=1` variable,
    and additionally ensure that a [warnings filter](https://docs.python.org/3/library/warnings.html#the-warnings-filter)
    that will not suppress any warnings is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Since the reported warning location is not always in the correct place, locating
    the offending code may be difficult without the full stacktrace. This can be achieved
    by transforming the warnings to exceptions by specifying the `error` warning filter,
    using Python option `-W error::DeprecationWarning`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With warnings turned on, our program now has a lot to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above guidance, we can migrate our program to use 2.0 styles, and
    as a bonus our program is much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The goal of “2.0 deprecations mode” is that a program which runs with no `RemovedIn20Warning`
    warnings with “2.0 deprecations mode” turned on is then ready to run in SQLAlchemy
    2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Migration to 2.0 Step Three - Resolve all RemovedIn20Warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Code can be developed iteratively to resolve these warnings. Within the SQLAlchemy
    project itself, the approach taken is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: enable the `SQLALCHEMY_WARN_20=1` environment variable in the test suite, for
    SQLAlchemy this is in the tox.ini file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the setup for the test suite, set up a series of warnings filters that
    will select for particular subsets of warnings to either raise an exception, or
    to be ignored (or logged). Work with just one subgroup of warnings at a time.
    Below, a warnings filter is configured for an application where the change to
    the Core level `.execute()` calls will be needed in order for all tests to pass,
    but all other 2.0-style warnings will be suppressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As each sub-category of warnings are resolved in the application, new warnings
    that are caught by the “always” filter can be added to the list of “errors” to
    be resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once no more warnings are emitted, the filter can be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migration to 2.0 Step Four - Use the `future` flag on Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object features an updated transaction-level API in version 2.0\. In 1.4, this
    new API is available by passing the flag `future=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag is used, the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects support the 2.0 API fully and not at all
    any legacy features, including the new argument format for [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), the removal of “implicit autocommit”,
    string statements require the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct unless the [`Connection.exec_driver_sql()`](../core/connections.html#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method is used, and connectionless
    execution from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is removed.
  prefs: []
  type: TYPE_NORMAL
- en: If all `RemovedIn20Warning` warnings have been resolved regarding use of the
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    then the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag may be enabled and there should be no errors
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new engine is described at [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which delivers a new [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. In addition to the above changes, the,
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object features [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, to support the new “commit-as-you-go”
    mode of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Migration to 2.0 Step Five - Use the `future` flag on Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object also features an updated transaction/connection level API in version 2.0\.
    This API is available in 1.4 using the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag on [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or on [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker").
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object supports “future” mode in place, and involves these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer supports “bound metadata” when it resolves the engine to be used for
    connectivity. This means that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object **must** be passed to the constructor (this
    may be either a legacy or future style object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.begin.subtransactions`](../orm/session_api.html#sqlalchemy.orm.Session.begin.params.subtransactions
    "sqlalchemy.orm.Session.begin") flag is no longer supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method always emits a COMMIT to the database,
    rather than attempting to reconcile “subtransactions”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method always rolls back the full stack of
    transactions at once, rather than attempting to keep “subtransactions” in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    also supports more flexible creational patterns in 1.4 which are now closely matched
    to the patterns used by the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. Highlights include that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") object supports a [`sessionmaker.begin()`](../orm/session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") context manager that will create a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and begin /commit a transaction in one block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Session-level vs. Engine level transaction control](../orm/session_transaction.html#orm-session-vs-engine)
    for a comparison of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") creational patterns compared to those of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: Once the application passes all tests/ runs with `SQLALCHEMY_WARN_20=1` and
    all `exc.RemovedIn20Warning` occurrences set to raise an error, **the application
    is ready!**.
  prefs: []
  type: TYPE_NORMAL
- en: The sections that follow will detail the specific changes to make for all major
    API modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Six - Add `__allow_unmapped__` to explicitly typed
    ORM models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 has new support for runtime interpretation of [**PEP 484**](https://peps.python.org/pep-0484/)
    typing annotations on ORM models. A requirement of these annotations is that they
    must make use of the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    generic container. Annotations which don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") which link to constructs such as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") will raise errors in Python, as they suggest mis-configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to these errors, as
    would occur in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Foo.bars` and `Bar.foo` [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations will raise an error at class construction
    time because they don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") (by contrast, the annotations that use [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") are ignored by 2.0, as these are able to be recognized
    as a legacy configuration style). To allow all annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to pass without error, the `__allow_unmapped__` attribute
    may be used on the class or any subclasses, which will cause the annotations in
    these cases to be ignored completely by the new Declarative system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `__allow_unmapped__` directive applies **only** to the *runtime* behavior
    of the ORM. It does not affect the behavior of Mypy, and the above mapping as
    written still requires that the Mypy plugin be installed. For fully 2.0 style
    ORM models that will type correctly under Mypy *without* a plugin, follow the
    migration steps at [Migrating an Existing Mapping](whatsnew_20.html#whatsnew-20-orm-typing-migration).
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates the application of `__allow_unmapped__` to the
    Declarative `Base` class, where it will take effect for all classes that descend
    from `Base`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0beta3: - improved the `__allow_unmapped__` attribute
    support to allow for 1.4-style explicit annotated relationships that don’t use
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    to remain usable.  ### Migration to 2.0 Step Seven - Test against a SQLAlchemy
    2.0 Release'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, SQLAlchemy 2.0 has additional API and behavioral changes
    that are intended to be backwards compatible, however may introduce some incompatibilities
    nonetheless. Therefore after the overall porting process is complete, the final
    step is to test against the most recent release of SQLAlchemy 2.0 to correct for
    any remaining issues that might be present.
  prefs: []
  type: TYPE_NORMAL
- en: The guide at [What’s New in SQLAlchemy 2.0?](whatsnew_20.html) provides an overview
    of new features and behaviors for SQLAlchemy 2.0 which extend beyond the base
    set of 1.4->2.0 API changes.
  prefs: []
  type: TYPE_NORMAL
- en: First Prerequisite, step one - A Working 1.3 Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is getting an existing application onto 1.4, in the case of a
    typical non trivial application, is to ensure it runs on SQLAlchemy 1.3 with no
    deprecation warnings. Release 1.4 does have a few changes linked to conditions
    that warn in previous version, including some warnings that were introduced in
    1.3, in particular some changes to the behavior of the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") and [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flags.
  prefs: []
  type: TYPE_NORMAL
- en: For best results, the application should be able to run, or pass all of its
    tests, with the latest SQLAlchemy 1.3 release with no SQLAlchemy deprecation warnings;
    these are warnings emitted for the [`SADeprecationWarning`](../core/exceptions.html#sqlalchemy.exc.SADeprecationWarning
    "sqlalchemy.exc.SADeprecationWarning") class.
  prefs: []
  type: TYPE_NORMAL
- en: First Prerequisite, step two - A Working 1.4 Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the application is good to go on SQLAlchemy 1.3, the next step is to get
    it running on SQLAlchemy 1.4\. In the vast majority of cases, applications should
    run without problems from SQLAlchemy 1.3 to 1.4\. However, it’s always the case
    between any 1.x and 1.y release, APIs and behaviors have changed either subtly
    or in some cases a little less subtly, and the SQLAlchemy project always gets
    a good deal of regression reports for the first few months.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 1.x->1.y release process usually has a few changes around the margins that
    are a little bit more dramatic and are based around use cases that are expected
    to be very seldom if at all used. For 1.4, the changes identified as being in
    this realm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The URL object is now immutable](migration_14.html#change-5526) - this impacts
    code that would be manipulating the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object and may impact code that makes use of the [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") extension point. This is an uncommon case
    but may affect in particular some test suites that are making use of special database
    provisioning logic. A github search for code that uses the relatively new and
    little-known [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") class found two projects that were unaffected
    by the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A SELECT statement is no longer implicitly considered to be a FROM clause](migration_14.html#change-4617)
    - this change may impact code that was somehow relying upon behavior that was
    mostly unusable in the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct, where it would create unnamed subqueries
    that were usually confusing and non-working. These subqueries would be rejected
    by most databases in any case as a name is usually required except on SQLite,
    however it is possible some applications will need to adjust some queries that
    are inadvertently relying upon this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[select().join() and outerjoin() add JOIN criteria to the current query, rather
    than creating a subquery](migration_14.html#change-select-join) - somewhat related,
    the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    class featured `.join()` and `.outerjoin()` methods that implicitly created a
    subquery and then returned a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") construct, which again would be mostly useless
    and produced lots of confusion. The decision was made to move forward with the
    vastly more useful 2.0-style join-building approach where these methods now work
    the same way as the ORM [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Many Core and ORM statement objects now perform much of their construction
    and validation in the compile phase](migration_14.html#change-deferred-construction)
    - some error messages related to construction of a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") or [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") may not be emitted until compilation / execution,
    rather than at construction time. This might impact some test suites that are
    testing against failure modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full overview of SQLAlchemy 1.4 changes, see the [What’s New in SQLAlchemy
    1.4?](migration_14.html) document.
  prefs: []
  type: TYPE_NORMAL
- en: Migration to 2.0 Step One - Python 3 only (Python 3.7 minimum for 2.0 compatibility)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 was first inspired by the fact that Python 2’s EOL was in 2020.
    SQLAlchemy is taking a longer period of time than other major projects to drop
    Python 2.7 support. However, in order to use SQLAlchemy 2.0, the application will
    need to be runnable on at least **Python 3.7**. SQLAlchemy 1.4 supports Python
    3.6 or newer within the Python 3 series; throughout the 1.4 series, the application
    can remain running on Python 2.7 or on at least Python 3.6\. Version 2.0 however
    starts at Python 3.7.
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Two - Turn on RemovedIn20Warnings'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 features a conditional deprecation warning system inspired by
    the Python “-3” flag that would indicate legacy patterns in a running application.
    For SQLAlchemy 1.4, the `RemovedIn20Warning` deprecation class is emitted only
    when an environment variable `SQLALCHEMY_WARN_20` is set to either of `true` or
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the example program below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program uses several patterns that many users will already identify
    as “legacy”, namely the use of the `Engine.execute()` method that’s part of the
    “connectionless execution” API. When we run the above program against 1.4, it
    returns a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable “2.0 deprecations mode”, we enable the `SQLALCHEMY_WARN_20=1` variable,
    and additionally ensure that a [warnings filter](https://docs.python.org/3/library/warnings.html#the-warnings-filter)
    that will not suppress any warnings is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Since the reported warning location is not always in the correct place, locating
    the offending code may be difficult without the full stacktrace. This can be achieved
    by transforming the warnings to exceptions by specifying the `error` warning filter,
    using Python option `-W error::DeprecationWarning`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With warnings turned on, our program now has a lot to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above guidance, we can migrate our program to use 2.0 styles, and
    as a bonus our program is much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The goal of “2.0 deprecations mode” is that a program which runs with no `RemovedIn20Warning`
    warnings with “2.0 deprecations mode” turned on is then ready to run in SQLAlchemy
    2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Migration to 2.0 Step Three - Resolve all RemovedIn20Warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Code can be developed iteratively to resolve these warnings. Within the SQLAlchemy
    project itself, the approach taken is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: enable the `SQLALCHEMY_WARN_20=1` environment variable in the test suite, for
    SQLAlchemy this is in the tox.ini file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the setup for the test suite, set up a series of warnings filters that
    will select for particular subsets of warnings to either raise an exception, or
    to be ignored (or logged). Work with just one subgroup of warnings at a time.
    Below, a warnings filter is configured for an application where the change to
    the Core level `.execute()` calls will be needed in order for all tests to pass,
    but all other 2.0-style warnings will be suppressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As each sub-category of warnings are resolved in the application, new warnings
    that are caught by the “always” filter can be added to the list of “errors” to
    be resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once no more warnings are emitted, the filter can be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migration to 2.0 Step Four - Use the `future` flag on Engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    object features an updated transaction-level API in version 2.0\. In 1.4, this
    new API is available by passing the flag `future=True` to the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag is used, the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects support the 2.0 API fully and not at all
    any legacy features, including the new argument format for [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), the removal of “implicit autocommit”,
    string statements require the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct unless the [`Connection.exec_driver_sql()`](../core/connections.html#sqlalchemy.engine.Connection.exec_driver_sql
    "sqlalchemy.engine.Connection.exec_driver_sql") method is used, and connectionless
    execution from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is removed.
  prefs: []
  type: TYPE_NORMAL
- en: If all `RemovedIn20Warning` warnings have been resolved regarding use of the
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    and [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection"),
    then the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag may be enabled and there should be no errors
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new engine is described at [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which delivers a new [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. In addition to the above changes, the,
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object features [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, to support the new “commit-as-you-go”
    mode of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Migration to 2.0 Step Five - Use the `future` flag on Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object also features an updated transaction/connection level API in version 2.0\.
    This API is available in 1.4 using the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag on [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or on [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker").
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object supports “future” mode in place, and involves these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer supports “bound metadata” when it resolves the engine to be used for
    connectivity. This means that an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object **must** be passed to the constructor (this
    may be either a legacy or future style object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.begin.subtransactions`](../orm/session_api.html#sqlalchemy.orm.Session.begin.params.subtransactions
    "sqlalchemy.orm.Session.begin") flag is no longer supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method always emits a COMMIT to the database,
    rather than attempting to reconcile “subtransactions”.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method always rolls back the full stack of
    transactions at once, rather than attempting to keep “subtransactions” in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    also supports more flexible creational patterns in 1.4 which are now closely matched
    to the patterns used by the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object. Highlights include that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") object supports a [`sessionmaker.begin()`](../orm/session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") context manager that will create a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and begin /commit a transaction in one block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Session-level vs. Engine level transaction control](../orm/session_transaction.html#orm-session-vs-engine)
    for a comparison of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") creational patterns compared to those of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection").
  prefs: []
  type: TYPE_NORMAL
- en: Once the application passes all tests/ runs with `SQLALCHEMY_WARN_20=1` and
    all `exc.RemovedIn20Warning` occurrences set to raise an error, **the application
    is ready!**.
  prefs: []
  type: TYPE_NORMAL
- en: The sections that follow will detail the specific changes to make for all major
    API modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Six - Add `__allow_unmapped__` to explicitly typed
    ORM models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 has new support for runtime interpretation of [**PEP 484**](https://peps.python.org/pep-0484/)
    typing annotations on ORM models. A requirement of these annotations is that they
    must make use of the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    generic container. Annotations which don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") which link to constructs such as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") will raise errors in Python, as they suggest mis-configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to these errors, as
    would occur in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Foo.bars` and `Bar.foo` [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations will raise an error at class construction
    time because they don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") (by contrast, the annotations that use [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") are ignored by 2.0, as these are able to be recognized
    as a legacy configuration style). To allow all annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") to pass without error, the `__allow_unmapped__` attribute
    may be used on the class or any subclasses, which will cause the annotations in
    these cases to be ignored completely by the new Declarative system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `__allow_unmapped__` directive applies **only** to the *runtime* behavior
    of the ORM. It does not affect the behavior of Mypy, and the above mapping as
    written still requires that the Mypy plugin be installed. For fully 2.0 style
    ORM models that will type correctly under Mypy *without* a plugin, follow the
    migration steps at [Migrating an Existing Mapping](whatsnew_20.html#whatsnew-20-orm-typing-migration).
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates the application of `__allow_unmapped__` to the
    Declarative `Base` class, where it will take effect for all classes that descend
    from `Base`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0beta3: - improved the `__allow_unmapped__` attribute
    support to allow for 1.4-style explicit annotated relationships that don’t use
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    to remain usable.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Migration to 2.0 Step Seven - Test against a SQLAlchemy 2.0 Release'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, SQLAlchemy 2.0 has additional API and behavioral changes
    that are intended to be backwards compatible, however may introduce some incompatibilities
    nonetheless. Therefore after the overall porting process is complete, the final
    step is to test against the most recent release of SQLAlchemy 2.0 to correct for
    any remaining issues that might be present.
  prefs: []
  type: TYPE_NORMAL
- en: The guide at [What’s New in SQLAlchemy 2.0?](whatsnew_20.html) provides an overview
    of new features and behaviors for SQLAlchemy 2.0 which extend beyond the base
    set of 1.4->2.0 API changes.
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - Core Connection / Transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Library-level (but not driver level) “Autocommit” removed from both Core
    and ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy 1.x, the following statements will automatically commit the underlying
    DBAPI transaction, but in SQLAlchemy 2.0 this will not occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Nor will this autocommit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The common workaround for custom DML that requires commit, the “autocommit”
    execution option, will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that is cross-compatible with [1.x style](../glossary.html#term-1.x-style)
    and [2.0 style](../glossary.html#term-2.0-style) execution is to make use of the
    [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or the [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'When using [2.0 style](../glossary.html#term-2.0-style) with the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag, “commit as you go” style may also be used, as
    the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    features **autobegin** behavior, which takes place when a statement is first invoked
    in the absence of an explicit call to [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: When [2.0 deprecations mode](#migration-20-deprecations-mode) is enabled, a
    warning will emit when the deprecated “autocommit” feature takes place, indicating
    those places where an explicit transaction should be noted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s first releases were at odds with the spirit of the Python DBAPI
    ([**PEP 249**](https://peps.python.org/pep-0249/)) in that it tried to hide [**PEP
    249**](https://peps.python.org/pep-0249/)’s emphasis on “implicit begin” and “explicit
    commit” of transactions. Fifteen years later we now see this was essentially a
    mistake, as SQLAlchemy’s many patterns that attempt to “hide” the presence of
    a transaction make for a more complex API which works inconsistently and is extremely
    confusing to especially those users who are new to relational databases and ACID
    transactions in general. SQLAlchemy 2.0 will do away with all attempts to implicitly
    commit transactions, and usage patterns will always require that the user demarcate
    the “beginning” and the “end” of a transaction in some way, in the same way as
    reading or writing to a file in Python has a “beginning” and an “end”.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of autocommit for a pure textual statement, there is actually a
    regular expression that parses every statement in order to detect autocommit!
    Not surprisingly, this regex is continuously failing to accommodate for various
    kinds of statements and stored procedures that imply a “write” to the database,
    leading to ongoing confusion as some statements produce results in the database
    and others don’t. By preventing the user from being aware of the transactional
    concept, we get a lot of bug reports on this one because users don’t understand
    that databases always use a transaction, whether or not some layer is autocommitting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 2.0 will require that all database actions at every level be explicit
    as to how the transaction should be used. For the vast majority of Core use cases,
    it’s the pattern that is already recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'For “commit as you go, or rollback instead” usage, which resembles how the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is normally used today, the “future” version of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which is the one that is returned from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that was created using the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag, includes new [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, which act upon a transaction
    that is now begun automatically when a statement is first invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `engine.connect()` method will return a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that features **autobegin**, meaning the `begin()`
    event is emitted when the execute method is first used (note however that there
    is no actual “BEGIN” in the Python DBAPI). “autobegin” is a new pattern in SQLAlchemy
    1.4 that is featured both by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as well as the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; autobegin allows that the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method may be called explicitly when the
    object is first acquired, for schemes that wish to demarcate the beginning of
    the transaction, but if the method is not called, then it occurs implicitly when
    work is first done on the object.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of “autocommit” is closely related to the removal of “connectionless”
    execution discussed at [“Implicit” and “Connectionless” execution, “bound metadata”
    removed](#migration-20-implicit-execution). All of these legacy patterns built
    up from the fact that Python did not have context managers or decorators when
    SQLAlchemy was first created, so there were no convenient idiomatic patterns for
    demarcating the use of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Driver-level autocommit remains available
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'True “autocommit” behavior is now widely available with most DBAPI implementations,
    and is supported by SQLAlchemy via the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter as discussed at [Setting
    Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).
    True autocommit is treated as an “isolation level” so that the structure of application
    code does not change when autocommit is used; the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") context manager as well as methods like
    [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") may still be used, they are simply no-ops
    at the database driver level when DBAPI-level autocommit is turned on.  ### “Implicit”
    and “Connectionless” execution, “bound metadata” removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to associate an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, which then makes available a range of so-called
    “connectionless” execution patterns, is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For schema level patterns, explicit use of an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is required. The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") may still be used directly as the source of connectivity
    for a [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") operation or autoload operation. For
    executing statements, only the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object has a [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method (in addition to the ORM-level [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The Core documentation has already standardized on the desired pattern here,
    so it is likely that most modern applications would not have to change much in
    any case, however there are likely many applications that still rely upon `engine.execute()`
    calls that will need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '“Connectionless” execution refers to the still fairly popular pattern of invoking
    `.execute()` from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The above operation implicitly procures a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, and runs the `.execute()` method on it.
    While this appears to be a simple convenience feature, it has been shown to give
    rise to several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Programs that feature extended strings of `engine.execute()` calls have become
    prevalent, overusing a feature that was intended to be seldom used and leading
    to inefficient non-transactional applications. New users are confused as to the
    difference between `engine.execute()` and `connection.execute()` and the nuance
    between these two approaches is often not understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The feature relies upon the “application level autocommit” feature in order
    to make sense, which itself is also being removed as it is also [inefficient and
    misleading](#migration-20-autocommit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to handle result sets, `Engine.execute` returns a result object with
    unconsumed cursor results. This cursor result necessarily still links to the DBAPI
    connection which remains in an open transaction, all of which is released once
    the result set has fully consumed the rows waiting within the cursor. This means
    that `Engine.execute` does not actually close out the connection resources that
    it claims to be managing when the call is complete. SQLAlchemy’s “autoclose” behavior
    is well-tuned enough that users don’t generally report any negative effects from
    this system, however it remains an overly implicit and inefficient system left
    over from SQLAlchemy’s earliest releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The removal of “connectionless” execution then leads to the removal of an even
    more legacy pattern, that of “implicit, connectionless” execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The above pattern has all the issues of “connectionless” execution, plus it
    relies upon the “bound metadata” pattern, which SQLAlchemy has tried to de-emphasize
    for many years. This was SQLAlchemy’s very first advertised usage model in version
    0.1, which became obsolete almost immediately when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object was introduced and later Python context
    managers provided a better pattern for using resources within a fixed scope.
  prefs: []
  type: TYPE_NORMAL
- en: With implicit execution removed, “bound metadata” itself also no longer has
    a purpose within this system. In modern use “bound metadata” tends to still be
    somewhat convenient for working within [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") calls as well as with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects, however having these functions receive an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") explicitly provides for clearer application design.
  prefs: []
  type: TYPE_NORMAL
- en: Many Choices becomes One Choice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Overall, the above executional patterns were introduced in SQLAlchemy’s very
    first 0.1 release before the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object even existed. After many years of de-emphasizing
    these patterns, “implicit, connectionless” execution and “bound metadata” are
    no longer as widely used so in 2.0 we seek to finally reduce the number of choices
    for how to execute a statement in Core from “many choices”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'to “one choice”, where by “one choice” we mean “explicit connection with explicit
    transaction”; there are still a few ways to demarcate transaction blocks depending
    on need. The “one choice” is to procure a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and then to explicitly demarcate the transaction,
    in the case that the operation is a write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: execute() method more strict, execution options are more prominent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument patterns that may be used with the [`sqlalchemy.engine.Connection()`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") execute method in SQLAlchemy 2.0 are highly simplified,
    removing many previously available argument patterns. The new API in the 1.4 series
    is described at [`sqlalchemy.engine.Connection()`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). The examples below illustrate the patterns that
    require modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method now accepts a subset of the argument
    styles that are accepted by the 1.x [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, so the following code is cross-compatible
    between 1.x and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `*args` and `**kwargs` has been removed both to remove the complexity
    of guessing what kind of arguments were passed to the method, as well as to make
    room for other options, namely the [`Connection.execute.execution_options`](../core/connections.html#sqlalchemy.engine.Connection.execute.params.execution_options
    "sqlalchemy.engine.Connection.execute") dictionary that is now available to provide
    options on a per statement basis. The method is also modified so that its use
    pattern matches that of the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which is a much more prominent API in
    2.0 style.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of direct string SQL is to resolve an inconsistency between [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") and [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), where in the former case the string is passed
    to the driver raw, and in the latter case it is first converted to a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct. By allowing only [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") this also limits the accepted parameter format
    to “named” and not “positional”. Finally, the string SQL use case is becoming
    more subject to scrutiny from a security perspective, and the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct has come to represent an explicit
    boundary into the textual SQL realm where attention to untrusted user input must
    be given.
  prefs: []
  type: TYPE_NORMAL
- en: '### Result rows act like named tuples'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 1.4 introduces an [all new Result object](migration_14.html#change-result-14-core)
    that in turn returns [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, which behave like named tuples when using “future” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Application code or test suites that are testing for a particular key being
    present in a row would need to test the `row.keys()` collection instead. This
    is however an unusual use case as a result row is typically used by code that
    already knows what columns are present within it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: Already part of 1.4, the previous `KeyedTuple` class that was used when selecting
    rows from the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has been replaced by the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class, which is the base of the same [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") that comes back with Core statement results when using
    the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag with [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") (when the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag is not set, Core result sets use the `LegacyRow`
    subclass, which maintains backwards-compatible behaviors for the `__contains__()`
    method; ORM exclusively uses the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class directly).
  prefs: []
  type: TYPE_NORMAL
- en: This [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    behaves like a named tuple, in that it acts as a sequence but also supports attribute
    name access, e.g. `row.some_column`. However, it also provides the previous “mapping”
    behavior via the special attribute `row._mapping`, which produces a Python mapping
    such that keyed access such as `row["some_column"]` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to receive results as mappings up front, the `mappings()` modifier
    on the result can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class as used by the ORM also supports access via entity or attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](migration_14.html#change-4710-core)  ### Library-level (but not driver
    level) “Autocommit” removed from both Core and ORM'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQLAlchemy 1.x, the following statements will automatically commit the underlying
    DBAPI transaction, but in SQLAlchemy 2.0 this will not occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Nor will this autocommit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The common workaround for custom DML that requires commit, the “autocommit”
    execution option, will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method that is cross-compatible with [1.x style](../glossary.html#term-1.x-style)
    and [2.0 style](../glossary.html#term-2.0-style) execution is to make use of the
    [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method, or the [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin") context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'When using [2.0 style](../glossary.html#term-2.0-style) with the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag, “commit as you go” style may also be used, as
    the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    features **autobegin** behavior, which takes place when a statement is first invoked
    in the absence of an explicit call to [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: When [2.0 deprecations mode](#migration-20-deprecations-mode) is enabled, a
    warning will emit when the deprecated “autocommit” feature takes place, indicating
    those places where an explicit transaction should be noted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s first releases were at odds with the spirit of the Python DBAPI
    ([**PEP 249**](https://peps.python.org/pep-0249/)) in that it tried to hide [**PEP
    249**](https://peps.python.org/pep-0249/)’s emphasis on “implicit begin” and “explicit
    commit” of transactions. Fifteen years later we now see this was essentially a
    mistake, as SQLAlchemy’s many patterns that attempt to “hide” the presence of
    a transaction make for a more complex API which works inconsistently and is extremely
    confusing to especially those users who are new to relational databases and ACID
    transactions in general. SQLAlchemy 2.0 will do away with all attempts to implicitly
    commit transactions, and usage patterns will always require that the user demarcate
    the “beginning” and the “end” of a transaction in some way, in the same way as
    reading or writing to a file in Python has a “beginning” and an “end”.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of autocommit for a pure textual statement, there is actually a
    regular expression that parses every statement in order to detect autocommit!
    Not surprisingly, this regex is continuously failing to accommodate for various
    kinds of statements and stored procedures that imply a “write” to the database,
    leading to ongoing confusion as some statements produce results in the database
    and others don’t. By preventing the user from being aware of the transactional
    concept, we get a lot of bug reports on this one because users don’t understand
    that databases always use a transaction, whether or not some layer is autocommitting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 2.0 will require that all database actions at every level be explicit
    as to how the transaction should be used. For the vast majority of Core use cases,
    it’s the pattern that is already recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'For “commit as you go, or rollback instead” usage, which resembles how the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is normally used today, the “future” version of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which is the one that is returned from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") that was created using the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag, includes new [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") and [`Connection.rollback()`](../core/connections.html#sqlalchemy.engine.Connection.rollback
    "sqlalchemy.engine.Connection.rollback") methods, which act upon a transaction
    that is now begun automatically when a statement is first invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `engine.connect()` method will return a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that features **autobegin**, meaning the `begin()`
    event is emitted when the execute method is first used (note however that there
    is no actual “BEGIN” in the Python DBAPI). “autobegin” is a new pattern in SQLAlchemy
    1.4 that is featured both by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as well as the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; autobegin allows that the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") method may be called explicitly when the
    object is first acquired, for schemes that wish to demarcate the beginning of
    the transaction, but if the method is not called, then it occurs implicitly when
    work is first done on the object.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of “autocommit” is closely related to the removal of “connectionless”
    execution discussed at [“Implicit” and “Connectionless” execution, “bound metadata”
    removed](#migration-20-implicit-execution). All of these legacy patterns built
    up from the fact that Python did not have context managers or decorators when
    SQLAlchemy was first created, so there were no convenient idiomatic patterns for
    demarcating the use of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Driver-level autocommit remains available
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: True “autocommit” behavior is now widely available with most DBAPI implementations,
    and is supported by SQLAlchemy via the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter as discussed at [Setting
    Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).
    True autocommit is treated as an “isolation level” so that the structure of application
    code does not change when autocommit is used; the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") context manager as well as methods like
    [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") may still be used, they are simply no-ops
    at the database driver level when DBAPI-level autocommit is turned on.
  prefs: []
  type: TYPE_NORMAL
- en: Driver-level autocommit remains available
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: True “autocommit” behavior is now widely available with most DBAPI implementations,
    and is supported by SQLAlchemy via the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter as discussed at [Setting
    Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).
    True autocommit is treated as an “isolation level” so that the structure of application
    code does not change when autocommit is used; the [`Connection.begin()`](../core/connections.html#sqlalchemy.engine.Connection.begin
    "sqlalchemy.engine.Connection.begin") context manager as well as methods like
    [`Connection.commit()`](../core/connections.html#sqlalchemy.engine.Connection.commit
    "sqlalchemy.engine.Connection.commit") may still be used, they are simply no-ops
    at the database driver level when DBAPI-level autocommit is turned on.
  prefs: []
  type: TYPE_NORMAL
- en: '### “Implicit” and “Connectionless” execution, “bound metadata” removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to associate an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, which then makes available a range of so-called
    “connectionless” execution patterns, is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For schema level patterns, explicit use of an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is required. The [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") may still be used directly as the source of connectivity
    for a [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") operation or autoload operation. For
    executing statements, only the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object has a [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method (in addition to the ORM-level [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The Core documentation has already standardized on the desired pattern here,
    so it is likely that most modern applications would not have to change much in
    any case, however there are likely many applications that still rely upon `engine.execute()`
    calls that will need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '“Connectionless” execution refers to the still fairly popular pattern of invoking
    `.execute()` from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The above operation implicitly procures a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object, and runs the `.execute()` method on it.
    While this appears to be a simple convenience feature, it has been shown to give
    rise to several issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Programs that feature extended strings of `engine.execute()` calls have become
    prevalent, overusing a feature that was intended to be seldom used and leading
    to inefficient non-transactional applications. New users are confused as to the
    difference between `engine.execute()` and `connection.execute()` and the nuance
    between these two approaches is often not understood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The feature relies upon the “application level autocommit” feature in order
    to make sense, which itself is also being removed as it is also [inefficient and
    misleading](#migration-20-autocommit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to handle result sets, `Engine.execute` returns a result object with
    unconsumed cursor results. This cursor result necessarily still links to the DBAPI
    connection which remains in an open transaction, all of which is released once
    the result set has fully consumed the rows waiting within the cursor. This means
    that `Engine.execute` does not actually close out the connection resources that
    it claims to be managing when the call is complete. SQLAlchemy’s “autoclose” behavior
    is well-tuned enough that users don’t generally report any negative effects from
    this system, however it remains an overly implicit and inefficient system left
    over from SQLAlchemy’s earliest releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The removal of “connectionless” execution then leads to the removal of an even
    more legacy pattern, that of “implicit, connectionless” execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The above pattern has all the issues of “connectionless” execution, plus it
    relies upon the “bound metadata” pattern, which SQLAlchemy has tried to de-emphasize
    for many years. This was SQLAlchemy’s very first advertised usage model in version
    0.1, which became obsolete almost immediately when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object was introduced and later Python context
    managers provided a better pattern for using resources within a fixed scope.
  prefs: []
  type: TYPE_NORMAL
- en: With implicit execution removed, “bound metadata” itself also no longer has
    a purpose within this system. In modern use “bound metadata” tends to still be
    somewhat convenient for working within [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") calls as well as with [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects, however having these functions receive an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") explicitly provides for clearer application design.
  prefs: []
  type: TYPE_NORMAL
- en: Many Choices becomes One Choice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Overall, the above executional patterns were introduced in SQLAlchemy’s very
    first 0.1 release before the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object even existed. After many years of de-emphasizing
    these patterns, “implicit, connectionless” execution and “bound metadata” are
    no longer as widely used so in 2.0 we seek to finally reduce the number of choices
    for how to execute a statement in Core from “many choices”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'to “one choice”, where by “one choice” we mean “explicit connection with explicit
    transaction”; there are still a few ways to demarcate transaction blocks depending
    on need. The “one choice” is to procure a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and then to explicitly demarcate the transaction,
    in the case that the operation is a write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Many Choices becomes One Choice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Overall, the above executional patterns were introduced in SQLAlchemy’s very
    first 0.1 release before the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object even existed. After many years of de-emphasizing
    these patterns, “implicit, connectionless” execution and “bound metadata” are
    no longer as widely used so in 2.0 we seek to finally reduce the number of choices
    for how to execute a statement in Core from “many choices”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'to “one choice”, where by “one choice” we mean “explicit connection with explicit
    transaction”; there are still a few ways to demarcate transaction blocks depending
    on need. The “one choice” is to procure a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and then to explicitly demarcate the transaction,
    in the case that the operation is a write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: execute() method more strict, execution options are more prominent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument patterns that may be used with the [`sqlalchemy.engine.Connection()`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") execute method in SQLAlchemy 2.0 are highly simplified,
    removing many previously available argument patterns. The new API in the 1.4 series
    is described at [`sqlalchemy.engine.Connection()`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"). The examples below illustrate the patterns that
    require modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method now accepts a subset of the argument
    styles that are accepted by the 1.x [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") method, so the following code is cross-compatible
    between 1.x and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `*args` and `**kwargs` has been removed both to remove the complexity
    of guessing what kind of arguments were passed to the method, as well as to make
    room for other options, namely the [`Connection.execute.execution_options`](../core/connections.html#sqlalchemy.engine.Connection.execute.params.execution_options
    "sqlalchemy.engine.Connection.execute") dictionary that is now available to provide
    options on a per statement basis. The method is also modified so that its use
    pattern matches that of the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method, which is a much more prominent API in
    2.0 style.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of direct string SQL is to resolve an inconsistency between [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") and [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), where in the former case the string is passed
    to the driver raw, and in the latter case it is first converted to a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct. By allowing only [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") this also limits the accepted parameter format
    to “named” and not “positional”. Finally, the string SQL use case is becoming
    more subject to scrutiny from a security perspective, and the [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct has come to represent an explicit
    boundary into the textual SQL realm where attention to untrusted user input must
    be given.
  prefs: []
  type: TYPE_NORMAL
- en: '### Result rows act like named tuples'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 1.4 introduces an [all new Result object](migration_14.html#change-result-14-core)
    that in turn returns [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects, which behave like named tuples when using “future” mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Application code or test suites that are testing for a particular key being
    present in a row would need to test the `row.keys()` collection instead. This
    is however an unusual use case as a result row is typically used by code that
    already knows what columns are present within it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: Already part of 1.4, the previous `KeyedTuple` class that was used when selecting
    rows from the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has been replaced by the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class, which is the base of the same [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") that comes back with Core statement results when using
    the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag with [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") (when the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") flag is not set, Core result sets use the `LegacyRow`
    subclass, which maintains backwards-compatible behaviors for the `__contains__()`
    method; ORM exclusively uses the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class directly).
  prefs: []
  type: TYPE_NORMAL
- en: This [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    behaves like a named tuple, in that it acts as a sequence but also supports attribute
    name access, e.g. `row.some_column`. However, it also provides the previous “mapping”
    behavior via the special attribute `row._mapping`, which produces a Python mapping
    such that keyed access such as `row["some_column"]` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to receive results as mappings up front, the `mappings()` modifier
    on the result can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class as used by the ORM also supports access via entity or attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](migration_14.html#change-4710-core)'
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - Core Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### select() no longer accepts varied constructor arguments, columns are passed
    positionally'
  prefs: []
  type: TYPE_NORMAL
- en: '**synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct as well as the related method [`FromClause.select()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.select
    "sqlalchemy.sql.expression.FromClause.select") will no longer accept keyword arguments
    to build up elements such as the WHERE clause, FROM list and ORDER BY. The list
    of columns may now be sent positionally, rather than as a list. Additionally,
    the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    construct now accepts its WHEN criteria positionally, rather than as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the “generative” style of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") will be supported. The list of columns / tables
    to SELECT from should be passed positionally. The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct in SQLAlchemy 1.4 accepts both the
    legacy styles and the new styles using an auto-detection scheme, so the code below
    is cross-compatible with 1.4 and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has for many years developed a convention for SQL constructs accepting
    an argument either as a list or as positional arguments. This convention states
    that **structural** elements, those that form the structure of a SQL statement,
    should be passed **positionally**. Conversely, **data** elements, those that form
    the parameterized data of a SQL statement, should be passed **as lists**. For
    many years, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct could not participate in this convention
    smoothly because of the very legacy calling pattern where the “WHERE” clause would
    be passed positionally. SQLAlchemy 2.0 finally resolves this by changing the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to only accept the “generative”
    style that has for many years been the only documented style in the Core tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of “structural” vs. “data” elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[select(), case() now accept positional expressions](migration_14.html#change-5284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[select() construct created in “legacy” mode; keyword arguments, etc.](../errors.html#error-c9ae)'
  prefs: []
  type: TYPE_NORMAL
- en: insert/update/delete DML no longer accept keyword constructor arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way as to the previous change to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), the constructor arguments to [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") other than the table argument are essentially
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples illustrate generative method use for the above examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The API and internals is being simplified for the DML constructs in a similar
    manner as that of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  prefs: []
  type: TYPE_NORMAL
- en: '### select() no longer accepts varied constructor arguments, columns are passed
    positionally'
  prefs: []
  type: TYPE_NORMAL
- en: '**synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct as well as the related method [`FromClause.select()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.select
    "sqlalchemy.sql.expression.FromClause.select") will no longer accept keyword arguments
    to build up elements such as the WHERE clause, FROM list and ORDER BY. The list
    of columns may now be sent positionally, rather than as a list. Additionally,
    the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    construct now accepts its WHEN criteria positionally, rather than as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the “generative” style of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") will be supported. The list of columns / tables
    to SELECT from should be passed positionally. The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct in SQLAlchemy 1.4 accepts both the
    legacy styles and the new styles using an auto-detection scheme, so the code below
    is cross-compatible with 1.4 and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has for many years developed a convention for SQL constructs accepting
    an argument either as a list or as positional arguments. This convention states
    that **structural** elements, those that form the structure of a SQL statement,
    should be passed **positionally**. Conversely, **data** elements, those that form
    the parameterized data of a SQL statement, should be passed **as lists**. For
    many years, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct could not participate in this convention
    smoothly because of the very legacy calling pattern where the “WHERE” clause would
    be passed positionally. SQLAlchemy 2.0 finally resolves this by changing the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to only accept the “generative”
    style that has for many years been the only documented style in the Core tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of “structural” vs. “data” elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[select(), case() now accept positional expressions](migration_14.html#change-5284)'
  prefs: []
  type: TYPE_NORMAL
- en: '[select() construct created in “legacy” mode; keyword arguments, etc.](../errors.html#error-c9ae)'
  prefs: []
  type: TYPE_NORMAL
- en: insert/update/delete DML no longer accept keyword constructor arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way as to the previous change to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), the constructor arguments to [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") other than the table argument are essentially
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples illustrate generative method use for the above examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The API and internals is being simplified for the DML constructs in a similar
    manner as that of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct.
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - ORM Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declarative becomes a first class API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlalchemy.ext.declarative` package is mostly, with some exceptions, moved
    to the `sqlalchemy.orm` package. The [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") and [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions are present without any behavioral changes.
    A new super-implementation of [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") known as [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") now serves as the top-level ORM configurational construct,
    which also provides for decorator-based declarative and new support for classical
    mappings that integrate with the declarative registry.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: After ten years or so of popularity, the `sqlalchemy.ext.declarative` package
    is now integrated into the `sqlalchemy.orm` namespace, with the exception of the
    declarative “extension” classes which remain as Declarative extensions. The change
    is detailed further in the 1.4 migration guide at [Declarative is now integrated
    into the ORM with new features](migration_14.html#change-5508).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html) - all new unified documentation
    for Declarative, classical mapping, dataclasses, attrs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative is now integrated into the ORM with new features](migration_14.html#change-5508)'
  prefs: []
  type: TYPE_NORMAL
- en: The original “mapper()” function now a core element of Declarative, renamed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlalchemy.orm.mapper()` standalone function moves behind the scenes to
    be invoked by higher level APIs. The new version of this function is the method
    [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") taken from a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code that works with classical mappings should change imports and code from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'To work from a central [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    is also the source for declarative mappings, and classical mappings now have access
    to this registry including string-based configuration on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: By popular demand, “classical mapping” is staying around, however the new form
    of it is based off of the [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object and is available as [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the primary rationale used for “classical mapping” is that of keeping
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    setup distinct from the class. Declarative has always allowed this style using
    so-called [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration).
    However, to remove the base class requirement, a first class [decorator](../orm/declarative_mapping.html)
    form has been added.
  prefs: []
  type: TYPE_NORMAL
- en: As yet another separate but related enhancement, support for [Python dataclasses](../orm/dataclasses.html#orm-declarative-dataclasses)
    is added as well to both declarative decorator and classical mapping forms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html) - all new unified documentation
    for Declarative, classical mapping, dataclasses, attrs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative becomes a first class API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlalchemy.ext.declarative` package is mostly, with some exceptions, moved
    to the `sqlalchemy.orm` package. The [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") and [`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions are present without any behavioral changes.
    A new super-implementation of [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") known as [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") now serves as the top-level ORM configurational construct,
    which also provides for decorator-based declarative and new support for classical
    mappings that integrate with the declarative registry.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'To:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: After ten years or so of popularity, the `sqlalchemy.ext.declarative` package
    is now integrated into the `sqlalchemy.orm` namespace, with the exception of the
    declarative “extension” classes which remain as Declarative extensions. The change
    is detailed further in the 1.4 migration guide at [Declarative is now integrated
    into the ORM with new features](migration_14.html#change-5508).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html) - all new unified documentation
    for Declarative, classical mapping, dataclasses, attrs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative is now integrated into the ORM with new features](migration_14.html#change-5508)'
  prefs: []
  type: TYPE_NORMAL
- en: The original “mapper()” function now a core element of Declarative, renamed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlalchemy.orm.mapper()` standalone function moves behind the scenes to
    be invoked by higher level APIs. The new version of this function is the method
    [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") taken from a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code that works with classical mappings should change imports and code from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'To work from a central [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The above [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    is also the source for declarative mappings, and classical mappings now have access
    to this registry including string-based configuration on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: By popular demand, “classical mapping” is staying around, however the new form
    of it is based off of the [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object and is available as [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the primary rationale used for “classical mapping” is that of keeping
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    setup distinct from the class. Declarative has always allowed this style using
    so-called [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration).
    However, to remove the base class requirement, a first class [decorator](../orm/declarative_mapping.html)
    form has been added.
  prefs: []
  type: TYPE_NORMAL
- en: As yet another separate but related enhancement, support for [Python dataclasses](../orm/dataclasses.html#orm-declarative-dataclasses)
    is added as well to both declarative decorator and classical mapping forms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html) - all new unified documentation
    for Declarative, classical mapping, dataclasses, attrs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 2.0 Migration - ORM Usage'
  prefs: []
  type: TYPE_NORMAL
- en: The biggest visible change in SQLAlchemy 2.0 is the use of [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") in conjunction with [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") to run ORM queries, instead of using [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query"). As mentioned elsewhere, there is no plan to actually
    remove the [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query") API itself, as it is now implemented by using
    the new API internally it will remain as a legacy API, and both APIs can be used
    freely.
  prefs: []
  type: TYPE_NORMAL
- en: The table below provides an introduction to the general change in calling form
    with links to documentation for each technique presented. The individual migration
    notes are in the embedded sections following the table, and may include additional
    notes not summarized here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of Major ORM Querying Patterns**'
  prefs: []
  type: TYPE_NORMAL
- en: '| [1.x style](../glossary.html#term-1.x-style) form | [2.0 style](../glossary.html#term-2.0-style)
    form | See Also |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query - get() method moves to Session](#migration-20-get-to-session)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[`Result.first()`](../core/connections.html#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Rows not uniquified by default](#joinedload-not-uniqued) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Query Unified with Core Select](#migration-20-unify-select)[Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '| [Getting ORM Results from Textual Statements](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM Execution Options](../orm/queryguide/api.html#orm-queryguide-execution-options)[Populate
    Existing](../orm/queryguide/api.html#orm-queryguide-populate-existing) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '| [ORM-Enabled INSERT, UPDATE, and DELETE statements](../orm/queryguide/dml.html#orm-expression-update-delete)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '| [`Session.scalar()`](../orm/session_api.html#sqlalchemy.orm.Session.scalar
    "sqlalchemy.orm.Session.scalar") |'
  prefs: []
  type: TYPE_TB
- en: '### ORM Query Unified with Core Select'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object (as well as the [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") and [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extensions) become long term legacy
    objects, replaced by the direct usage of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct in conjunction with the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. Results that are returned from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in the form of lists of objects or tuples, or as scalar
    ORM objects are returned from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") uniformly as [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, which feature an interface consistent with
    that of Core execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Legacy code examples are illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Because the vast majority of an ORM application is expected to make use of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects as well as that the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") interface being available does not impact the new interface,
    the object will stay around in 2.0 but will no longer be part of documentation
    nor will it be supported for the most part. The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct now suits both the Core and ORM
    use cases, which when invoked via the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method will return ORM-oriented results, that
    is, ORM objects if that’s what was requested.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Select()`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct **adds many new methods** for compatibility with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Select.filter()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter
    "sqlalchemy.sql.expression.Select.filter") [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by"), newly reworked [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") methods, [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options"), etc. Other more supplemental methods
    of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    such as [`Query.populate_existing()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") are implemented via execution options.
  prefs: []
  type: TYPE_NORMAL
- en: Return results are in terms of a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, the new version of the SQLAlchemy `ResultProxy`
    object, which also adds many new methods for compatibility with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one"), [`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all
    "sqlalchemy.engine.Result.all"), [`Result.first()`](../core/connections.html#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first"), [`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object however does require some different calling patterns, in that when first
    returned it will **always return tuples** and it will **not deduplicate results
    in memory**. In order to return single ORM objects the way [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") does, the [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") modifier must be called first. In order to
    return uniqued objects, as is necessary when using joined eager loading, the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") modifier must be called first.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for all new features of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") including execution options, etc. are at [ORM
    Querying Guide](../orm/queryguide/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below are some examples of how to migrate to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that SQLAlchemy has both a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct as well as a separate [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object that features an extremely similar, but fundamentally
    incompatible interface is likely the greatest inconsistency in SQLAlchemy, one
    that arose as a result of small incremental additions over time that added up
    to two major APIs that are divergent.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy’s first releases, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object didn’t exist at all. The original idea was that
    the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct itself would be able to select rows, and that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not classes, would be used to create the various
    criteria in a Core-style approach. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") came along some months / years into SQLAlchemy’s history
    as a user proposal for a new, “buildable” querying object originally called `SelectResults`
    was accepted. Concepts like a `.where()` method, which `SelectResults` called
    `.filter()`, were not present in SQLAlchemy previously, and the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct used only the “all-at-once” construction
    style that’s now deprecated at [select() no longer accepts varied constructor
    arguments, columns are passed positionally](#migration-20-5284).
  prefs: []
  type: TYPE_NORMAL
- en: As the new approach took off, the object evolved into the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as new features such as being able to select individual
    columns, being able to select multiple entities at once, being able to build subqueries
    from a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object rather than from a [`select`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object were added. The goal became that [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should have the full functionality of [`select`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in that it could be composed to build SELECT
    statements fully with no explicit use of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") needed. At the same time, [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") had also evolved “generative” methods like
    [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  prefs: []
  type: TYPE_NORMAL
- en: In modern SQLAlchemy, this goal has been achieved and the two objects are now
    completely overlapping in functionality. The major challenge to unifying these
    objects was that the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object needed to remain **completely agnostic
    of the ORM**. To achieve this, the vast majority of logic from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") has been moved into the SQL compile phase, where ORM-specific
    compiler plugins receive the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct and interpret its contents in terms
    of an ORM-style query, before passing off to the core-level compiler in order
    to create a SQL string. With the advent of the new [SQL compilation caching system](migration_14.html#change-4639),
    the majority of this ORM logic is also cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query is internally unified with select, update, delete; 2.0 style execution
    available](migration_14.html#change-5159)  ### ORM Query - get() method moves
    to Session'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get "sqlalchemy.orm.Query.get")
    method remains for legacy purposes, but the primary interface is now the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1.4 / 2.0, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object adds a new [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object is to be a legacy object in 2.0, as ORM queries are now available using
    the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    object. As the [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get
    "sqlalchemy.orm.Query.get") method defines a special interaction with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and does not necessarily even emit a query, it’s more
    appropriate that it be part of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where it is similar to other “identity” methods such
    as [`refresh`](../orm/session_api.html#sqlalchemy.orm.Session.refresh "sqlalchemy.orm.Session.refresh")
    and [`merge`](../orm/session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge").
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy originally included “get()” to resemble the Hibernate `Session.load()`
    method. As is so often the case, we got it slightly wrong as this method is really
    more about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    than with writing a SQL query.  ### ORM Query - Joining / loading on relationships
    uses attributes, not strings'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This refers to patterns such as that of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") as well as query options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") which currently accept a mixture of string attribute
    names or actual class attributes. The string forms will all be removed in 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern SQLAlchemy 1.x versions support the recommended technique which is to
    use mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The same techniques apply to [2.0-style](../glossary.html#term-1) style use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The string calling form is ambiguous and requires that the internals do extra
    work to determine the appropriate path and retrieve the correct mapped property.
    By passing the ORM mapped attribute directly, not only is the necessary information
    passed up front, the attribute is also typed and is more potentially compatible
    with IDEs and pep-484 integrations.
  prefs: []
  type: TYPE_NORMAL
- en: ORM Query - Chaining using lists of attributes, rather than individual calls,
    removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: '“Chained” forms of joining and loader options which accept multiple mapped
    attributes in a list will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use individual calls to [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") for 1.x /2.0 cross compatible use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'For [2.0-style](../glossary.html#term-1) use, [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") has the same behavior of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), and also features a new [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method that allows an explicit left
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the chaining of attributes is in line with simplifying the calling
    interface of methods such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Query - join(…, aliased=True), from_joinpoint removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aliased=True` option on [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is removed, as is the `from_joinpoint` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use explicit aliases instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The `aliased=True` option on [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is another feature that seems to be almost never
    used, based on extensive code searches to find actual use of this feature. The
    internal complexity that the `aliased=True` flag requires is **enormous**, and
    will be going away in 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Most users aren’t familiar with this flag, however it allows for automatic aliasing
    of elements along a join, which then applies automatic aliasing to filter conditions.
    The original use case was to assist in long chains of self-referential joins,
    as in the example shown above. However, the automatic adaption of the filter criteria
    is enormously complicated internally and almost never used in real world applications.
    The pattern also leads to issues such as if filter criteria need to be added at
    each link in the chain; the pattern then must use the `from_joinpoint` flag which
    SQLAlchemy developers could absolutely find no occurrence of this parameter ever
    being used in real world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aliased=True` and `from_joinpoint` parameters were developed at a time
    when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object didn’t yet have good capabilities regarding joining along relationship
    attributes, functions like [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") did not exist, and the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct itself didn’t exist early on.  ### Using DISTINCT
    with additional columns, but only select the entity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    will automatically add columns in the ORDER BY when distinct is used. The following
    query will select from all User columns as well as “address.email_address” but
    only return User objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: In version 2.0, the “email_address” column will not be automatically added to
    the columns clause, and the above query will fail, since relational databases
    won’t allow you to ORDER BY “address.email_address” when using DISTINCT if it
    isn’t also in the columns clause.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2.0, the column must be added explicitly. To resolve the issue of only returning
    the main entity object, and not the extra column, use the [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: This case is an example of the limited flexibility of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") leading to the case where implicit, “magical” behavior
    needed to be added; the “email_address” column is implicitly added to the columns
    clause, then additional internal logic would omit that column from the actual
    results returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new approach simplifies the interaction and makes what’s going on explicit,
    while still making it possible to fulfill the original use case without inconvenience.  ###
    Selecting from the query itself as a subquery, e.g. “from_self()”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query.from_self()` method will be removed from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct may be used to emit ORM queries against an entity that is in terms of
    any arbitrary selectable. It has been enhanced in version 1.4 to smoothly accommodate
    being used multiple times against the same subquery for different entities as
    well. This can be used in [1.x style](../glossary.html#term-1.x-style) with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") as below; note that since the final query wants to query
    in terms of both the `User` and `Address` entities, two separate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The same form may be used in [2.0 style](../glossary.html#term-2.0-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Query.from_self()` method is a very complicated method that is rarely used.
    The purpose of this method is to convert a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") into a subquery, then return a new [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") which SELECTs from that subquery. The elaborate aspect
    of this method is that the returned query applies automatic translation of ORM
    entities and columns to be stated in the SELECT in terms of the subquery, as well
    as that it allows the entities and columns to be SELECTed from to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Because `Query.from_self()` packs an intense amount of implicit translation
    into the SQL it produces, while it does allow a certain kind of pattern to be
    executed very succinctly, real world use of this method is infrequent as it is
    not simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The new approach makes use of the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct so that the ORM internals don’t need to guess
    which entities and columns should be adapted and in what way; in the example above,
    the `ua` and `aa` objects, both of which are `AliasedClass` instances, provide
    to the internals an unambiguous marker as to where the subquery should be referenced
    as well as what entity column or relationship is being considered for a given
    component of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.4 also features an improved labeling style that no longer requires
    the use of long labels that include the table name in order to disambiguate columns
    of same names from different tables. In the above examples, even if our `User`
    and `Address` entities have overlapping column names, we can select from both
    entities at once without having to specify any particular labeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query will disambiguate the `.id` column of `User` and `Address`,
    where `Address.id` is rendered and tracked as `id_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[#5221](https://www.sqlalchemy.org/trac/ticket/5221)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting entities from alternative selectables; Query.select_entity_from()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query.select_entity_from()` method will be removed in 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case described at [Selecting from the query itself as a subquery,
    e.g. “from_self()”](#migration-20-query-from-self), the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object provides a single place that operations like
    “select entity from a subquery” may be achieved. Using [1.x style](../glossary.html#term-1.x-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Using [2.0 style](../glossary.html#term-2.0-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The points here are basically the same as those discussed at [Selecting from
    the query itself as a subquery, e.g. “from_self()”](#migration-20-query-from-self).
    The `Query.select_from_entity()` method was another way to instruct the query
    to load rows for a particular ORM mapped entity from an alternate selectable,
    which involved having the ORM apply automatic aliasing to that entity wherever
    it was used in the query later on, such as in the WHERE clause or ORDER BY. This
    intensely complex feature is seldom used in this way, where as was the case with
    `Query.from_self()`, it’s much easier to follow what’s going on when using an
    explicit [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, both from a user point of view as well as how the internals of the SQLAlchemy
    ORM must handle it.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Rows not uniquified by default'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM rows returned by `session.execute(stmt)` are no longer automatically “uniqued”.
    This will normally be a welcome change, except in the case where the “joined eager
    loading” loader strategy is used with collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '**Migrating to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a joined load of a collection, it’s required that the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method is called. The ORM will actually set
    a default row handler that will raise an error if this is not done, to ensure
    that a joined eager load collection does not return duplicate rows while still
    maintaining explicitness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The situation here is a little bit unusual, in that SQLAlchemy is requiring
    that a method be invoked that it is in fact entirely capable of doing automatically.
    The reason for requiring that the method be called is to ensure the developer
    is “opting in” to the use of the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method, such that they will not be confused
    when a straight count of rows does not conflict with the count of records in the
    actual result set, which has been a long running source of user confusion and
    bug reports for many years. That the uniquifying is not happening in any other
    case by default will improve performance and also improve clarity in those cases
    where automatic uniquing was causing confusing results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the degree that having to call [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") when joined eager load collections are used
    is inconvenient, in modern SQLAlchemy the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") strategy presents a collection-oriented eager loader
    that is superior in most respects to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and should be preferred.  ### “Dynamic” relationship
    loaders superseded by “Write Only”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `lazy="dynamic"` relationship loader strategy, discussed at [Dynamic Relationship
    Loaders](../orm/large_collections.html#dynamic-relationship), makes use of the
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object which is legacy in 2.0\. The “dynamic” relationship is not directly compatible
    with asyncio without workarounds, and additionally it does not fulfill its original
    purpose of preventing iteration of large collections as it has several behaviors
    where this iteration occurs implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A new loader strategy known as `lazy="write_only"` is introduced, which through
    the [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") collection class provides a very strict
    “no implicit iteration” API and additionally integrates with 2.0 style statement
    execution, supporting asyncio as well as direct integrations with the new [ORM-enabled
    Bulk DML](whatsnew_20.html#change-8360) featureset.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, `lazy="dynamic"` remains **fully supported** in version 2.0;
    applications can delay migrating this particular pattern until they are fully
    on the 2.0 series.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: The new “write only” feature is only available in SQLAlchemy 2.0, and is not
    part of 1.4\. At the same time, the `lazy="dynamic"` loader strategy remains fully
    supported in version 2.0, and even includes new pep-484 and annotated mapping
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore the best strategy for migrating from “dynamic” is to **wait until
    the application is fully running on 2.0**, then migrate directly from [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery"), which is the collection type used by the “dynamic”
    strategy, to [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection"), which is the collection type used by hte
    “write_only” strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some techniques are available to use `lazy="dynamic"` under 1.4 in a more “2.0”
    style however. There are two ways to achieve 2.0 style querying that’s in terms
    of a specific relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make use of the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") attribute on an existing `lazy="dynamic"` relationship.
    We can use methods like [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") with the dynamic loader straight away as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") function to construct a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The original idea was that the [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") function should be sufficient, however continuing
    to make use of special attributes on the relationship itself remains appealing,
    and there’s no reason a 2.0 style construct can’t be made to work here as well.
  prefs: []
  type: TYPE_NORMAL
- en: The new “write_only” loader strategy provides a new kind of collection which
    does not support implicit iteration or item access. Instead, reading the contents
    of the collection is performed by calling upon its `.select()` method to help
    construct an appropriate SELECT statement. The collection also includes methods
    `.insert()`, `.update()`, `.delete()` which may be used to emit bulk DML statements
    for the items in the collection. In a manner similar to that of the “dynamic”
    feature, there are also methods `.add()`, `.add_all()` and `.remove()` which queue
    individual members for addition or removal using the unit of work process. An
    introduction to the new feature is as [New “Write Only” relationship strategy
    supersedes “dynamic”](whatsnew_20.html#change-7123).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[New “Write Only” relationship strategy supersedes “dynamic”](whatsnew_20.html#change-7123)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)  ###
    Autocommit mode removed from Session; autobegin support added'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will no longer support “autocommit” mode, that is, this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in “autocommit” mode is so that the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is available, so that framework integrations
    and event hooks can control when this event happens. In 1.4, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now features [autobegin behavior](migration_14.html#change-5074)
    which resolves this issue; the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method may now be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “autocommit” mode is another holdover from the first versions of SQLAlchemy.
    The flag has stayed around mostly in support of allowing explicit use of [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"), which is now solved by 1.4, as well as to allow
    the use of “subtransactions”, which are also removed in 2.0.  ### Session “subtransaction”
    behavior removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The “subtransaction” pattern that was often used with autocommit mode is also
    deprecated in 1.4\. This pattern allowed the use of the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method when a transaction were already begun,
    resulting in a construct called a “subtransaction”, which was essentially a block
    that would prevent the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method from actually committing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide backwards compatibility for applications that make use of this pattern,
    the following context manager or a similar implementation based on a decorator
    may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'The above context manager may be used in the same way the “subtransaction”
    flag works, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare towards the preferred idiomatic pattern, the begin block should
    be at the outermost level. This removes the need for individual functions or methods
    to be concerned with the details of transaction demarcation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern has been shown to be confusing in real world applications, and
    it is preferable for an application to ensure that the top-most level of database
    operations are performed with a single begin/commit pair.  ### ORM Query Unified
    with Core Select'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object (as well as the [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") and [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extensions) become long term legacy
    objects, replaced by the direct usage of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct in conjunction with the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method. Results that are returned from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in the form of lists of objects or tuples, or as scalar
    ORM objects are returned from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") uniformly as [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, which feature an interface consistent with
    that of Core execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Legacy code examples are illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Because the vast majority of an ORM application is expected to make use of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects as well as that the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") interface being available does not impact the new interface,
    the object will stay around in 2.0 but will no longer be part of documentation
    nor will it be supported for the most part. The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct now suits both the Core and ORM
    use cases, which when invoked via the [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") method will return ORM-oriented results, that
    is, ORM objects if that’s what was requested.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Select()`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    construct **adds many new methods** for compatibility with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Select.filter()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter
    "sqlalchemy.sql.expression.Select.filter") [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by"), newly reworked [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") methods, [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options"), etc. Other more supplemental methods
    of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    such as [`Query.populate_existing()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") are implemented via execution options.
  prefs: []
  type: TYPE_NORMAL
- en: Return results are in terms of a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") object, the new version of the SQLAlchemy `ResultProxy`
    object, which also adds many new methods for compatibility with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one
    "sqlalchemy.engine.Result.one"), [`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all
    "sqlalchemy.engine.Result.all"), [`Result.first()`](../core/connections.html#sqlalchemy.engine.Result.first
    "sqlalchemy.engine.Result.first"), [`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object however does require some different calling patterns, in that when first
    returned it will **always return tuples** and it will **not deduplicate results
    in memory**. In order to return single ORM objects the way [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") does, the [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") modifier must be called first. In order to
    return uniqued objects, as is necessary when using joined eager loading, the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") modifier must be called first.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for all new features of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") including execution options, etc. are at [ORM
    Querying Guide](../orm/queryguide/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below are some examples of how to migrate to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that SQLAlchemy has both a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct as well as a separate [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object that features an extremely similar, but fundamentally
    incompatible interface is likely the greatest inconsistency in SQLAlchemy, one
    that arose as a result of small incremental additions over time that added up
    to two major APIs that are divergent.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy’s first releases, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object didn’t exist at all. The original idea was that
    the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct itself would be able to select rows, and that [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not classes, would be used to create the various
    criteria in a Core-style approach. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") came along some months / years into SQLAlchemy’s history
    as a user proposal for a new, “buildable” querying object originally called `SelectResults`
    was accepted. Concepts like a `.where()` method, which `SelectResults` called
    `.filter()`, were not present in SQLAlchemy previously, and the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct used only the “all-at-once” construction
    style that’s now deprecated at [select() no longer accepts varied constructor
    arguments, columns are passed positionally](#migration-20-5284).
  prefs: []
  type: TYPE_NORMAL
- en: As the new approach took off, the object evolved into the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as new features such as being able to select individual
    columns, being able to select multiple entities at once, being able to build subqueries
    from a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object rather than from a [`select`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object were added. The goal became that [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should have the full functionality of [`select`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") in that it could be composed to build SELECT
    statements fully with no explicit use of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") needed. At the same time, [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") had also evolved “generative” methods like
    [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  prefs: []
  type: TYPE_NORMAL
- en: In modern SQLAlchemy, this goal has been achieved and the two objects are now
    completely overlapping in functionality. The major challenge to unifying these
    objects was that the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object needed to remain **completely agnostic
    of the ORM**. To achieve this, the vast majority of logic from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") has been moved into the SQL compile phase, where ORM-specific
    compiler plugins receive the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct and interpret its contents in terms
    of an ORM-style query, before passing off to the core-level compiler in order
    to create a SQL string. With the advent of the new [SQL compilation caching system](migration_14.html#change-4639),
    the majority of this ORM logic is also cached.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Query is internally unified with select, update, delete; 2.0 style execution
    available](migration_14.html#change-5159)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Query - get() method moves to Session'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get "sqlalchemy.orm.Query.get")
    method remains for legacy purposes, but the primary interface is now the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1.4 / 2.0, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object adds a new [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object is to be a legacy object in 2.0, as ORM queries are now available using
    the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    object. As the [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get
    "sqlalchemy.orm.Query.get") method defines a special interaction with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and does not necessarily even emit a query, it’s more
    appropriate that it be part of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where it is similar to other “identity” methods such
    as [`refresh`](../orm/session_api.html#sqlalchemy.orm.Session.refresh "sqlalchemy.orm.Session.refresh")
    and [`merge`](../orm/session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge").
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy originally included “get()” to resemble the Hibernate `Session.load()`
    method. As is so often the case, we got it slightly wrong as this method is really
    more about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    than with writing a SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Query - Joining / loading on relationships uses attributes, not strings'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This refers to patterns such as that of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") as well as query options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") which currently accept a mixture of string attribute
    names or actual class attributes. The string forms will all be removed in 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern SQLAlchemy 1.x versions support the recommended technique which is to
    use mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'The same techniques apply to [2.0-style](../glossary.html#term-1) style use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The string calling form is ambiguous and requires that the internals do extra
    work to determine the appropriate path and retrieve the correct mapped property.
    By passing the ORM mapped attribute directly, not only is the necessary information
    passed up front, the attribute is also typed and is more potentially compatible
    with IDEs and pep-484 integrations.
  prefs: []
  type: TYPE_NORMAL
- en: ORM Query - Chaining using lists of attributes, rather than individual calls,
    removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: '“Chained” forms of joining and loader options which accept multiple mapped
    attributes in a list will be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use individual calls to [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") for 1.x /2.0 cross compatible use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'For [2.0-style](../glossary.html#term-1) use, [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") has the same behavior of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), and also features a new [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") method that allows an explicit left
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the chaining of attributes is in line with simplifying the calling
    interface of methods such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join").
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Query - join(…, aliased=True), from_joinpoint removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aliased=True` option on [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is removed, as is the `from_joinpoint` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use explicit aliases instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The `aliased=True` option on [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is another feature that seems to be almost never
    used, based on extensive code searches to find actual use of this feature. The
    internal complexity that the `aliased=True` flag requires is **enormous**, and
    will be going away in 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Most users aren’t familiar with this flag, however it allows for automatic aliasing
    of elements along a join, which then applies automatic aliasing to filter conditions.
    The original use case was to assist in long chains of self-referential joins,
    as in the example shown above. However, the automatic adaption of the filter criteria
    is enormously complicated internally and almost never used in real world applications.
    The pattern also leads to issues such as if filter criteria need to be added at
    each link in the chain; the pattern then must use the `from_joinpoint` flag which
    SQLAlchemy developers could absolutely find no occurrence of this parameter ever
    being used in real world applications.
  prefs: []
  type: TYPE_NORMAL
- en: The `aliased=True` and `from_joinpoint` parameters were developed at a time
    when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object didn’t yet have good capabilities regarding joining along relationship
    attributes, functions like [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") did not exist, and the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct itself didn’t exist early on.
  prefs: []
  type: TYPE_NORMAL
- en: '### Using DISTINCT with additional columns, but only select the entity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    will automatically add columns in the ORDER BY when distinct is used. The following
    query will select from all User columns as well as “address.email_address” but
    only return User objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: In version 2.0, the “email_address” column will not be automatically added to
    the columns clause, and the above query will fail, since relational databases
    won’t allow you to ORDER BY “address.email_address” when using DISTINCT if it
    isn’t also in the columns clause.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2.0, the column must be added explicitly. To resolve the issue of only returning
    the main entity object, and not the extra column, use the [`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: This case is an example of the limited flexibility of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") leading to the case where implicit, “magical” behavior
    needed to be added; the “email_address” column is implicitly added to the columns
    clause, then additional internal logic would omit that column from the actual
    results returned.
  prefs: []
  type: TYPE_NORMAL
- en: The new approach simplifies the interaction and makes what’s going on explicit,
    while still making it possible to fulfill the original use case without inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: '### Selecting from the query itself as a subquery, e.g. “from_self()”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query.from_self()` method will be removed from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct may be used to emit ORM queries against an entity that is in terms of
    any arbitrary selectable. It has been enhanced in version 1.4 to smoothly accommodate
    being used multiple times against the same subquery for different entities as
    well. This can be used in [1.x style](../glossary.html#term-1.x-style) with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") as below; note that since the final query wants to query
    in terms of both the `User` and `Address` entities, two separate [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") constructs are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'The same form may be used in [2.0 style](../glossary.html#term-2.0-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Query.from_self()` method is a very complicated method that is rarely used.
    The purpose of this method is to convert a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") into a subquery, then return a new [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") which SELECTs from that subquery. The elaborate aspect
    of this method is that the returned query applies automatic translation of ORM
    entities and columns to be stated in the SELECT in terms of the subquery, as well
    as that it allows the entities and columns to be SELECTed from to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Because `Query.from_self()` packs an intense amount of implicit translation
    into the SQL it produces, while it does allow a certain kind of pattern to be
    executed very succinctly, real world use of this method is infrequent as it is
    not simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The new approach makes use of the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") construct so that the ORM internals don’t need to guess
    which entities and columns should be adapted and in what way; in the example above,
    the `ua` and `aa` objects, both of which are `AliasedClass` instances, provide
    to the internals an unambiguous marker as to where the subquery should be referenced
    as well as what entity column or relationship is being considered for a given
    component of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.4 also features an improved labeling style that no longer requires
    the use of long labels that include the table name in order to disambiguate columns
    of same names from different tables. In the above examples, even if our `User`
    and `Address` entities have overlapping column names, we can select from both
    entities at once without having to specify any particular labeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query will disambiguate the `.id` column of `User` and `Address`,
    where `Address.id` is rendered and tracked as `id_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[#5221](https://www.sqlalchemy.org/trac/ticket/5221)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting entities from alternative selectables; Query.select_entity_from()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query.select_entity_from()` method will be removed in 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case described at [Selecting from the query itself as a subquery,
    e.g. “from_self()”](#migration-20-query-from-self), the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") object provides a single place that operations like
    “select entity from a subquery” may be achieved. Using [1.x style](../glossary.html#term-1.x-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'Using [2.0 style](../glossary.html#term-2.0-style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The points here are basically the same as those discussed at [Selecting from
    the query itself as a subquery, e.g. “from_self()”](#migration-20-query-from-self).
    The `Query.select_from_entity()` method was another way to instruct the query
    to load rows for a particular ORM mapped entity from an alternate selectable,
    which involved having the ORM apply automatic aliasing to that entity wherever
    it was used in the query later on, such as in the WHERE clause or ORDER BY. This
    intensely complex feature is seldom used in this way, where as was the case with
    `Query.from_self()`, it’s much easier to follow what’s going on when using an
    explicit [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object, both from a user point of view as well as how the internals of the SQLAlchemy
    ORM must handle it.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Rows not uniquified by default'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM rows returned by `session.execute(stmt)` are no longer automatically “uniqued”.
    This will normally be a welcome change, except in the case where the “joined eager
    loading” loader strategy is used with collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '**Migrating to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a joined load of a collection, it’s required that the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method is called. The ORM will actually set
    a default row handler that will raise an error if this is not done, to ensure
    that a joined eager load collection does not return duplicate rows while still
    maintaining explicitness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The situation here is a little bit unusual, in that SQLAlchemy is requiring
    that a method be invoked that it is in fact entirely capable of doing automatically.
    The reason for requiring that the method be called is to ensure the developer
    is “opting in” to the use of the [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") method, such that they will not be confused
    when a straight count of rows does not conflict with the count of records in the
    actual result set, which has been a long running source of user confusion and
    bug reports for many years. That the uniquifying is not happening in any other
    case by default will improve performance and also improve clarity in those cases
    where automatic uniquing was causing confusing results.
  prefs: []
  type: TYPE_NORMAL
- en: To the degree that having to call [`Result.unique()`](../core/connections.html#sqlalchemy.engine.Result.unique
    "sqlalchemy.engine.Result.unique") when joined eager load collections are used
    is inconvenient, in modern SQLAlchemy the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") strategy presents a collection-oriented eager loader
    that is superior in most respects to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") and should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '### “Dynamic” relationship loaders superseded by “Write Only”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `lazy="dynamic"` relationship loader strategy, discussed at [Dynamic Relationship
    Loaders](../orm/large_collections.html#dynamic-relationship), makes use of the
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object which is legacy in 2.0\. The “dynamic” relationship is not directly compatible
    with asyncio without workarounds, and additionally it does not fulfill its original
    purpose of preventing iteration of large collections as it has several behaviors
    where this iteration occurs implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: A new loader strategy known as `lazy="write_only"` is introduced, which through
    the [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") collection class provides a very strict
    “no implicit iteration” API and additionally integrates with 2.0 style statement
    execution, supporting asyncio as well as direct integrations with the new [ORM-enabled
    Bulk DML](whatsnew_20.html#change-8360) featureset.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, `lazy="dynamic"` remains **fully supported** in version 2.0;
    applications can delay migrating this particular pattern until they are fully
    on the 2.0 series.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: The new “write only” feature is only available in SQLAlchemy 2.0, and is not
    part of 1.4\. At the same time, the `lazy="dynamic"` loader strategy remains fully
    supported in version 2.0, and even includes new pep-484 and annotated mapping
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore the best strategy for migrating from “dynamic” is to **wait until
    the application is fully running on 2.0**, then migrate directly from [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery"), which is the collection type used by the “dynamic”
    strategy, to [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection"), which is the collection type used by hte
    “write_only” strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some techniques are available to use `lazy="dynamic"` under 1.4 in a more “2.0”
    style however. There are two ways to achieve 2.0 style querying that’s in terms
    of a specific relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make use of the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") attribute on an existing `lazy="dynamic"` relationship.
    We can use methods like [`Session.scalars()`](../orm/session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") with the dynamic loader straight away as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") function to construct a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct directly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The original idea was that the [`with_parent()`](../orm/queryguide/api.html#sqlalchemy.orm.with_parent
    "sqlalchemy.orm.with_parent") function should be sufficient, however continuing
    to make use of special attributes on the relationship itself remains appealing,
    and there’s no reason a 2.0 style construct can’t be made to work here as well.
  prefs: []
  type: TYPE_NORMAL
- en: The new “write_only” loader strategy provides a new kind of collection which
    does not support implicit iteration or item access. Instead, reading the contents
    of the collection is performed by calling upon its `.select()` method to help
    construct an appropriate SELECT statement. The collection also includes methods
    `.insert()`, `.update()`, `.delete()` which may be used to emit bulk DML statements
    for the items in the collection. In a manner similar to that of the “dynamic”
    feature, there are also methods `.add()`, `.add_all()` and `.remove()` which queue
    individual members for addition or removal using the unit of work process. An
    introduction to the new feature is as [New “Write Only” relationship strategy
    supersedes “dynamic”](whatsnew_20.html#change-7123).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[New “Write Only” relationship strategy supersedes “dynamic”](whatsnew_20.html#change-7123)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Autocommit mode removed from Session; autobegin support added'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will no longer support “autocommit” mode, that is, this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in “autocommit” mode is so that the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is available, so that framework integrations
    and event hooks can control when this event happens. In 1.4, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") now features [autobegin behavior](migration_14.html#change-5074)
    which resolves this issue; the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method may now be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: The “autocommit” mode is another holdover from the first versions of SQLAlchemy.
    The flag has stayed around mostly in support of allowing explicit use of [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"), which is now solved by 1.4, as well as to allow
    the use of “subtransactions”, which are also removed in 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '### Session “subtransaction” behavior removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The “subtransaction” pattern that was often used with autocommit mode is also
    deprecated in 1.4\. This pattern allowed the use of the [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method when a transaction were already begun,
    resulting in a construct called a “subtransaction”, which was essentially a block
    that would prevent the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method from actually committing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration to 2.0**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide backwards compatibility for applications that make use of this pattern,
    the following context manager or a similar implementation based on a decorator
    may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'The above context manager may be used in the same way the “subtransaction”
    flag works, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare towards the preferred idiomatic pattern, the begin block should
    be at the outermost level. This removes the need for individual functions or methods
    to be concerned with the details of transaction demarcation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '**Discussion**'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern has been shown to be confusing in real world applications, and
    it is preferable for an application to ensure that the top-most level of database
    operations are performed with a single begin/commit pair.
  prefs: []
  type: TYPE_NORMAL
- en: 2.0 Migration - ORM Extension and Recipe Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dogpile cache recipe and Horizontal Sharding uses new Session API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object becomes legacy, these two recipes which previously relied upon subclassing
    of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object now make use of the [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook. See the section [Re-Executing
    Statements](../orm/session_events.html#do-orm-execute-re-executing) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Baked Query Extension Superseded by built-in caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The baked query extension is superseded by the built in caching system and is
    no longer used by the ORM internals.
  prefs: []
  type: TYPE_NORMAL
- en: See [SQL Compilation Caching](../core/connections.html#sql-caching) for full
    background on the new caching system.
  prefs: []
  type: TYPE_NORMAL
- en: Dogpile cache recipe and Horizontal Sharding uses new Session API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object becomes legacy, these two recipes which previously relied upon subclassing
    of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object now make use of the [`SessionEvents.do_orm_execute()`](../orm/events.html#sqlalchemy.orm.SessionEvents.do_orm_execute
    "sqlalchemy.orm.SessionEvents.do_orm_execute") hook. See the section [Re-Executing
    Statements](../orm/session_events.html#do-orm-execute-re-executing) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Baked Query Extension Superseded by built-in caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The baked query extension is superseded by the built in caching system and is
    no longer used by the ORM internals.
  prefs: []
  type: TYPE_NORMAL
- en: See [SQL Compilation Caching](../core/connections.html#sql-caching) for full
    background on the new caching system.
  prefs: []
  type: TYPE_NORMAL
- en: Asyncio Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 includes asyncio support for both Core and ORM. The new API exclusively
    makes use of the “future” patterns noted above. See [Asynchronous IO Support for
    Core and ORM](migration_14.html#change-3414) for background.
  prefs: []
  type: TYPE_NORMAL
