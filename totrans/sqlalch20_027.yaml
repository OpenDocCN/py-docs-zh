- en: Non-Traditional Mappings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/nonstandard_mappings.html](https://docs.sqlalchemy.org/en/20/orm/nonstandard_mappings.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Mapping a Class against Multiple Tables'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Mappers can be constructed against arbitrary relational units (called *selectables*)
    in addition to plain tables. For example, the [`join()`](../core/selectable.html#sqlalchemy.sql.expression.join
    "sqlalchemy.sql.expression.join") function creates a selectable unit comprised
    of multiple tables, complete with its own composite primary key, which can be
    mapped in the same way as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the example above, the join expresses columns for both the `user` and the
    `address` table. The `user.id` and `address.user_id` columns are equated by foreign
    key, so in the mapping they are defined as one attribute, `AddressUser.id`, using
    [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    to indicate a specialized column mapping. Based on this part of the configuration,
    the mapping will copy new primary key values from `user.id` into the `address.user_id`
    column when a flush occurs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `address.id` column is mapped explicitly to an attribute named
    `address_id`. This is to **disambiguate** the mapping of the `address.id` column
    from the same-named `AddressUser.id` attribute, which here has been assigned to
    refer to the `user` table combined with the `address.user_id` foreign key.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The natural primary key of the above mapping is the composite of `(user.id,
    address.id)`, as these are the primary key columns of the `user` and `address`
    table combined together. The identity of an `AddressUser` object will be in terms
    of these two values, and is represented from an `AddressUser` object as `(AddressUser.id,
    AddressUser.address_id)`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'When referring to the `AddressUser.id` column, most SQL expressions will make
    use of only the first column in the list of columns mapped, as the two columns
    are synonymous. However, for the special use case such as a GROUP BY expression
    where both columns must be referenced at the same time while making use of the
    proper context, that is, accommodating for aliases and similar, the accessor [`Comparator.expressions`](internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") may be used:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'New in version 1.3.17: Added the [`Comparator.expressions`](internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") accessor.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A mapping against multiple tables as illustrated above supports persistence,
    that is, INSERT, UPDATE and DELETE of rows within the targeted tables. However,
    it does not support an operation that would UPDATE one table and perform INSERT
    or DELETE on others at the same time for one record. That is, if a record PtoQ
    is mapped to tables “p” and “q”, where it has a row based on a LEFT OUTER JOIN
    of “p” and “q”, if an UPDATE proceeds that is to alter data in the “q” table in
    an existing record, the row in “q” must exist; it won’t emit an INSERT if the
    primary key identity is already present. If the row does not exist, for most DBAPI
    drivers which support reporting the number of rows affected by an UPDATE, the
    ORM will fail to detect an updated row and raise an error; otherwise, the data
    would be silently ignored.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'A recipe to allow for an on-the-fly “insert” of the related row might make
    use of the .MapperEvents.before_update event and look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'where above, a row is INSERTed into the `q_table` table by creating an INSERT
    construct with [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert"), then executing it using the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which is the same one being used to emit other
    SQL for the flush process. The user-supplied logic would have to detect that the
    LEFT OUTER JOIN from “p” to “q” does not have an entry for the “q” side.  ## Mapping
    a Class against Arbitrary Subqueries'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to mapping against a join, a plain [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object can be used with a mapper as well.
    The example fragment below illustrates mapping a class called `Customer` to a
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    which includes a join to a subquery:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, the full row represented by `customer_select` will be all the columns
    of the `customers` table, in addition to those columns exposed by the `subq` subquery,
    which are `order_count`, `highest_order`, and `customer_id`. Mapping the `Customer`
    class to this selectable then creates a class which will contain those attributes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When the ORM persists new instances of `Customer`, only the `customers` table
    will actually receive an INSERT. This is because the primary key of the `orders`
    table is not represented in the mapping; the ORM will only emit an INSERT into
    a table for which it has mapped the primary key.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The practice of mapping to arbitrary SELECT statements, especially complex ones
    as above, is almost never needed; it necessarily tends to produce complex queries
    which are often less efficient than that which would be produced by direct query
    construction. The practice is to some degree based on the very early history of
    SQLAlchemy where the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct was meant to represent the primary querying interface; in modern usage,
    the [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object can be used to construct virtually any SELECT statement, including complex
    composites, and should be favored over the “map-to-selectable” approach.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Mappers for One Class
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In modern SQLAlchemy, a particular class is mapped by only one so-called **primary**
    mapper at a time. This mapper is involved in three main areas of functionality:
    querying, persistence, and instrumentation of the mapped class. The rationale
    of the primary mapper relates to the fact that the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") modifies the class itself, not only persisting it towards
    a particular [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    but also [instrumenting](../glossary.html#term-instrumenting) attributes upon
    the class which are structured specifically according to the table metadata. It’s
    not possible for more than one mapper to be associated with a class in equal measure,
    since only one mapper can actually instrument the class.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a “non-primary” mapper had existed for many versions of SQLAlchemy
    however as of version 1.3 this feature is deprecated. The one case where such
    a non-primary mapper is useful is when constructing a relationship to a class
    against an alternative selectable. This use case is now suited using the `aliased`
    construct and is described at [Relationship to Aliased Class](join_conditions.html#relationship-aliased-class).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: As far as the use case of a class that can actually be fully persisted to different
    tables under different scenarios, very early versions of SQLAlchemy offered a
    feature for this adapted from Hibernate, known as the “entity name” feature. However,
    this use case became infeasible within SQLAlchemy once the mapped class itself
    became the source of SQL expression construction; that is, the class’ attributes
    themselves link directly to mapped table columns. The feature was removed and
    replaced with a simple recipe-oriented approach to accomplishing this task without
    any ambiguity of instrumentation - to create new subclasses, each mapped individually.
    This pattern is now available as a recipe at [Entity Name](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/EntityName).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '## Mapping a Class against Multiple Tables'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Mappers can be constructed against arbitrary relational units (called *selectables*)
    in addition to plain tables. For example, the [`join()`](../core/selectable.html#sqlalchemy.sql.expression.join
    "sqlalchemy.sql.expression.join") function creates a selectable unit comprised
    of multiple tables, complete with its own composite primary key, which can be
    mapped in the same way as a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the example above, the join expresses columns for both the `user` and the
    `address` table. The `user.id` and `address.user_id` columns are equated by foreign
    key, so in the mapping they are defined as one attribute, `AddressUser.id`, using
    [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    to indicate a specialized column mapping. Based on this part of the configuration,
    the mapping will copy new primary key values from `user.id` into the `address.user_id`
    column when a flush occurs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `address.id` column is mapped explicitly to an attribute named
    `address_id`. This is to **disambiguate** the mapping of the `address.id` column
    from the same-named `AddressUser.id` attribute, which here has been assigned to
    refer to the `user` table combined with the `address.user_id` foreign key.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The natural primary key of the above mapping is the composite of `(user.id,
    address.id)`, as these are the primary key columns of the `user` and `address`
    table combined together. The identity of an `AddressUser` object will be in terms
    of these two values, and is represented from an `AddressUser` object as `(AddressUser.id,
    AddressUser.address_id)`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'When referring to the `AddressUser.id` column, most SQL expressions will make
    use of only the first column in the list of columns mapped, as the two columns
    are synonymous. However, for the special use case such as a GROUP BY expression
    where both columns must be referenced at the same time while making use of the
    proper context, that is, accommodating for aliases and similar, the accessor [`Comparator.expressions`](internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") may be used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'New in version 1.3.17: Added the [`Comparator.expressions`](internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") accessor.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: A mapping against multiple tables as illustrated above supports persistence,
    that is, INSERT, UPDATE and DELETE of rows within the targeted tables. However,
    it does not support an operation that would UPDATE one table and perform INSERT
    or DELETE on others at the same time for one record. That is, if a record PtoQ
    is mapped to tables “p” and “q”, where it has a row based on a LEFT OUTER JOIN
    of “p” and “q”, if an UPDATE proceeds that is to alter data in the “q” table in
    an existing record, the row in “q” must exist; it won’t emit an INSERT if the
    primary key identity is already present. If the row does not exist, for most DBAPI
    drivers which support reporting the number of rows affected by an UPDATE, the
    ORM will fail to detect an updated row and raise an error; otherwise, the data
    would be silently ignored.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的对多个表的映射支持持久性，即对目标表中的行进行INSERT、UPDATE和DELETE操作。然而，它不支持在一条记录中同时对一个表进行UPDATE并在其他表上执行INSERT或DELETE的操作。也就是说，如果将记录PtoQ映射到“p”和“q”表，其中它基于“p”和“q”的LEFT
    OUTER JOIN的行，如果进行更新以更改现有记录中“q”表中的数据，则“q”中的行必须存在；如果主键标识已经存在，它不会发出INSERT。如果行不存在，对于大多数支持报告UPDATE受影响行数的DBAPI驱动程序，ORM将无法检测到更新的行并引发错误；否则，数据将被静默忽略。
- en: 'A recipe to allow for an on-the-fly “insert” of the related row might make
    use of the .MapperEvents.before_update event and look like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在“插入”相关行时使用的配方可能利用`.MapperEvents.before_update`事件，并且看起来像：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: where above, a row is INSERTed into the `q_table` table by creating an INSERT
    construct with [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert"), then executing it using the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") which is the same one being used to emit other
    SQL for the flush process. The user-supplied logic would have to detect that the
    LEFT OUTER JOIN from “p” to “q” does not have an entry for the “q” side.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，通过使用[`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert")创建一个INSERT构造将一行插入`q_table`表，然后使用给定的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")执行它，这与用于发出刷新过程中的其他SQL的相同连接。用户提供的逻辑必须检测从“p”到“q”的LEFT
    OUTER JOIN是否没有“q”方面的条目。
- en: '## Mapping a Class against Arbitrary Subqueries'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '## 将类映射到任意子查询'
- en: 'Similar to mapping against a join, a plain [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") object can be used with a mapper as well.
    The example fragment below illustrates mapping a class called `Customer` to a
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    which includes a join to a subquery:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于对连接进行映射，也可以将一个普通的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")对象与映射器一起使用。下面的示例片段说明了将名为`Customer`的类映射到包含与子查询连接的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")的过程：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Above, the full row represented by `customer_select` will be all the columns
    of the `customers` table, in addition to those columns exposed by the `subq` subquery,
    which are `order_count`, `highest_order`, and `customer_id`. Mapping the `Customer`
    class to this selectable then creates a class which will contain those attributes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，由`customer_select`表示的完整行将是`customers`表的所有列，以及`subq`子查询暴露的那些列，即`order_count`、`highest_order`和`customer_id`。将`Customer`类映射到这个可选择的类，然后创建一个包含这些属性的类。
- en: When the ORM persists new instances of `Customer`, only the `customers` table
    will actually receive an INSERT. This is because the primary key of the `orders`
    table is not represented in the mapping; the ORM will only emit an INSERT into
    a table for which it has mapped the primary key.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当ORM持久化`Customer`的新实例时，实际上只有`customers`表会收到INSERT。这是因为`orders`表的主键没有在映射中表示；ORM只会对已映射主键的表发出INSERT。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The practice of mapping to arbitrary SELECT statements, especially complex ones
    as above, is almost never needed; it necessarily tends to produce complex queries
    which are often less efficient than that which would be produced by direct query
    construction. The practice is to some degree based on the very early history of
    SQLAlchemy where the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct was meant to represent the primary querying interface; in modern usage,
    the [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object can be used to construct virtually any SELECT statement, including complex
    composites, and should be favored over the “map-to-selectable” approach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Mappers for One Class
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In modern SQLAlchemy, a particular class is mapped by only one so-called **primary**
    mapper at a time. This mapper is involved in three main areas of functionality:
    querying, persistence, and instrumentation of the mapped class. The rationale
    of the primary mapper relates to the fact that the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") modifies the class itself, not only persisting it towards
    a particular [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"),
    but also [instrumenting](../glossary.html#term-instrumenting) attributes upon
    the class which are structured specifically according to the table metadata. It’s
    not possible for more than one mapper to be associated with a class in equal measure,
    since only one mapper can actually instrument the class.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a “non-primary” mapper had existed for many versions of SQLAlchemy
    however as of version 1.3 this feature is deprecated. The one case where such
    a non-primary mapper is useful is when constructing a relationship to a class
    against an alternative selectable. This use case is now suited using the `aliased`
    construct and is described at [Relationship to Aliased Class](join_conditions.html#relationship-aliased-class).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: As far as the use case of a class that can actually be fully persisted to different
    tables under different scenarios, very early versions of SQLAlchemy offered a
    feature for this adapted from Hibernate, known as the “entity name” feature. However,
    this use case became infeasible within SQLAlchemy once the mapped class itself
    became the source of SQL expression construction; that is, the class’ attributes
    themselves link directly to mapped table columns. The feature was removed and
    replaced with a simple recipe-oriented approach to accomplishing this task without
    any ambiguity of instrumentation - to create new subclasses, each mapped individually.
    This pattern is now available as a recipe at [Entity Name](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/EntityName).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
