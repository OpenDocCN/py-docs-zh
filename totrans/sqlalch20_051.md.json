["```py\n>>> from sqlalchemy import inspect\n>>> insp = inspect(my_object)\n>>> insp.persistent\nTrue\n```", "```py\nfor obj in session:\n    print(obj)\n```", "```py\nif obj in session:\n    print(\"Object is present\")\n```", "```py\n# pending objects recently added to the Session\nsession.new\n\n# persistent objects which currently have changes detected\n# (this collection is now created on the fly each time the property is called)\nsession.dirty\n\n# persistent objects that have been marked as deleted via session.delete(obj)\nsession.deleted\n\n# dictionary of all persistent objects, keyed on their\n# identity key\nsession.identity_map\n```", "```py\nfrom sqlalchemy import event\n\ndef strong_reference_session(session):\n    @event.listens_for(session, \"pending_to_persistent\")\n    @event.listens_for(session, \"deleted_to_persistent\")\n    @event.listens_for(session, \"detached_to_persistent\")\n    @event.listens_for(session, \"loaded_as_persistent\")\n    def strong_ref_object(sess, instance):\n        if \"refs\" not in sess.info:\n            sess.info[\"refs\"] = refs = set()\n        else:\n            refs = sess.info[\"refs\"]\n\n        refs.add(instance)\n\n    @event.listens_for(session, \"persistent_to_detached\")\n    @event.listens_for(session, \"persistent_to_deleted\")\n    @event.listens_for(session, \"persistent_to_transient\")\n    def deref_object(sess, instance):\n        sess.info[\"refs\"].discard(instance)\n```", "```py\nfrom sqlalchemy.orm import Session\n\nmy_session = Session()\nstrong_reference_session(my_session)\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\n\nmaker = sessionmaker()\nstrong_reference_session(maker)\n```", "```py\nmerged_object = session.merge(existing_object)\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(50), nullable=False)\n    addresses = relationship(\"Address\", backref=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String(50), nullable=False)\n    user_id = mapped_column(Integer, ForeignKey(\"user.id\"), nullable=False)\n```", "```py\n>>> u1 = User(name=\"ed\", addresses=[Address(email_address=\"ed@ed.com\")])\n>>> session.add(u1)\n>>> session.commit()\n```", "```py\n>>> existing_a1 = u1.addresses[0]\n>>> a1 = Address(id=existing_a1.id)\n```", "```py\n>>> a1.user = u1\n>>> a1 = session.merge(a1)\n>>> session.commit()\nsqlalchemy.orm.exc.FlushError: New instance <Address at 0x1298f50>\nwith identity key (<class '__main__.Address'>, (1,)) conflicts with\npersistent instance <Address at 0x12a25d0>\n```", "```py\n>>> a1 = Address()\n>>> a1.user = u1\n>>> a1 in session\nTrue\n>>> existing_a1 in session\nTrue\n>>> a1 is existing_a1\nFalse\n```", "```py\n>>> a1 = Address(id=existing_a1.id, user_id=u1.id)\n>>> a1.user = None\n>>> a1 = session.merge(a1)\n>>> session.commit()\nsqlalchemy.exc.IntegrityError: (IntegrityError) address.user_id\nmay not be NULL\n```", "```py\n>>> a1 = Address(id=existing_a1, user_id=user.id)\n>>> assert a1 not in session\n>>> a1 = session.merge(a1)\n```", "```py\n>>> a1 = Address(id=existing_a1, user_id=user.id)\n>>> a1.user\n>>> a1.__dict__\n{'_sa_instance_state': <sqlalchemy.orm.state.InstanceState object at 0x1298d10>,\n 'user_id': 1,\n 'id': 1,\n 'user': None}\n>>> # we don't want user=None merged, remove it\n>>> del a1.user\n>>> a1 = session.merge(a1)\n>>> # success\n>>> session.commit()\n```", "```py\nsession.expunge(obj1)\n```", "```py\nuser = session.scalars(select(User).filter_by(name=\"user1\").limit(1)).first()\n```", "```py\n>>> user.__dict__\n{\n 'id': 1, 'name': u'user1',\n '_sa_instance_state': <...>,\n}\n```", "```py\n>>> session.expire(user)\n>>> user.__dict__\n{'_sa_instance_state': <...>}\n```", "```py\n>>> print(user.name)\nSELECT  user.id  AS  user_id,  user.name  AS  user_name\nFROM  user\nWHERE  user.id  =  ?\n(1,)\nuser1\n```", "```py\n>>> user.__dict__\n{\n 'id': 1, 'name': u'user1',\n '_sa_instance_state': <...>,\n}\n```", "```py\n>>> user.name = \"user2\"\n```", "```py\n>>> session.expire(user)\n>>> user.name\n'user1'\n```", "```py\n# expire all ORM-mapped attributes on obj1\nsession.expire(obj1)\n```", "```py\n# expire only attributes obj1.attr1, obj1.attr2\nsession.expire(obj1, [\"attr1\", \"attr2\"])\n```", "```py\nsession.expire_all()\n```", "```py\n# reload all attributes on obj1\nsession.refresh(obj1)\n```", "```py\n# reload obj1.attr1, obj1.attr2\nsession.refresh(obj1, [\"attr1\", \"attr2\"])\n```", "```py\nstmt = (\n    select(User)\n    .execution_options(populate_existing=True)\n    .where((User.name.in_([\"a\", \"b\", \"c\"])))\n)\nfor user in session.execute(stmt).scalars():\n    print(user)  # will be refreshed for those columns that came back from the query\n```", "```py\n>>> from sqlalchemy import inspect\n>>> insp = inspect(my_object)\n>>> insp.persistent\nTrue\n```", "```py\n>>> from sqlalchemy import inspect\n>>> insp = inspect(my_object)\n>>> insp.persistent\nTrue\n```", "```py\nfor obj in session:\n    print(obj)\n```", "```py\nif obj in session:\n    print(\"Object is present\")\n```", "```py\n# pending objects recently added to the Session\nsession.new\n\n# persistent objects which currently have changes detected\n# (this collection is now created on the fly each time the property is called)\nsession.dirty\n\n# persistent objects that have been marked as deleted via session.delete(obj)\nsession.deleted\n\n# dictionary of all persistent objects, keyed on their\n# identity key\nsession.identity_map\n```", "```py\nfrom sqlalchemy import event\n\ndef strong_reference_session(session):\n    @event.listens_for(session, \"pending_to_persistent\")\n    @event.listens_for(session, \"deleted_to_persistent\")\n    @event.listens_for(session, \"detached_to_persistent\")\n    @event.listens_for(session, \"loaded_as_persistent\")\n    def strong_ref_object(sess, instance):\n        if \"refs\" not in sess.info:\n            sess.info[\"refs\"] = refs = set()\n        else:\n            refs = sess.info[\"refs\"]\n\n        refs.add(instance)\n\n    @event.listens_for(session, \"persistent_to_detached\")\n    @event.listens_for(session, \"persistent_to_deleted\")\n    @event.listens_for(session, \"persistent_to_transient\")\n    def deref_object(sess, instance):\n        sess.info[\"refs\"].discard(instance)\n```", "```py\nfrom sqlalchemy.orm import Session\n\nmy_session = Session()\nstrong_reference_session(my_session)\n```", "```py\nfrom sqlalchemy.orm import sessionmaker\n\nmaker = sessionmaker()\nstrong_reference_session(maker)\n```", "```py\nmerged_object = session.merge(existing_object)\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(50), nullable=False)\n    addresses = relationship(\"Address\", backref=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String(50), nullable=False)\n    user_id = mapped_column(Integer, ForeignKey(\"user.id\"), nullable=False)\n```", "```py\n>>> u1 = User(name=\"ed\", addresses=[Address(email_address=\"ed@ed.com\")])\n>>> session.add(u1)\n>>> session.commit()\n```", "```py\n>>> existing_a1 = u1.addresses[0]\n>>> a1 = Address(id=existing_a1.id)\n```", "```py\n>>> a1.user = u1\n>>> a1 = session.merge(a1)\n>>> session.commit()\nsqlalchemy.orm.exc.FlushError: New instance <Address at 0x1298f50>\nwith identity key (<class '__main__.Address'>, (1,)) conflicts with\npersistent instance <Address at 0x12a25d0>\n```", "```py\n>>> a1 = Address()\n>>> a1.user = u1\n>>> a1 in session\nTrue\n>>> existing_a1 in session\nTrue\n>>> a1 is existing_a1\nFalse\n```", "```py\n>>> a1 = Address(id=existing_a1.id, user_id=u1.id)\n>>> a1.user = None\n>>> a1 = session.merge(a1)\n>>> session.commit()\nsqlalchemy.exc.IntegrityError: (IntegrityError) address.user_id\nmay not be NULL\n```", "```py\n>>> a1 = Address(id=existing_a1, user_id=user.id)\n>>> assert a1 not in session\n>>> a1 = session.merge(a1)\n```", "```py\n>>> a1 = Address(id=existing_a1, user_id=user.id)\n>>> a1.user\n>>> a1.__dict__\n{'_sa_instance_state': <sqlalchemy.orm.state.InstanceState object at 0x1298d10>,\n 'user_id': 1,\n 'id': 1,\n 'user': None}\n>>> # we don't want user=None merged, remove it\n>>> del a1.user\n>>> a1 = session.merge(a1)\n>>> # success\n>>> session.commit()\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String(50), nullable=False)\n    addresses = relationship(\"Address\", backref=\"user\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    email_address = mapped_column(String(50), nullable=False)\n    user_id = mapped_column(Integer, ForeignKey(\"user.id\"), nullable=False)\n```", "```py\n>>> u1 = User(name=\"ed\", addresses=[Address(email_address=\"ed@ed.com\")])\n>>> session.add(u1)\n>>> session.commit()\n```", "```py\n>>> existing_a1 = u1.addresses[0]\n>>> a1 = Address(id=existing_a1.id)\n```", "```py\n>>> a1.user = u1\n>>> a1 = session.merge(a1)\n>>> session.commit()\nsqlalchemy.orm.exc.FlushError: New instance <Address at 0x1298f50>\nwith identity key (<class '__main__.Address'>, (1,)) conflicts with\npersistent instance <Address at 0x12a25d0>\n```", "```py\n>>> a1 = Address()\n>>> a1.user = u1\n>>> a1 in session\nTrue\n>>> existing_a1 in session\nTrue\n>>> a1 is existing_a1\nFalse\n```", "```py\n>>> a1 = Address(id=existing_a1.id, user_id=u1.id)\n>>> a1.user = None\n>>> a1 = session.merge(a1)\n>>> session.commit()\nsqlalchemy.exc.IntegrityError: (IntegrityError) address.user_id\nmay not be NULL\n```", "```py\n>>> a1 = Address(id=existing_a1, user_id=user.id)\n>>> assert a1 not in session\n>>> a1 = session.merge(a1)\n```", "```py\n>>> a1 = Address(id=existing_a1, user_id=user.id)\n>>> a1.user\n>>> a1.__dict__\n{'_sa_instance_state': <sqlalchemy.orm.state.InstanceState object at 0x1298d10>,\n 'user_id': 1,\n 'id': 1,\n 'user': None}\n>>> # we don't want user=None merged, remove it\n>>> del a1.user\n>>> a1 = session.merge(a1)\n>>> # success\n>>> session.commit()\n```", "```py\nsession.expunge(obj1)\n```", "```py\nuser = session.scalars(select(User).filter_by(name=\"user1\").limit(1)).first()\n```", "```py\n>>> user.__dict__\n{\n 'id': 1, 'name': u'user1',\n '_sa_instance_state': <...>,\n}\n```", "```py\n>>> session.expire(user)\n>>> user.__dict__\n{'_sa_instance_state': <...>}\n```", "```py\n>>> print(user.name)\nSELECT  user.id  AS  user_id,  user.name  AS  user_name\nFROM  user\nWHERE  user.id  =  ?\n(1,)\nuser1\n```", "```py\n>>> user.__dict__\n{\n 'id': 1, 'name': u'user1',\n '_sa_instance_state': <...>,\n}\n```", "```py\n>>> user.name = \"user2\"\n```", "```py\n>>> session.expire(user)\n>>> user.name\n'user1'\n```", "```py\n# expire all ORM-mapped attributes on obj1\nsession.expire(obj1)\n```", "```py\n# expire only attributes obj1.attr1, obj1.attr2\nsession.expire(obj1, [\"attr1\", \"attr2\"])\n```", "```py\nsession.expire_all()\n```", "```py\n# reload all attributes on obj1\nsession.refresh(obj1)\n```", "```py\n# reload obj1.attr1, obj1.attr2\nsession.refresh(obj1, [\"attr1\", \"attr2\"])\n```", "```py\nstmt = (\n    select(User)\n    .execution_options(populate_existing=True)\n    .where((User.name.in_([\"a\", \"b\", \"c\"])))\n)\nfor user in session.execute(stmt).scalars():\n    print(user)  # will be refreshed for those columns that came back from the query\n```"]