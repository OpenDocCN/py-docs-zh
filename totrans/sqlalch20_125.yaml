- en: What’s New in SQLAlchemy 2.0?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html](https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note for Readers
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 2.0’s transition documents are separated into **two** documents
    - one which details major API shifts from the 1.x to 2.x series, and the other
    which details new features and behaviors relative to SQLAlchemy 1.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html) - 1.x to 2.x API
    shifts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What’s New in SQLAlchemy 2.0?](#) - this document, new features and behaviors
    for SQLAlchemy 2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers who have not yet updated their 1.4 application to follow SQLAlchemy
    2.0 engine and ORM conventions may navigate to [SQLAlchemy 2.0 - Major Migration
    Guide](migration_20.html) for a guide to ensuring SQLAlchemy 2.0 compatibility,
    which is a prerequisite for having working code under version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 1.4 and SQLAlchemy
    version 2.0, **independent** of the major changes between [1.x style](../glossary.html#term-1.x-style)
    and [2.0 style](../glossary.html#term-2.0-style) usage. Readers should start with
    the [SQLAlchemy 2.0 - Major Migration Guide](migration_20.html) document to get
    an overall picture of the major compatibility changes between the 1.x and 2.x
    series.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the major 1.x->2.x migration path, the next largest paradigm shift
    in SQLAlchemy 2.0 is deep integration with [**PEP 484**](https://peps.python.org/pep-0484/)
    typing practices and current capabilities, particularly within the ORM. New type-driven
    ORM declarative styles inspired by Python [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    as well as new integrations with dataclasses themselves, complement an overall
    approach that no longer requires stubs and also goes very far towards providing
    a type-aware method chain from SQL statement to result set.
  prefs: []
  type: TYPE_NORMAL
- en: The prominence of Python typing is significant not only so that type checkers
    like [mypy](https://mypy.readthedocs.io/en/stable/) can run without plugins; more
    significantly it allows IDEs like [vscode](https://code.visualstudio.com/) and
    [pycharm](https://www.jetbrains.com/pycharm/) to take a much more active role
    in assisting with the composition of a SQLAlchemy application.
  prefs: []
  type: TYPE_NORMAL
- en: New Typing Support in Core and ORM - Stubs / Extensions no longer used
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach to typing for Core and ORM has been completely reworked, compared
    to the interim approach that was provided in version 1.4 via the [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    package. The new approach begins at the most fundamental element in SQLAlchemy
    which is the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    or more accurately the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") that underlies all SQL expressions
    that have a type. This expression-level typing then extends into the area of statement
    construction, statement execution, and result sets, and finally into the ORM where
    new [declarative](../orm/declarative_config.html) forms allow for fully typed
    ORM models that integrate all the way from statement to result set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Typing support should be considered **beta level** software for the 2.0 series.
    Typing details are subject to change however significant backwards-incompatible
    changes are not planned.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Expression / Statement / Result Set Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section provides background and examples for SQLAlchemy’s new SQL expression
    typing approach, which extends from base [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs through SQL statements and
    result sets and into realm of ORM mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale and Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  prefs: []
  type: TYPE_NORMAL
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  prefs: []
  type: TYPE_NORMAL
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  prefs: []
  type: TYPE_NORMAL
- en: '#### SQL Expression Typing - Examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Python Types Assigned to SQL Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ORM classes, scalars, etc. work great.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: the catch - all stubs must be uninstalled
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Declarative Models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 introduced the first SQLAlchemy-native ORM typing support using
    a combination of [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    and the [Mypy Plugin](../orm/extensions/mypy.html). In SQLAlchemy 2.0, the Mypy
    plugin **remains available, and has been updated to work with SQLAlchemy 2.0’s
    typing system**. However, it should now be considered **deprecated**, as applications
    now have a straightforward path to adopting the new typing support that does not
    use plugins or stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  prefs: []
  type: TYPE_NORMAL
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Migrating an Existing Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  prefs: []
  type: TYPE_NORMAL
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  prefs: []
  type: TYPE_NORMAL
- en: Typing is supported from step 3 onwards
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.  ### Using Legacy Mypy-Typed Models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to errors under the
    new system, as such annotations are flagged as errors when using constructs such
    as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: The section [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly
    typed ORM models](migration_20.html#migration-20-step-six) illustrates how to
    temporarily disable these errors from being raised for a legacy ORM model that
    uses explicit annotations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](migration_20.html#migration-20-step-six)  ### Native Support for Dataclasses
    Mapped as ORM Models'
  prefs: []
  type: TYPE_NORMAL
- en: The new ORM Declarative features introduced above at [ORM Declarative Models](#whatsnew-20-orm-declarative-typing)
    introduced the new [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct and illustrated type-centric mapping
    with optional use of [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`.
    We can take the mapping one step further by integrating this with Python [dataclasses](https://docs.python.org/3/library/dataclasses.html).
    This new feature is made possible via [**PEP 681**](https://peps.python.org/pep-0681/)
    which allows for type checkers to recognize classes that are dataclass compatible,
    or are fully dataclasses, but were declared through alternate APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dataclasses feature, mapped classes gain an `__init__()` method that
    supports positional arguments as well as customizable default values for optional
    keyword arguments. As mentioned previously, dataclasses also generate many useful
    methods such as `__str__()`, `__eq__()`. Dataclass serialization methods such
    as [dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)
    and [dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)
    also work, but don’t currently accommodate for self-referential structures, which
    makes them less viable for mappings that have bidirectional relationships.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s current integration approach converts the user-defined class into
    a **real dataclass** to provide runtime functionality; the feature makes use of
    the existing dataclass feature introduced in SQLAlchemy 1.4 at [Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)
    to produce an equivalent runtime mapping with a fully integrated configuration
    style, which is also more correctly typed than was possible with the previous
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: To support dataclasses in compliance with [**PEP 681**](https://peps.python.org/pep-0681/),
    ORM constructs like [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") accept additional [**PEP 681**](https://peps.python.org/pep-0681/)
    arguments `init`, `default`, and `default_factory` which are passed along to the
    dataclass creation process. These arguments currently must be present in an explicit
    directive on the right side, just as they would be used with `dataclasses.field()`;
    they currently can’t be local to an `Annotated` construct on the left side. To
    support the convenient use of `Annotated` while still supporting dataclass configuration,
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    can merge a minimal set of right-hand arguments with that of an existing [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct located on the left side within an `Annotated`
    construct, so that most of the succinctness is maintained, as will be seen below.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable dataclasses using class inheritance we make use of the [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin, either directly on each class, or on
    the `Base` class, as illustrated below where we further modify the example mapping
    from “Step 5” of [ORM Declarative Models](#whatsnew-20-orm-declarative-typing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping has used the `@dataclasses.dataclass` decorator directly
    on each mapped class at the same time that the declarative mapping was set up,
    internally setting up each `dataclasses.field()` directive as indicated. `User`
    / `Address` structures can be created using positional arguments as configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)  ##
    Optimized ORM bulk insert now implemented for all backends other than MySQL'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dramatic performance improvement introduced in the 1.4 series and described
    at [ORM Batch inserts with psycopg2 now batch statements with RETURNING in most
    cases](migration_14.html#change-5263) has now been generalized to all included
    backends that support RETURNING, which is all backends other than MySQL: SQLite,
    MariaDB, PostgreSQL (all drivers), and Oracle; SQL Server has support but is temporarily
    disabled in version 2.0.9 [[1]](#id2). While the original feature was most critical
    for the psycopg2 driver which otherwise had major performance issues when using
    `cursor.executemany()`, the change is also critical for other PostgreSQL drivers
    such as asyncpg, as when using RETURNING, single-statement INSERT statements are
    still unacceptably slow, as well as when using SQL Server that also seems to have
    very slow executemany speed for INSERT statements regardless of whether or not
    RETURNING is used.'
  prefs: []
  type: TYPE_NORMAL
- en: The performance of the new feature provides an almost across-the-board order
    of magnitude performance increase for basically every driver when INSERTing ORM
    objects that don’t have a pre-assigned primary key value, as indicated in the
    table below, in most cases specific to the use of RETURNING which is not normally
    supported with executemany().
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 “fast execution helper” approach consists of transforming an INSERT..RETURNING
    statement with a single parameter set into a single statement that INSERTs many
    parameter sets, using multiple “VALUES…” clauses so that it can accommodate many
    parameter sets at once. Parameter sets are then typically batched into groups
    of 1000 or similar, so that no single INSERT statement is excessively large, and
    the INSERT statement is then invoked for each batch of parameters, rather than
    for each individual parameter set. Primary key values and server defaults are
    returned by RETURNING, which continues to work as each statement execution is
    invoked using `cursor.execute()`, rather than `cursor.executemany()`.
  prefs: []
  type: TYPE_NORMAL
- en: This allows many rows to be inserted in one statement while also being able
    to return newly-generated primary key values as well as SQL and server defaults.
    SQLAlchemy historically has always needed to invoke one statement per parameter
    set, as it relied upon Python DBAPI Features such as `cursor.lastrowid` which
    do not support multiple rows.
  prefs: []
  type: TYPE_NORMAL
- en: With most databases now offering RETURNING (with the conspicuous exception of
    MySQL, given that MariaDB supports it), the new change generalizes the psycopg2
    “fast execution helper” approach to all dialects that support RETURNING, which
    now includes SQlite and MariaDB, and for which no other approach for “executemany
    plus RETURNING” is possible, which includes SQLite, MariaDB, and all PG drivers.
    The cx_Oracle and oracledb drivers used for Oracle support RETURNING with executemany
    natively, and this has also been implemented to provide equivalent performance
    improvements. With SQLite and MariaDB now offering RETURNING support, ORM use
    of `cursor.lastrowid` is nearly a thing of the past, with only MySQL still relying
    upon it.
  prefs: []
  type: TYPE_NORMAL
- en: For INSERT statements that don’t use RETURNING, traditional executemany() behavior
    is used for most backends, with the current exception of psycopg2, which has very
    slow executemany() performance overall and are still improved by the “insertmanyvalues”
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy includes a [Performance Suite](../orm/examples.html#examples-performance)
    within the `examples/` directory, where we can make use of the `bulk_insert` suite
    to benchmark INSERTs of many rows using both Core and ORM in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: For the tests below, we are inserting **100,000 objects**, and in all cases
    we actually have 100,000 real Python ORM objects in memory, either created up
    front or generated on the fly. All databases other than SQLite are run over a
    local network connection, not localhost; this causes the “slower” results to be
    extremely slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations that are improved by this feature include:'
  prefs: []
  type: TYPE_NORMAL
- en: unit of work flushes for objects added to the session using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new [ORM Bulk Insert Statement](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    feature, which improves upon the experimental version of this feature first introduced
    in SQLAlchemy 1.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    “bulk” operations described at [Bulk Operations](../orm/persistence_techniques.html#bulk-operations),
    which are superseded by the above mentioned ORM Bulk Insert feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get a sense of the scale of the operation, below are performance measurements
    using the `test_flush_no_pk` performance suite, which historically represents
    SQLAlchemy’s worst-case INSERT performance task, where objects that don’t have
    primary key values need to be INSERTed, and then the newly generated primary key
    values must be fetched so that the objects can be used for subsequent flush operations,
    such as establishment within relationships, flushing joined-inheritance models,
    etc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This test can be run from any SQLAlchemy source tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The table below summarizes performance measurements with the latest 1.4 series
    of SQLAlchemy compared to 2.0, both running the same test:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
  prefs: []
  type: TYPE_TB
- en: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
  prefs: []
  type: TYPE_TB
- en: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
  prefs: []
  type: TYPE_TB
- en: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional drivers have no change in performance; the psycopg2 drivers,
    for which fast executemany was already implemented in SQLAlchemy 1.4, and MySQL,
    which continues to not offer RETURNING support:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
  prefs: []
  type: TYPE_TB
- en: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
  prefs: []
  type: TYPE_TB
- en: Summary of Changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following bullets list the individual changes made within 2.0 in order
    to get all drivers to this state:'
  prefs: []
  type: TYPE_NORMAL
- en: RETURNING implemented for SQLite - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RETURNING implemented for MariaDB - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix multi-row RETURNING for Oracle - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make insert() executemany() support RETURNING for as many dialects as possible,
    usually with VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emit a warning when RETURNING w/ executemany is used for non-supporting backend
    (currently no RETURNING backend has this limitation) - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a a new setting `"auto"`, which
    will enable “eager defaults” automatically for INSERT statements, when the backend
    in use supports RETURNING with “insertmanyvalues”. See [Fetching Server-Generated
    Defaults](../orm/persistence_techniques.html#orm-server-defaults) for documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - Documentation and background on the new feature as well as how to configure
    it  ## ORM-enabled Insert, Upsert, Update and Delete Statements, with ORM RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 ported the features of the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to [2.0 style](../glossary.html#term-2.0-style)
    execution, which meant that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct could be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to deliver ORM results. Support was also added
    for [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    to be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), to the degree that they could provide implementations
    of [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete").
  prefs: []
  type: TYPE_NORMAL
- en: The major missing element has been support for the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct. The 1.4 documentation addressed
    this with some recipes for “inserts” and “upserts” with use of [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") to integrate RETURNING into
    an ORM context. 2.0 now fully closes the gap by integrating direct support for
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    as an enhanced version of the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method, along with full ORM RETURNING
    support for all DML structures.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk Insert with RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    can be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), with or without [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), which when passed with a separate
    parameter list will invoke the same process as was previously implemented by [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings"), with additional enhancements.
    This will optimize the batching of rows making use of the new [fast insertmany](#change-6047)
    feature, while also adding support for heterogeneous parameter sets and multiple-table
    mappings like joined table inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: RETURNING is supported for all of these use cases, where the ORM will construct
    a full result set from multiple statement invocations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
  prefs: []
  type: TYPE_NORMAL
- en: Bulk UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a similar manner as that of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), passing the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a parameter list that
    includes primary key values to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will invoke the same process as previously supported
    by the [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This feature does not however
    support RETURNING, as it uses a SQL UPDATE statement that is invoked using DBAPI
    [executemany](../glossary.html#term-executemany):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk UPDATE by Primary Key](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT / upsert … VALUES … RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    with [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values"), the set of parameters may include
    SQL expressions. Additionally, upsert variants such as those for SQLite, PostgreSQL
    and MariaDB are also supported. These statements may now include [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") clauses with column expressions
    or full ORM entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk Insert with Per Row SQL Expressions](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](../orm/queryguide/dml.html#orm-queryguide-upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM UPDATE / DELETE with WHERE … RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.4 also had some modest support for the RETURNING feature to be
    used with the [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    constructs, when used with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This support has now been upgraded to be fully
    native, including that the `fetch` synchronization strategy may also proceed whether
    or not explicit use of RETURNING is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
  prefs: []
  type: TYPE_NORMAL
- en: Improved `synchronize_session` behavior for ORM UPDATE / DELETE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default strategy for [synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)
    is now a new value `"auto"`. This strategy will attempt to use the `"evaluate"`
    strategy and then automatically fall back to the `"fetch"` strategy. For all backends
    other than MySQL / MariaDB, `"fetch"` uses RETURNING to fetch UPDATE/DELETEd primary
    key identifiers within the same statement, so is generally more efficient than
    previous versions (in 1.4, RETURNING was only available for PostgreSQL, SQL Server).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting a Synchronization Strategy](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Listed tickets for new ORM DML with RETURNING features:'
  prefs: []
  type: TYPE_NORMAL
- en: convert `insert()` at ORM level to interpret `values()` in an ORM context -
    [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: evaluate feasibility of dml.returning(Entity) to deliver ORM expressions, automatically
    apply select().from_statement equiv - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'given ORM insert, try to carry the bulk methods along, re: inheritance - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)  ##
    New “Write Only” relationship strategy supersedes “dynamic”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `lazy="dynamic"` loader strategy becomes legacy, in that it is hardcoded
    to make use of legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This loader strategy is both not compatible with asyncio,
    and additionally has many behaviors that implicitly iterate its contents, which
    defeat the original purpose of the “dynamic” relationship as being for very large
    collections that should not be implicitly fully loaded into memory at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “dynamic” strategy is now superseded by a new strategy `lazy="write_only"`.
    Configuration of “write only” may be achieved using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), or when using [type annotated mappings](#whatsnew-20-orm-declarative-typing),
    indicating the [`WriteOnlyMapped`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation as the mapping style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The write-only-mapped collection resembles `lazy="dynamic"` in that the collection
    may be assigned up front, and also has methods such as [`WriteOnlyCollection.add()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add") and [`WriteOnlyCollection.remove()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") to modify the collection on an individual
    item basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The bigger difference is on the database loading side, where the collection
    has no ability to load objects from the database directly; instead, SQL construction
    methods such as [`WriteOnlyCollection.select()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") are used to produce SQL constructs
    such as [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    which are then executed using [2.0 style](../glossary.html#term-2.0-style) to
    load the desired objects in an explicit way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") also integrates with the new [ORM bulk dml](#change-8360)
    features, including support for bulk INSERT and UPDATE/DELETE with WHERE criteria,
    all including RETURNING support as well. See the complete documentation at [Write
    Only Relationships](../orm/large_collections.html#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: New pep-484 / type annotated mapping support for Dynamic Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though “dynamic” relationships are legacy in 2.0, as these patterns are
    expected to have a long lifespan, [type annotated mapping](#whatsnew-20-orm-declarative-typing)
    support is now added for “dynamic” relationships in the same way that its available
    for the new `lazy="write_only"` approach, using the [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The above mapping will provide an `Account.account_transactions` collection
    that is typed as returning the [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") collection type, including its element type, e.g.
    `AppenderQuery[AccountTransaction]`. This then allows iteration and queries to
    yield objects which are typed as `AccountTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamic Relationship Loaders](../orm/large_collections.html#dynamic-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)  ## Installation is now
    fully pep-517 enabled'
  prefs: []
  type: TYPE_NORMAL
- en: The source distribution now includes a `pyproject.toml` file to allow for complete
    [**PEP 517**](https://peps.python.org/pep-0517/) support. In particular this allows
    a local source build using `pip` to automatically install the [Cython](https://cython.org/)
    optional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7311](https://www.sqlalchemy.org/trac/ticket/7311)  ## C Extensions now ported
    to Cython'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy C extensions have been replaced with all new extensions written
    in [Cython](https://cython.org/). While Cython was evaluated back in 2010 when
    the C extensions were first created, the nature and focus of the C extensions
    in use today has changed quite a bit from that time. At the same time, Cython
    has apparently evolved significantly, as has the Python build / distribution toolchain
    which made it feasible for us to revisit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The move to Cython provides dramatic new advantages with no apparent downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: The Cython extensions that replace specific C extensions have all benchmarked
    as **faster**, often slightly, but sometimes significantly, than virtually all
    the C code that SQLAlchemy previously included. While this seems amazing, it appears
    to be a product of non-obvious optimizations within Cython’s implementation that
    would not be present in a direct Python to C port of a function, as was particularly
    the case for many of the custom collection types added to the C extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython extensions are much easier to write, maintain and debug compared to raw
    C code, and in most cases are line-per-line equivalent to the Python code. It
    is expected that many more elements of SQLAlchemy will be ported to Cython in
    the coming releases which should open many new doors to performance improvements
    that were previously out of reach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython is very mature and widely used, including being the basis of some of
    the prominent database drivers supported by SQLAlchemy including `asyncpg`, `psycopg3`
    and `asyncmy`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the previous C extensions, the Cython extensions are pre-built within SQLAlchemy’s
    wheel distributions which are automatically available to `pip` from PyPi. Manual
    build instructions are also unchanged with the exception of the Cython requirement.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7256](https://www.sqlalchemy.org/trac/ticket/7256)  ## Major Architectural,
    Performance and API Enhancements for Database Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: The internal system by which [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects and their components are [reflected](../core/reflection.html#metadata-reflection)
    has been completely rearchitected to allow high performance bulk reflection of
    thousands of tables at once for participating dialects. Currently, the **PostgreSQL**
    and **Oracle** dialects participate in the new architecture, where the PostgreSQL
    dialect can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects nearly three times faster, and the Oracle dialect
    can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects ten times faster.
  prefs: []
  type: TYPE_NORMAL
- en: The rearchitecture applies most directly to dialects that make use of SELECT
    queries against system catalog tables to reflect tables, and the remaining included
    dialect that can benefit from this approach will be the SQL Server dialect. The
    MySQL/MariaDB and SQLite dialects by contrast make use of non-relational systems
    to reflect database tables, and were not subject to a pre-existing performance
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: The new API is backwards compatible with the previous system, and should require
    no changes to third party dialects to retain compatibility; third party dialects
    can also opt into the new system by implementing batched queries for schema reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Along with this change, the API and behavior of the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object has been improved and enhanced
    with more consistent cross-dialect behaviors as well as new methods and new performance
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Performance Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source distribution includes a script `test/perf/many_table_reflection.py`
    which benches both existing reflection features as well as new ones. A limited
    set of its tests may be run on older versions of SQLAlchemy, where here we use
    it to illustrate differences in performance to invoke `metadata.reflect()` to
    reflect 250 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects at once over a local network connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dialect | Operation | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
  prefs: []
  type: TYPE_TB
- en: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
  prefs: []
  type: TYPE_TB
- en: Behavioral Changes for `Inspector()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For SQLAlchemy-included dialects for SQLite, PostgreSQL, MySQL/MariaDB, Oracle,
    and SQL Server, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence"), [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index"), [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") now all behave consistently
    in terms of caching: they all fully cache their result after being called the
    first time for a particular [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object. Programs that create or drop
    tables/sequences while calling upon the same [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object will not receive updated status
    after the state of the database has changed. A call to [`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache") or a new [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") should be used when DDL changes are
    to be executed. Previously, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence") methods did not implement
    caching nor did the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") support caching for these methods, while
    the [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") methods were, leading
    to inconsistent results between the two types of method.'
  prefs: []
  type: TYPE_NORMAL
- en: Behavior for third party dialects is dependent on whether or not they implement
    the “reflection cache” decorator for the dialect-level implementation of these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: New Methods and Improvements for `Inspector()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: added a method [`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema") that returns if a schema
    is present in the target database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: added a method [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index") that returns if a table has
    a particular index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspection methods such as [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") that work on a single table
    at a time should now all consistently raise [`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError") if a table or view is not found; this change
    is specific to individual dialects, so may not be the case for existing third-party
    dialects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separated the handling of “views” and “materialized views”, as in real world
    use cases, these two constructs make use of different DDL for CREATE and DROP;
    this includes that there are now separate [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and [`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)  ## Dialect support for
    psycopg 3 (a.k.a. “psycopg”)'
  prefs: []
  type: TYPE_NORMAL
- en: Added dialect support for the [psycopg 3](https://pypi.org/project/psycopg/)
    DBAPI, which despite the number “3” now goes by the package name `psycopg`, superseding
    the previous `psycopg2` package that for the time being remains SQLAlchemy’s “default”
    driver for the `postgresql` dialects. `psycopg` is a completely reworked and modernized
    database adapter for PostgreSQL which supports concepts such as prepared statements
    as well as Python asyncio.
  prefs: []
  type: TYPE_NORMAL
- en: '`psycopg` is the first DBAPI supported by SQLAlchemy which provides both a
    pep-249 synchronous API as well as an asyncio driver. The same `psycopg` database
    URL may be used with the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") and [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine-creation functions, and the
    corresponding sync or asyncio version of the dialect will be selected automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[psycopg](../dialects/postgresql.html#postgresql-psycopg)  ## Dialect support
    for oracledb'
  prefs: []
  type: TYPE_NORMAL
- en: Added dialect support for the [oracledb](https://pypi.org/project/oracledb/)
    DBAPI, which is the renamed, new major release of the popular cx_Oracle driver.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[python-oracledb](../dialects/oracle.html#oracledb)  ## New Conditional DDL
    for Constraints and Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new method [`Constraint.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Constraint.ddl_if
    "sqlalchemy.schema.Constraint.ddl_if") and [`Index.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Index.ddl_if
    "sqlalchemy.schema.Index.ddl_if") allows constructs such as [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") and [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") to be rendered conditionally for a given [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), based on the same kinds of criteria that are accepted
    by the `DDLElement.execute_if()` method. In the example below, the CHECK constraint
    and index will only be produced against a PostgreSQL backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](../core/ddl.html#schema-ddl-ddl-if)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7631](https://www.sqlalchemy.org/trac/ticket/7631)  ## DATE, TIME, DATETIME
    datatypes now support literal rendering on all backends'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal rendering is now implemented for date and time types for backend specific
    compilation, including PostgreSQL and Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Previously, such literal rendering only worked when stringifying statements
    without any dialect given; when attempting to render with a dialect-specific type,
    a `NotImplementedError` would be raised, up until SQLAlchemy 1.4.45 where this
    became a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") (part of [#8800](https://www.sqlalchemy.org/trac/ticket/8800)).
  prefs: []
  type: TYPE_NORMAL
- en: The default rendering is modified ISO-8601 rendering (i.e. ISO-8601 with the
    T converted to a space) when using `literal_binds` with the SQL compilers provided
    by the PostgreSQL, MySQL, MariaDB, MSSQL, Oracle dialects. For Oracle, the ISO
    format is wrapped inside of an appropriate TO_DATE() function call. The rendering
    for SQLite is unchanged as this dialect always included string rendering for date
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[#5052](https://www.sqlalchemy.org/trac/ticket/5052)  ## Context Manager Support
    for `Result`, `AsyncResult`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object now supports context manager use, which will ensure the object and its
    underlying cursor is closed at the end of the block. This is useful in particular
    with server side cursors, where it’s important that the open cursor object is
    closed at the end of an operation, even if user-defined exceptions have occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With asyncio use, the [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") and [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") have been altered to provide for optional
    async context manager use, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[#8710](https://www.sqlalchemy.org/trac/ticket/8710)'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers behavioral changes made in SQLAlchemy 2.0 which are not
    otherwise part of the major 1.4->2.0 migration path; changes here are not expected
    to have significant effects on backwards compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '### New transaction join modes for `Session`'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of “joining an external transaction into a Session” has been revised
    and improved, allowing explicit control over how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will accommodate an incoming [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that already has a transaction and possibly a
    savepoint already established. The new parameter [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") includes a series of option values which can accommodate
    the existing transaction in several ways, most importantly allowing a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to operate in a fully transactional style using savepoints
    exclusively, while leaving the externally initiated transaction non-committed
    and active under all circumstances, allowing test suites to rollback all changes
    that take place within tests.
  prefs: []
  type: TYPE_NORMAL
- en: The primary improvement this allows is that the recipe documented at [Joining
    a Session into an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction),
    which also changed from SQLAlchemy 1.3 to 1.4, is now simplified to no longer
    require explicit use of an event handler or any mention of an explicit savepoint;
    by using `join_transaction_mode="create_savepoint"`, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will never affect the state of an incoming transaction,
    and will instead create a savepoint (i.e. “nested transaction”) as its root transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates part of the example given at [Joining a Session into
    an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction);
    see that section for a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The default mode selected for [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") is `"conditional_savepoint"`, which uses `"create_savepoint"`
    behavior if the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is itself already on a savepoint. If the given
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is in a transaction but not a savepoint, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will propagate “rollback” calls but not “commit” calls,
    but will not begin a new savepoint on its own. This behavior is chosen by default
    for its maximum compatibility with older SQLAlchemy versions as well as that it
    does not start a new SAVEPOINT unless the given driver is already making use of
    SAVEPOINT, as support for SAVEPOINT varies not only with specific backend and
    driver but also configurationally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates a case that worked in SQLAlchemy 1.3, stopped working
    in SQLAlchemy 1.4, and is now restored in SQLAlchemy 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Where above, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is joined to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that has a savepoint started on it; the state
    of these two units remains unchanged after the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has worked with the transaction. In SQLAlchemy 1.3,
    the above case worked because the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would begin a “subtransaction” upon the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which would allow the outer savepoint / transaction
    to remain unaffected for simple cases as above. Since subtransactions were deprecated
    in 1.4 and are now removed in 2.0, this behavior was no longer available. The
    new default behavior improves upon the behavior of “subtransactions” by using
    a real, second SAVEPOINT instead, so that even calls to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") prevent the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from “breaking out” into the externally initiated SAVEPOINT
    or transaction.
  prefs: []
  type: TYPE_NORMAL
- en: New code that is joining a transaction-started [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should however select a [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") explicitly, so that the desired behavior is explicitly
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)  ### `str(engine.url)`
    will obfuscate the password by default'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid leakage of database passwords, calling `str()` on a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") will now enable the password obfuscation feature by default.
    Previously, this obfuscation would be in place for `__repr__()` calls but not
    `__str__()`. This change will impact applications and test suites that attempt
    to invoke [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    given the stringified URL from another engine, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The above engine `e2` will not have the correct password; it will have the obfuscated
    string `"***"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferred approach for the above pattern is to pass the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object directly, there’s no need to stringify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, for a stringified URL with cleartext password, use the [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") method, passing the [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)  ### Stricter rules for
    replacement of Columns in Table objects with same-names, keys'
  prefs: []
  type: TYPE_NORMAL
- en: Stricter rules are in place for appending of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, both moving some previous deprecation warnings
    to exceptions, and preventing some previous scenarios that would cause duplicate
    columns to appear in tables, when [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") were set to `True`, for both programmatic [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construction as well as during reflection operations.
  prefs: []
  type: TYPE_NORMAL
- en: Under no circumstances should a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object ever have two or more [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with the same name, regardless of what .key
    they have. An edge case where this was still possible was identified and fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that has the same name or key as an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will always raise [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError") (a new subclass of [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") in 2.0.0b4) unless additional parameters are present;
    [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") for [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column"), and [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") for construction of a same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as an existing one, with or without reflection being
    used. Previously, there was a deprecation warning in place for this scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is now emitted if a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is created, that does include [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table"), where an incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that has no separate [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") would fully replace an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that does have a key, which suggests the operation
    is not what the user intended. This can happen particularly during a secondary
    reflection step, such as `metadata.reflect(extend_existing=True)`. The warning
    suggests that the [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") parameter be set to `False` to prevent this. Previously,
    in 1.4 and earlier, the incoming column would be added **in addition** to the
    existing column. This was a bug and is a behavioral change in 2.0 (as of 2.0.0b4),
    as the previous key will **no longer be present** in the column collection when
    this occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)  ### ORM Declarative Applies
    Column Orders Differently; Control behavior using `sort_order`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative has changed the system by which mapped columns that originate from
    mixin or abstract base classes are sorted along with the columns that are on the
    declared class itself to place columns from the declared class first, followed
    by mixin columns. The following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces a CREATE TABLE as follows on 1.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas on 2.0 it produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For the specific case above, this can be seen as an improvement, as the primary
    key columns on the `Model` are now where one would typically prefer. However,
    this is no comfort for the application that defined models the other way around,
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This now produces CREATE TABLE output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this issue, SQLAlchemy 2.0.4 introduces a new parameter on [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") called [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column"), which is an integer value, defaulting to `0`,
    that can be set to a positive or negative value so that columns are placed before
    or after other columns, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The above model places “id” before all others and “col1” after “id”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Future SQLAlchemy releases may opt to provide an explicit ordering hint for
    the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, as this ordering is ORM specific.  ### The `Sequence` construct reverts
    to not having any explicit default “start” value; impacts MS SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to SQLAlchemy 1.4, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct would emit only simple `CREATE SEQUENCE`
    DDL, if no additional arguments were specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    support was added for MS SQL Server, where the default start value is inconveniently
    set to `-2**63`, version 1.4 decided to default the DDL to emit a start value
    of 1, if [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") were not otherwise provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This change has introduced other complexities, including that when the [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") parameter is included, this default of `1` should
    in fact default to what [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") states, else a min_value that’s below the start_value
    may be seen as contradictory. As looking at this issue started to become a bit
    of a rabbit hole of other various edge cases, we decided to instead revert this
    change and restore the original behavior of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") which is to have no opinion, and just emit CREATE
    SEQUENCE, allowing the database itself to make its decisions on how the various
    parameters of `SEQUENCE` should interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to ensure that the start value is 1 on all backends, **the start
    value of 1 may be indicated explicitly**, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Beyond all of that, for autogeneration of integer primary keys on modern backends
    including PostgreSQL, Oracle, SQL Server, the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct should be preferred, which also works
    the same way in 1.4 and 2.0 with no changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)  ### “with_variant()”
    clones the original TypeEngine rather than changing the type'
  prefs: []
  type: TYPE_NORMAL
- en: The [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method, which is used to apply alternate
    per-database behaviors to a particular type, now returns a copy of the original
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object with the variant information stored internally, rather than wrapping it
    inside the `Variant` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the previous `Variant` approach was able to maintain all the in-Python
    behaviors of the original type using dynamic attribute getters, the improvement
    here is that when calling upon a variant, the returned type remains an instance
    of the original type, which works more smoothly with type checkers such as mypy
    and pylance. Given a program as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A type checker like pyright will now report the type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In addition, as illustrated above, multiple dialect names may be passed for
    single type, in particular this is helpful for the pair of `"mysql"` and `"mariadb"`
    dialects which are considered separately as of SQLAlchemy 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)  ### Python division operator
    performs true division for all backends; added floor division'
  prefs: []
  type: TYPE_NORMAL
- en: The Core expression language now supports both “true division” (i.e. the `/`
    Python operator) and “floor division” (i.e. the `//` Python operator) including
    backend-specific behaviors to normalize different databases in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a “true division” operation against two integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL division operator on PostgreSQL for example normally acts as “floor
    division” when used against integers, meaning the above result would return the
    integer “0”. For this and similar backends, SQLAlchemy now renders the SQL using
    a form which is equivalent towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With `param_1=5`, `param_2=10`, so that the return expression will be of type
    NUMERIC, typically as the Python value `decimal.Decimal("0.5")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a “floor division” operation against two integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL division operator on MySQL and Oracle for example normally acts as
    “true division” when used against integers, meaning the above result would return
    the floating point value “0.5”. For these and similar backends, SQLAlchemy now
    renders the SQL using a form which is equivalent towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With param_1=5, param_2=10, so that the return expression will be of type INTEGER,
    as the Python value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backwards-incompatible change here would be if an application using PostgreSQL,
    SQL Server, or SQLite which relied on the Python “truediv” operator to return
    an integer value in all cases. Applications which rely upon this behavior should
    instead use the Python “floor division” operator `//` for these operations, or
    for forwards compatibility when using a previous SQLAlchemy version, the floor
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The above form would be needed on any SQLAlchemy version prior to 2.0 in order
    to provide backend-agnostic floor division.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)  ### Session raises proactively
    when illegal concurrent or reentrant access is detected'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now trap more errors related to illegal concurrent state changes within multithreaded
    or other concurrent scenarios as well as for event hooks which perform unexpected
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One error that’s been known to occur when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in multiple threads simultaneously is `AttributeError:
    ''NoneType'' object has no attribute ''twophase''`, which is completely cryptic.
    This error occurs when a thread calls [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which internally invokes the `SessionTransaction.close()`
    method to end the transactional context, at the same time that another thread
    is in progress running a query as from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). Within [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), the internal method that acquires a database
    connection for the current transaction first begins by asserting that the session
    is “active”, but after this assertion passes, the concurrent call to [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") interferes with this state which leads to the
    undefined condition above.'
  prefs: []
  type: TYPE_NORMAL
- en: The change applies guards to all state-changing methods surrounding the [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object so that in the above case, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will instead fail as it will seek to change
    the state to one that is disallowed for the duration of the already-in-progress
    method that wants to get the current connection to run a database query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the test script illustrated at [#7433](https://www.sqlalchemy.org/trac/ticket/7433),
    the previous error case looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the `_connection_for_bind()` method isn’t able to continue since concurrent
    access placed it into an invalid state. Using the new approach, the originator
    of the state change throws the error instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The state transition checks intentionally don’t use explicit locks to detect
    concurrent thread activity, instead relying upon simple attribute set / value
    test operations that inherently fail when unexpected concurrent changes occur.
    The rationale is that the approach can detect illegal state changes that occur
    entirely within a single thread, such as an event handler that runs on session
    transaction events calls a state-changing method that’s not expected, or under
    asyncio if a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were shared among multiple asyncio tasks, as well as
    when using patching-style concurrency approaches such as gevent.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)  ### The SQLite dialect
    uses QueuePool for file-based databases'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect now defaults to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") when a file based database is used. This is set along
    with setting the `check_same_thread` parameter to `False`. It has been observed
    that the previous approach of defaulting to [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool"), which does not hold onto database connections after
    they are released, did in fact have a measurable negative performance impact.
    As always, the pool class is customizable via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)  ### New Oracle FLOAT
    type with binary precision; decimal precision not accepted directly'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new datatype [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") has been added to the Oracle dialect, to accompany
    the addition of [`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    and database-specific [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE"), [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") and [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") datatypes. Oracle’s `FLOAT` accepts a so-called “binary
    precision” parameter that per Oracle documentation is roughly a standard “precision”
    value divided by 0.3103:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: A binary precision value of 126 is synonymous with using the [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") datatype, and a value of 63 is equivalent
    to using the [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    datatype. Other precision values are specific to the [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype also accepts a “precision” parameter, but this is decimal precision which
    is not accepted by Oracle. Rather than attempting to guess the conversion, the
    Oracle dialect will now raise an informative error if [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") is used with a precision value against the Oracle backend.
    To specify a [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype with an explicit precision value for supporting backends, while also
    supporting other backends, use the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]  ### New RANGE / MULTIRANGE support and changes for PostgreSQL backends'
  prefs: []
  type: TYPE_NORMAL
- en: RANGE / MULTIRANGE support has been fully implemented for psycopg2, psycopg3,
    and asyncpg dialects. The new support uses a new SQLAlchemy-specific [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object that is agnostic of the different
    backends and does not require the use of backend-specific imports or extension
    steps. For multirange support, lists of [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects are used.
  prefs: []
  type: TYPE_NORMAL
- en: Code that used the previous psycopg2-specific types should be modified to use
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range"),
    which presents a compatible interface.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object also features comparison support
    which mirrors that of PostgreSQL. Implemented so far are [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") and [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") methods which work in the
    same way as the PostgreSQL `@>` and `<@`. Additional operator support may be added
    in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation at [Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)
    for background on using the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)  ###
    `match()` operator on PostgreSQL uses `plainto_tsquery()` rather than `to_tsquery()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Operators.match()` function now renders `col @@ plainto_tsquery(expr)`
    on the PostgreSQL backend, rather than `col @@ to_tsquery()`. `plainto_tsquery()`
    accepts plain text whereas `to_tsquery()` accepts specialized query symbols, and
    is therefore less cross-compatible with other backends.
  prefs: []
  type: TYPE_NORMAL
- en: All PostgreSQL search functions and operators are available through use of [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to generate PostgreSQL-specific functions and
    [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") (a boolean-typed version of [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")) to generate arbitrary operators, in
    the same manner as they are available in previous versions. See the examples at
    [Full Text Search](../dialects/postgresql.html#postgresql-match).
  prefs: []
  type: TYPE_NORMAL
- en: Existing SQLAlchemy projects that make use of PG-specific directives within
    `Operators.match()` should make use of `func.to_tsquery()` directly. To render
    SQL in exactly the same form as would be present in 1.4, see the version note
    at [Simple plain text matching with match()](../dialects/postgresql.html#postgresql-simple-match).
  prefs: []
  type: TYPE_NORMAL
- en: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)'
  prefs: []
  type: TYPE_NORMAL
- en: New Typing Support in Core and ORM - Stubs / Extensions no longer used
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The approach to typing for Core and ORM has been completely reworked, compared
    to the interim approach that was provided in version 1.4 via the [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    package. The new approach begins at the most fundamental element in SQLAlchemy
    which is the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    or more accurately the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") that underlies all SQL expressions
    that have a type. This expression-level typing then extends into the area of statement
    construction, statement execution, and result sets, and finally into the ORM where
    new [declarative](../orm/declarative_config.html) forms allow for fully typed
    ORM models that integrate all the way from statement to result set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Typing support should be considered **beta level** software for the 2.0 series.
    Typing details are subject to change however significant backwards-incompatible
    changes are not planned.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Expression / Statement / Result Set Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section provides background and examples for SQLAlchemy’s new SQL expression
    typing approach, which extends from base [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs through SQL statements and
    result sets and into realm of ORM mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale and Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  prefs: []
  type: TYPE_NORMAL
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  prefs: []
  type: TYPE_NORMAL
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  prefs: []
  type: TYPE_NORMAL
- en: '#### SQL Expression Typing - Examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Python Types Assigned to SQL Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ORM classes, scalars, etc. work great.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: the catch - all stubs must be uninstalled
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Declarative Models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 introduced the first SQLAlchemy-native ORM typing support using
    a combination of [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    and the [Mypy Plugin](../orm/extensions/mypy.html). In SQLAlchemy 2.0, the Mypy
    plugin **remains available, and has been updated to work with SQLAlchemy 2.0’s
    typing system**. However, it should now be considered **deprecated**, as applications
    now have a straightforward path to adopting the new typing support that does not
    use plugins or stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  prefs: []
  type: TYPE_NORMAL
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Migrating an Existing Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  prefs: []
  type: TYPE_NORMAL
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  prefs: []
  type: TYPE_NORMAL
- en: Typing is supported from step 3 onwards
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.  ### Using Legacy Mypy-Typed Models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to errors under the
    new system, as such annotations are flagged as errors when using constructs such
    as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: The section [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly
    typed ORM models](migration_20.html#migration-20-step-six) illustrates how to
    temporarily disable these errors from being raised for a legacy ORM model that
    uses explicit annotations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](migration_20.html#migration-20-step-six)  ### Native Support for Dataclasses
    Mapped as ORM Models'
  prefs: []
  type: TYPE_NORMAL
- en: The new ORM Declarative features introduced above at [ORM Declarative Models](#whatsnew-20-orm-declarative-typing)
    introduced the new [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct and illustrated type-centric mapping
    with optional use of [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`.
    We can take the mapping one step further by integrating this with Python [dataclasses](https://docs.python.org/3/library/dataclasses.html).
    This new feature is made possible via [**PEP 681**](https://peps.python.org/pep-0681/)
    which allows for type checkers to recognize classes that are dataclass compatible,
    or are fully dataclasses, but were declared through alternate APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dataclasses feature, mapped classes gain an `__init__()` method that
    supports positional arguments as well as customizable default values for optional
    keyword arguments. As mentioned previously, dataclasses also generate many useful
    methods such as `__str__()`, `__eq__()`. Dataclass serialization methods such
    as [dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)
    and [dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)
    also work, but don’t currently accommodate for self-referential structures, which
    makes them less viable for mappings that have bidirectional relationships.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s current integration approach converts the user-defined class into
    a **real dataclass** to provide runtime functionality; the feature makes use of
    the existing dataclass feature introduced in SQLAlchemy 1.4 at [Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)
    to produce an equivalent runtime mapping with a fully integrated configuration
    style, which is also more correctly typed than was possible with the previous
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: To support dataclasses in compliance with [**PEP 681**](https://peps.python.org/pep-0681/),
    ORM constructs like [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") accept additional [**PEP 681**](https://peps.python.org/pep-0681/)
    arguments `init`, `default`, and `default_factory` which are passed along to the
    dataclass creation process. These arguments currently must be present in an explicit
    directive on the right side, just as they would be used with `dataclasses.field()`;
    they currently can’t be local to an `Annotated` construct on the left side. To
    support the convenient use of `Annotated` while still supporting dataclass configuration,
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    can merge a minimal set of right-hand arguments with that of an existing [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct located on the left side within an `Annotated`
    construct, so that most of the succinctness is maintained, as will be seen below.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable dataclasses using class inheritance we make use of the [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin, either directly on each class, or on
    the `Base` class, as illustrated below where we further modify the example mapping
    from “Step 5” of [ORM Declarative Models](#whatsnew-20-orm-declarative-typing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping has used the `@dataclasses.dataclass` decorator directly
    on each mapped class at the same time that the declarative mapping was set up,
    internally setting up each `dataclasses.field()` directive as indicated. `User`
    / `Address` structures can be created using positional arguments as configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Expression / Statement / Result Set Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section provides background and examples for SQLAlchemy’s new SQL expression
    typing approach, which extends from base [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs through SQL statements and
    result sets and into realm of ORM mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale and Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  prefs: []
  type: TYPE_NORMAL
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  prefs: []
  type: TYPE_NORMAL
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  prefs: []
  type: TYPE_NORMAL
- en: '#### SQL Expression Typing - Examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Python Types Assigned to SQL Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ORM classes, scalars, etc. work great.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: the catch - all stubs must be uninstalled
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale and Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  prefs: []
  type: TYPE_NORMAL
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  prefs: []
  type: TYPE_NORMAL
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  prefs: []
  type: TYPE_NORMAL
- en: '#### SQL Expression Typing - Examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  prefs: []
  type: TYPE_NORMAL
- en: Simple Python Types Assigned to SQL Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ORM classes, scalars, etc. work great.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: the catch - all stubs must be uninstalled
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Declarative Models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 introduced the first SQLAlchemy-native ORM typing support using
    a combination of [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    and the [Mypy Plugin](../orm/extensions/mypy.html). In SQLAlchemy 2.0, the Mypy
    plugin **remains available, and has been updated to work with SQLAlchemy 2.0’s
    typing system**. However, it should now be considered **deprecated**, as applications
    now have a straightforward path to adopting the new typing support that does not
    use plugins or stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  prefs: []
  type: TYPE_NORMAL
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Migrating an Existing Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  prefs: []
  type: TYPE_NORMAL
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  prefs: []
  type: TYPE_NORMAL
- en: Typing is supported from step 3 onwards
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  prefs: []
  type: TYPE_NORMAL
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Migrating an Existing Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  prefs: []
  type: TYPE_NORMAL
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  prefs: []
  type: TYPE_NORMAL
- en: Typing is supported from step 3 onwards
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  prefs: []
  type: TYPE_NORMAL
- en: Typing is supported from step 3 onwards
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Legacy Mypy-Typed Models'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to errors under the
    new system, as such annotations are flagged as errors when using constructs such
    as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: The section [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly
    typed ORM models](migration_20.html#migration-20-step-six) illustrates how to
    temporarily disable these errors from being raised for a legacy ORM model that
    uses explicit annotations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](migration_20.html#migration-20-step-six)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Native Support for Dataclasses Mapped as ORM Models'
  prefs: []
  type: TYPE_NORMAL
- en: The new ORM Declarative features introduced above at [ORM Declarative Models](#whatsnew-20-orm-declarative-typing)
    introduced the new [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct and illustrated type-centric mapping
    with optional use of [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`.
    We can take the mapping one step further by integrating this with Python [dataclasses](https://docs.python.org/3/library/dataclasses.html).
    This new feature is made possible via [**PEP 681**](https://peps.python.org/pep-0681/)
    which allows for type checkers to recognize classes that are dataclass compatible,
    or are fully dataclasses, but were declared through alternate APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dataclasses feature, mapped classes gain an `__init__()` method that
    supports positional arguments as well as customizable default values for optional
    keyword arguments. As mentioned previously, dataclasses also generate many useful
    methods such as `__str__()`, `__eq__()`. Dataclass serialization methods such
    as [dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)
    and [dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)
    also work, but don’t currently accommodate for self-referential structures, which
    makes them less viable for mappings that have bidirectional relationships.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s current integration approach converts the user-defined class into
    a **real dataclass** to provide runtime functionality; the feature makes use of
    the existing dataclass feature introduced in SQLAlchemy 1.4 at [Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)
    to produce an equivalent runtime mapping with a fully integrated configuration
    style, which is also more correctly typed than was possible with the previous
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: To support dataclasses in compliance with [**PEP 681**](https://peps.python.org/pep-0681/),
    ORM constructs like [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") accept additional [**PEP 681**](https://peps.python.org/pep-0681/)
    arguments `init`, `default`, and `default_factory` which are passed along to the
    dataclass creation process. These arguments currently must be present in an explicit
    directive on the right side, just as they would be used with `dataclasses.field()`;
    they currently can’t be local to an `Annotated` construct on the left side. To
    support the convenient use of `Annotated` while still supporting dataclass configuration,
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    can merge a minimal set of right-hand arguments with that of an existing [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct located on the left side within an `Annotated`
    construct, so that most of the succinctness is maintained, as will be seen below.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable dataclasses using class inheritance we make use of the [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin, either directly on each class, or on
    the `Base` class, as illustrated below where we further modify the example mapping
    from “Step 5” of [ORM Declarative Models](#whatsnew-20-orm-declarative-typing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The above mapping has used the `@dataclasses.dataclass` decorator directly
    on each mapped class at the same time that the declarative mapping was set up,
    internally setting up each `dataclasses.field()` directive as indicated. `User`
    / `Address` structures can be created using positional arguments as configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Optimized ORM bulk insert now implemented for all backends other than MySQL'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dramatic performance improvement introduced in the 1.4 series and described
    at [ORM Batch inserts with psycopg2 now batch statements with RETURNING in most
    cases](migration_14.html#change-5263) has now been generalized to all included
    backends that support RETURNING, which is all backends other than MySQL: SQLite,
    MariaDB, PostgreSQL (all drivers), and Oracle; SQL Server has support but is temporarily
    disabled in version 2.0.9 [[1]](#id2). While the original feature was most critical
    for the psycopg2 driver which otherwise had major performance issues when using
    `cursor.executemany()`, the change is also critical for other PostgreSQL drivers
    such as asyncpg, as when using RETURNING, single-statement INSERT statements are
    still unacceptably slow, as well as when using SQL Server that also seems to have
    very slow executemany speed for INSERT statements regardless of whether or not
    RETURNING is used.'
  prefs: []
  type: TYPE_NORMAL
- en: The performance of the new feature provides an almost across-the-board order
    of magnitude performance increase for basically every driver when INSERTing ORM
    objects that don’t have a pre-assigned primary key value, as indicated in the
    table below, in most cases specific to the use of RETURNING which is not normally
    supported with executemany().
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 “fast execution helper” approach consists of transforming an INSERT..RETURNING
    statement with a single parameter set into a single statement that INSERTs many
    parameter sets, using multiple “VALUES…” clauses so that it can accommodate many
    parameter sets at once. Parameter sets are then typically batched into groups
    of 1000 or similar, so that no single INSERT statement is excessively large, and
    the INSERT statement is then invoked for each batch of parameters, rather than
    for each individual parameter set. Primary key values and server defaults are
    returned by RETURNING, which continues to work as each statement execution is
    invoked using `cursor.execute()`, rather than `cursor.executemany()`.
  prefs: []
  type: TYPE_NORMAL
- en: This allows many rows to be inserted in one statement while also being able
    to return newly-generated primary key values as well as SQL and server defaults.
    SQLAlchemy historically has always needed to invoke one statement per parameter
    set, as it relied upon Python DBAPI Features such as `cursor.lastrowid` which
    do not support multiple rows.
  prefs: []
  type: TYPE_NORMAL
- en: With most databases now offering RETURNING (with the conspicuous exception of
    MySQL, given that MariaDB supports it), the new change generalizes the psycopg2
    “fast execution helper” approach to all dialects that support RETURNING, which
    now includes SQlite and MariaDB, and for which no other approach for “executemany
    plus RETURNING” is possible, which includes SQLite, MariaDB, and all PG drivers.
    The cx_Oracle and oracledb drivers used for Oracle support RETURNING with executemany
    natively, and this has also been implemented to provide equivalent performance
    improvements. With SQLite and MariaDB now offering RETURNING support, ORM use
    of `cursor.lastrowid` is nearly a thing of the past, with only MySQL still relying
    upon it.
  prefs: []
  type: TYPE_NORMAL
- en: For INSERT statements that don’t use RETURNING, traditional executemany() behavior
    is used for most backends, with the current exception of psycopg2, which has very
    slow executemany() performance overall and are still improved by the “insertmanyvalues”
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy includes a [Performance Suite](../orm/examples.html#examples-performance)
    within the `examples/` directory, where we can make use of the `bulk_insert` suite
    to benchmark INSERTs of many rows using both Core and ORM in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: For the tests below, we are inserting **100,000 objects**, and in all cases
    we actually have 100,000 real Python ORM objects in memory, either created up
    front or generated on the fly. All databases other than SQLite are run over a
    local network connection, not localhost; this causes the “slower” results to be
    extremely slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations that are improved by this feature include:'
  prefs: []
  type: TYPE_NORMAL
- en: unit of work flushes for objects added to the session using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new [ORM Bulk Insert Statement](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    feature, which improves upon the experimental version of this feature first introduced
    in SQLAlchemy 1.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    “bulk” operations described at [Bulk Operations](../orm/persistence_techniques.html#bulk-operations),
    which are superseded by the above mentioned ORM Bulk Insert feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get a sense of the scale of the operation, below are performance measurements
    using the `test_flush_no_pk` performance suite, which historically represents
    SQLAlchemy’s worst-case INSERT performance task, where objects that don’t have
    primary key values need to be INSERTed, and then the newly generated primary key
    values must be fetched so that the objects can be used for subsequent flush operations,
    such as establishment within relationships, flushing joined-inheritance models,
    etc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'This test can be run from any SQLAlchemy source tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The table below summarizes performance measurements with the latest 1.4 series
    of SQLAlchemy compared to 2.0, both running the same test:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
  prefs: []
  type: TYPE_TB
- en: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
  prefs: []
  type: TYPE_TB
- en: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
  prefs: []
  type: TYPE_TB
- en: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional drivers have no change in performance; the psycopg2 drivers,
    for which fast executemany was already implemented in SQLAlchemy 1.4, and MySQL,
    which continues to not offer RETURNING support:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
  prefs: []
  type: TYPE_TB
- en: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
  prefs: []
  type: TYPE_TB
- en: Summary of Changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following bullets list the individual changes made within 2.0 in order
    to get all drivers to this state:'
  prefs: []
  type: TYPE_NORMAL
- en: RETURNING implemented for SQLite - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RETURNING implemented for MariaDB - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix multi-row RETURNING for Oracle - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make insert() executemany() support RETURNING for as many dialects as possible,
    usually with VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emit a warning when RETURNING w/ executemany is used for non-supporting backend
    (currently no RETURNING backend has this limitation) - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a a new setting `"auto"`, which
    will enable “eager defaults” automatically for INSERT statements, when the backend
    in use supports RETURNING with “insertmanyvalues”. See [Fetching Server-Generated
    Defaults](../orm/persistence_techniques.html#orm-server-defaults) for documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - Documentation and background on the new feature as well as how to configure
    it'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy includes a [Performance Suite](../orm/examples.html#examples-performance)
    within the `examples/` directory, where we can make use of the `bulk_insert` suite
    to benchmark INSERTs of many rows using both Core and ORM in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: For the tests below, we are inserting **100,000 objects**, and in all cases
    we actually have 100,000 real Python ORM objects in memory, either created up
    front or generated on the fly. All databases other than SQLite are run over a
    local network connection, not localhost; this causes the “slower” results to be
    extremely slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations that are improved by this feature include:'
  prefs: []
  type: TYPE_NORMAL
- en: unit of work flushes for objects added to the session using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new [ORM Bulk Insert Statement](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    feature, which improves upon the experimental version of this feature first introduced
    in SQLAlchemy 1.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    “bulk” operations described at [Bulk Operations](../orm/persistence_techniques.html#bulk-operations),
    which are superseded by the above mentioned ORM Bulk Insert feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get a sense of the scale of the operation, below are performance measurements
    using the `test_flush_no_pk` performance suite, which historically represents
    SQLAlchemy’s worst-case INSERT performance task, where objects that don’t have
    primary key values need to be INSERTed, and then the newly generated primary key
    values must be fetched so that the objects can be used for subsequent flush operations,
    such as establishment within relationships, flushing joined-inheritance models,
    etc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This test can be run from any SQLAlchemy source tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The table below summarizes performance measurements with the latest 1.4 series
    of SQLAlchemy compared to 2.0, both running the same test:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
  prefs: []
  type: TYPE_TB
- en: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
  prefs: []
  type: TYPE_TB
- en: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
  prefs: []
  type: TYPE_TB
- en: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional drivers have no change in performance; the psycopg2 drivers,
    for which fast executemany was already implemented in SQLAlchemy 1.4, and MySQL,
    which continues to not offer RETURNING support:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
  prefs: []
  type: TYPE_TB
- en: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
  prefs: []
  type: TYPE_TB
- en: Summary of Changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following bullets list the individual changes made within 2.0 in order
    to get all drivers to this state:'
  prefs: []
  type: TYPE_NORMAL
- en: RETURNING implemented for SQLite - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RETURNING implemented for MariaDB - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix multi-row RETURNING for Oracle - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make insert() executemany() support RETURNING for as many dialects as possible,
    usually with VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emit a warning when RETURNING w/ executemany is used for non-supporting backend
    (currently no RETURNING backend has this limitation) - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a a new setting `"auto"`, which
    will enable “eager defaults” automatically for INSERT statements, when the backend
    in use supports RETURNING with “insertmanyvalues”. See [Fetching Server-Generated
    Defaults](../orm/persistence_techniques.html#orm-server-defaults) for documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - Documentation and background on the new feature as well as how to configure
    it'
  prefs: []
  type: TYPE_NORMAL
- en: '## ORM-enabled Insert, Upsert, Update and Delete Statements, with ORM RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 1.4 ported the features of the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to [2.0 style](../glossary.html#term-2.0-style)
    execution, which meant that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct could be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to deliver ORM results. Support was also added
    for [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    to be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), to the degree that they could provide implementations
    of [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete").
  prefs: []
  type: TYPE_NORMAL
- en: The major missing element has been support for the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct. The 1.4 documentation addressed
    this with some recipes for “inserts” and “upserts” with use of [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") to integrate RETURNING into
    an ORM context. 2.0 now fully closes the gap by integrating direct support for
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    as an enhanced version of the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method, along with full ORM RETURNING
    support for all DML structures.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk Insert with RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    can be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), with or without [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), which when passed with a separate
    parameter list will invoke the same process as was previously implemented by [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings"), with additional enhancements.
    This will optimize the batching of rows making use of the new [fast insertmany](#change-6047)
    feature, while also adding support for heterogeneous parameter sets and multiple-table
    mappings like joined table inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: RETURNING is supported for all of these use cases, where the ORM will construct
    a full result set from multiple statement invocations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
  prefs: []
  type: TYPE_NORMAL
- en: Bulk UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a similar manner as that of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), passing the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a parameter list that
    includes primary key values to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will invoke the same process as previously supported
    by the [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This feature does not however
    support RETURNING, as it uses a SQL UPDATE statement that is invoked using DBAPI
    [executemany](../glossary.html#term-executemany):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk UPDATE by Primary Key](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT / upsert … VALUES … RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    with [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values"), the set of parameters may include
    SQL expressions. Additionally, upsert variants such as those for SQLite, PostgreSQL
    and MariaDB are also supported. These statements may now include [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") clauses with column expressions
    or full ORM entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk Insert with Per Row SQL Expressions](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](../orm/queryguide/dml.html#orm-queryguide-upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM UPDATE / DELETE with WHERE … RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.4 also had some modest support for the RETURNING feature to be
    used with the [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    constructs, when used with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This support has now been upgraded to be fully
    native, including that the `fetch` synchronization strategy may also proceed whether
    or not explicit use of RETURNING is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
  prefs: []
  type: TYPE_NORMAL
- en: Improved `synchronize_session` behavior for ORM UPDATE / DELETE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default strategy for [synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)
    is now a new value `"auto"`. This strategy will attempt to use the `"evaluate"`
    strategy and then automatically fall back to the `"fetch"` strategy. For all backends
    other than MySQL / MariaDB, `"fetch"` uses RETURNING to fetch UPDATE/DELETEd primary
    key identifiers within the same statement, so is generally more efficient than
    previous versions (in 1.4, RETURNING was only available for PostgreSQL, SQL Server).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting a Synchronization Strategy](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Listed tickets for new ORM DML with RETURNING features:'
  prefs: []
  type: TYPE_NORMAL
- en: convert `insert()` at ORM level to interpret `values()` in an ORM context -
    [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: evaluate feasibility of dml.returning(Entity) to deliver ORM expressions, automatically
    apply select().from_statement equiv - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'given ORM insert, try to carry the bulk methods along, re: inheritance - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk Insert with RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    can be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), with or without [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), which when passed with a separate
    parameter list will invoke the same process as was previously implemented by [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings"), with additional enhancements.
    This will optimize the batching of rows making use of the new [fast insertmany](#change-6047)
    feature, while also adding support for heterogeneous parameter sets and multiple-table
    mappings like joined table inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: RETURNING is supported for all of these use cases, where the ORM will construct
    a full result set from multiple statement invocations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
  prefs: []
  type: TYPE_NORMAL
- en: Bulk UPDATE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a similar manner as that of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), passing the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a parameter list that
    includes primary key values to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will invoke the same process as previously supported
    by the [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This feature does not however
    support RETURNING, as it uses a SQL UPDATE statement that is invoked using DBAPI
    [executemany](../glossary.html#term-executemany):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk UPDATE by Primary Key](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT / upsert … VALUES … RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    with [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values"), the set of parameters may include
    SQL expressions. Additionally, upsert variants such as those for SQLite, PostgreSQL
    and MariaDB are also supported. These statements may now include [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") clauses with column expressions
    or full ORM entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk Insert with Per Row SQL Expressions](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM “upsert” Statements](../orm/queryguide/dml.html#orm-queryguide-upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: ORM UPDATE / DELETE with WHERE … RETURNING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.4 also had some modest support for the RETURNING feature to be
    used with the [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    constructs, when used with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This support has now been upgraded to be fully
    native, including that the `fetch` synchronization strategy may also proceed whether
    or not explicit use of RETURNING is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
  prefs: []
  type: TYPE_NORMAL
- en: Improved `synchronize_session` behavior for ORM UPDATE / DELETE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default strategy for [synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)
    is now a new value `"auto"`. This strategy will attempt to use the `"evaluate"`
    strategy and then automatically fall back to the `"fetch"` strategy. For all backends
    other than MySQL / MariaDB, `"fetch"` uses RETURNING to fetch UPDATE/DELETEd primary
    key identifiers within the same statement, so is generally more efficient than
    previous versions (in 1.4, RETURNING was only available for PostgreSQL, SQL Server).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting a Synchronization Strategy](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Listed tickets for new ORM DML with RETURNING features:'
  prefs: []
  type: TYPE_NORMAL
- en: convert `insert()` at ORM level to interpret `values()` in an ORM context -
    [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: evaluate feasibility of dml.returning(Entity) to deliver ORM expressions, automatically
    apply select().from_statement equiv - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'given ORM insert, try to carry the bulk methods along, re: inheritance - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## New “Write Only” relationship strategy supersedes “dynamic”'
  prefs: []
  type: TYPE_NORMAL
- en: The `lazy="dynamic"` loader strategy becomes legacy, in that it is hardcoded
    to make use of legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This loader strategy is both not compatible with asyncio,
    and additionally has many behaviors that implicitly iterate its contents, which
    defeat the original purpose of the “dynamic” relationship as being for very large
    collections that should not be implicitly fully loaded into memory at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “dynamic” strategy is now superseded by a new strategy `lazy="write_only"`.
    Configuration of “write only” may be achieved using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), or when using [type annotated mappings](#whatsnew-20-orm-declarative-typing),
    indicating the [`WriteOnlyMapped`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation as the mapping style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The write-only-mapped collection resembles `lazy="dynamic"` in that the collection
    may be assigned up front, and also has methods such as [`WriteOnlyCollection.add()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add") and [`WriteOnlyCollection.remove()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") to modify the collection on an individual
    item basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The bigger difference is on the database loading side, where the collection
    has no ability to load objects from the database directly; instead, SQL construction
    methods such as [`WriteOnlyCollection.select()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") are used to produce SQL constructs
    such as [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    which are then executed using [2.0 style](../glossary.html#term-2.0-style) to
    load the desired objects in an explicit way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") also integrates with the new [ORM bulk dml](#change-8360)
    features, including support for bulk INSERT and UPDATE/DELETE with WHERE criteria,
    all including RETURNING support as well. See the complete documentation at [Write
    Only Relationships](../orm/large_collections.html#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: New pep-484 / type annotated mapping support for Dynamic Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though “dynamic” relationships are legacy in 2.0, as these patterns are
    expected to have a long lifespan, [type annotated mapping](#whatsnew-20-orm-declarative-typing)
    support is now added for “dynamic” relationships in the same way that its available
    for the new `lazy="write_only"` approach, using the [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The above mapping will provide an `Account.account_transactions` collection
    that is typed as returning the [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") collection type, including its element type, e.g.
    `AppenderQuery[AccountTransaction]`. This then allows iteration and queries to
    yield objects which are typed as `AccountTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamic Relationship Loaders](../orm/large_collections.html#dynamic-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)'
  prefs: []
  type: TYPE_NORMAL
- en: New pep-484 / type annotated mapping support for Dynamic Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though “dynamic” relationships are legacy in 2.0, as these patterns are
    expected to have a long lifespan, [type annotated mapping](#whatsnew-20-orm-declarative-typing)
    support is now added for “dynamic” relationships in the same way that its available
    for the new `lazy="write_only"` approach, using the [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The above mapping will provide an `Account.account_transactions` collection
    that is typed as returning the [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") collection type, including its element type, e.g.
    `AppenderQuery[AccountTransaction]`. This then allows iteration and queries to
    yield objects which are typed as `AccountTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamic Relationship Loaders](../orm/large_collections.html#dynamic-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Installation is now fully pep-517 enabled'
  prefs: []
  type: TYPE_NORMAL
- en: The source distribution now includes a `pyproject.toml` file to allow for complete
    [**PEP 517**](https://peps.python.org/pep-0517/) support. In particular this allows
    a local source build using `pip` to automatically install the [Cython](https://cython.org/)
    optional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7311](https://www.sqlalchemy.org/trac/ticket/7311)'
  prefs: []
  type: TYPE_NORMAL
- en: '## C Extensions now ported to Cython'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy C extensions have been replaced with all new extensions written
    in [Cython](https://cython.org/). While Cython was evaluated back in 2010 when
    the C extensions were first created, the nature and focus of the C extensions
    in use today has changed quite a bit from that time. At the same time, Cython
    has apparently evolved significantly, as has the Python build / distribution toolchain
    which made it feasible for us to revisit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The move to Cython provides dramatic new advantages with no apparent downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: The Cython extensions that replace specific C extensions have all benchmarked
    as **faster**, often slightly, but sometimes significantly, than virtually all
    the C code that SQLAlchemy previously included. While this seems amazing, it appears
    to be a product of non-obvious optimizations within Cython’s implementation that
    would not be present in a direct Python to C port of a function, as was particularly
    the case for many of the custom collection types added to the C extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython extensions are much easier to write, maintain and debug compared to raw
    C code, and in most cases are line-per-line equivalent to the Python code. It
    is expected that many more elements of SQLAlchemy will be ported to Cython in
    the coming releases which should open many new doors to performance improvements
    that were previously out of reach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython is very mature and widely used, including being the basis of some of
    the prominent database drivers supported by SQLAlchemy including `asyncpg`, `psycopg3`
    and `asyncmy`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the previous C extensions, the Cython extensions are pre-built within SQLAlchemy’s
    wheel distributions which are automatically available to `pip` from PyPi. Manual
    build instructions are also unchanged with the exception of the Cython requirement.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7256](https://www.sqlalchemy.org/trac/ticket/7256)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Major Architectural, Performance and API Enhancements for Database Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: The internal system by which [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects and their components are [reflected](../core/reflection.html#metadata-reflection)
    has been completely rearchitected to allow high performance bulk reflection of
    thousands of tables at once for participating dialects. Currently, the **PostgreSQL**
    and **Oracle** dialects participate in the new architecture, where the PostgreSQL
    dialect can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects nearly three times faster, and the Oracle dialect
    can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects ten times faster.
  prefs: []
  type: TYPE_NORMAL
- en: The rearchitecture applies most directly to dialects that make use of SELECT
    queries against system catalog tables to reflect tables, and the remaining included
    dialect that can benefit from this approach will be the SQL Server dialect. The
    MySQL/MariaDB and SQLite dialects by contrast make use of non-relational systems
    to reflect database tables, and were not subject to a pre-existing performance
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: The new API is backwards compatible with the previous system, and should require
    no changes to third party dialects to retain compatibility; third party dialects
    can also opt into the new system by implementing batched queries for schema reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Along with this change, the API and behavior of the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object has been improved and enhanced
    with more consistent cross-dialect behaviors as well as new methods and new performance
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Performance Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source distribution includes a script `test/perf/many_table_reflection.py`
    which benches both existing reflection features as well as new ones. A limited
    set of its tests may be run on older versions of SQLAlchemy, where here we use
    it to illustrate differences in performance to invoke `metadata.reflect()` to
    reflect 250 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects at once over a local network connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dialect | Operation | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
  prefs: []
  type: TYPE_TB
- en: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
  prefs: []
  type: TYPE_TB
- en: Behavioral Changes for `Inspector()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For SQLAlchemy-included dialects for SQLite, PostgreSQL, MySQL/MariaDB, Oracle,
    and SQL Server, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence"), [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index"), [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") now all behave consistently
    in terms of caching: they all fully cache their result after being called the
    first time for a particular [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object. Programs that create or drop
    tables/sequences while calling upon the same [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object will not receive updated status
    after the state of the database has changed. A call to [`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache") or a new [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") should be used when DDL changes are
    to be executed. Previously, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence") methods did not implement
    caching nor did the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") support caching for these methods, while
    the [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") methods were, leading
    to inconsistent results between the two types of method.'
  prefs: []
  type: TYPE_NORMAL
- en: Behavior for third party dialects is dependent on whether or not they implement
    the “reflection cache” decorator for the dialect-level implementation of these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: New Methods and Improvements for `Inspector()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: added a method [`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema") that returns if a schema
    is present in the target database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: added a method [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index") that returns if a table has
    a particular index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspection methods such as [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") that work on a single table
    at a time should now all consistently raise [`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError") if a table or view is not found; this change
    is specific to individual dialects, so may not be the case for existing third-party
    dialects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separated the handling of “views” and “materialized views”, as in real world
    use cases, these two constructs make use of different DDL for CREATE and DROP;
    this includes that there are now separate [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and [`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)'
  prefs: []
  type: TYPE_NORMAL
- en: Performance Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The source distribution includes a script `test/perf/many_table_reflection.py`
    which benches both existing reflection features as well as new ones. A limited
    set of its tests may be run on older versions of SQLAlchemy, where here we use
    it to illustrate differences in performance to invoke `metadata.reflect()` to
    reflect 250 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects at once over a local network connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dialect | Operation | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  prefs: []
  type: TYPE_TB
- en: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
  prefs: []
  type: TYPE_TB
- en: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
  prefs: []
  type: TYPE_TB
- en: Behavioral Changes for `Inspector()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For SQLAlchemy-included dialects for SQLite, PostgreSQL, MySQL/MariaDB, Oracle,
    and SQL Server, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence"), [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index"), [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") now all behave consistently
    in terms of caching: they all fully cache their result after being called the
    first time for a particular [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object. Programs that create or drop
    tables/sequences while calling upon the same [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object will not receive updated status
    after the state of the database has changed. A call to [`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache") or a new [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") should be used when DDL changes are
    to be executed. Previously, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence") methods did not implement
    caching nor did the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") support caching for these methods, while
    the [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") methods were, leading
    to inconsistent results between the two types of method.'
  prefs: []
  type: TYPE_NORMAL
- en: Behavior for third party dialects is dependent on whether or not they implement
    the “reflection cache” decorator for the dialect-level implementation of these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: New Methods and Improvements for `Inspector()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: added a method [`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema") that returns if a schema
    is present in the target database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: added a method [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index") that returns if a table has
    a particular index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspection methods such as [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") that work on a single table
    at a time should now all consistently raise [`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError") if a table or view is not found; this change
    is specific to individual dialects, so may not be the case for existing third-party
    dialects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separated the handling of “views” and “materialized views”, as in real world
    use cases, these two constructs make use of different DDL for CREATE and DROP;
    this includes that there are now separate [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and [`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Dialect support for psycopg 3 (a.k.a. “psycopg”)'
  prefs: []
  type: TYPE_NORMAL
- en: Added dialect support for the [psycopg 3](https://pypi.org/project/psycopg/)
    DBAPI, which despite the number “3” now goes by the package name `psycopg`, superseding
    the previous `psycopg2` package that for the time being remains SQLAlchemy’s “default”
    driver for the `postgresql` dialects. `psycopg` is a completely reworked and modernized
    database adapter for PostgreSQL which supports concepts such as prepared statements
    as well as Python asyncio.
  prefs: []
  type: TYPE_NORMAL
- en: '`psycopg` is the first DBAPI supported by SQLAlchemy which provides both a
    pep-249 synchronous API as well as an asyncio driver. The same `psycopg` database
    URL may be used with the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") and [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine-creation functions, and the
    corresponding sync or asyncio version of the dialect will be selected automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[psycopg](../dialects/postgresql.html#postgresql-psycopg)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Dialect support for oracledb'
  prefs: []
  type: TYPE_NORMAL
- en: Added dialect support for the [oracledb](https://pypi.org/project/oracledb/)
    DBAPI, which is the renamed, new major release of the popular cx_Oracle driver.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[python-oracledb](../dialects/oracle.html#oracledb)'
  prefs: []
  type: TYPE_NORMAL
- en: '## New Conditional DDL for Constraints and Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new method [`Constraint.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Constraint.ddl_if
    "sqlalchemy.schema.Constraint.ddl_if") and [`Index.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Index.ddl_if
    "sqlalchemy.schema.Index.ddl_if") allows constructs such as [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") and [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") to be rendered conditionally for a given [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), based on the same kinds of criteria that are accepted
    by the `DDLElement.execute_if()` method. In the example below, the CHECK constraint
    and index will only be produced against a PostgreSQL backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling DDL Generation of Constraints and Indexes](../core/ddl.html#schema-ddl-ddl-if)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7631](https://www.sqlalchemy.org/trac/ticket/7631)'
  prefs: []
  type: TYPE_NORMAL
- en: '## DATE, TIME, DATETIME datatypes now support literal rendering on all backends'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal rendering is now implemented for date and time types for backend specific
    compilation, including PostgreSQL and Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Previously, such literal rendering only worked when stringifying statements
    without any dialect given; when attempting to render with a dialect-specific type,
    a `NotImplementedError` would be raised, up until SQLAlchemy 1.4.45 where this
    became a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") (part of [#8800](https://www.sqlalchemy.org/trac/ticket/8800)).
  prefs: []
  type: TYPE_NORMAL
- en: The default rendering is modified ISO-8601 rendering (i.e. ISO-8601 with the
    T converted to a space) when using `literal_binds` with the SQL compilers provided
    by the PostgreSQL, MySQL, MariaDB, MSSQL, Oracle dialects. For Oracle, the ISO
    format is wrapped inside of an appropriate TO_DATE() function call. The rendering
    for SQLite is unchanged as this dialect always included string rendering for date
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[#5052](https://www.sqlalchemy.org/trac/ticket/5052)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Context Manager Support for `Result`, `AsyncResult`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object now supports context manager use, which will ensure the object and its
    underlying cursor is closed at the end of the block. This is useful in particular
    with server side cursors, where it’s important that the open cursor object is
    closed at the end of an operation, even if user-defined exceptions have occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'With asyncio use, the [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") and [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") have been altered to provide for optional
    async context manager use, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[#8710](https://www.sqlalchemy.org/trac/ticket/8710)'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers behavioral changes made in SQLAlchemy 2.0 which are not
    otherwise part of the major 1.4->2.0 migration path; changes here are not expected
    to have significant effects on backwards compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '### New transaction join modes for `Session`'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of “joining an external transaction into a Session” has been revised
    and improved, allowing explicit control over how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will accommodate an incoming [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that already has a transaction and possibly a
    savepoint already established. The new parameter [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") includes a series of option values which can accommodate
    the existing transaction in several ways, most importantly allowing a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to operate in a fully transactional style using savepoints
    exclusively, while leaving the externally initiated transaction non-committed
    and active under all circumstances, allowing test suites to rollback all changes
    that take place within tests.
  prefs: []
  type: TYPE_NORMAL
- en: The primary improvement this allows is that the recipe documented at [Joining
    a Session into an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction),
    which also changed from SQLAlchemy 1.3 to 1.4, is now simplified to no longer
    require explicit use of an event handler or any mention of an explicit savepoint;
    by using `join_transaction_mode="create_savepoint"`, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will never affect the state of an incoming transaction,
    and will instead create a savepoint (i.e. “nested transaction”) as its root transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates part of the example given at [Joining a Session into
    an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction);
    see that section for a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The default mode selected for [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") is `"conditional_savepoint"`, which uses `"create_savepoint"`
    behavior if the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is itself already on a savepoint. If the given
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is in a transaction but not a savepoint, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will propagate “rollback” calls but not “commit” calls,
    but will not begin a new savepoint on its own. This behavior is chosen by default
    for its maximum compatibility with older SQLAlchemy versions as well as that it
    does not start a new SAVEPOINT unless the given driver is already making use of
    SAVEPOINT, as support for SAVEPOINT varies not only with specific backend and
    driver but also configurationally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates a case that worked in SQLAlchemy 1.3, stopped working
    in SQLAlchemy 1.4, and is now restored in SQLAlchemy 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Where above, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is joined to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that has a savepoint started on it; the state
    of these two units remains unchanged after the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has worked with the transaction. In SQLAlchemy 1.3,
    the above case worked because the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would begin a “subtransaction” upon the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which would allow the outer savepoint / transaction
    to remain unaffected for simple cases as above. Since subtransactions were deprecated
    in 1.4 and are now removed in 2.0, this behavior was no longer available. The
    new default behavior improves upon the behavior of “subtransactions” by using
    a real, second SAVEPOINT instead, so that even calls to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") prevent the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from “breaking out” into the externally initiated SAVEPOINT
    or transaction.
  prefs: []
  type: TYPE_NORMAL
- en: New code that is joining a transaction-started [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should however select a [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") explicitly, so that the desired behavior is explicitly
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)  ### `str(engine.url)`
    will obfuscate the password by default'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid leakage of database passwords, calling `str()` on a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") will now enable the password obfuscation feature by default.
    Previously, this obfuscation would be in place for `__repr__()` calls but not
    `__str__()`. This change will impact applications and test suites that attempt
    to invoke [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    given the stringified URL from another engine, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The above engine `e2` will not have the correct password; it will have the obfuscated
    string `"***"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferred approach for the above pattern is to pass the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object directly, there’s no need to stringify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, for a stringified URL with cleartext password, use the [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") method, passing the [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)  ### Stricter rules for
    replacement of Columns in Table objects with same-names, keys'
  prefs: []
  type: TYPE_NORMAL
- en: Stricter rules are in place for appending of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, both moving some previous deprecation warnings
    to exceptions, and preventing some previous scenarios that would cause duplicate
    columns to appear in tables, when [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") were set to `True`, for both programmatic [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construction as well as during reflection operations.
  prefs: []
  type: TYPE_NORMAL
- en: Under no circumstances should a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object ever have two or more [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with the same name, regardless of what .key
    they have. An edge case where this was still possible was identified and fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that has the same name or key as an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will always raise [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError") (a new subclass of [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") in 2.0.0b4) unless additional parameters are present;
    [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") for [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column"), and [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") for construction of a same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as an existing one, with or without reflection being
    used. Previously, there was a deprecation warning in place for this scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is now emitted if a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is created, that does include [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table"), where an incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that has no separate [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") would fully replace an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that does have a key, which suggests the operation
    is not what the user intended. This can happen particularly during a secondary
    reflection step, such as `metadata.reflect(extend_existing=True)`. The warning
    suggests that the [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") parameter be set to `False` to prevent this. Previously,
    in 1.4 and earlier, the incoming column would be added **in addition** to the
    existing column. This was a bug and is a behavioral change in 2.0 (as of 2.0.0b4),
    as the previous key will **no longer be present** in the column collection when
    this occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)  ### ORM Declarative Applies
    Column Orders Differently; Control behavior using `sort_order`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative has changed the system by which mapped columns that originate from
    mixin or abstract base classes are sorted along with the columns that are on the
    declared class itself to place columns from the declared class first, followed
    by mixin columns. The following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces a CREATE TABLE as follows on 1.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas on 2.0 it produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'For the specific case above, this can be seen as an improvement, as the primary
    key columns on the `Model` are now where one would typically prefer. However,
    this is no comfort for the application that defined models the other way around,
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'This now produces CREATE TABLE output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this issue, SQLAlchemy 2.0.4 introduces a new parameter on [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") called [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column"), which is an integer value, defaulting to `0`,
    that can be set to a positive or negative value so that columns are placed before
    or after other columns, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The above model places “id” before all others and “col1” after “id”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Future SQLAlchemy releases may opt to provide an explicit ordering hint for
    the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, as this ordering is ORM specific.  ### The `Sequence` construct reverts
    to not having any explicit default “start” value; impacts MS SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to SQLAlchemy 1.4, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct would emit only simple `CREATE SEQUENCE`
    DDL, if no additional arguments were specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    support was added for MS SQL Server, where the default start value is inconveniently
    set to `-2**63`, version 1.4 decided to default the DDL to emit a start value
    of 1, if [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") were not otherwise provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: This change has introduced other complexities, including that when the [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") parameter is included, this default of `1` should
    in fact default to what [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") states, else a min_value that’s below the start_value
    may be seen as contradictory. As looking at this issue started to become a bit
    of a rabbit hole of other various edge cases, we decided to instead revert this
    change and restore the original behavior of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") which is to have no opinion, and just emit CREATE
    SEQUENCE, allowing the database itself to make its decisions on how the various
    parameters of `SEQUENCE` should interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to ensure that the start value is 1 on all backends, **the start
    value of 1 may be indicated explicitly**, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Beyond all of that, for autogeneration of integer primary keys on modern backends
    including PostgreSQL, Oracle, SQL Server, the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct should be preferred, which also works
    the same way in 1.4 and 2.0 with no changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)  ### “with_variant()”
    clones the original TypeEngine rather than changing the type'
  prefs: []
  type: TYPE_NORMAL
- en: The [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method, which is used to apply alternate
    per-database behaviors to a particular type, now returns a copy of the original
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object with the variant information stored internally, rather than wrapping it
    inside the `Variant` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the previous `Variant` approach was able to maintain all the in-Python
    behaviors of the original type using dynamic attribute getters, the improvement
    here is that when calling upon a variant, the returned type remains an instance
    of the original type, which works more smoothly with type checkers such as mypy
    and pylance. Given a program as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'A type checker like pyright will now report the type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: In addition, as illustrated above, multiple dialect names may be passed for
    single type, in particular this is helpful for the pair of `"mysql"` and `"mariadb"`
    dialects which are considered separately as of SQLAlchemy 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)  ### Python division operator
    performs true division for all backends; added floor division'
  prefs: []
  type: TYPE_NORMAL
- en: The Core expression language now supports both “true division” (i.e. the `/`
    Python operator) and “floor division” (i.e. the `//` Python operator) including
    backend-specific behaviors to normalize different databases in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a “true division” operation against two integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL division operator on PostgreSQL for example normally acts as “floor
    division” when used against integers, meaning the above result would return the
    integer “0”. For this and similar backends, SQLAlchemy now renders the SQL using
    a form which is equivalent towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: With `param_1=5`, `param_2=10`, so that the return expression will be of type
    NUMERIC, typically as the Python value `decimal.Decimal("0.5")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a “floor division” operation against two integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL division operator on MySQL and Oracle for example normally acts as
    “true division” when used against integers, meaning the above result would return
    the floating point value “0.5”. For these and similar backends, SQLAlchemy now
    renders the SQL using a form which is equivalent towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: With param_1=5, param_2=10, so that the return expression will be of type INTEGER,
    as the Python value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backwards-incompatible change here would be if an application using PostgreSQL,
    SQL Server, or SQLite which relied on the Python “truediv” operator to return
    an integer value in all cases. Applications which rely upon this behavior should
    instead use the Python “floor division” operator `//` for these operations, or
    for forwards compatibility when using a previous SQLAlchemy version, the floor
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: The above form would be needed on any SQLAlchemy version prior to 2.0 in order
    to provide backend-agnostic floor division.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)  ### Session raises proactively
    when illegal concurrent or reentrant access is detected'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now trap more errors related to illegal concurrent state changes within multithreaded
    or other concurrent scenarios as well as for event hooks which perform unexpected
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One error that’s been known to occur when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in multiple threads simultaneously is `AttributeError:
    ''NoneType'' object has no attribute ''twophase''`, which is completely cryptic.
    This error occurs when a thread calls [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which internally invokes the `SessionTransaction.close()`
    method to end the transactional context, at the same time that another thread
    is in progress running a query as from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). Within [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), the internal method that acquires a database
    connection for the current transaction first begins by asserting that the session
    is “active”, but after this assertion passes, the concurrent call to [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") interferes with this state which leads to the
    undefined condition above.'
  prefs: []
  type: TYPE_NORMAL
- en: The change applies guards to all state-changing methods surrounding the [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object so that in the above case, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will instead fail as it will seek to change
    the state to one that is disallowed for the duration of the already-in-progress
    method that wants to get the current connection to run a database query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the test script illustrated at [#7433](https://www.sqlalchemy.org/trac/ticket/7433),
    the previous error case looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the `_connection_for_bind()` method isn’t able to continue since concurrent
    access placed it into an invalid state. Using the new approach, the originator
    of the state change throws the error instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: The state transition checks intentionally don’t use explicit locks to detect
    concurrent thread activity, instead relying upon simple attribute set / value
    test operations that inherently fail when unexpected concurrent changes occur.
    The rationale is that the approach can detect illegal state changes that occur
    entirely within a single thread, such as an event handler that runs on session
    transaction events calls a state-changing method that’s not expected, or under
    asyncio if a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were shared among multiple asyncio tasks, as well as
    when using patching-style concurrency approaches such as gevent.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)  ### The SQLite dialect
    uses QueuePool for file-based databases'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect now defaults to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") when a file based database is used. This is set along
    with setting the `check_same_thread` parameter to `False`. It has been observed
    that the previous approach of defaulting to [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool"), which does not hold onto database connections after
    they are released, did in fact have a measurable negative performance impact.
    As always, the pool class is customizable via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)  ### New Oracle FLOAT
    type with binary precision; decimal precision not accepted directly'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new datatype [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") has been added to the Oracle dialect, to accompany
    the addition of [`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    and database-specific [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE"), [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") and [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") datatypes. Oracle’s `FLOAT` accepts a so-called “binary
    precision” parameter that per Oracle documentation is roughly a standard “precision”
    value divided by 0.3103:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: A binary precision value of 126 is synonymous with using the [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") datatype, and a value of 63 is equivalent
    to using the [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    datatype. Other precision values are specific to the [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype also accepts a “precision” parameter, but this is decimal precision which
    is not accepted by Oracle. Rather than attempting to guess the conversion, the
    Oracle dialect will now raise an informative error if [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") is used with a precision value against the Oracle backend.
    To specify a [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype with an explicit precision value for supporting backends, while also
    supporting other backends, use the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]  ### New RANGE / MULTIRANGE support and changes for PostgreSQL backends'
  prefs: []
  type: TYPE_NORMAL
- en: RANGE / MULTIRANGE support has been fully implemented for psycopg2, psycopg3,
    and asyncpg dialects. The new support uses a new SQLAlchemy-specific [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object that is agnostic of the different
    backends and does not require the use of backend-specific imports or extension
    steps. For multirange support, lists of [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects are used.
  prefs: []
  type: TYPE_NORMAL
- en: Code that used the previous psycopg2-specific types should be modified to use
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range"),
    which presents a compatible interface.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object also features comparison support
    which mirrors that of PostgreSQL. Implemented so far are [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") and [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") methods which work in the
    same way as the PostgreSQL `@>` and `<@`. Additional operator support may be added
    in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation at [Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)
    for background on using the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)  ###
    `match()` operator on PostgreSQL uses `plainto_tsquery()` rather than `to_tsquery()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Operators.match()` function now renders `col @@ plainto_tsquery(expr)`
    on the PostgreSQL backend, rather than `col @@ to_tsquery()`. `plainto_tsquery()`
    accepts plain text whereas `to_tsquery()` accepts specialized query symbols, and
    is therefore less cross-compatible with other backends.
  prefs: []
  type: TYPE_NORMAL
- en: All PostgreSQL search functions and operators are available through use of [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to generate PostgreSQL-specific functions and
    [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") (a boolean-typed version of [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")) to generate arbitrary operators, in
    the same manner as they are available in previous versions. See the examples at
    [Full Text Search](../dialects/postgresql.html#postgresql-match).
  prefs: []
  type: TYPE_NORMAL
- en: Existing SQLAlchemy projects that make use of PG-specific directives within
    `Operators.match()` should make use of `func.to_tsquery()` directly. To render
    SQL in exactly the same form as would be present in 1.4, see the version note
    at [Simple plain text matching with match()](../dialects/postgresql.html#postgresql-simple-match).
  prefs: []
  type: TYPE_NORMAL
- en: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)  ### New transaction join
    modes for `Session`'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of “joining an external transaction into a Session” has been revised
    and improved, allowing explicit control over how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will accommodate an incoming [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that already has a transaction and possibly a
    savepoint already established. The new parameter [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") includes a series of option values which can accommodate
    the existing transaction in several ways, most importantly allowing a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to operate in a fully transactional style using savepoints
    exclusively, while leaving the externally initiated transaction non-committed
    and active under all circumstances, allowing test suites to rollback all changes
    that take place within tests.
  prefs: []
  type: TYPE_NORMAL
- en: The primary improvement this allows is that the recipe documented at [Joining
    a Session into an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction),
    which also changed from SQLAlchemy 1.3 to 1.4, is now simplified to no longer
    require explicit use of an event handler or any mention of an explicit savepoint;
    by using `join_transaction_mode="create_savepoint"`, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will never affect the state of an incoming transaction,
    and will instead create a savepoint (i.e. “nested transaction”) as its root transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates part of the example given at [Joining a Session into
    an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction);
    see that section for a full example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: The default mode selected for [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") is `"conditional_savepoint"`, which uses `"create_savepoint"`
    behavior if the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is itself already on a savepoint. If the given
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is in a transaction but not a savepoint, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will propagate “rollback” calls but not “commit” calls,
    but will not begin a new savepoint on its own. This behavior is chosen by default
    for its maximum compatibility with older SQLAlchemy versions as well as that it
    does not start a new SAVEPOINT unless the given driver is already making use of
    SAVEPOINT, as support for SAVEPOINT varies not only with specific backend and
    driver but also configurationally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates a case that worked in SQLAlchemy 1.3, stopped working
    in SQLAlchemy 1.4, and is now restored in SQLAlchemy 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Where above, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is joined to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that has a savepoint started on it; the state
    of these two units remains unchanged after the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has worked with the transaction. In SQLAlchemy 1.3,
    the above case worked because the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would begin a “subtransaction” upon the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which would allow the outer savepoint / transaction
    to remain unaffected for simple cases as above. Since subtransactions were deprecated
    in 1.4 and are now removed in 2.0, this behavior was no longer available. The
    new default behavior improves upon the behavior of “subtransactions” by using
    a real, second SAVEPOINT instead, so that even calls to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") prevent the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from “breaking out” into the externally initiated SAVEPOINT
    or transaction.
  prefs: []
  type: TYPE_NORMAL
- en: New code that is joining a transaction-started [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should however select a [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") explicitly, so that the desired behavior is explicitly
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `str(engine.url)` will obfuscate the password by default'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid leakage of database passwords, calling `str()` on a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") will now enable the password obfuscation feature by default.
    Previously, this obfuscation would be in place for `__repr__()` calls but not
    `__str__()`. This change will impact applications and test suites that attempt
    to invoke [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    given the stringified URL from another engine, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The above engine `e2` will not have the correct password; it will have the obfuscated
    string `"***"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preferred approach for the above pattern is to pass the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object directly, there’s no need to stringify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, for a stringified URL with cleartext password, use the [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") method, passing the [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Stricter rules for replacement of Columns in Table objects with same-names,
    keys'
  prefs: []
  type: TYPE_NORMAL
- en: Stricter rules are in place for appending of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, both moving some previous deprecation warnings
    to exceptions, and preventing some previous scenarios that would cause duplicate
    columns to appear in tables, when [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") were set to `True`, for both programmatic [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construction as well as during reflection operations.
  prefs: []
  type: TYPE_NORMAL
- en: Under no circumstances should a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object ever have two or more [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with the same name, regardless of what .key
    they have. An edge case where this was still possible was identified and fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that has the same name or key as an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will always raise [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError") (a new subclass of [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") in 2.0.0b4) unless additional parameters are present;
    [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") for [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column"), and [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") for construction of a same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as an existing one, with or without reflection being
    used. Previously, there was a deprecation warning in place for this scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is now emitted if a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is created, that does include [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table"), where an incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that has no separate [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") would fully replace an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that does have a key, which suggests the operation
    is not what the user intended. This can happen particularly during a secondary
    reflection step, such as `metadata.reflect(extend_existing=True)`. The warning
    suggests that the [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") parameter be set to `False` to prevent this. Previously,
    in 1.4 and earlier, the incoming column would be added **in addition** to the
    existing column. This was a bug and is a behavioral change in 2.0 (as of 2.0.0b4),
    as the previous key will **no longer be present** in the column collection when
    this occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ORM Declarative Applies Column Orders Differently; Control behavior using
    `sort_order`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative has changed the system by which mapped columns that originate from
    mixin or abstract base classes are sorted along with the columns that are on the
    declared class itself to place columns from the declared class first, followed
    by mixin columns. The following mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces a CREATE TABLE as follows on 1.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas on 2.0 it produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'For the specific case above, this can be seen as an improvement, as the primary
    key columns on the `Model` are now where one would typically prefer. However,
    this is no comfort for the application that defined models the other way around,
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'This now produces CREATE TABLE output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this issue, SQLAlchemy 2.0.4 introduces a new parameter on [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") called [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column"), which is an integer value, defaulting to `0`,
    that can be set to a positive or negative value so that columns are placed before
    or after other columns, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'The above model places “id” before all others and “col1” after “id”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Future SQLAlchemy releases may opt to provide an explicit ordering hint for
    the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, as this ordering is ORM specific.
  prefs: []
  type: TYPE_NORMAL
- en: '### The `Sequence` construct reverts to not having any explicit default “start”
    value; impacts MS SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to SQLAlchemy 1.4, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct would emit only simple `CREATE SEQUENCE`
    DDL, if no additional arguments were specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    support was added for MS SQL Server, where the default start value is inconveniently
    set to `-2**63`, version 1.4 decided to default the DDL to emit a start value
    of 1, if [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") were not otherwise provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This change has introduced other complexities, including that when the [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") parameter is included, this default of `1` should
    in fact default to what [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") states, else a min_value that’s below the start_value
    may be seen as contradictory. As looking at this issue started to become a bit
    of a rabbit hole of other various edge cases, we decided to instead revert this
    change and restore the original behavior of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") which is to have no opinion, and just emit CREATE
    SEQUENCE, allowing the database itself to make its decisions on how the various
    parameters of `SEQUENCE` should interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to ensure that the start value is 1 on all backends, **the start
    value of 1 may be indicated explicitly**, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Beyond all of that, for autogeneration of integer primary keys on modern backends
    including PostgreSQL, Oracle, SQL Server, the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct should be preferred, which also works
    the same way in 1.4 and 2.0 with no changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)'
  prefs: []
  type: TYPE_NORMAL
- en: '### “with_variant()” clones the original TypeEngine rather than changing the
    type'
  prefs: []
  type: TYPE_NORMAL
- en: The [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method, which is used to apply alternate
    per-database behaviors to a particular type, now returns a copy of the original
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object with the variant information stored internally, rather than wrapping it
    inside the `Variant` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the previous `Variant` approach was able to maintain all the in-Python
    behaviors of the original type using dynamic attribute getters, the improvement
    here is that when calling upon a variant, the returned type remains an instance
    of the original type, which works more smoothly with type checkers such as mypy
    and pylance. Given a program as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'A type checker like pyright will now report the type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: In addition, as illustrated above, multiple dialect names may be passed for
    single type, in particular this is helpful for the pair of `"mysql"` and `"mariadb"`
    dialects which are considered separately as of SQLAlchemy 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Python division operator performs true division for all backends; added
    floor division'
  prefs: []
  type: TYPE_NORMAL
- en: The Core expression language now supports both “true division” (i.e. the `/`
    Python operator) and “floor division” (i.e. the `//` Python operator) including
    backend-specific behaviors to normalize different databases in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a “true division” operation against two integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL division operator on PostgreSQL for example normally acts as “floor
    division” when used against integers, meaning the above result would return the
    integer “0”. For this and similar backends, SQLAlchemy now renders the SQL using
    a form which is equivalent towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: With `param_1=5`, `param_2=10`, so that the return expression will be of type
    NUMERIC, typically as the Python value `decimal.Decimal("0.5")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a “floor division” operation against two integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL division operator on MySQL and Oracle for example normally acts as
    “true division” when used against integers, meaning the above result would return
    the floating point value “0.5”. For these and similar backends, SQLAlchemy now
    renders the SQL using a form which is equivalent towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: With param_1=5, param_2=10, so that the return expression will be of type INTEGER,
    as the Python value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backwards-incompatible change here would be if an application using PostgreSQL,
    SQL Server, or SQLite which relied on the Python “truediv” operator to return
    an integer value in all cases. Applications which rely upon this behavior should
    instead use the Python “floor division” operator `//` for these operations, or
    for forwards compatibility when using a previous SQLAlchemy version, the floor
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: The above form would be needed on any SQLAlchemy version prior to 2.0 in order
    to provide backend-agnostic floor division.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Session raises proactively when illegal concurrent or reentrant access
    is detected'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now trap more errors related to illegal concurrent state changes within multithreaded
    or other concurrent scenarios as well as for event hooks which perform unexpected
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One error that’s been known to occur when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in multiple threads simultaneously is `AttributeError:
    ''NoneType'' object has no attribute ''twophase''`, which is completely cryptic.
    This error occurs when a thread calls [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which internally invokes the `SessionTransaction.close()`
    method to end the transactional context, at the same time that another thread
    is in progress running a query as from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). Within [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), the internal method that acquires a database
    connection for the current transaction first begins by asserting that the session
    is “active”, but after this assertion passes, the concurrent call to [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") interferes with this state which leads to the
    undefined condition above.'
  prefs: []
  type: TYPE_NORMAL
- en: The change applies guards to all state-changing methods surrounding the [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object so that in the above case, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will instead fail as it will seek to change
    the state to one that is disallowed for the duration of the already-in-progress
    method that wants to get the current connection to run a database query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the test script illustrated at [#7433](https://www.sqlalchemy.org/trac/ticket/7433),
    the previous error case looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the `_connection_for_bind()` method isn’t able to continue since concurrent
    access placed it into an invalid state. Using the new approach, the originator
    of the state change throws the error instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The state transition checks intentionally don’t use explicit locks to detect
    concurrent thread activity, instead relying upon simple attribute set / value
    test operations that inherently fail when unexpected concurrent changes occur.
    The rationale is that the approach can detect illegal state changes that occur
    entirely within a single thread, such as an event handler that runs on session
    transaction events calls a state-changing method that’s not expected, or under
    asyncio if a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were shared among multiple asyncio tasks, as well as
    when using patching-style concurrency approaches such as gevent.
  prefs: []
  type: TYPE_NORMAL
- en: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The SQLite dialect uses QueuePool for file-based databases'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect now defaults to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") when a file based database is used. This is set along
    with setting the `check_same_thread` parameter to `False`. It has been observed
    that the previous approach of defaulting to [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool"), which does not hold onto database connections after
    they are released, did in fact have a measurable negative performance impact.
    As always, the pool class is customizable via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New Oracle FLOAT type with binary precision; decimal precision not accepted
    directly'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new datatype [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") has been added to the Oracle dialect, to accompany
    the addition of [`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    and database-specific [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE"), [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") and [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") datatypes. Oracle’s `FLOAT` accepts a so-called “binary
    precision” parameter that per Oracle documentation is roughly a standard “precision”
    value divided by 0.3103:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: A binary precision value of 126 is synonymous with using the [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") datatype, and a value of 63 is equivalent
    to using the [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    datatype. Other precision values are specific to the [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype also accepts a “precision” parameter, but this is decimal precision which
    is not accepted by Oracle. Rather than attempting to guess the conversion, the
    Oracle dialect will now raise an informative error if [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") is used with a precision value against the Oracle backend.
    To specify a [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype with an explicit precision value for supporting backends, while also
    supporting other backends, use the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '### New RANGE / MULTIRANGE support and changes for PostgreSQL backends'
  prefs: []
  type: TYPE_NORMAL
- en: RANGE / MULTIRANGE support has been fully implemented for psycopg2, psycopg3,
    and asyncpg dialects. The new support uses a new SQLAlchemy-specific [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object that is agnostic of the different
    backends and does not require the use of backend-specific imports or extension
    steps. For multirange support, lists of [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects are used.
  prefs: []
  type: TYPE_NORMAL
- en: Code that used the previous psycopg2-specific types should be modified to use
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range"),
    which presents a compatible interface.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object also features comparison support
    which mirrors that of PostgreSQL. Implemented so far are [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") and [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") methods which work in the
    same way as the PostgreSQL `@>` and `<@`. Additional operator support may be added
    in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation at [Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)
    for background on using the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)'
  prefs: []
  type: TYPE_NORMAL
- en: '### `match()` operator on PostgreSQL uses `plainto_tsquery()` rather than `to_tsquery()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Operators.match()` function now renders `col @@ plainto_tsquery(expr)`
    on the PostgreSQL backend, rather than `col @@ to_tsquery()`. `plainto_tsquery()`
    accepts plain text whereas `to_tsquery()` accepts specialized query symbols, and
    is therefore less cross-compatible with other backends.
  prefs: []
  type: TYPE_NORMAL
- en: All PostgreSQL search functions and operators are available through use of [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to generate PostgreSQL-specific functions and
    [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") (a boolean-typed version of [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")) to generate arbitrary operators, in
    the same manner as they are available in previous versions. See the examples at
    [Full Text Search](../dialects/postgresql.html#postgresql-match).
  prefs: []
  type: TYPE_NORMAL
- en: Existing SQLAlchemy projects that make use of PG-specific directives within
    `Operators.match()` should make use of `func.to_tsquery()` directly. To render
    SQL in exactly the same form as would be present in 1.4, see the version note
    at [Simple plain text matching with match()](../dialects/postgresql.html#postgresql-simple-match).
  prefs: []
  type: TYPE_NORMAL
- en: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)'
  prefs: []
  type: TYPE_NORMAL
