- en: What’s New in SQLAlchemy 2.0?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 有哪些新功能？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html](https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html](https://docs.sqlalchemy.org/en/20/changelog/whatsnew_20.html)
- en: Note for Readers
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 读者注意事项
- en: 'SQLAlchemy 2.0’s transition documents are separated into **two** documents
    - one which details major API shifts from the 1.x to 2.x series, and the other
    which details new features and behaviors relative to SQLAlchemy 1.4:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 的过渡文档分为 **两个** 文档 - 一个详细说明了从 1.x 到 2.x 系列的主要 API 转换，另一个详细说明了与
    SQLAlchemy 1.4 相关的新功能和行为：
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html) - 1.x to 2.x API
    shifts'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html) - 1.x 到 2.x API
    转换'
- en: '[What’s New in SQLAlchemy 2.0?](#) - this document, new features and behaviors
    for SQLAlchemy 2.0'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 有哪些新功能？](#) - 本文档，SQLAlchemy 2.0 的新功能和行为'
- en: Readers who have not yet updated their 1.4 application to follow SQLAlchemy
    2.0 engine and ORM conventions may navigate to [SQLAlchemy 2.0 - Major Migration
    Guide](migration_20.html) for a guide to ensuring SQLAlchemy 2.0 compatibility,
    which is a prerequisite for having working code under version 2.0.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未将其 1.4 应用程序更新为遵循 SQLAlchemy 2.0 引擎和 ORM 约定的读者可以导航到[SQLAlchemy 2.0 - Major
    Migration Guide](migration_20.html)了解确保 SQLAlchemy 2.0 兼容性的指南，这是在版本 2.0 下拥有可工作代码的先决条件。
- en: About this Document
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 1.4 and SQLAlchemy
    version 2.0, **independent** of the major changes between [1.x style](../glossary.html#term-1.x-style)
    and [2.0 style](../glossary.html#term-2.0-style) usage. Readers should start with
    the [SQLAlchemy 2.0 - Major Migration Guide](migration_20.html) document to get
    an overall picture of the major compatibility changes between the 1.x and 2.x
    series.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本文描述了 SQLAlchemy 版本 1.4 与版本 2.0 之间的变化，**与** [1.x 风格](../glossary.html#term-1.x-style)和
    [2.0 风格](../glossary.html#term-2.0-style)的主要变化无关。读者应该从[SQLAlchemy 2.0 - Major
    Migration Guide](migration_20.html)文档开始，以了解 1.x 和 2.x 系列之间的主要兼容性变化的整体图片。
- en: Aside from the major 1.x->2.x migration path, the next largest paradigm shift
    in SQLAlchemy 2.0 is deep integration with [**PEP 484**](https://peps.python.org/pep-0484/)
    typing practices and current capabilities, particularly within the ORM. New type-driven
    ORM declarative styles inspired by Python [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    as well as new integrations with dataclasses themselves, complement an overall
    approach that no longer requires stubs and also goes very far towards providing
    a type-aware method chain from SQL statement to result set.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要的 1.x->2.x 迁移路径之外，SQLAlchemy 2.0 中下一个最大的范式转变是与[**PEP 484**](https://peps.python.org/pep-0484/)类型实践和当前能力的深度集成，特别是在
    ORM 中。受 Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)启发的新型基于类型的
    ORM 声明风格，以及与 dataclasses 本身的新集成，补充了一种不再需要存根并且在从 SQL 语句到结果集的类型感知方法链方面取得了很大进展的整体方法。
- en: The prominence of Python typing is significant not only so that type checkers
    like [mypy](https://mypy.readthedocs.io/en/stable/) can run without plugins; more
    significantly it allows IDEs like [vscode](https://code.visualstudio.com/) and
    [pycharm](https://www.jetbrains.com/pycharm/) to take a much more active role
    in assisting with the composition of a SQLAlchemy application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 类型的突出地位不仅仅在于使得诸如[mypy](https://mypy.readthedocs.io/en/stable/)之类的类型检查器可以无需插件而运行；更重要的是，它使得像[vscode](https://code.visualstudio.com/)和[pycharm](https://www.jetbrains.com/pycharm/)这样的集成开发环境能够在辅助编写
    SQLAlchemy 应用程序时发挥更加积极的作用。
- en: New Typing Support in Core and ORM - Stubs / Extensions no longer used
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Core 和 ORM 中的新类型支持 - 不再使用存根 / 扩展
- en: The approach to typing for Core and ORM has been completely reworked, compared
    to the interim approach that was provided in version 1.4 via the [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    package. The new approach begins at the most fundamental element in SQLAlchemy
    which is the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    or more accurately the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") that underlies all SQL expressions
    that have a type. This expression-level typing then extends into the area of statement
    construction, statement execution, and result sets, and finally into the ORM where
    new [declarative](../orm/declarative_config.html) forms allow for fully typed
    ORM models that integrate all the way from statement to result set.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与版本1.4中通过[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)包提供的临时方法相比，Core和ORM的类型化方法已经完全重新设计。新方法从SQLAlchemy中最基本的元素开始，即[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，或者更准确地说是支撑所有具有类型的SQL表达式的[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")。然后，这种表达级别的类型化扩展到语句构造、语句执行和结果集，并最终扩展到ORM，其中新的[declarative](../orm/declarative_config.html)形式允许完全类型化的ORM模型，从语句到结果集完全集成。
- en: Tip
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Typing support should be considered **beta level** software for the 2.0 series.
    Typing details are subject to change however significant backwards-incompatible
    changes are not planned.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2.0系列，类型化支持应该被视为**beta级别**软件。类型化细节可能会更改，但不计划进行重大的不兼容性更改。
- en: SQL Expression / Statement / Result Set Typing
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL表达式/语句/结果集类型化
- en: This section provides background and examples for SQLAlchemy’s new SQL expression
    typing approach, which extends from base [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs through SQL statements and
    result sets and into realm of ORM mapping.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了关于SQLAlchemy新的SQL表达式类型化方法的背景和示例，该方法从基本的[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")构造扩展到SQL语句和结果集，以及ORM映射的领域。
- en: Rationale and Overview
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理论基础和概述
- en: Tip
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是一个架构讨论。跳转到[SQL Expression Typing - Examples](#whatsnew-20-expression-typing-examples)只需查看新类型化的外观。
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)中，SQL表达式被标记为[泛型](https://peps.python.org/pep-0484/#generics)，然后引用一个[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象，比如[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")或[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")作为它们的泛型参数（例如`Column[Integer]`）。这本身就是与原始的Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)包不同的地方，原始的包直接将[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")及其基本构造标记为Python类型的泛型，比如`int`、`datetime`和`str`。人们希望由于[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")本身与`int` / `datetime` / `str`泛型相关，会有方法来保持两个级别的信息，并能够通过中间构造[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")从列表达式中提取Python类型。然而，事实并非如此，因为[**PEP 484**](https://peps.python.org/pep-0484/)实际上没有足够丰富的功能集来使这成为可行的选择，缺乏诸如[higher
    kinded TypeVars](https://github.com/python/typing/issues/548)之类的功能。
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在对[**PEP 484**](https://peps.python.org/pep-0484/)当前功能进行[深入评估](https://github.com/python/typing/discussions/999)之后，SQLAlchemy
    2.0认识到了在这个领域原始的[sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)的智慧，并回归到了直接将列表达式链接到Python类型的做法。这意味着，如果有SQL表达式到不同子类型的情况，比如`Column(VARCHAR)`与`Column(Unicode)`，这两种[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")子类型的具体细节不会被传递，因为类型只会传递`str`，但在实践中，这通常不是一个问题，直接出现Python类型通常更有用，因为它代表了将要直接存储和接收的Python数据。
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这意味着像 `Column('id', Integer)` 这样的表达式被类型为 `Column[int]`。这允许建立一个可行的 SQLAlchemy
    构造 -> Python 数据类型的流水线，而无需使用类型插件。关键是，它允许完全与 ORM 的范式进行互操作，即使用引用 ORM 映射类类型的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 构造（例如，包含用户映射实例的 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，例如在我们的教程中使用的 `User` 和 `Address` 示例）。虽然 Python 的类型当前对于元组类型的定制支持非常有限（其中
    [**PEP 646**](https://peps.python.org/pep-0646/)，第一个试图处理类似元组的对象的 pep，[在功能上受到故意限制](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)，并且本身尚不适用于任意元组操作），但已经设计了一个相当不错的方法，允许基本的
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    -> [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    -> [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    类型功能，包括用于 ORM 类的功能，在要将 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象展开为单独的列条目时，会添加一个小的面向类型的访问器，允许各个 Python 值保持与它们来源于的 SQL
    表达式相关联的 Python 类型（翻译：它可以工作）。
- en: '#### SQL Expression Typing - Examples'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '#### SQL 表达式类型 - 示例'
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类型行为简要介绍。评论指示在 [vscode](https://code.visualstudio.com/) 中悬停在代码上会看到什么（或者在使用 [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    助手时，大致会显示什么类型工具）：
- en: Simple Python Types Assigned to SQL Expressions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给 SQL 表达式的简单 Python 类型
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造的单个 SQL 表达式，以及任何返回行的构造，包括返回行的 DML，例如带有 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 的 [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")，都被打包成一个 `Tuple[]` 类型，其中保留了每个元素的
    Python 类型。
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何返回行构造的`Tuple[]`类型，在调用`.execute()`方法时，传递到[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")。为了将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象解包为元组，[`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple")或[`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t")访问器基本上将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")强制转换为相应的`Tuple[]`（尽管在运行时仍然是相同的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象）。
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于单列语句的标量值，像[`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar")、[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars")等方法会做正确的事情。
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述对于返回行构造的支持与ORM映射类一起运作最好，因为映射类可以为其成员列出具体类型。下面的示例设置了一个类，使用了[新的类型感知语法](#whatsnew-20-orm-declarative-typing)，在下一节中描述：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用上述映射，属性从语句到结果集都有类型并自我表达：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 映射类本身也是类型，并且表现得相同，例如针对两个映射类进行的SELECT：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在选择映射类时，像[`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")这样的构造也可以工作，保持原始映射类的列级属性以及语句预期的返回类型：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core Table 还没有一个良好的方法来在通过[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问它们时维护[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的类型。
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")设置为类的一个实例，而[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问器通常通过名称动态访问[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，因此尚未建立针对此的已知类型方法；需要一些替代语法。
- en: ORM classes, scalars, etc. work great.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM类、标量等都很好用。
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 典型的 ORM 类选择用例，作为标量或元组，所有工作都可以，无论是 2.0 还是 1.x 风格的查询，都可以得到精确的类型，要么是自身，要么包含在适当的容器内，如
    `Sequence[]`、`List[]` 或 `Iterator[]`：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧版 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    也获得了元组类型。
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    的类型支持远远超出了 [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs) 或 [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    提供的范围，其中标量对象和元组类型的 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象在大多数情况下都会保留结果级别的类型：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: the catch - all stubs must be uninstalled
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 陷阱 - 所有存根必须被卸载
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类型支持的一个关键注意事项是，**所有 SQLAlchemy 存根包都必须被卸载** 才能使类型化工作。当针对 Python 虚拟环境运行 [mypy](https://mypy.readthedocs.io/en/stable/)
    时，只需卸载这些包即可。但是，目前 typeshed 中也包含 SQLAlchemy 存根包，typeshed 本身被捆绑到一些类型工具中，如 [Pylance](https://github.com/microsoft/pylance-release)，因此在某些情况下，可能需要定位这些包的文件并删除它们，以确保新的类型化能够正确工作。
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 SQLAlchemy 2.0 发布为最终状态，typeshed 将从其自己的存根源中删除 SQLAlchemy。
- en: '### ORM Declarative Models'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM 声明性模型'
- en: SQLAlchemy 1.4 introduced the first SQLAlchemy-native ORM typing support using
    a combination of [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    and the [Mypy Plugin](../orm/extensions/mypy.html). In SQLAlchemy 2.0, the Mypy
    plugin **remains available, and has been updated to work with SQLAlchemy 2.0’s
    typing system**. However, it should now be considered **deprecated**, as applications
    now have a straightforward path to adopting the new typing support that does not
    use plugins or stubs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4 引入了第一个使用 [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    和 [Mypy Plugin](../orm/extensions/mypy.html) 的 SQLAlchemy 本机 ORM 类型支持的方法。在 SQLAlchemy
    2.0 中，Mypy 插件 **仍然可用，并已更新以与 SQLAlchemy 2.0 的类型系统一起工作**。但是，现在应该将其视为**已弃用**，因为应用程序现在有了采用新的不使用插件或存根的类型支持的简单路径。
- en: Overview
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概览
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统的基本方法是，当使用完全[声明性](../orm/declarative_tables.html#orm-declarative-table)模型（即不使用[混合声明性](../orm/declarative_tables.html#orm-imperative-table-configuration)或[命令式](../orm/mapping_styles.html#orm-imperative-mapping)配置，这些配置保持不变）时，映射列声明首先通过检查每个属性声明左侧的类型注释（如果存在）在运行时派生。左手类型注释应包含在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类型中，否则不认为属性是映射属性。然后，属性声明可以引用右手边的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，该构造用于提供有关要生成和映射的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的附加Core级架构信息。如果左侧存在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释，则此右侧声明是可选的；如果左侧没有注释，则[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")可用作[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")指令的精确替代，在这种情况下，它将提供更准确（但不精确）的属性类型行为，即使没有注释也是如此。
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的灵感来自于 Python 的 [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    方法，该方法从左侧开始注释，然后允许在右侧进行可选的 `dataclasses.field()` 规范；与 dataclasses 方法的关键区别在于 SQLAlchemy
    的方法严格地 **选择加入**，其中使用 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 而没有任何类型注释的现有映射继续按照其原来的方式工作，而且 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造可以直接替代 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 而不需要任何显式类型注释。只有在需要精确的属性级 Python 类型时才需要使用 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 进行显式注释。这些注释可以根据需要在每个属性上使用，对于那些具体类型有帮助的属性；使用 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 的非注释属性将在实例级别被标记为 `Any`。
- en: '#### Migrating an Existing Mapping'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 迁移现有映射'
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到新的 ORM 方法开始时更加冗长，但随着可用的新功能的充分使用，变得比以前更加简洁。以下步骤详细说明了一个典型的过渡，然后继续说明了一些更多的选项。
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一步 - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 被 [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 取代。
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 类型中观察到的一个限制是似乎没有能力从函数动态生成一个类，然后这个类被理解为新类的基础。为了解决这个问题而不使用插件，通常对 [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 的调用可以被替换为使用 [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类，该类产生与通常相同的 `Base` 对象，但是类型工具理解它：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二步 - 用 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 替换 Declarative 中的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")是一个ORM类型感知的构造，可以直接替换为[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的使用。给定一个1.x风格的映射如下：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"); 不需要更改任何参数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的单独列 **尚未使用Python类型进行类型化**，而是被类型化为`Mapped[Any]`；这是因为我们可以声明任何列为`Optional`或者不声明，而且没有办法在我们明确地对其进行类型化时有一个“猜测”。
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这一步，我们上面的映射已经为所有属性设置了适当的[描述符](../glossary.html#term-descriptor)类型，并且可以用于查询以及实例级别的操作，所有这些操作都将以**不使用插件的mypy
    –strict模式**通过。
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三步 - 使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")根据需要应用确切的Python类型。
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于所有需要确切类型的属性；那些可以留作`Any`的属性可以跳过。为了上下文，我们还说明了在一个`relationship()`中应用确切类型时如何使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")。这个中间步骤中的映射会更冗长，但是熟练之后，这一步可以与后续步骤结合起来更直接地更新映射：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的ORM映射是完全类型化的，并将生成精确类型的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")构造。我们现在可以继续简化映射声明中的冗余部分。
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第四步 - 删除不再需要的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`nullable`参数都可以使用`Optional[]`隐含；在没有`Optional[]`的情况下，`nullable`默认为`False`。所有没有参数的SQL类型，如`Integer`和`String`，可以单独表示为Python注释。不带参数的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令可以完全移除。[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")现在从左侧注释派生其类，还支持前向引用（正如[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")已经支持了十年的字符串型前向引用一样 ;) ）：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第五步 - 利用 pep-593 `Annotated` 将常见指令打包到类型中
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项根本性的新功能，提供了一种替代或补充方法，用于[声明式混合](../orm/declarative_mixins.html)作为提供类型定向配置的手段，并且在大多数情况下也替代了[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰函数的需要。
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明式映射允许将Python类型映射到SQL类型，例如将`str`映射到[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，通过使用[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")进行自定义。使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` 允许我们创建特定Python类型的变体，以便可以使用相同的类型，例如`str`，每个类型提供[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")的变体，如下所示，其中使用名为`str50`的`Annotated` `str` 将指示`String(50)`：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果使用`Annotated[]`，声明式将从左侧类型中提取完整的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")定义，方法是将[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构作为`Annotated[]`结构的任何参数传递（感谢[@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)说明这个想法）。在未来的版本中，这项功能可能会扩展到包括[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")、[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")和其他结构，但目前仅限于[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。下面的示例除了我们的`str50`示例外，还添加了额外的`Annotated`类型，以说明此功能：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，与`Mapped[str50]`、`Mapped[intpk]`或`Mapped[user_fk]`映射的列从[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")以及直接使用`Annotated`构造从中提取，以便重用预先建立的类型和列配置。
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选步骤 - 将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)，其中一个关键优势是我们可以构建一个严格类型化的`__init__()`方法，具有明确的位置参数、关键字参数和默认参数，更不用说我们可以免费获得`__str__()`和`__repr__()`等方法。接下来的部分[作为ORM模型映射的数据类的本机支持](#whatsnew-20-dataclasses)进一步说明了以上模型的转换。
- en: Typing is supported from step 3 onwards
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从第3步开始支持类型标注
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述示例，从“第3步”开始的任何示例都将包括模型的属性已进行类型标注，并将填充到[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象中：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.  ### Using Legacy Mypy-Typed Models'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[具有mapped_column()的声明性表](../orm/declarative_tables.html#orm-declarative-table)
    - 更新的声明性文档，用于声明性生成和映射[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")列。  ###
    使用传统的Mypy类型化模型'
- en: SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to errors under the
    new system, as such annotations are flagged as errors when using constructs such
    as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Mypy插件](../orm/extensions/mypy.html)的SQLAlchemy应用程序，其中明确注释不使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")在其注释中的，当使用诸如[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")之类的构造时，将根据新系统标记为错误。
- en: The section [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly
    typed ORM models](migration_20.html#migration-20-step-six) illustrates how to
    temporarily disable these errors from being raised for a legacy ORM model that
    uses explicit annotations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 部分[迁移到2.0步骤六 - 为显式类型的ORM模型添加__allow_unmapped__](migration_20.html#migration-20-step-six)说明了如何为使用显式注释的遗留ORM模型临时禁用这些错误的触发。
- en: See also
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](migration_20.html#migration-20-step-six)  ### Native Support for Dataclasses
    Mapped as ORM Models'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移到2.0步骤六 - 为显式类型的ORM模型添加__allow_unmapped__](migration_20.html#migration-20-step-six)  ###
    作为ORM模型映射的数据类的本机支持'
- en: The new ORM Declarative features introduced above at [ORM Declarative Models](#whatsnew-20-orm-declarative-typing)
    introduced the new [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct and illustrated type-centric mapping
    with optional use of [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`.
    We can take the mapping one step further by integrating this with Python [dataclasses](https://docs.python.org/3/library/dataclasses.html).
    This new feature is made possible via [**PEP 681**](https://peps.python.org/pep-0681/)
    which allows for type checkers to recognize classes that are dataclass compatible,
    or are fully dataclasses, but were declared through alternate APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面介绍的新ORM声明式特性中，引入了新的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，以及可选使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`进行类型中心化映射的示例。我们可以通过将其与Python的[dataclasses](https://docs.python.org/3/library/dataclasses.html)集成，进一步完善这种映射。这一新特性是通过[**PEP
    681**](https://peps.python.org/pep-0681/)实现的，允许类型检查器识别与`dataclass`兼容的类，或者完全是`dataclass`，但是通过其他API声明的类。
- en: Using the dataclasses feature, mapped classes gain an `__init__()` method that
    supports positional arguments as well as customizable default values for optional
    keyword arguments. As mentioned previously, dataclasses also generate many useful
    methods such as `__str__()`, `__eq__()`. Dataclass serialization methods such
    as [dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)
    and [dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)
    also work, but don’t currently accommodate for self-referential structures, which
    makes them less viable for mappings that have bidirectional relationships.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dataclasses`特性，映射类获得了一个`__init__()`方法，支持位置参数以及可选关键字参数的自定义默认值。如前所述，`dataclasses`还会生成许多有用的方法，比如`__str__()`、`__eq__()`。`dataclasses`的序列化方法，比如[dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)和[dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)也可以使用，但目前不支持自引用结构，这使得它们对于具有双向关系的映射来说不太适用。
- en: SQLAlchemy’s current integration approach converts the user-defined class into
    a **real dataclass** to provide runtime functionality; the feature makes use of
    the existing dataclass feature introduced in SQLAlchemy 1.4 at [Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)
    to produce an equivalent runtime mapping with a fully integrated configuration
    style, which is also more correctly typed than was possible with the previous
    approach.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy当前的集成方法将用户定义的类转换为一个**真实的dataclass**，以提供运行时功能；该特性利用了SQLAlchemy 1.4中引入的现有dataclass特性，在[Python
    Dataclasses, attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)中生成一个等效的运行时映射，具有完全集成的配置样式，比以前的方法更正确地类型化。
- en: To support dataclasses in compliance with [**PEP 681**](https://peps.python.org/pep-0681/),
    ORM constructs like [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") accept additional [**PEP 681**](https://peps.python.org/pep-0681/)
    arguments `init`, `default`, and `default_factory` which are passed along to the
    dataclass creation process. These arguments currently must be present in an explicit
    directive on the right side, just as they would be used with `dataclasses.field()`;
    they currently can’t be local to an `Annotated` construct on the left side. To
    support the convenient use of `Annotated` while still supporting dataclass configuration,
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    can merge a minimal set of right-hand arguments with that of an existing [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct located on the left side within an `Annotated`
    construct, so that most of the succinctness is maintained, as will be seen below.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持符合 [**PEP 681**](https://peps.python.org/pep-0681/) 的数据类，ORM 构造如 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 和 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 现在接受额外的 [**PEP 681**](https://peps.python.org/pep-0681/)
    参数 `init`、`default` 和 `default_factory`，这些参数将传递到数据类创建过程中。这些参数目前必须以右侧的显式指令的形式存在，就像它们在
    `dataclasses.field()` 中使用时一样；它们目前不能局部存在于左侧的 `Annotated` 构造中。为了支持方便地使用 `Annotated`
    并仍然支持数据类配置，[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 可以将一组最小的右侧参数与位于左侧的 `Annotated` 构造内的现有 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造合并，以便保持大部分简洁性，如下所示。
- en: 'To enable dataclasses using class inheritance we make use of the [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin, either directly on each class, or on
    the `Base` class, as illustrated below where we further modify the example mapping
    from “Step 5” of [ORM Declarative Models](#whatsnew-20-orm-declarative-typing):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用使用类继承的数据类，我们利用了 [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin，可以直接在每个类上使用，也可以在 `Base` 类上使用，如下所示，在这里我们进一步修改了来自
    “Step 5” 的示例映射[ORM 声明性模型](#whatsnew-20-orm-declarative-typing)。
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The above mapping has used the `@dataclasses.dataclass` decorator directly
    on each mapped class at the same time that the declarative mapping was set up,
    internally setting up each `dataclasses.field()` directive as indicated. `User`
    / `Address` structures can be created using positional arguments as configured:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射已经直接在每个映射类上使用 `@dataclasses.dataclass` 装饰器设置，同时在设置声明性映射时内部设置了每个 `dataclasses.field()`
    指令，如所示。可以使用按位置配置的 `User` / `Address` 结构创建：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)  ##
    Optimized ORM bulk insert now implemented for all backends other than MySQL'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明式数据类映射](../orm/dataclasses.html#orm-declarative-native-dataclasses)  ##
    除了 MySQL 外，所有后端现在都实现了优化的 ORM 批量插入'
- en: 'The dramatic performance improvement introduced in the 1.4 series and described
    at [ORM Batch inserts with psycopg2 now batch statements with RETURNING in most
    cases](migration_14.html#change-5263) has now been generalized to all included
    backends that support RETURNING, which is all backends other than MySQL: SQLite,
    MariaDB, PostgreSQL (all drivers), and Oracle; SQL Server has support but is temporarily
    disabled in version 2.0.9 [[1]](#id2). While the original feature was most critical
    for the psycopg2 driver which otherwise had major performance issues when using
    `cursor.executemany()`, the change is also critical for other PostgreSQL drivers
    such as asyncpg, as when using RETURNING, single-statement INSERT statements are
    still unacceptably slow, as well as when using SQL Server that also seems to have
    very slow executemany speed for INSERT statements regardless of whether or not
    RETURNING is used.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4系列中引入的戏剧性性能改进，并在[ORM Batch inserts with psycopg2 now batch statements with
    RETURNING in most cases](migration_14.html#change-5263)中描述，现已推广到所有支持RETURNING的包含后端，除了MySQL之外的所有后端：SQLite，MariaDB，PostgreSQL（所有驱动程序）和Oracle；
    SQL Server具有支持，但在版本2.0.9中暂时禁用[[1]](#id2)。虽然原始功能对于psycopg2驱动程序最为关键，否则在使用`cursor.executemany()`时会有严重的性能问题，但该变更对于其他PostgreSQL驱动程序如asyncpg同样关键，因为在使用RETURNING时，单语句INSERT语句仍然不可接受地慢，以及在使用SQL
    Server时，似乎无论是否使用RETURNING，INSERT语句的executemany速度都非常慢。
- en: The performance of the new feature provides an almost across-the-board order
    of magnitude performance increase for basically every driver when INSERTing ORM
    objects that don’t have a pre-assigned primary key value, as indicated in the
    table below, in most cases specific to the use of RETURNING which is not normally
    supported with executemany().
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能的性能几乎在各个方面都提供了一个数量级的性能增加，当INSERT ORM对象时，这些对象没有预先分配的主键值，在下表中有所指示，大多数情况下特定于使用RETURNING，而这通常不支持executemany()。
- en: The psycopg2 “fast execution helper” approach consists of transforming an INSERT..RETURNING
    statement with a single parameter set into a single statement that INSERTs many
    parameter sets, using multiple “VALUES…” clauses so that it can accommodate many
    parameter sets at once. Parameter sets are then typically batched into groups
    of 1000 or similar, so that no single INSERT statement is excessively large, and
    the INSERT statement is then invoked for each batch of parameters, rather than
    for each individual parameter set. Primary key values and server defaults are
    returned by RETURNING, which continues to work as each statement execution is
    invoked using `cursor.execute()`, rather than `cursor.executemany()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2的“快速执行助手”方法包括将一个带有单个参数集的INSERT..RETURNING语句转换为一个语句，该语句插入了许多参数集，使用多个“VALUES…”子句，以便一次容纳许多参数集。然后，参数集通常被分批为1000个或类似的组，以便没有单个INSERT语句过大，并且INSERT语句然后为每批参数调用，而不是为每个单独的参数集调用。主键值和服务器默认值由RETURNING返回，这仍然有效，因为每个语句执行都是使用`cursor.execute()`调用的，而不是`cursor.executemany()`。
- en: This allows many rows to be inserted in one statement while also being able
    to return newly-generated primary key values as well as SQL and server defaults.
    SQLAlchemy historically has always needed to invoke one statement per parameter
    set, as it relied upon Python DBAPI Features such as `cursor.lastrowid` which
    do not support multiple rows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在一个语句中插入许多行，同时还能返回新生成的主键值以及SQL和服务器默认值。 SQLAlchemy在历史上一直需要为每个参数集调用一个语句，因为它依赖于Python
    DBAPI功能，如`cursor.lastrowid`，这些功能不支持多行。
- en: With most databases now offering RETURNING (with the conspicuous exception of
    MySQL, given that MariaDB supports it), the new change generalizes the psycopg2
    “fast execution helper” approach to all dialects that support RETURNING, which
    now includes SQlite and MariaDB, and for which no other approach for “executemany
    plus RETURNING” is possible, which includes SQLite, MariaDB, and all PG drivers.
    The cx_Oracle and oracledb drivers used for Oracle support RETURNING with executemany
    natively, and this has also been implemented to provide equivalent performance
    improvements. With SQLite and MariaDB now offering RETURNING support, ORM use
    of `cursor.lastrowid` is nearly a thing of the past, with only MySQL still relying
    upon it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数数据库现在都提供RETURNING（明显的例外是MySQL，鉴于MariaDB支持它），新的更改将psycopg2的“快速执行助手”方法推广到所有支持RETURNING的方言，现在包括SQlite和MariaDB，对于支持“executemany加RETURNING”的其他方法不可能的方言，包括SQLite、MariaDB和所有PG驱动程序。用于Oracle的cx_Oracle和oracledb驱动程序本地支持使用executemany返回，这也已经实现以提供等效的性能改进。由于SQLite和MariaDB现在支持RETURNING，ORM对`cursor.lastrowid`的使用几乎已经成为过去，只有MySQL仍然依赖它。
- en: For INSERT statements that don’t use RETURNING, traditional executemany() behavior
    is used for most backends, with the current exception of psycopg2, which has very
    slow executemany() performance overall and are still improved by the “insertmanyvalues”
    approach.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用RETURNING的INSERT语句，大多数后端使用传统的executemany()行为，当前的例外是psycopg2，它的executemany()性能总体上非常慢，并且仍然通过“insertmanyvalues”方法得到改进。
- en: Benchmarks
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: SQLAlchemy includes a [Performance Suite](../orm/examples.html#examples-performance)
    within the `examples/` directory, where we can make use of the `bulk_insert` suite
    to benchmark INSERTs of many rows using both Core and ORM in different ways.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在`examples/`目录中包含一个[性能套件](../orm/examples.html#examples-performance)，我们可以利用`bulk_insert`套件以不同的方式使用Core和ORM来对许多行进行INSERT的基准测试。
- en: For the tests below, we are inserting **100,000 objects**, and in all cases
    we actually have 100,000 real Python ORM objects in memory, either created up
    front or generated on the fly. All databases other than SQLite are run over a
    local network connection, not localhost; this causes the “slower” results to be
    extremely slow.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下测试，我们正在插入**100,000个对象**，在所有情况下，我们实际上在内存中有100,000个真实的Python ORM对象，要么是预先创建的，要么是动态生成的。除了SQLite之外的所有数据库都通过本地网络连接运行，而不是localhost；这导致“较慢”的结果非常慢。
- en: 'Operations that are improved by this feature include:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此功能改进的操作包括：
- en: unit of work flushes for objects added to the session using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all").
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")和[`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")将对象添加到会话中的工作单元刷新。
- en: The new [ORM Bulk Insert Statement](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    feature, which improves upon the experimental version of this feature first introduced
    in SQLAlchemy 1.4.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的[ORM批量插入语句](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)功能，改进了SQLAlchemy
    1.4中首次引入的实验性版本。
- en: the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    “bulk” operations described at [Bulk Operations](../orm/persistence_techniques.html#bulk-operations),
    which are superseded by the above mentioned ORM Bulk Insert feature.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[Bulk Operations](../orm/persistence_techniques.html#bulk-operations)中描述的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")“批量”操作，被上述ORM批量插入功能取代。
- en: 'To get a sense of the scale of the operation, below are performance measurements
    using the `test_flush_no_pk` performance suite, which historically represents
    SQLAlchemy’s worst-case INSERT performance task, where objects that don’t have
    primary key values need to be INSERTed, and then the newly generated primary key
    values must be fetched so that the objects can be used for subsequent flush operations,
    such as establishment within relationships, flushing joined-inheritance models,
    etc:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解操作的规模，以下是使用`test_flush_no_pk`性能套件进行的性能测量，该套件历史上代表了SQLAlchemy的最坏情况INSERT性能任务，其中需要INSERT没有主键值的对象，然后必须获取新生成的主键值，以便这些对象可以用于后续的flush操作，比如在关系中建立关系，刷新联合继承模型等：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This test can be run from any SQLAlchemy source tree as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何SQLAlchemy源代码树中运行此测试：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The table below summarizes performance measurements with the latest 1.4 series
    of SQLAlchemy compared to 2.0, both running the same test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了最新的1.4系列SQLAlchemy与2.0在运行相同测试时的性能测量：
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
- en: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
- en: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
- en: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
- en: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
- en: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Two additional drivers have no change in performance; the psycopg2 drivers,
    for which fast executemany was already implemented in SQLAlchemy 1.4, and MySQL,
    which continues to not offer RETURNING support:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个驱动程序在性能上没有变化；psycopg2驱动程序，在SQLAlchemy 1.4中已经实现了快速executemany，以及MySQL，继续不提供RETURNING支持：
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
- en: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
- en: Summary of Changes
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更摘要
- en: 'The following bullets list the individual changes made within 2.0 in order
    to get all drivers to this state:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的项目列出了2.0中为使所有驱动程序达到这种状态而进行的各个更改：
- en: RETURNING implemented for SQLite - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite实现了RETURNING - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
- en: RETURNING implemented for MariaDB - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB实现了RETURNING - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
- en: Fix multi-row RETURNING for Oracle - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复Oracle的多行RETURNING - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
- en: make insert() executemany() support RETURNING for as many dialects as possible,
    usually with VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使insert() executemany()支持尽可能多的方言，通常使用VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
- en: Emit a warning when RETURNING w/ executemany is used for non-supporting backend
    (currently no RETURNING backend has this limitation) - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当RETURNING与executemany一起用于不支持的后端时发出警告（当前没有RETURNING后端有此限制） - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
- en: The ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a a new setting `"auto"`, which
    will enable “eager defaults” automatically for INSERT statements, when the backend
    in use supports RETURNING with “insertmanyvalues”. See [Fetching Server-Generated
    Defaults](../orm/persistence_techniques.html#orm-server-defaults) for documentation.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 参数现在默认为新设置`"auto"`，当使用的后端支持“insertmanyvalues”时，将自动为INSERT语句启用“急切默认值”。请参阅[获取服务器生成的默认值](../orm/persistence_techniques.html#orm-server-defaults)以获取文档。
- en: See also
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - Documentation and background on the new feature as well as how to configure
    it  ## ORM-enabled Insert, Upsert, Update and Delete Statements, with ORM RETURNING'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[“插入多个值”行为适用于INSERT语句](../core/connections.html#engine-insertmanyvalues) -
    新功能的文档和背景以及如何配置它的说明  ## 启用ORM的插入、更新和删除语句，带有ORM RETURNING'
- en: SQLAlchemy 1.4 ported the features of the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to [2.0 style](../glossary.html#term-2.0-style)
    execution, which meant that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct could be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to deliver ORM results. Support was also added
    for [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    to be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), to the degree that they could provide implementations
    of [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete").
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4 将传统的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象的特性移植到[2.0风格](../glossary.html#term-2.0-style)的执行中，这意味着[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造可以传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")以提供 ORM 结果。还添加了对[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")和[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete")的支持，可以传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，以便它们可以提供[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")和[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")的实现。
- en: The major missing element has been support for the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct. The 1.4 documentation addressed
    this with some recipes for “inserts” and “upserts” with use of [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") to integrate RETURNING into
    an ORM context. 2.0 now fully closes the gap by integrating direct support for
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    as an enhanced version of the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method, along with full ORM RETURNING
    support for all DML structures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 主要缺失的元素是对[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")构造的支持。1.4
    文档通过一些关于在 ORM 上下文中使用[`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")来集成 RETURNING 的“插入”和“upserts”的示例来解决这个问题。2.0
    现在通过将[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")直接支持作为[`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")方法的增强版本，以及对所有 DML 结构的完整 ORM RETURNING
    支持来完全弥补这一差距。
- en: Bulk Insert with RETURNING
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有 RETURNING 的批量插入
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    can be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), with or without [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), which when passed with a separate
    parameter list will invoke the same process as was previously implemented by [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings"), with additional enhancements.
    This will optimize the batching of rows making use of the new [fast insertmany](#change-6047)
    feature, while also adding support for heterogeneous parameter sets and multiple-table
    mappings like joined table inheritance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")可以传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，可以带有或不带有[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")，当与一个单独的参数列表一起传递时，将调用与以前由[`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")实现的相同过程，同时还添加了额外的增强功能。这将通过利用新的[快速插入多行](#change-6047)功能来优化行的批处理，同时还支持异构参数集和多表映射，如联合表继承：'
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: RETURNING is supported for all of these use cases, where the ORM will construct
    a full result set from multiple statement invocations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RETURNING支持所有这些用例，其中ORM将从多个语句调用构造完整的结果集。
- en: See also
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM批量INSERT语句](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
- en: Bulk UPDATE
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量UPDATE
- en: 'In a similar manner as that of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), passing the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a parameter list that
    includes primary key values to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will invoke the same process as previously supported
    by the [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This feature does not however
    support RETURNING, as it uses a SQL UPDATE statement that is invoked using DBAPI
    [executemany](../glossary.html#term-executemany):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")类似，将[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")构造与包含主键值的参数列表一起传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")将调用与以前由[`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings")方法支持的相同过程。但是，此功能不支持RETURNING，因为它使用SQL
    UPDATE语句，该语句使用DBAPI [executemany](../glossary.html#term-executemany)��行调用：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Bulk UPDATE by Primary Key](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[按主键进行ORM批量UPDATE](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
- en: INSERT / upsert … VALUES … RETURNING
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INSERT / upsert … VALUES … RETURNING
- en: 'When using [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    with [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values"), the set of parameters may include
    SQL expressions. Additionally, upsert variants such as those for SQLite, PostgreSQL
    and MariaDB are also supported. These statements may now include [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") clauses with column expressions
    or full ORM entities:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")与[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")时，参数集合可能包含SQL表达式。此外，还支持SQLite、PostgreSQL和MariaDB等数据库的upsert变体。这些语句现在可以包括带有列表达式或完整ORM实体的[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")子句：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Bulk Insert with Per Row SQL Expressions](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM批量插入带有每行SQL表达式](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
- en: '[ORM “upsert” Statements](../orm/queryguide/dml.html#orm-queryguide-upsert)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM “upsert”语句](../orm/queryguide/dml.html#orm-queryguide-upsert)'
- en: ORM UPDATE / DELETE with WHERE … RETURNING
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有WHERE … RETURNING的ORM UPDATE / DELETE
- en: 'SQLAlchemy 1.4 also had some modest support for the RETURNING feature to be
    used with the [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    constructs, when used with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This support has now been upgraded to be fully
    native, including that the `fetch` synchronization strategy may also proceed whether
    or not explicit use of RETURNING is present:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4还对RETURNING功能提供了一些支持，可与[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")和[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造一起使用，当与[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")一起使用时。此支持现已升级为完全本地化，包括`fetch`同步策略是否存在RETURNING的明确使用：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[带有自定义WHERE条件的ORM UPDATE和DELETE](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
- en: '[Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用RETURNING进行UPDATE/DELETE和自定义WHERE条件](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
- en: Improved `synchronize_session` behavior for ORM UPDATE / DELETE
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进了ORM UPDATE / DELETE的`synchronize_session`行为
- en: The default strategy for [synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)
    is now a new value `"auto"`. This strategy will attempt to use the `"evaluate"`
    strategy and then automatically fall back to the `"fetch"` strategy. For all backends
    other than MySQL / MariaDB, `"fetch"` uses RETURNING to fetch UPDATE/DELETEd primary
    key identifiers within the same statement, so is generally more efficient than
    previous versions (in 1.4, RETURNING was only available for PostgreSQL, SQL Server).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)的默认策略现在是一个新值`"auto"`。此策略将尝试使用`"evaluate"`策略，然后自动回退到`"fetch"`策略。对于除了
    MySQL / MariaDB 之外的所有后端，`"fetch"`使用 RETURNING 在同一语句中获取已更新/删除的主键标识符，因此通常比以前版本更有效（在
    1.4 版本中，RETURNING 仅适用于 PostgreSQL、SQL Server）。'
- en: See also
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 亦见
- en: '[Selecting a Synchronization Strategy](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择同步策略](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
- en: Summary of Changes
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更摘要
- en: 'Listed tickets for new ORM DML with RETURNING features:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 ORM DML 带有 RETURNING 特性的已列出的票证：
- en: convert `insert()` at ORM level to interpret `values()` in an ORM context -
    [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 ORM 级别的`insert()`转换为在 ORM 上下文中解释`values()` - [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
- en: evaluate feasibility of dml.returning(Entity) to deliver ORM expressions, automatically
    apply select().from_statement equiv - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估`dml.returning(Entity)`的可行性，以提供 ORM 表达式，自动应用`select().from_statement`等效 -
    [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
- en: 'given ORM insert, try to carry the bulk methods along, re: inheritance - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)  ##
    New “Write Only” relationship strategy supersedes “dynamic”'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '给定 ORM 插入，尝试携带批量方法，有关继承 - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)  ##
    新的“仅写入”关系策略取代了“动态”'
- en: The `lazy="dynamic"` loader strategy becomes legacy, in that it is hardcoded
    to make use of legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This loader strategy is both not compatible with asyncio,
    and additionally has many behaviors that implicitly iterate its contents, which
    defeat the original purpose of the “dynamic” relationship as being for very large
    collections that should not be implicitly fully loaded into memory at any time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: “懒加载”策略`lazy="dynamic"`已经过时，因为它被硬编码为使用传统的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")。这个加载策略既不兼容asyncio，而且还有许多行为隐式迭代其内容，这违背了“动态”关系的原始目的，即用于非常大的集合，不应随时隐式加载到内存中。
- en: 'The “dynamic” strategy is now superseded by a new strategy `lazy="write_only"`.
    Configuration of “write only” may be achieved using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), or when using [type annotated mappings](#whatsnew-20-orm-declarative-typing),
    indicating the [`WriteOnlyMapped`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation as the mapping style:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: “动态”策略现已由新策略`lazy="write_only"`取代。可以使用[`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数的配置[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")来实现“仅写入”，或者在使用[类型注释映射](#whatsnew-20-orm-declarative-typing)时，指示[`WriteOnlyMapped`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped")注解作为映射样式：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The write-only-mapped collection resembles `lazy="dynamic"` in that the collection
    may be assigned up front, and also has methods such as [`WriteOnlyCollection.add()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add") and [`WriteOnlyCollection.remove()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") to modify the collection on an individual
    item basis:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 写入唯一映射集合类似于`lazy="dynamic"`，因为集合可以提前分配，并且还具有诸如[`WriteOnlyCollection.add()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add")和[`WriteOnlyCollection.remove()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove")等方法，以逐个项目的方式修改集合：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The bigger difference is on the database loading side, where the collection
    has no ability to load objects from the database directly; instead, SQL construction
    methods such as [`WriteOnlyCollection.select()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") are used to produce SQL constructs
    such as [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    which are then executed using [2.0 style](../glossary.html#term-2.0-style) to
    load the desired objects in an explicit way:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的区别在于数据库加载方面，集合无法直接从数据库加载对象；而是使用诸如 [`WriteOnlyCollection.select()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") 等 SQL 构造方法来生成诸如 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 的 SQL 构造，然后使用 [2.0 风格](../glossary.html#term-2.0-style)
    以显式方式加载所需对象：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") also integrates with the new [ORM bulk dml](#change-8360)
    features, including support for bulk INSERT and UPDATE/DELETE with WHERE criteria,
    all including RETURNING support as well. See the complete documentation at [Write
    Only Relationships](../orm/large_collections.html#write-only-relationship).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") 也与新的 [ORM 批量 DML](#change-8360) 特性集成，包括支持带有
    WHERE 条件的批量 INSERT 和 UPDATE/DELETE，全部支持 RETURNING。详见完整文档 [Write Only Relationships](../orm/large_collections.html#write-only-relationship)。'
- en: See also
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
- en: New pep-484 / type annotated mapping support for Dynamic Relationships
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为动态关系添加了新的 pep-484 / 类型注释映射支持
- en: 'Even though “dynamic” relationships are legacy in 2.0, as these patterns are
    expected to have a long lifespan, [type annotated mapping](#whatsnew-20-orm-declarative-typing)
    support is now added for “dynamic” relationships in the same way that its available
    for the new `lazy="write_only"` approach, using the [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“动态”关系在 2.0 中是遗留的，但由于这些模式预计具有很长的寿命，[类型注释映射](#whatsnew-20-orm-declarative-typing)
    现在也为“动态”关系添加了支持，方式与新的 `lazy="write_only"` 方法相同，使用 [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") 注释：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The above mapping will provide an `Account.account_transactions` collection
    that is typed as returning the [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") collection type, including its element type, e.g.
    `AppenderQuery[AccountTransaction]`. This then allows iteration and queries to
    yield objects which are typed as `AccountTransaction`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将提供一个类型为 [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") 集合类型的 `Account.account_transactions` 集合，包括其元素类型，例如
    `AppenderQuery[AccountTransaction]`。然后允许迭代和查询产生类型为 `AccountTransaction` 的对象。
- en: See also
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Dynamic Relationship Loaders](../orm/large_collections.html#dynamic-relationship)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[动态关系加载器](../orm/large_collections.html#dynamic-relationship)'
- en: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)  ## Installation is now
    fully pep-517 enabled'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)  ## 安装现在完全启用了 pep-517'
- en: The source distribution now includes a `pyproject.toml` file to allow for complete
    [**PEP 517**](https://peps.python.org/pep-0517/) support. In particular this allows
    a local source build using `pip` to automatically install the [Cython](https://cython.org/)
    optional dependency.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 源发行版现在包括一个 `pyproject.toml` 文件，以支持完整的 [**PEP 517**](https://peps.python.org/pep-0517/)
    支持。特别是，这允许使用 `pip` 进行本地源构建时自动安装 [Cython](https://cython.org/) 可选依赖项。
- en: '[#7311](https://www.sqlalchemy.org/trac/ticket/7311)  ## C Extensions now ported
    to Cython'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7311](https://www.sqlalchemy.org/trac/ticket/7311)  ## C 扩展现在已转换为 Cython'
- en: The SQLAlchemy C extensions have been replaced with all new extensions written
    in [Cython](https://cython.org/). While Cython was evaluated back in 2010 when
    the C extensions were first created, the nature and focus of the C extensions
    in use today has changed quite a bit from that time. At the same time, Cython
    has apparently evolved significantly, as has the Python build / distribution toolchain
    which made it feasible for us to revisit it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy C 扩展已被全部采用 [Cython](https://cython.org/) 编写的全新扩展所取代。虽然在创建 C 扩展时曾于
    2010 年评估过 Cython，但如今实际使用的 C 扩展的性质和重点与当时已经发生了很大变化。与此同时，Cython 显然也有了显著的发展，Python
    的构建/分发工具链也使我们有可能重新审视它。
- en: 'The move to Cython provides dramatic new advantages with no apparent downsides:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 Cython 提供了明显的新优势，而没有明显的不利因素：
- en: The Cython extensions that replace specific C extensions have all benchmarked
    as **faster**, often slightly, but sometimes significantly, than virtually all
    the C code that SQLAlchemy previously included. While this seems amazing, it appears
    to be a product of non-obvious optimizations within Cython’s implementation that
    would not be present in a direct Python to C port of a function, as was particularly
    the case for many of the custom collection types added to the C extensions.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换特定 C 扩展的 Cython 扩展已经被全部作为**更快**的扩展进行了基准测试，通常情况下稍微快一点，但有时比 SQLAlchemy 以前包含的几乎所有
    C 代码都要显著快。虽然这看起来很神奇，但似乎是 Cython 实现中的一些非显而易见的优化的产物，在许多情况下，这些优化不会出现在直接的 Python 到
    C 的函数移植中，特别是对于许多添加到 C 扩展中的自定义集合类型而言。
- en: Cython extensions are much easier to write, maintain and debug compared to raw
    C code, and in most cases are line-per-line equivalent to the Python code. It
    is expected that many more elements of SQLAlchemy will be ported to Cython in
    the coming releases which should open many new doors to performance improvements
    that were previously out of reach.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原始的 C 代码相比，Cython 扩展编写、维护和调试都要容易得多，在大多数情况下与 Python 代码几乎一致。预计未来的版本中会有更多的 SQLAlchemy
    元素被移植到 Cython 中，这将打开许多以前无法触及的性能改进的新门。
- en: Cython is very mature and widely used, including being the basis of some of
    the prominent database drivers supported by SQLAlchemy including `asyncpg`, `psycopg3`
    and `asyncmy`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 非常成熟并被广泛使用，包括成为 SQLAlchemy 支持的一些著名数据库驱动程序的基础，包括 `asyncpg`、`psycopg3`
    和 `asyncmy`。
- en: Like the previous C extensions, the Cython extensions are pre-built within SQLAlchemy’s
    wheel distributions which are automatically available to `pip` from PyPi. Manual
    build instructions are also unchanged with the exception of the Cython requirement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 C 扩展一样，Cython 扩展已经预先构建在 SQLAlchemy 的 wheel 发布中，这些发布会自动提供给 `pip` 从 PyPi
    安装。手动构建说明也没有改变，除了对 Cython 的要求。
- en: See also
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建 Cython 扩展](../intro.html#c-extensions)'
- en: '[#7256](https://www.sqlalchemy.org/trac/ticket/7256)  ## Major Architectural,
    Performance and API Enhancements for Database Reflection'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7256](https://www.sqlalchemy.org/trac/ticket/7256)  ## 数据库反射的主要架构、性能和 API
    增强'
- en: The internal system by which [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects and their components are [reflected](../core/reflection.html#metadata-reflection)
    has been completely rearchitected to allow high performance bulk reflection of
    thousands of tables at once for participating dialects. Currently, the **PostgreSQL**
    and **Oracle** dialects participate in the new architecture, where the PostgreSQL
    dialect can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects nearly three times faster, and the Oracle dialect
    can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects ten times faster.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 完全重新设计了 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象及其组件 [反射](../core/reflection.html#metadata-reflection) 的内部系统，以允许参与的方言一次性高性能地批量反射数千个表。目前，**PostgreSQL**
    和 **Oracle** 方言参与了新的架构，其中 PostgreSQL 方言现在可以比以前快近三倍地反射大量的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，而 Oracle 方言现在可以比以前快十倍地反射大量的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象。
- en: The rearchitecture applies most directly to dialects that make use of SELECT
    queries against system catalog tables to reflect tables, and the remaining included
    dialect that can benefit from this approach will be the SQL Server dialect. The
    MySQL/MariaDB and SQLite dialects by contrast make use of non-relational systems
    to reflect database tables, and were not subject to a pre-existing performance
    issue.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重新架构主要适用于使用 SELECT 查询系统目录表以反映表的方言，而其余包含的方言可以从这种方法中受益的是 SQL Server 方言。相比之下，MySQL/MariaDB
    和 SQLite 方言使用非关系型系统来反映数据库表，并且没有受到现有性能问题的影响。
- en: The new API is backwards compatible with the previous system, and should require
    no changes to third party dialects to retain compatibility; third party dialects
    can also opt into the new system by implementing batched queries for schema reflection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 新 API 兼容先前的系统，并且不需要更改第三方方言以保持兼容性；第三方方言也可以通过实现批量查询模式反射模式来选择新系统。
- en: Along with this change, the API and behavior of the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object has been improved and enhanced
    with more consistent cross-dialect behaviors as well as new methods and new performance
    features.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 对象的 API 和行为已经改进和增强，具有更一致的跨方言行为以及新方法和新性能特性。
- en: Performance Overview
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能概述
- en: 'The source distribution includes a script `test/perf/many_table_reflection.py`
    which benches both existing reflection features as well as new ones. A limited
    set of its tests may be run on older versions of SQLAlchemy, where here we use
    it to illustrate differences in performance to invoke `metadata.reflect()` to
    reflect 250 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects at once over a local network connection:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 源分发包括一个脚本 `test/perf/many_table_reflection.py`，用于测试现有的反射功能以及新功能。其中一部分测试可以在旧版本的
    SQLAlchemy 上运行，我们在这里使用它来说明性能差异，以在本地网络连接上一次性反射 250 个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象：
- en: '| Dialect | Operation | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 方言 | 操作 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg2 | `metadata.reflect()`，250 张表 | 8.2 | 3.3 |'
- en: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| oracle+cx_oracle | `metadata.reflect()`，250 张表 | 60.4 | 6.8 |'
- en: Behavioral Changes for `Inspector()`
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Inspector()` 的行为变更'
- en: 'For SQLAlchemy-included dialects for SQLite, PostgreSQL, MySQL/MariaDB, Oracle,
    and SQL Server, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence"), [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index"), [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") now all behave consistently
    in terms of caching: they all fully cache their result after being called the
    first time for a particular [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object. Programs that create or drop
    tables/sequences while calling upon the same [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object will not receive updated status
    after the state of the database has changed. A call to [`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache") or a new [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") should be used when DDL changes are
    to be executed. Previously, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence") methods did not implement
    caching nor did the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") support caching for these methods, while
    the [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") methods were, leading
    to inconsistent results between the two types of method.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLAlchemy包含的SQLite、PostgreSQL、MySQL/MariaDB、Oracle和SQL Server的方言，[`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table")、[`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence")、[`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index")、[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names")现在在缓存方面都表现一致：在为特定[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象第一次调用后，它们都会完全缓存其结果。在调用相同的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象时创建或删除表/序列的程序将在数据库状态更改后不会收到更新的状态。当要执行DDL更改时，应使用调用[`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache")或新的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")。以前，[`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table")、[`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence")方法未实现缓存，[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")也不支持这些方法的缓存，而[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names")方法则是，导致两种方法之间的结果不一致。
- en: Behavior for third party dialects is dependent on whether or not they implement
    the “reflection cache” decorator for the dialect-level implementation of these
    methods.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方方言的行为取决于它们是否实现了这些方法的方言级别实现的“反射缓存”装饰器。
- en: New Methods and Improvements for `Inspector()`
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的方法和`Inspector()`的改进
- en: added a method [`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema") that returns if a schema
    is present in the target database
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法[`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema")，用于返回目标数据库中是否存在模式
- en: added a method [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index") that returns if a table has
    a particular index.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法[`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index")，用于返回表是否具有特定索引。
- en: Inspection methods such as [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") that work on a single table
    at a time should now all consistently raise [`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError") if a table or view is not found; this change
    is specific to individual dialects, so may not be the case for existing third-party
    dialects.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对一次只对单个表起作用的检查方法，例如[`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")，现在应该一致地引发[`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError")如果找不到表或视图; 此更改特定于各个方言，因此对于现有的第三方方言可能不适用。
- en: Separated the handling of “views” and “materialized views”, as in real world
    use cases, these two constructs make use of different DDL for CREATE and DROP;
    this includes that there are now separate [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and [`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“视图”和“材料化视图”的处理分开，因为在现实世界的用例中，这两个构造使用不同的DDL来创建和删除; 这包括现在有单独的[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names")和[`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names")方法。
- en: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)  ## Dialect support for
    psycopg 3 (a.k.a. “psycopg”)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)  ## 对psycopg 3（也称为“psycopg”）的方言支持'
- en: Added dialect support for the [psycopg 3](https://pypi.org/project/psycopg/)
    DBAPI, which despite the number “3” now goes by the package name `psycopg`, superseding
    the previous `psycopg2` package that for the time being remains SQLAlchemy’s “default”
    driver for the `postgresql` dialects. `psycopg` is a completely reworked and modernized
    database adapter for PostgreSQL which supports concepts such as prepared statements
    as well as Python asyncio.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为[psycopg 3](https://pypi.org/project/psycopg/) DBAPI增加了方言支持，尽管现在被称为`psycopg`，但它的包名仍然取代了之前的`psycopg2`包，后者目前仍然是SQLAlchemy“默认”的`postgresql`方言驱动程序。
    `psycopg`是一个完全重新设计和现代化的用于PostgreSQL的数据库适配器，支持诸如准备语句和Python asyncio等概念。
- en: '`psycopg` is the first DBAPI supported by SQLAlchemy which provides both a
    pep-249 synchronous API as well as an asyncio driver. The same `psycopg` database
    URL may be used with the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") and [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine-creation functions, and the
    corresponding sync or asyncio version of the dialect will be selected automatically.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`psycopg`是SQLAlchemy支持的第一个同时提供pep-249同步API和asyncio驱动程序的DBAPI。可以使用相同的`psycopg`数据库URL与[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")和[`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine")引擎创建函数，自动选择相应的同步或asyncio版本的方言。'
- en: See also
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[psycopg](../dialects/postgresql.html#postgresql-psycopg)  ## Dialect support
    for oracledb'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[psycopg](../dialects/postgresql.html#postgresql-psycopg)  ## 对oracledb的方言支持'
- en: Added dialect support for the [oracledb](https://pypi.org/project/oracledb/)
    DBAPI, which is the renamed, new major release of the popular cx_Oracle driver.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为[oracledb](https://pypi.org/project/oracledb/) DBAPI增加了方言支持，这是流行的cx_Oracle驱动程序的重命名的新主要版本。
- en: See also
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[python-oracledb](../dialects/oracle.html#oracledb)  ## New Conditional DDL
    for Constraints and Indexes'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[python-oracledb](../dialects/oracle.html#oracledb)  ## 新的条件 DDL 用于约束和索引'
- en: 'A new method [`Constraint.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Constraint.ddl_if
    "sqlalchemy.schema.Constraint.ddl_if") and [`Index.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Index.ddl_if
    "sqlalchemy.schema.Index.ddl_if") allows constructs such as [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") and [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") to be rendered conditionally for a given [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), based on the same kinds of criteria that are accepted
    by the `DDLElement.execute_if()` method. In the example below, the CHECK constraint
    and index will only be produced against a PostgreSQL backend:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的方法 [`Constraint.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Constraint.ddl_if
    "sqlalchemy.schema.Constraint.ddl_if") 和 [`Index.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Index.ddl_if
    "sqlalchemy.schema.Index.ddl_if") 允许诸如 [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 和 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 这样的构造在给定的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 上有条件地呈现，基于与 `DDLElement.execute_if()` 方法接受的相同类型的条件。在下面的示例中，CHECK
    约束和索引只会针对 PostgreSQL 后端生成：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See also
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Controlling DDL Generation of Constraints and Indexes](../core/ddl.html#schema-ddl-ddl-if)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[控制约束和索引的 DDL 生成](../core/ddl.html#schema-ddl-ddl-if)'
- en: '[#7631](https://www.sqlalchemy.org/trac/ticket/7631)  ## DATE, TIME, DATETIME
    datatypes now support literal rendering on all backends'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7631](https://www.sqlalchemy.org/trac/ticket/7631)  ## DATE、TIME、DATETIME
    数据类型现在在所有后端上都支持字面渲染'
- en: 'Literal rendering is now implemented for date and time types for backend specific
    compilation, including PostgreSQL and Oracle:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 字面渲染现在已经实现了对于日期和时间类型的后端特定编译，包括 PostgreSQL 和 Oracle：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Previously, such literal rendering only worked when stringifying statements
    without any dialect given; when attempting to render with a dialect-specific type,
    a `NotImplementedError` would be raised, up until SQLAlchemy 1.4.45 where this
    became a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") (part of [#8800](https://www.sqlalchemy.org/trac/ticket/8800)).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这样的字面渲染仅在未提供任何方言的情况下将语句转换为字符串时才起作用；当尝试使用特定于方言的类型进行渲染时，会引发 `NotImplementedError`，直到
    SQLAlchemy 1.4.45，这变成了一个 [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")（部分来源于 [#8800](https://www.sqlalchemy.org/trac/ticket/8800)）。
- en: The default rendering is modified ISO-8601 rendering (i.e. ISO-8601 with the
    T converted to a space) when using `literal_binds` with the SQL compilers provided
    by the PostgreSQL, MySQL, MariaDB, MSSQL, Oracle dialects. For Oracle, the ISO
    format is wrapped inside of an appropriate TO_DATE() function call. The rendering
    for SQLite is unchanged as this dialect always included string rendering for date
    values.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 PostgreSQL、MySQL、MariaDB、MSSQL、Oracle 方言提供的 SQL 编译器的 `literal_binds` 时，默认渲染是修改后的
    ISO-8601 渲染（即将 T 转换为空格的 ISO-8601）。对于 Oracle，ISO 格式被包装在适当的 TO_DATE() 函数调用中。对于 SQLite，渲染保持不变，因为这个方言始终为日期值包含字符串渲染。
- en: '[#5052](https://www.sqlalchemy.org/trac/ticket/5052)  ## Context Manager Support
    for `Result`, `AsyncResult`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5052](https://www.sqlalchemy.org/trac/ticket/5052)  ## `Result`、`AsyncResult`
    的上下文管理器支持'
- en: 'The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object now supports context manager use, which will ensure the object and its
    underlying cursor is closed at the end of the block. This is useful in particular
    with server side cursors, where it’s important that the open cursor object is
    closed at the end of an operation, even if user-defined exceptions have occurred:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    对象现在支持上下文管理器的使用，这将确保对象及其底层游标在块结束时关闭。这在特定于服务器端游标的情况下特别有用，在这种情况下，重要的是在操作结束时关闭打开的游标对象，即使发生了用户定义的异常：'
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With asyncio use, the [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") and [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") have been altered to provide for optional
    async context manager use, as in:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用asyncio时，[`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult")和[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")已经改变，以提供可选的异步上下文管理器使用，如下所示：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[#8710](https://www.sqlalchemy.org/trac/ticket/8710)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8710](https://www.sqlalchemy.org/trac/ticket/8710)'
- en: Behavioral Changes
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变化
- en: This section covers behavioral changes made in SQLAlchemy 2.0 which are not
    otherwise part of the major 1.4->2.0 migration path; changes here are not expected
    to have significant effects on backwards compatibility.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了SQLAlchemy 2.0中的行为变化，这些变化不属于主要的1.4->2.0迁移路径；这里的变化不会对向后兼容性产生重大影响。
- en: '### New transaction join modes for `Session`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '### `Session` 的新事务加入模式'
- en: The behavior of “joining an external transaction into a Session” has been revised
    and improved, allowing explicit control over how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will accommodate an incoming [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that already has a transaction and possibly a
    savepoint already established. The new parameter [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") includes a series of option values which can accommodate
    the existing transaction in several ways, most importantly allowing a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to operate in a fully transactional style using savepoints
    exclusively, while leaving the externally initiated transaction non-committed
    and active under all circumstances, allowing test suites to rollback all changes
    that take place within tests.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: “将外部事务加入到会话中”的行为已经修订和改进，允许显式控制[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")如何适应已经建立了事务并可能已经建立了保存点的传入[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")。新参数[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")包括一系列选项值，可以以几种方式适应现有事务，最重要的是允许[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")专门使用保存点以全事务方式操作，同时始终将外部启动的事务未提交且活跃，允许测试套件回滚所有在测试中发生的更改。
- en: The primary improvement this allows is that the recipe documented at [Joining
    a Session into an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction),
    which also changed from SQLAlchemy 1.3 to 1.4, is now simplified to no longer
    require explicit use of an event handler or any mention of an explicit savepoint;
    by using `join_transaction_mode="create_savepoint"`, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will never affect the state of an incoming transaction,
    and will instead create a savepoint (i.e. “nested transaction”) as its root transaction.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来的主要改进是[将会话加入外部事务（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)的文档化配方，它也从SQLAlchemy
    1.3更改为1.4，现在简化为不再需要显式使用事件处理程序或任何提及显式保存点；通过使用`join_transaction_mode="create_savepoint"`，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")永远不会影响传入事务的状态，而是创建一个保存点（即“嵌套事务”）作为其根事务。
- en: 'The following illustrates part of the example given at [Joining a Session into
    an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction);
    see that section for a full example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[将会话加入外部事务（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)中给出的示例的一部分；请参阅该部分以获取完整示例：
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The default mode selected for [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") is `"conditional_savepoint"`, which uses `"create_savepoint"`
    behavior if the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is itself already on a savepoint. If the given
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is in a transaction but not a savepoint, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will propagate “rollback” calls but not “commit” calls,
    but will not begin a new savepoint on its own. This behavior is chosen by default
    for its maximum compatibility with older SQLAlchemy versions as well as that it
    does not start a new SAVEPOINT unless the given driver is already making use of
    SAVEPOINT, as support for SAVEPOINT varies not only with specific backend and
    driver but also configurationally.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")的默认模式是`"conditional_savepoint"`，如果给定的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")本身已经在一个保存点上，则使用`"create_savepoint"`行为。如果给定的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")在一个事务中但不在一个保存点上，则[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会传播“回滚”调用但不会传播“提交”调用，但不会自行开始一个新的保存点。这种行为被默认选择是因为它与旧版本的
    SQLAlchemy 兼容性最大，并且只有在给定的驱动程序已经使用 SAVEPOINT 时才会开始一个新的 SAVEPOINT，因为对 SAVEPOINT
    的支持不仅取决于特定的后端和驱动程序，还取决于配置。
- en: 'The following illustrates a case that worked in SQLAlchemy 1.3, stopped working
    in SQLAlchemy 1.4, and is now restored in SQLAlchemy 2.0:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了一个在 SQLAlchemy 1.3 中工作的情况，在 SQLAlchemy 1.4 中停止工作，并在 SQLAlchemy 2.0 中恢复的情况：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Where above, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is joined to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that has a savepoint started on it; the state
    of these two units remains unchanged after the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has worked with the transaction. In SQLAlchemy 1.3,
    the above case worked because the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would begin a “subtransaction” upon the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which would allow the outer savepoint / transaction
    to remain unaffected for simple cases as above. Since subtransactions were deprecated
    in 1.4 and are now removed in 2.0, this behavior was no longer available. The
    new default behavior improves upon the behavior of “subtransactions” by using
    a real, second SAVEPOINT instead, so that even calls to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") prevent the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from “breaking out” into the externally initiated SAVEPOINT
    or transaction.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")与一个在其上启动了保存点的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")连接在一起；这两个单元的状态在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")处理完事务后保持不变。在 SQLAlchemy 1.3 中，上述情况能够正常工作是因为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上开始一个“子事务”，这样外部保存点/事务可以保持不受影响，就像上面的简单情况一样。由于子事务在
    1.4 中已被弃用并在 2.0 中被移除，这种行为不再可用。新的默认行为通过使用一个真正的第二个 SAVEPOINT 来改进“子事务”的行为，因此即使调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")也会阻止[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")“跳出”到外部启动的 SAVEPOINT 或事务。
- en: New code that is joining a transaction-started [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should however select a [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") explicitly, so that the desired behavior is explicitly
    defined.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个已启动事务的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")加入到一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的新代码应该明确选择一个[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")，以便明确定义所需的行为。
- en: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)  ### `str(engine.url)`
    will obfuscate the password by default'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)  ### `str(engine.url)`
    现在默认会混淆密码'
- en: 'To avoid leakage of database passwords, calling `str()` on a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") will now enable the password obfuscation feature by default.
    Previously, this obfuscation would be in place for `__repr__()` calls but not
    `__str__()`. This change will impact applications and test suites that attempt
    to invoke [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    given the stringified URL from another engine, such as:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据库密码泄漏，在[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")上调用`str()`现在将默认启用密码混淆功能。以前，这种混淆会在`__repr__()`调用中生效，但不会在`__str__()`中生效。这种变化将影响那些试图从另一个引擎传递字符串化的URL调用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")的应用程序和测试套件，例如：
- en: '[PRE36]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The above engine `e2` will not have the correct password; it will have the obfuscated
    string `"***"`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎`e2`将不会具有正确的密码；它将具有混淆的字符串`"***"`。
- en: 'The preferred approach for the above pattern is to pass the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object directly, there’s no need to stringify:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式的首选方法是直接传递[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")对象，无需将其字符串化：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Otherwise, for a stringified URL with cleartext password, use the [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") method, passing the [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") parameter as `False`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对于具有明文密码的字符串化URL，请使用[`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string")方法，将[`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string")参数设置为`False`：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)  ### Stricter rules for
    replacement of Columns in Table objects with same-names, keys'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)  ### 对具有相同名称和键的表对象中列的替换规则更加严格'
- en: Stricter rules are in place for appending of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, both moving some previous deprecation warnings
    to exceptions, and preventing some previous scenarios that would cause duplicate
    columns to appear in tables, when [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") were set to `True`, for both programmatic [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construction as well as during reflection operations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象附加[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，现在有更严格的规则，将一些先前的弃用警告转换为异常，并阻止一些先前可能导致表中出现重复列的情况，当[`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table")设置为`True`时，无论是在编程式[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构建还是在反射操作期间。
- en: Under no circumstances should a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object ever have two or more [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with the same name, regardless of what .key
    they have. An edge case where this was still possible was identified and fixed.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论如何，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象永远不应该具有两个或更多具有相同名称的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，无论它们有什么`.key`。已经确定并修复了一个仍然可能发生这种情况的边缘情况。
- en: Adding a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that has the same name or key as an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will always raise [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError") (a new subclass of [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") in 2.0.0b4) unless additional parameters are present;
    [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") for [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column"), and [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") for construction of a same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as an existing one, with or without reflection being
    used. Previously, there was a deprecation warning in place for this scenario.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向具有与现有 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    相同名称或键的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    添加 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    将始终引发 [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError")（在2.0.0b4中是 [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") 的新子类），除非存在其他参数；[`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") 用于 [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column")，以及 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") 用于构建与现有表同名的表，无论是否使用了反射。以前，此场景会出现弃用警告。
- en: A warning is now emitted if a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is created, that does include [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table"), where an incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that has no separate [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") would fully replace an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that does have a key, which suggests the operation
    is not what the user intended. This can happen particularly during a secondary
    reflection step, such as `metadata.reflect(extend_existing=True)`. The warning
    suggests that the [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") parameter be set to `False` to prevent this. Previously,
    in 1.4 and earlier, the incoming column would be added **in addition** to the
    existing column. This was a bug and is a behavioral change in 2.0 (as of 2.0.0b4),
    as the previous key will **no longer be present** in the column collection when
    this occurs.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，如果创建了一个包含 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的警告，该警告会包括 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table")，其中一个没有单独的 [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") 的传入 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 将完全替换一个具有键的现有 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，这表明操作不是用户想要的。这可能特别发生在二次反射步骤期间，例如 `metadata.reflect(extend_existing=True)`。警告建议将
    [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") 参数设置为 `False` 以防止此问题。在1.4及更早版本中，传入的列将**额外添加**到现有列中。这是一个错误，在2.0（截至2.0.0b4）中是行为更改，因为当这种情况发生时，先前的键将**不再存在**于列集合中。
- en: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)  ### ORM Declarative Applies
    Column Orders Differently; Control behavior using `sort_order`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)  ### ORM Declarative 对列顺序的应用方式不同；使用
    `sort_order` 控制行为'
- en: 'Declarative has changed the system by which mapped columns that originate from
    mixin or abstract base classes are sorted along with the columns that are on the
    declared class itself to place columns from the declared class first, followed
    by mixin columns. The following mapping:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式已经改变了从混入或抽象基类派生的映射列的排序系统，以及与声明类本身上的列一起排序，将来自声明类的列放在首位，然后是混入列。以下映射：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Produces a CREATE TABLE as follows on 1.4:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 上产生一个 CREATE TABLE 如下所示：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Whereas on 2.0 it produces:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 2.0 上则产生：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For the specific case above, this can be seen as an improvement, as the primary
    key columns on the `Model` are now where one would typically prefer. However,
    this is no comfort for the application that defined models the other way around,
    as:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述特定情况，这可以看作是一种改进，因为 `Model` 上的主键列现在通常在一个人更喜欢的地方。然而，对于以另一种方式定义模型的应用程序来说，这并不令人舒服，因为：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This now produces CREATE TABLE output as:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将产生 CREATE TABLE 输出如下所示：
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To solve this issue, SQLAlchemy 2.0.4 introduces a new parameter on [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") called [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column"), which is an integer value, defaulting to `0`,
    that can be set to a positive or negative value so that columns are placed before
    or after other columns, as in the example below:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，SQLAlchemy 2.0.4 引入了一个新参数 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")，名为 [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column")，它是一个整数值，默认为 `0`，可以设置为正值或负值，以使列在其他列之前或之后排列，如下面的示例所示：
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The above model places “id” before all others and “col1” after “id”:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模型将 “id” 放在所有其他列之前，将 “col1” 放在 “id” 之后：
- en: '[PRE45]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Future SQLAlchemy releases may opt to provide an explicit ordering hint for
    the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, as this ordering is ORM specific.  ### The `Sequence` construct reverts
    to not having any explicit default “start” value; impacts MS SQL Server'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的 SQLAlchemy 版本可能会选择为 [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 结构提供显式的排序提示，因为这种排序是 ORM 特定的。### `Sequence` 结构恢复为没有任何显式默认的
    “start” 值；影响 MS SQL Server
- en: 'Prior to SQLAlchemy 1.4, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct would emit only simple `CREATE SEQUENCE`
    DDL, if no additional arguments were specified:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 1.4 之前，如果未指定其他参数，则 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 结构将仅发出简单的 `CREATE SEQUENCE` DDL：
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, as [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    support was added for MS SQL Server, where the default start value is inconveniently
    set to `-2**63`, version 1.4 decided to default the DDL to emit a start value
    of 1, if [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") were not otherwise provided:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于在 MS SQL Server 上增加了对 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 的支持，其中默认的起始值设置为 `-2**63`，版本 1.4 决定将 DDL 默认设置为 1，如果未提供
    [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") 参数：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This change has introduced other complexities, including that when the [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") parameter is included, this default of `1` should
    in fact default to what [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") states, else a min_value that’s below the start_value
    may be seen as contradictory. As looking at this issue started to become a bit
    of a rabbit hole of other various edge cases, we decided to instead revert this
    change and restore the original behavior of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") which is to have no opinion, and just emit CREATE
    SEQUENCE, allowing the database itself to make its decisions on how the various
    parameters of `SEQUENCE` should interact with each other.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变引入了其他复杂性，包括当包括 [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") 参数时，这个 `1` 的默认值实际上应该默认为 [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") 声明的内容，否则，一个低于起始值的 min_value 可能会被视为矛盾的。由于观察这个问题开始变得有点复杂，我们决定撤销这个改变，并恢复
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    的原始行为，即不表达任何观点，只是发出 CREATE SEQUENCE，允许数据库自己决定 `SEQUENCE` 的各个参数如何相互作用。
- en: 'Therefore, to ensure that the start value is 1 on all backends, **the start
    value of 1 may be indicated explicitly**, as below:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保所有后端的起始值都为 1，**可能需要显式指定起始值为 1**，如下所示：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Beyond all of that, for autogeneration of integer primary keys on modern backends
    including PostgreSQL, Oracle, SQL Server, the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct should be preferred, which also works
    the same way in 1.4 and 2.0 with no changes in behavior.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于在现代后端包括PostgreSQL、Oracle、SQL Server上自动生成整数主键，应优先使用[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")构造，这在1.4和2.0中的行为没有变化。
- en: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)  ### “with_variant()”
    clones the original TypeEngine rather than changing the type'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)  ### “with_variant()”克隆原始TypeEngine而不是更改类型'
- en: The [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method, which is used to apply alternate
    per-database behaviors to a particular type, now returns a copy of the original
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object with the variant information stored internally, rather than wrapping it
    inside the `Variant` class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")方法用于将特定类型应用于每个数据库的替代行为，现在返回原始[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象的副本，其中包含内部存储的变体信息，而不是将其包装在`Variant`类中。'
- en: 'While the previous `Variant` approach was able to maintain all the in-Python
    behaviors of the original type using dynamic attribute getters, the improvement
    here is that when calling upon a variant, the returned type remains an instance
    of the original type, which works more smoothly with type checkers such as mypy
    and pylance. Given a program as below:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 而以前的`Variant`方法能够通过动态属性获取器维护原始类型的所有Python行为，这里的改进是当调用变体时，返回的类型仍然是原始类型的实例，这与mypy和pylance等类型检查器更加顺畅地配合。给定以下程序：
- en: '[PRE49]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A type checker like pyright will now report the type as:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器如pyright现在将报告类型为：
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In addition, as illustrated above, multiple dialect names may be passed for
    single type, in particular this is helpful for the pair of `"mysql"` and `"mariadb"`
    dialects which are considered separately as of SQLAlchemy 1.4.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如上所示，可以为单个类型传递多个方言名称，特别是对于被视为SQLAlchemy 1.4的“mysql”和“mariadb”方言对来说，这是有帮助的。
- en: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)  ### Python division operator
    performs true division for all backends; added floor division'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)  ### Python除法运算符对所有后端执行真除法；添加地板除法'
- en: The Core expression language now supports both “true division” (i.e. the `/`
    Python operator) and “floor division” (i.e. the `//` Python operator) including
    backend-specific behaviors to normalize different databases in this regard.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达语言现在支持“真除法”（即Python运算符`/`）和“地板除法”（即Python运算符`//`），包括后端特定的行为以规范不同数据库在这方面的行为。
- en: 'Given a “true division” operation against two integer values:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数值进行“真除法”操作：
- en: '[PRE51]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The SQL division operator on PostgreSQL for example normally acts as “floor
    division” when used against integers, meaning the above result would return the
    integer “0”. For this and similar backends, SQLAlchemy now renders the SQL using
    a form which is equivalent towards:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在PostgreSQL上，SQL除法运算符在针对整数时通常作为“地板除法”运行，这意味着上述结果将返回整数“0”。对于这样的后端，SQLAlchemy现在呈现的SQL形式等效于：
- en: '[PRE52]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With `param_1=5`, `param_2=10`, so that the return expression will be of type
    NUMERIC, typically as the Python value `decimal.Decimal("0.5")`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`param_1=5`，`param_2=10`，以便返回表达式的类型为NUMERIC，通常作为Python值`decimal.Decimal("0.5")`。
- en: 'Given a “floor division” operation against two integer values:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数值进行“地板除法”操作：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The SQL division operator on MySQL and Oracle for example normally acts as
    “true division” when used against integers, meaning the above result would return
    the floating point value “0.5”. For these and similar backends, SQLAlchemy now
    renders the SQL using a form which is equivalent towards:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在MySQL和Oracle上，SQL除法运算符在针对整数时通常作为“真除法”运行，这意味着上述结果将返回浮点值“0.5”。对于这些和类似的后端，SQLAlchemy现在呈现的SQL形式等效于：
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With param_1=5, param_2=10, so that the return expression will be of type INTEGER,
    as the Python value `0`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`param_1=5`，`param_2=10`，以便返回表达式的类型为INTEGER，如Python值`0`。
- en: 'The backwards-incompatible change here would be if an application using PostgreSQL,
    SQL Server, or SQLite which relied on the Python “truediv” operator to return
    an integer value in all cases. Applications which rely upon this behavior should
    instead use the Python “floor division” operator `//` for these operations, or
    for forwards compatibility when using a previous SQLAlchemy version, the floor
    function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的不兼容更改是，如果一个应用程序使用 PostgreSQL、SQL Server 或 SQLite，并依赖于 Python 的“truediv”运算符在所有情况下返回整数值。依赖于此行为的应用程序应该使用
    Python 的“floor division”运算符 `//` 进行这些操作，或者在使用之前的 SQLAlchemy 版本时，使用 floor 函数以实现向前兼容性：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The above form would be needed on any SQLAlchemy version prior to 2.0 in order
    to provide backend-agnostic floor division.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 SQLAlchemy 2.0 之前的版本中，都需要上述形式来提供与后端无关的地板除法。
- en: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)  ### Session raises proactively
    when illegal concurrent or reentrant access is detected'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)  ### 当检测到非法并发或重入访问时，会主动引发会话错误'
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now trap more errors related to illegal concurrent state changes within multithreaded
    or other concurrent scenarios as well as for event hooks which perform unexpected
    state changes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在可以捕获更多与多线程或其他并发场景中的非法并发状态更改以及执行意外状态更改的事件钩子相关的错误。'
- en: 'One error that’s been known to occur when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in multiple threads simultaneously is `AttributeError:
    ''NoneType'' object has no attribute ''twophase''`, which is completely cryptic.
    This error occurs when a thread calls [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which internally invokes the `SessionTransaction.close()`
    method to end the transactional context, at the same time that another thread
    is in progress running a query as from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). Within [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), the internal method that acquires a database
    connection for the current transaction first begins by asserting that the session
    is “active”, but after this assertion passes, the concurrent call to [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") interferes with this state which leads to the
    undefined condition above.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '当一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    在多个线程同时使用时，已知会发生的一个错误是 `AttributeError: ''NoneType'' object has no attribute ''twophase''`，这完全晦涩难懂。这个错误发生在一个线程调用
    [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    时，内部调用 `SessionTransaction.close()` 方法来结束事务上下文，同时另一个线程正在运行查询，如 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")。在 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 中，获取当前事务的数据库连接的内部方法首先开始断言会话是“活动的”，但在此断言通过后，同时进行的对
    [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    的并发调用会干扰这种状态，导致上述未定义的条件。'
- en: The change applies guards to all state-changing methods surrounding the [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object so that in the above case, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will instead fail as it will seek to change
    the state to one that is disallowed for the duration of the already-in-progress
    method that wants to get the current connection to run a database query.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 该更改对围绕 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象的所有改变状态的方法应用了保护措施，因此在上述情况下，[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 方法将会失败，因为它将试图将状态更改为在已经进行中的方法期间不允许的状态，而该方法希望获取当前连接以运行数据库查询。
- en: 'Using the test script illustrated at [#7433](https://www.sqlalchemy.org/trac/ticket/7433),
    the previous error case looks like:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在 [#7433](https://www.sqlalchemy.org/trac/ticket/7433) 中说明的测试脚本，先前的错误案例如下：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Where the `_connection_for_bind()` method isn’t able to continue since concurrent
    access placed it into an invalid state. Using the new approach, the originator
    of the state change throws the error instead:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当`_connection_for_bind()`方法无法继续运行，因为并发访问使其处于无效状态时。使用新方法，状态更改的发起者会抛出错误：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The state transition checks intentionally don’t use explicit locks to detect
    concurrent thread activity, instead relying upon simple attribute set / value
    test operations that inherently fail when unexpected concurrent changes occur.
    The rationale is that the approach can detect illegal state changes that occur
    entirely within a single thread, such as an event handler that runs on session
    transaction events calls a state-changing method that’s not expected, or under
    asyncio if a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were shared among multiple asyncio tasks, as well as
    when using patching-style concurrency approaches such as gevent.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换检查故意不使用显式锁来检测并发线程活动，而是依赖于简单的属性设置/值测试操作，当意外的并发更改发生时，这些操作会自然失败。其理念在于，该方法可以检测到完全在单个线程内发生的非法状态更改，例如在事件处理程序上运行会话事务事件调用了一个不被期望的改变状态的方法，或者在
    asyncio 中，如果一个特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")被多个
    asyncio 任务共享，以及在使用类似 gevent 的补丁式并发方法时。
- en: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)  ### The SQLite dialect
    uses QueuePool for file-based databases'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)  ### SQLite 方言在基于文件的数据库中使用
    QueuePool'
- en: The SQLite dialect now defaults to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") when a file based database is used. This is set along
    with setting the `check_same_thread` parameter to `False`. It has been observed
    that the previous approach of defaulting to [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool"), which does not hold onto database connections after
    they are released, did in fact have a measurable negative performance impact.
    As always, the pool class is customizable via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于文件的数据库时，SQLite 方言现在默认使用 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。这是与将 `check_same_thread` 参数设置为 `False` 一起设置的。已经观察到，以前默认使用
    [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool "sqlalchemy.pool.NullPool")
    的方法，在释放数据库连接后不保留连接，实际上对性能产生了可衡量的负面影响。如常，池类可通过 [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") 参数进行自定义。
- en: See also
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[线程/池行为](../dialects/sqlite.html#pysqlite-threading-pool)'
- en: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)  ### New Oracle FLOAT
    type with binary precision; decimal precision not accepted directly'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)  ### 新的 Oracle FLOAT 类型，具有二进制精度；不直接接受十进制精度'
- en: 'A new datatype [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") has been added to the Oracle dialect, to accompany
    the addition of [`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    and database-specific [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE"), [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") and [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") datatypes. Oracle’s `FLOAT` accepts a so-called “binary
    precision” parameter that per Oracle documentation is roughly a standard “precision”
    value divided by 0.3103:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 方言现已添加了新的数据类型 [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT")，以配合 [`Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double") 和数据库特定的 [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE")、[`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") 和 [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") 数据类型的添加。Oracle 的 `FLOAT` 接受所谓的“二进制精度”参数，根据 Oracle 文档，大致为标准“精度”值除以
    0.3103：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A binary precision value of 126 is synonymous with using the [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") datatype, and a value of 63 is equivalent
    to using the [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    datatype. Other precision values are specific to the [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") type itself.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制精度值 126 与使用 [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") 数据类型是等效的，值 63 等效于使用 [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") 数据类型。其他精度值特定于 [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") 类型本身。
- en: 'The SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype also accepts a “precision” parameter, but this is decimal precision which
    is not accepted by Oracle. Rather than attempting to guess the conversion, the
    Oracle dialect will now raise an informative error if [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") is used with a precision value against the Oracle backend.
    To specify a [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype with an explicit precision value for supporting backends, while also
    supporting other backends, use the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    数据类型也接受“精度”参数，但这是十进制精度，Oracle 不接受。与其尝试猜测转换，Oracle 方言现在将在针对 Oracle 后端使用带有精度值的 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 时引发一个信息丰富的错误。为了为支持的后端指定具有显式精度值的 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 数据类型，同时还支持其他后端，可以使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 方法，如下所示：
- en: '[PRE59]  ### New RANGE / MULTIRANGE support and changes for PostgreSQL backends'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE59]  ### PostgreSQL 后端的新 RANGE / MULTIRANGE 支持和更改'
- en: RANGE / MULTIRANGE support has been fully implemented for psycopg2, psycopg3,
    and asyncpg dialects. The new support uses a new SQLAlchemy-specific [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object that is agnostic of the different
    backends and does not require the use of backend-specific imports or extension
    steps. For multirange support, lists of [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects are used.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: RANGE / MULTIRANGE 支持已完全实现为 psycopg2、psycopg3 和 asyncpg 方言。新支持使用了一个新的 SQLAlchemy
    特定的 [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象，它对不同的后端是不可知的，不需要使用后端特定的导入或扩展步骤。对于多范围支持，使用
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    对象的列表。
- en: Code that used the previous psycopg2-specific types should be modified to use
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range"),
    which presents a compatible interface.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的特定于 psycopg2 的类型的代码应修改为使用[`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range")，它提供了兼容的接口。
- en: The [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object also features comparison support
    which mirrors that of PostgreSQL. Implemented so far are [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") and [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") methods which work in the
    same way as the PostgreSQL `@>` and `<@`. Additional operator support may be added
    in future releases.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象还具有与 PostgreSQL 相同的比较支持。到目前为止已实现了 [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") 和 [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") 方法，它们的工作方式与 PostgreSQL 的
    `@>` 和 `<@` 相同。未来的版本可能会添加其他运算符支持。'
- en: See the documentation at [Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)
    for background on using the new feature.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[范围和多范围类型](../dialects/postgresql.html#postgresql-ranges)处的文档，了解如何使用新功能的背景信息。
- en: See also
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[范围和多范围类型](../dialects/postgresql.html#postgresql-ranges)'
- en: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)  ###
    `match()` operator on PostgreSQL uses `plainto_tsquery()` rather than `to_tsquery()`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)  ###
    在PostgreSQL上使用`match()`操作符使用`plainto_tsquery()`而不是`to_tsquery()`'
- en: The `Operators.match()` function now renders `col @@ plainto_tsquery(expr)`
    on the PostgreSQL backend, rather than `col @@ to_tsquery()`. `plainto_tsquery()`
    accepts plain text whereas `to_tsquery()` accepts specialized query symbols, and
    is therefore less cross-compatible with other backends.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operators.match()`函数现在在PostgreSQL后端上呈现为`col @@ plainto_tsquery(expr)`，而不是`col
    @@ to_tsquery()`。`plainto_tsquery()`接受纯文本，而`to_tsquery()`接受专门的查询符号，因此与其他后端的兼容性较差。'
- en: All PostgreSQL search functions and operators are available through use of [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to generate PostgreSQL-specific functions and
    [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") (a boolean-typed version of [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")) to generate arbitrary operators, in
    the same manner as they are available in previous versions. See the examples at
    [Full Text Search](../dialects/postgresql.html#postgresql-match).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")生成PostgreSQL特定函数和[`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")（[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")的布尔类型版本）来生成任意运算符，以与之前版本相同的方式，所有PostgreSQL搜索函数和操作符都可用。请参阅[全文搜索](../dialects/postgresql.html#postgresql-match)中的示例。
- en: Existing SQLAlchemy projects that make use of PG-specific directives within
    `Operators.match()` should make use of `func.to_tsquery()` directly. To render
    SQL in exactly the same form as would be present in 1.4, see the version note
    at [Simple plain text matching with match()](../dialects/postgresql.html#postgresql-simple-match).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的SQLAlchemy项目如果在`Operators.match()`中使用了PG特定的指令，应该直接使用`func.to_tsquery()`。要以与1.4版本完全相同的形式呈现SQL，请参阅[使用match()进行简单纯文本匹配](../dialects/postgresql.html#postgresql-simple-match)的版本说明。
- en: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)'
- en: New Typing Support in Core and ORM - Stubs / Extensions no longer used
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Core和ORM中的新类型支持-不再使用存根/扩展
- en: The approach to typing for Core and ORM has been completely reworked, compared
    to the interim approach that was provided in version 1.4 via the [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    package. The new approach begins at the most fundamental element in SQLAlchemy
    which is the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    or more accurately the [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") that underlies all SQL expressions
    that have a type. This expression-level typing then extends into the area of statement
    construction, statement execution, and result sets, and finally into the ORM where
    new [declarative](../orm/declarative_config.html) forms allow for fully typed
    ORM models that integrate all the way from statement to result set.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 与1.4版本中通过[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)包提供的临时方法相比，Core和ORM的类型化方法已完全重写。新方法始于SQLAlchemy中最基本的元素，即[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，更准确地说是底层所有具有类型的SQL表达式的[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")。然后，这个表达式级别的类型化扩展到语句构造、语句执行和结果集的领域，最终扩展到ORM，其中新的[声明性](../orm/declarative_config.html)形式允许完全类型化的ORM模型，从语句到结果集全部集成。
- en: Tip
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Typing support should be considered **beta level** software for the 2.0 series.
    Typing details are subject to change however significant backwards-incompatible
    changes are not planned.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2.0系列，类型支持应被视为**beta级别**软件。类型详细信息可能会发生变化，但不计划进行重大不兼容更改。
- en: SQL Expression / Statement / Result Set Typing
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL表达式/语句/结果集类型化
- en: This section provides background and examples for SQLAlchemy’s new SQL expression
    typing approach, which extends from base [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs through SQL statements and
    result sets and into realm of ORM mapping.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了SQLAlchemy的新SQL表达类型方法的背景和示例，它从基本的[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")构造扩展到SQL语句和结果集，以及ORM映射的领域。
- en: Rationale and Overview
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原因和概述
- en: Tip
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是一个架构讨论。 跳转到[SQL表达类型 - 示例](#whatsnew-20-expression-typing-examples)以查看新的类型化外观。
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)中，SQL表达式被类型化为[泛型](https://peps.python.org/pep-0484/#generics)，然后引用[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象，如[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")，[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")，或[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")作为它们的泛型参数（如`Column[Integer]`）。 这本身就是与最初的Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)包不同的地方，其中[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")及其基本构造直接以Python类型为泛型，例如`int`，`datetime`和`str`。 希望由于[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")本身是对`int` / `datetime` / `str`的泛型，因此有方法可以保持两个级别的信息，并且可以通过[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")从列表达式中提取Python类型作为中间构造。 但是，事实并非如此，因为[**PEP 484**](https://peps.python.org/pep-0484/)没有足够丰富的功能集使其可行，缺乏诸如[higher
    kinded TypeVars](https://github.com/python/typing/issues/548)之类的功能。
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 经过对[当前能力的深入评估](https://github.com/python/typing/discussions/999)，SQLAlchemy
    2.0 实现了[**PEP 484**](https://peps.python.org/pep-0484/)的原始智慧，直接将列表达式与Python类型进行关联。这意味着，如果有不同子类型的SQL表达式，比如`Column(VARCHAR)`和`Column(Unicode)`，那么这两个[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")子类型的具体信息不会随类型一起传递，因为类型只会携带`str`，但实际上这通常不是问题，通常更有用的是Python类型立即出现，因为它代表了将直接存储和接收的Python数据。
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这意味着像`Column('id', Integer)`这样的表达式被类型化为`Column[int]`。这允许建立一个可行的SQLAlchemy构造
    -> Python数据类型的管道，而无需使用类型插件。至关重要的是，它允许与ORM使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")构造的完全互操作性，这些构造引用ORM映射的类类型（例如，包含用户映射实例的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，如我们教程中使用的`User`和`Address`示例）。虽然Python类型当前对元组类型的定制支持非常有限（其中[**PEP
    646**](https://peps.python.org/pep-0646/)是第一个试图处理类似元组对象的pep，[故意在功能上受到限制](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)，并且本身尚不适用于任意元组操作），但已经设计出了一个相当不错的方法，允许基本的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")类型化功能，包括ORM类，其中在将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象解包为单独列条目时，添加了一个小的面向类型的访问器，允许各个Python值保持与其来源的SQL表达式相关联的Python类型（翻译：它有效）。
- en: '#### SQL Expression Typing - Examples'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '#### SQL表达式类型化 - 示例'
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 简要介绍了类型行为。注释指示在[vscode](https://code.visualstudio.com/)中悬停在代码上会看到什么（或者使用[reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)辅助工具时大致会显示什么）：
- en: Simple Python Types Assigned to SQL Expressions
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的Python类型分配给SQL表达式
- en: '[PRE60]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")构造的单个SQL表达式以及任何返回行的构造，包括返回行的DML，如带有[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")，都打包成一个保留每个元素Python类型的`Tuple[]`类型。
- en: '[PRE61]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回行的结构中的`Tuple[]`类型，在调用`.execute()`方法时，传递到[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")。为了将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象解包为元组，[`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple")或[`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t")访问器本质上将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")转换为相应的`Tuple[]`（但在运行时仍保持相同的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象）。
- en: '[PRE62]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于单列语句的标量值，使用[`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar")、[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars")等方法是正确的。
- en: '[PRE63]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于ORM映射类，上述对返回行构造的支持与其最配套，因为映射类可以列出其成员的特定类型。下面的示例设置了一个使用[新的类型感知语法](#whatsnew-20-orm-declarative-typing)的类，将在下一节中描述：
- en: '[PRE64]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上述映射，属性从语句到结果集一路类型化并表达自己：
- en: '[PRE65]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 映射类本身也是类型，并且行为相同，例如针对两个映射类进行SELECT查询：
- en: '[PRE66]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当选择映射类时，像[`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")这样的构造也能正常工作，保持原始映射类的列级属性以及语句期望的返回类型：
- en: '[PRE67]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心表（Core Table）目前还没有一个合适的方法来在通过[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问时维护[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的类型。
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")被设置为类的实例，并且[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问器通常通过名称动态访问[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，因此尚未为此建立类型化方法；需要一些替代语法。
- en: ORM classes, scalars, etc. work great.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM类、标量等工作得很好。
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择ORM类作为标量或元组的典型用例都有效，无论是2.0还是1.x风格的查询，都可以获得确切的类型，无论是单独还是包含在适当的容器中，如`Sequence[]`、`List[]`或`Iterator[]`：
- en: '[PRE68]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")也获得了元组类型。
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的类型支持远远超出了[sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)或[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)提供的范围，其中标量对象以及元组类型的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将保留大多数情况下的结果级别类型：
- en: '[PRE69]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: the catch - all stubs must be uninstalled
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意 - 所有存根必须被卸载
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 类型支持的一个关键警告是**必须卸载所有SQLAlchemy存根包**才能使类型化工作。在针对Python虚拟环境运行[mypy](https://mypy.readthedocs.io/en/stable/)时，只需卸载这些包。但是，SQLAlchemy存根包目前也是[typeshed](https://github.com/python/typeshed)的一部分，它本身捆绑在一些类型工具中，如[Pylance](https://github.com/microsoft/pylance-release)，因此在某些情况下可能需要定位这些包的文件并删除它们，如果它们实际上干扰了新的类型化正确工作。
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SQLAlchemy 2.0以最终状态发布，typeshed将从其自己的存根源中删除SQLAlchemy。
- en: '### ORM Declarative Models'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM声明模型'
- en: SQLAlchemy 1.4 introduced the first SQLAlchemy-native ORM typing support using
    a combination of [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    and the [Mypy Plugin](../orm/extensions/mypy.html). In SQLAlchemy 2.0, the Mypy
    plugin **remains available, and has been updated to work with SQLAlchemy 2.0’s
    typing system**. However, it should now be considered **deprecated**, as applications
    now have a straightforward path to adopting the new typing support that does not
    use plugins or stubs.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4引入了第一个使用[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)和[Mypy
    Plugin](../orm/extensions/mypy.html)组合的SQLAlchemy本机ORM类型支持。在SQLAlchemy 2.0中，Mypy插件**仍然可用，并已更新以与SQLAlchemy
    2.0的类型系统一起使用**。但是，现在应该将其视为**已弃用**，因为应用程序现在有一条直接的路径来采用新的类型支持，而不使用插件或存根。
- en: Overview
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概述
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统的基本方法是，当使用完全[声明式](../orm/declarative_tables.html#orm-declarative-table)模型（即不使用[混合声明式](../orm/declarative_tables.html#orm-imperative-table-configuration)或[命令式](../orm/mapping_styles.html#orm-imperative-mapping)配置，这些配置不变）时，映射列声明首先在运行时通过检查每个属性声明左侧的类型注释来推导，如果存在的话。左手类型注释应该包含在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类型中，否则该属性不被视为映射属性。然后属性声明可以引用右侧的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，用于提供有关要生成和映射的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的附加核心级模式信息。如果左侧存在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释，则此右侧声明是可选的；如果左侧没有注释，则[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")可以用作[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")指令的精确替代，其中它将提供更准确（但不精确）的属性类型行为，即使没有注释存在。
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法受到Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)方法的启发，它从左边开始注释，然后允许右边的可选`dataclasses.field()`规范；与dataclasses方法的关键区别在于SQLAlchemy的方法是严格的**选择加入**，其中使用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的现有映射如果没有任何类型注释，将继续像以往一样工作，并且[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造可以直接替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")而不需要任何显式类型注释。只有在确切的属性级Python类型存在时，才需要使用带有[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的显式注释。这些注释可以根据需要，按属性基础使用，对于那些特定类型有帮助的属性；使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")的未注释属性将在实例级别被标记为`Any`。
- en: '#### Migrating an Existing Mapping'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 迁移现有映射'
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到新的ORM方法开始时更加冗长，但随着可用的新功能的充分利用，变得比以前更简洁。以下步骤详细说明了典型的过渡，然后继续说明了一些更多的选项。
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一步 - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")被[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")取代。
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型中观察到的一个限制是似乎没有能力从函数动态生成一个类，然后被类型工具理解为新类的基础。为了解决这个问题而不使用插件，通常对[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")的调用可以替换为使用[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类，它产生与通常相同的`Base`对象，只是类型工具理解它：
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二步 - 用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的声明性使用
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")是一个ORM-typing感知构造，可以直接用于[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的使用。鉴于一个1.x风格的映射如下：'
- en: '[PRE71]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")；不需要更改任何参数：
- en: '[PRE72]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 上述各列目前都**尚未使用Python类型进行类型化**，而是被类型化为`Mapped[Any]`；这是因为我们可以将任何列声明为可选的或非可选的，并且没有办法在我们明确地对其进行类型化时不引起类型错误。
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这一步中，我们上述的映射已经为所有属性设置了适当的[描述符](../glossary.html#term-descriptor)，并且可以用于查询以及实例级别的操作，所有这些操作都将在**mypy
    –strict mode**下通过，而无需插件。
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三步 - 使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")根据需要应用确切的Python类型。
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于所有需要确切类型的属性；可以跳过那些可以保留为`Any`的属性。为了上下文，我们还说明了在一个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")中使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的情况，我们在这个中间步骤中应用了一个确切的类型。映射在这个中间步骤中将更加冗长，但是通过熟练掌握，这一步可以与后续步骤结合起来更直接地更新映射：
- en: '[PRE73]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的ORM映射已完全类型化，并将生成精确类型的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")构造。现在我们可以继续减少映射声明中的冗余部分。
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第四步 - 移除不再需要的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`nullable`参数都可以使用`Optional[]`隐含；在没有`Optional[]`的情况下，`nullable`默认为`False`。所有没有参数的
    SQL 类型，如`Integer`和`String`，可以仅表示为 Python 注释。不带参数的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令可以完全删除。现在，[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")从左手注释中派生其类，还支持向前引用（正如[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")已经支持字符串型向前引用十年一样；）：
- en: '[PRE74]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第五步 - 利用 pep-593 `Annotated` 将常见指令打包成类型
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项全新的功能，提供了一种替代或补充[声明性混合](../orm/declarative_mixins.html)的方法，作为提供基于类型的配置的手段，并且在大多数情况下取代了[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰的函数的需求。
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明式映射允许将 Python 类型映射到 SQL 类型，例如`str`映射到[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，通过[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")进行定制。使用[**PEP 593**](https://peps.python.org/pep-0593/)中的`Annotated`，我们可以创建特定
    Python 类型的变体，以便相同的类型（例如`str`）可以提供[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")的不同变体，如下所示，使用`Annotated` `str`称为`str50`将表示`String(50)`：
- en: '[PRE75]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果使用`Annotated[]`，声明式将从左手类型中提取完整的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")定义，方法是将[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构作为`Annotated[]`结构的任何参数传递（感谢[@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)对此想法的说明）。该功能可能会在未来的版本中扩展到包括[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")、[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")和其他结构，但目前仅限于[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。下面的示例除了我们的`str50`示例之外，还添加了其他`Annotated`类型，以说明此功能：
- en: '[PRE76]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，使用`Mapped[str50]`、`Mapped[intpk]`或`Mapped[user_fk]`映射的列从[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")以及`Annotated`构造中直接获取，以便重用预先建立的类型和列配置。
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选步骤 - 将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)，其中一个关键优势是我们可以构建一个严格类型化的`__init__()`方法，具有显式的位置参数、仅关键字参数和默认参数，更不用说我们还可以免费获得`__str__()`和`__repr__()`等方法。接下来的部分[作为
    ORM 模型映射的 Dataclasses 的本机支持](#whatsnew-20-dataclasses)进一步说明了上述模型的转换。
- en: Typing is supported from step 3 onwards
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从第 3 步开始支持类型注释
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述示例，从“第 3 步”开始的任何示例都将包括模型的属性是类型化的，并将传递到[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象：
- en: '[PRE77]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.  ### Using Legacy Mypy-Typed Models'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 mapped_column() 的声明性表](../orm/declarative_tables.html#orm-declarative-table)
    - 更新了声明性文档，用于声明性生成和映射[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")列。  ###
    使用传统 Mypy 类型化模型'
- en: SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to errors under the
    new system, as such annotations are flagged as errors when using constructs such
    as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Mypy 插件](../orm/extensions/mypy.html)进行 SQLAlchemy 应用程序，其中明确注释不使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")在其注释中的构造的应用程序，在新系统下会出现错误，因为这些注释在使用[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")等构造时被标记为错误。
- en: The section [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly
    typed ORM models](migration_20.html#migration-20-step-six) illustrates how to
    temporarily disable these errors from being raised for a legacy ORM model that
    uses explicit annotations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移至 2.0 步骤六 - 为显式类型的 ORM 模型添加 __allow_unmapped__](migration_20.html#migration-20-step-six)
    部分说明了如何临时禁用这些错误，以避免针对使用显式注释的传统 ORM 模型引发错误。'
- en: See also
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](migration_20.html#migration-20-step-six)  ### Native Support for Dataclasses
    Mapped as ORM Models'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移至 2.0 步骤六 - 为显式类型的 ORM 模型添加 __allow_unmapped__](migration_20.html#migration-20-step-six)  ###
    作为 ORM 模型映射的 Dataclasses 的本机支持'
- en: The new ORM Declarative features introduced above at [ORM Declarative Models](#whatsnew-20-orm-declarative-typing)
    introduced the new [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct and illustrated type-centric mapping
    with optional use of [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`.
    We can take the mapping one step further by integrating this with Python [dataclasses](https://docs.python.org/3/library/dataclasses.html).
    This new feature is made possible via [**PEP 681**](https://peps.python.org/pep-0681/)
    which allows for type checkers to recognize classes that are dataclass compatible,
    or are fully dataclasses, but were declared through alternate APIs.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 上面介绍的新ORM声明式特性在[ORM声明式模型](#whatsnew-20-orm-declarative-typing)中引入了新的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，并通过可选使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`展示了以类型为中心的映射。我们可以通过将这个与Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)集成，进一步推进映射。这个新特性是通过[**PEP
    681**](https://peps.python.org/pep-0681/)实现的，该特性允许类型检查器识别与数据类兼容或完全是数据类但是通过替代API声明的类。
- en: Using the dataclasses feature, mapped classes gain an `__init__()` method that
    supports positional arguments as well as customizable default values for optional
    keyword arguments. As mentioned previously, dataclasses also generate many useful
    methods such as `__str__()`, `__eq__()`. Dataclass serialization methods such
    as [dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)
    and [dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)
    also work, but don’t currently accommodate for self-referential structures, which
    makes them less viable for mappings that have bidirectional relationships.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类特性，映射类获得一个`__init__()`方法，支持位置参数以及可选关键字参数的可定制默认值。正如前面提到的，数据类还生成许多有用的方法，如`__str__()`，`__eq__()`。数据类的序列化方法，如[dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)和[dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)，也可以使用，但目前不支持自引用结构，这使得它们对具有双向关系的映射不太适用。
- en: SQLAlchemy’s current integration approach converts the user-defined class into
    a **real dataclass** to provide runtime functionality; the feature makes use of
    the existing dataclass feature introduced in SQLAlchemy 1.4 at [Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)
    to produce an equivalent runtime mapping with a fully integrated configuration
    style, which is also more correctly typed than was possible with the previous
    approach.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的当前集成方法将用户定义的类转换为**真正的数据类**，以提供运行时功能；该功能利用了SQLAlchemy 1.4中引入的现有数据类功能，以在完全集成的配置样式下生成等效的运行时映射，这种映射比以前的方法更正确地进行了类型标记，并且还使用了在[Python数据类，attrs支持的情况下，声明式，命令式映射](migration_14.html#change-5027)中介绍的特性。
- en: To support dataclasses in compliance with [**PEP 681**](https://peps.python.org/pep-0681/),
    ORM constructs like [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") accept additional [**PEP 681**](https://peps.python.org/pep-0681/)
    arguments `init`, `default`, and `default_factory` which are passed along to the
    dataclass creation process. These arguments currently must be present in an explicit
    directive on the right side, just as they would be used with `dataclasses.field()`;
    they currently can’t be local to an `Annotated` construct on the left side. To
    support the convenient use of `Annotated` while still supporting dataclass configuration,
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    can merge a minimal set of right-hand arguments with that of an existing [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct located on the left side within an `Annotated`
    construct, so that most of the succinctness is maintained, as will be seen below.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持符合[**PEP 681**](https://peps.python.org/pep-0681/)的数据类，ORM构造如[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")接受额外的[**PEP 681**](https://peps.python.org/pep-0681/)参数`init`、`default`和`default_factory`，这些参数被传递给数据类创建过程。这些参数目前必须存在于右侧的显式指令中，就像它们与`dataclasses.field()`一起使用时一样；它们目前不能是左侧`Annotated`构造的本地参数。为了支持方便使用`Annotated`，同时仍支持数据类配置，[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")可以将右侧参数的最小集合与位于`Annotated`构造内的现有[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造合并，以便保持大部分简洁性，正如下面将看到的那样。
- en: 'To enable dataclasses using class inheritance we make use of the [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin, either directly on each class, or on
    the `Base` class, as illustrated below where we further modify the example mapping
    from “Step 5” of [ORM Declarative Models](#whatsnew-20-orm-declarative-typing):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用使用类继承的数据类，我们利用了[`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin，可以直接在每个类上使用，也可以在`Base`类上使用，如下面的示例所示，我们进一步修改了“步骤5”的示例映射来自[ORM声明模型](#whatsnew-20-orm-declarative-typing)：
- en: '[PRE78]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The above mapping has used the `@dataclasses.dataclass` decorator directly
    on each mapped class at the same time that the declarative mapping was set up,
    internally setting up each `dataclasses.field()` directive as indicated. `User`
    / `Address` structures can be created using positional arguments as configured:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射已直接在每个映射类上使用了`@dataclasses.dataclass`装饰器，同时设置了声明性映射，内部将每个`dataclasses.field()`指令设置为所示。可以使用配置的位置参数创建`User`
    / `Address`结构：
- en: '[PRE79]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明性数据类映射](../orm/dataclasses.html#orm-declarative-native-dataclasses)'
- en: SQL Expression / Statement / Result Set Typing
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL表达式 / 语句 / 结果集类型
- en: This section provides background and examples for SQLAlchemy’s new SQL expression
    typing approach, which extends from base [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") constructs through SQL statements and
    result sets and into realm of ORM mapping.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为SQLAlchemy的新SQL表达式类型方法提供了背景和示例，该方法从基本的[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")构造扩展到SQL语句和结果集，并进入ORM映射的领域。
- en: Rationale and Overview
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原理与概述
- en: Tip
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是一个架构讨论。直接跳转到[SQL表达式类型化 - 示例](#whatsnew-20-expression-typing-examples)来查看新的类型化是什么样子的。
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) 中，SQL
    表达式被类型化为[泛型](https://peps.python.org/pep-0484/#generics)，然后引用了一个 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 对象，如 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 或 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 作为它们的泛型参数（如 `Column[Integer]`）。这本身就是与原始 Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    软件包所做的不同，其中 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    及其基础构造直接是 Python 类型的泛型，比如 `int`、`datetime` 和 `str`。希望通过 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 本身对 `int` / `datetime` / `str` 的泛型，可以维护两个信息级别，并且可以通过
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    作为中间构造从列表达式中提取 Python 类型。然而，情况并非如此，因为[**PEP 484**](https://peps.python.org/pep-0484/)
    没有足够丰富的功能集来实现这一点，缺乏诸如[高阶类型变量](https://github.com/python/typing/issues/548)之类的功能。
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 经过对当前[**PEP 484**](https://peps.python.org/pep-0484/)的能力的[深度评估](https://github.com/python/typing/discussions/999)，SQLAlchemy
    2.0 在这一领域实现了 [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs) 的原始智慧，并直接将列表达式与
    Python 类型进行了链接。这意味着，如果有 SQL 表达式到不同子类型的情况，比如 `Column(VARCHAR)` vs. `Column(Unicode)`，那么这两种
    [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    子类型的具体细节并不会随着类型一起传递，但在实践中，这通常不是问题，而且通常情况下，Python 类型是立即存在的，因为它代表了直接存储和接收该列的 Python
    数据。
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这意味着像 `Column('id', Integer)` 这样的表达式被类型化为 `Column[int]`。 这允许建立一个可行的 SQLAlchemy
    构造 -> Python 数据类型的流水线，而无需使用类型插件。 至关重要的是，它允许完全与 ORM 使用的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 构造的范式进行交互，这些构造引用了 ORM 映射的类类型（例如包含用户映射实例的 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，例如我们教程中使用的 `User` 和 `Address` 示例）。 虽然 Python 类型目前对于元组类型的定制支持非常有限（其中
    [**PEP 646**](https://peps.python.org/pep-0646/)，第一个试图处理类似元组的对象的 pep，[在其功能上有意受到了限制](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)，并且本身尚不适用于任意元组操作），但已经设计出了一种相当不错的方法，允许基本的
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    -> [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    -> [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    类型功能，包括对 ORM 类的支持，在要将 [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    对象展开为单独的列条目时，添加了一个小的面向类型的访问器，允许各个 Python 值保持与其来源的 SQL 表达式相关联的 Python 类型（翻译：它有效）。
- en: '#### SQL Expression Typing - Examples'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '#### SQL 表达式类型化 - 示例'
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 类型行为的简要介绍。 注释指示了在 [vscode](https://code.visualstudio.com/) 上悬停在代码上会看到什么（或者使用
    [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    助手时，大致会显示什么类型工具）：
- en: Simple Python Types Assigned to SQL Expressions
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的简单类型赋给 SQL 表达式
- en: '[PRE80]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造的单个 SQL 表达式，以及任何返回行的构造，包括返回行的 DML，例如 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 与 [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")，都被打包到一个 `Tuple[]` 类型中，该类型保留了每个元素的
    Python 类型。
- en: '[PRE81]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何返回行构造的`Tuple[]`类型，在调用`.execute()`方法时，传递到[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")。为了将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象解包为元组，[`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple")或[`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t")访问器本质上将[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")转换为相应的`Tuple[]`（尽管在运行时仍保持相同的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象）。
- en: '[PRE82]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单列语句的标量值通过[`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar")、[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars")等方法执行正确操作。
- en: '[PRE83]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述对于返回行构造的支持与ORM映射类一起效果最佳，因为映射类可以列出其成员的具体类型。下面的示例设置了一个类，使用了[新的类型感知语法](#whatsnew-20-orm-declarative-typing)，在下一节中描述：
- en: '[PRE84]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上述映射，属性被类型化，并且从语句一直表达到结果集：
- en: '[PRE85]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 映射类本身也是类型，并且表现方式相同，例如针对两个映射类的SELECT：
- en: '[PRE86]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在选择映射类时，像[`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")这样的构造也可以正常工作，保持原始映射类的列级属性以及语句期望的返回类型：
- en: '[PRE87]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心表目前尚无良好的方法来维护通过[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问器访问时[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的类型。
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")被设置为类的实例，并且[`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c")访问器通常通过名称动态访问[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，目前尚未为此建立类型化方法；需要一些替代语法。
- en: ORM classes, scalars, etc. work great.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM类、标量等效果很好。
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择 ORM 类作为标量或元组的典型用例都适用，无论是 2.0 还是 1.x 样式的查询，都能返回准确的类型，无论是独立的还是包含在适当的容器中，如 `Sequence[]`、`List[]`
    或 `Iterator[]`：
- en: '[PRE88]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    也获得了元组类型化。
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    的类型支持远远超出了 [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs) 或 [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    提供的范围，其中标量对象和元组类型的 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象在大多数情况下将保留结果级的类型：'
- en: '[PRE89]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: the catch - all stubs must be uninstalled
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意事项 - 必须卸载所有存根
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型支持的一个关键注意事项是 **必须卸载所有 SQLAlchemy 存根包** 才能使类型化工作。当对 Python 虚拟环境运行 [mypy](https://mypy.readthedocs.io/en/stable/)
    时，只需卸载这些包。但是，目前 SQLAlchemy 存根包也是 [typeshed](https://github.com/python/typeshed)
    的一部分，它本身被捆绑到一些类型工具中，例如 [Pylance](https://github.com/microsoft/pylance-release)，因此在某些情况下，可能需要定位这些包的文件并将其删除，以确保它们不会干扰新的类型化工作正常运行。
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 SQLAlchemy 2.0 正式发布，typeshed 将从其自己的存根源中删除 SQLAlchemy。
- en: Rationale and Overview
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原理与概述
- en: Tip
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This section is an architectural discussion. Skip ahead to [SQL Expression Typing
    - Examples](#whatsnew-20-expression-typing-examples) to just see what the new
    typing looks like.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是一个架构讨论。要快速查看新的类型，请跳转到[SQL 表达式类型化 - 示例](#whatsnew-20-expression-typing-examples)。
- en: In [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs), SQL
    expressions were typed as [generics](https://peps.python.org/pep-0484/#generics)
    that then referred to a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") as their generic argument (such as `Column[Integer]`).
    This was itself a departure from what the original Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    package did, where [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    and its foundational constructs were directly generic on Python types, such as
    `int`, `datetime` and `str`. It was hoped that since [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") themselves are generic against `int` / `datetime` /
    `str`, there would be ways to maintain both levels of information and to be able
    to extract the Python type from a column expression via the [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") as an intermediary construct. However, this is
    not the case, as [**PEP 484**](https://peps.python.org/pep-0484/) doesn’t really
    have a rich enough feature set for this to be viable, lacking capabilities such
    as [higher kinded TypeVars](https://github.com/python/typing/issues/548).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) 中，SQL
    表达式被类型化为 [泛型](https://peps.python.org/pep-0484/#generics)，然后引用了 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 对象，例如 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 或 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 作为它们的泛型参数（如 `Column[Integer]`）。这本身是对原始 Dropbox [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    包的偏离，其中 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    及其基本构造直接泛型化为 Python 类型，如 `int`、`datetime` 和 `str`。希望 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") / [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") / [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 本身是对 `int` / `datetime` / `str` 泛型化的，就有可能保持两个层次的信息并能够通过
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    作为中介构造从列表达式中提取 Python 类型。然而，事实并非如此，因为 [**PEP 484**](https://peps.python.org/pep-0484/)
    实际上没有足够丰富的功能集使得这成为可行的，缺乏诸如 [更高种类的类型变量](https://github.com/python/typing/issues/548)
    等能力。
- en: So after a [deep assessment](https://github.com/python/typing/discussions/999)
    of the current capabilities of [**PEP 484**](https://peps.python.org/pep-0484/),
    SQLAlchemy 2.0 has realized the original wisdom of [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    in this area and returned to linking column expressions directly to Python types.
    This does mean that if one has SQL expressions to different subtypes, like `Column(VARCHAR)`
    vs. `Column(Unicode)`, the specifics of those two [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") subtypes is not carried along as the type only carries
    along `str`, but in practice this is usually not an issue and it is generally
    vastly more useful that the Python type is immediately present, as it represents
    the in-Python data one will be storing and receiving for this column directly.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 经过对当前 [深度评估](https://github.com/python/typing/discussions/999)，SQLAlchemy 2.0
    在这一领域实现了 [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs) 的原始智慧，并直接将列表达式与
    Python 类型关联起来。这意味着如果有 SQL 表达式到不同子类型的情况，比如 `Column(VARCHAR)` 和 `Column(Unicode)`，那么这两个
    [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    子类型的具体细节并不会随着类型一起传递，但实际上这通常不是问题，通常更有用的是 Python 类型立即出现，因为它代表了直接存储和接收此列的 Python
    数据。
- en: 'Concretely, this means that an expression like `Column(''id'', Integer)` is
    typed as `Column[int]`. This allows for a viable pipeline of SQLAlchemy construct
    -> Python datatype to be set up, without the need for typing plugins. Crucially,
    it allows full interoperability with the ORM’s paradigm of using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") constructs that reference ORM mapped class types (e.g.
    a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    containing instances of user-mapped instances, such as the `User` and `Address`
    examples used in our tutorials). While Python typing currently has very limited
    support for customization of tuple-types (where [**PEP 646**](https://peps.python.org/pep-0646/),
    the first pep that attempts to deal with tuple-like objects, was [intentionally
    limited in its functionality](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)
    and by itself is not yet viable for arbitrary tuple manipulation), a fairly decent
    approach has been devised that allows for basic [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") -> [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") -> [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") typing to function, including for ORM classes, where
    at the point at which a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object is to be unpacked into individual column entries,
    a small typing-oriented accessor is added that allows the individual Python values
    to maintain the Python type linked to the SQL expression from which they originated
    (translation: it works).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这意味着像 `Column('id', Integer)` 这样的表达式被类型化为 `Column[int]`。这允许建立一个可行的 SQLAlchemy
    构造 -> Python 数据类型的管道，而无需使用类型插件。至关重要的是，它允许完全与 ORM 的范式进行互操作，即使用引用 ORM 映射类类型的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 构造（例如包含用户映射实例的 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，例如我们教程中使用的 `User` 和 `Address` 示例）。虽然 Python 类型当前对元组类型的自定义支持非常有限（其中
    [**PEP 646**](https://peps.python.org/pep-0646/) 是第一个试图处理类似元组对象的 pep，但[其功能故意受到限制](https://mail.python.org/archives/list/typing-sig@python.org/message/G2PNHRR32JMFD3JR7ACA2NDKWTDSEPUG/)，本身尚不适用于任意元组操作），但已经设计出了一个相当不错的方法，允许基本的
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    -> [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    -> [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    类型功能运行，包括对 ORM 类的支持，在将 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象拆包为单独的列条目时，添加了一个小的面向类型的访问器，以便使得每个 Python 值都能保持与其来源的
    SQL 表达式关联的 Python 类型（翻译：它可以正常工作）。
- en: '#### SQL Expression Typing - Examples'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '#### SQL 表达式类型 - 示例'
- en: 'A brief tour of typing behaviors. Comments indicate what one would see hovering
    over the code in [vscode](https://code.visualstudio.com/) (or roughly what typing
    tools would display when using the [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    helper):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 对类型行为的简要介绍。注释指示了在 [vscode](https://code.visualstudio.com/) 中悬停在代码上会看到什么（或者在使用
    [reveal_type()](https://mypy.readthedocs.io/en/latest/common_issues.html?highlight=reveal_type#reveal-type)
    助手时大致会显示什么类型工具）：
- en: Simple Python Types Assigned to SQL Expressions
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单的 Python 类型分配给 SQL 表达式
- en: '[PRE90]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Individual SQL expressions assigned to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs, as well as any row-returning construct,
    including row-returning DML such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") with [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), are packed into a `Tuple[]` type
    which retains the Python type for each element.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分配给 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造的各个 SQL 表达式，以及任何返回行的构造，包括返回行的 DML，如 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 与 [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")，都打包成一个 `Tuple[]` 类型，其中保留了每个元素的 Python
    类型。
- en: '[PRE91]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `Tuple[]` type from any row returning construct, when invoked with an `.execute()`
    method, carries through to [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). In order to unpack the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object as a tuple, the [`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") or [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") accessor essentially casts the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") into the corresponding `Tuple[]` (though remains the
    same [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object at runtime).
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何行返回结构的 `Tuple[]` 类型，在调用 `.execute()` 方法时，都会传递到 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")。为了将 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象解包为元组，[`Row.tuple()`](../core/connections.html#sqlalchemy.engine.Row.tuple
    "sqlalchemy.engine.Row.tuple") 或 [`Row.t`](../core/connections.html#sqlalchemy.engine.Row.t
    "sqlalchemy.engine.Row.t") 访问器实质上将 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 强制转换为相应的 `Tuple[]`（尽管在运行时仍然是相同的 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象）。
- en: '[PRE92]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Scalar values for single-column statements do the right thing with methods like
    [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar"), [`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars"), etc.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单列语句的标量值通过诸如 [`Connection.scalar()`](../core/connections.html#sqlalchemy.engine.Connection.scalar
    "sqlalchemy.engine.Connection.scalar")、[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") 等方法执行正确操作。
- en: '[PRE93]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The above support for row-returning constructs works the best with ORM mapped
    classes, as a mapped class can list out specific types for its members. The example
    below sets up a class using [new type-aware syntaxes](#whatsnew-20-orm-declarative-typing),
    described in the following section:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述对行返回结构的支持最适用于 ORM 映射类，因为映射类可以为其成员列出特定类型。下面的示例设置了一个类，使用了[新的类型感知语法](#whatsnew-20-orm-declarative-typing)，在下一节中描述：
- en: '[PRE94]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'With the above mapping, the attributes are typed and express themselves all
    the way from statement to result set:'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上述映射，属性被类型化，并且从语句一直表达到结果集：
- en: '[PRE95]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Mapped classes themselves are also types, and behave the same way, such as
    a SELECT against two mapped classes:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 映射类本身也是类型，并且行为相同，例如对两个映射类进行 SELECT：
- en: '[PRE96]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When selecting mapped classes, constructs like [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased") work as well, maintaining the column-level attributes
    of the original mapped class as well as the return type expected from a statement:'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当选择映射类时，像 [`aliased`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    这样的结构也可以正常工作，同时保持原始映射类的列级属性以及语句期望的返回类型：
- en: '[PRE97]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Core Table does not yet have a decent way to maintain typing of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects when accessing them via the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Core Table` 目前尚无一个合适的方式来在通过 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") 访问时维护 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的类型。'
- en: Since [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    is set up as an instance of a class, and the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") accessor typically accesses [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects dynamically by name, there’s not yet an established
    typing approach for this; some alternative syntax would be needed.
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '由于 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    被设置为类的一个实例，并且 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c "sqlalchemy.schema.Table.c")
    访问器通常通过名称动态访问 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象，目前尚无一种确定的类型化方法；需要一些替代语法。 '
- en: ORM classes, scalars, etc. work great.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM 类、标量等都能很好地工作。
- en: 'The typical use case of selecting ORM classes, as scalars or tuples, all works,
    both 2.0 and 1.x style queries, getting back the exact type either by itself or
    contained within the appropriate container such as `Sequence[]`, `List[]` or `Iterator[]`:'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择ORM类的典型用例，作为标量或元组，都可以正常工作，无论是2.0还是1.x风格的查询，都可以得到确切的类型，无论是单独的还是包含在适当容器中，如`Sequence[]`，`List[]`或`Iterator[]`：
- en: '[PRE98]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    gains tuple typing as well.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")也获得了元组类型支持。
- en: 'The typing support for [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") goes well beyond what [sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)
    or [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs) offered,
    where both scalar-object as well as tuple-typed [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects will retain result level typing for most cases:'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的类型支持远远超出了[sqlalchemy-stubs](https://github.com/dropbox/sqlalchemy-stubs)或[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)提供的范围，其中标量对象以及元组类型的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将保留大多数情况下的结果级别类型：
- en: '[PRE99]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: the catch - all stubs must be uninstalled
  id: totrans-509
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点是 - 必须卸载所有存根
- en: A key caveat with the typing support is that **all SQLAlchemy stubs packages
    must be uninstalled** for typing to work. When running [mypy](https://mypy.readthedocs.io/en/stable/)
    against a Python virtualenv, this is only a matter of uninstalling those packages.
    However, a SQLAlchemy stubs package is also currently part of [typeshed](https://github.com/python/typeshed),
    which itself is bundled into some typing tools such as [Pylance](https://github.com/microsoft/pylance-release),
    so it may be necessary in some cases to locate the files for these packages and
    delete them, if they are in fact interfering with the new typing working correctly.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型支持相关的一个关键注意事项是**必须卸载所有SQLAlchemy存根包**才能使类型工作。当针对Python虚拟环境运行[mypy](https://mypy.readthedocs.io/en/stable/)时，只需卸载这些包。然而，SQLAlchemy存根包目前也是[typeshed](https://github.com/python/typeshed)的一部分，它本身被捆绑到一些类型工具中，如[Pylance](https://github.com/microsoft/pylance-release)，因此在某些情况下可能需要定位这些包的文件并删除它们，以确保新的类型正确工作。
- en: Once SQLAlchemy 2.0 is released in final status, typeshed will remove SQLAlchemy
    from its own stubs source.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦SQLAlchemy 2.0发布为最终状态，typeshed将从其自己的存根源中删除SQLAlchemy。
- en: '### ORM Declarative Models'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM声明性模型'
- en: SQLAlchemy 1.4 introduced the first SQLAlchemy-native ORM typing support using
    a combination of [sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)
    and the [Mypy Plugin](../orm/extensions/mypy.html). In SQLAlchemy 2.0, the Mypy
    plugin **remains available, and has been updated to work with SQLAlchemy 2.0’s
    typing system**. However, it should now be considered **deprecated**, as applications
    now have a straightforward path to adopting the new typing support that does not
    use plugins or stubs.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4引入了第一个使用[sqlalchemy2-stubs](https://github.com/sqlalchemy/sqlalchemy2-stubs)和[Mypy插件](../orm/extensions/mypy.html)的SQLAlchemy本机ORM类型支持。在SQLAlchemy
    2.0中，Mypy插件**仍然可用，并已更新以与SQLAlchemy 2.0的类型系统配合使用**。然而，现在应该将其视为**已弃用**，因为应用程序现在有一条直接的路径来采用新的类型支持，而不使用插件或存根。
- en: Overview
  id: totrans-514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概述
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统的基本方法是，当使用完全[声明式](../orm/declarative_tables.html#orm-declarative-table)模型（即不使用[混合声明式](../orm/declarative_tables.html#orm-imperative-table-configuration)或[命令式](../orm/mapping_styles.html#orm-imperative-mapping)配置，这些配置不变）时，映射的列声明首先通过检查每个属性声明左侧的类型注解（如果存在）在运行时派生。期望左手类型注释包含在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类型中，否则不认为该属性是映射属性。然后，属性声明可以引用右侧的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，该构造用于提供关于要生成和映射的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的附加核心级模式信息。如果左侧存在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注解，则此右侧声明是可选的；如果左侧没有注解，则[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")可以作为[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")指令的精确替换使用，在这种情况下，它将为属性提供更准确（但不是精确）的类型行为，即使没有注解存在也是如此。
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法受到了 Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    的启发，它从左边开始注释，然后允许在右边进行可选的`dataclasses.field()`规范；与 dataclasses 方法的主要区别在于 SQLAlchemy
    的方法是严格的**选择加入**，其中使用 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的现有映射而没有任何类型注释的映射将继续像以往一样工作，而 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造可以直接替换为 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 而不需要任何显式的类型注释。只有在需要存在确切的属性级 Python 类型时，才需要使用 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的显式注释。这些注释可以根据需要，按属性基础在那些有用的特定类型的属性上使用；使用 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 的未注释的属性将在实例级别上被类型为`Any`。
- en: '#### Migrating an Existing Mapping'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 迁移现有映射'
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 转向新的 ORM 方法开始时更加冗长，但随着可用的新功能的充分利用，它变得比以前更加简洁。以下步骤详细介绍了一个典型的转换，然后继续说明了一些更多的选项。
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一步 - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")被[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")所取代。
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 类型中观察到的一个限制是似乎没有能力从一个函数动态生成一个类，然后被类型工具理解为新类的基础。为了解决这个问题而不使用插件，通常调用[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")可以被替换为使用[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类，它产生与通常相同的`Base`对象，只是类型工具理解它：
- en: '[PRE100]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二步 - 使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的声明性使用。
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")是一个ORM类型感知构造，可以直接替换为[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的使用。给定一个1.x风格的映射如下：'
- en: '[PRE101]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")；不需要更改任何参数：
- en: '[PRE102]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的各个列**尚未使用Python类型进行类型化**，而是被类型化为`Mapped[Any]`；这是因为我们可以声明任何列为`Optional`或非`Optional`，并且没有办法在不引起类型错误的情况下进行“猜测”。
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这一步，我们上面的映射已经为所有属性设置了适当的[描述符](../glossary.html#term-descriptor)类型，并且可以用于查询以及实例级别的操作，所有这些都将**通过mypy的--strict模式**而无需插件。
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三步 - 根据需要使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")应用精确的Python类型。
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于所有需要精确类型的属性；可以跳过那些可以保留为`Any`的属性。为了上下文，我们还演示了在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")中应用精确类型时使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")。在这个中间步骤中，映射会更加冗长，但是通过熟练掌握，这一步可以与后续步骤结合起来更直接地更新映射：
- en: '[PRE103]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的ORM映射已经完全类型化，并将生成精确类型的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")构造。现在我们可以继续简化映射声明中的冗余部分。
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第四步 - 删除不再需要的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `nullable` 参数都可以使用 `Optional[]` 隐含; 在没有 `Optional[]` 的情况下，`nullable` 默认为
    `False`。所有没有参数的 SQL 类型，如 `Integer` 和 `String`，可以单独用 Python 注释表示。一个没有参数的 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 指令可以完全移除。[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 现在从左手注释派生其类，支持正向引用（因为 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 已经支持基于字符串的正向引用十年了 ;) ）：
- en: '[PRE104]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第五步 - 利用 pep-593 `Annotated` 将常见指令打包成类型
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全新的功能，提供了一种替代或补充的方法，作为[声明性混入](../orm/declarative_mixins.html)的一种方式，以提供面向类型的配置，并且在大多数情况下取代了
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    装饰函数的需要。
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Declarative 映射允许将 Python 类型映射到 SQL 类型，例如将 `str` 映射到 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，通过使用 [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 进行自定义。使用 [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` 允许我们创建特定 Python 类型的变体，以便可以使用相同的类型，如 `str`，每个都提供 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") ���变体，如下所示，使用 `Annotated` `str`，称为 `str50` 将指示 `String(50)`：
- en: '[PRE105]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果使用 `Annotated[]`，Declarative 将从左手类型中提取完整的 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 定义，通过将任何参数传递给 `Annotated[]` 构造 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造（感谢 [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    展示这个想法）。这种能力可能在未来的版本中扩展到包括 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")、[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 和其他构造，但目前仅限于 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。下面的示例除了我们的 `str50` 示例外，还添加了额外的 `Annotated` 类型，以说明这个特性：
- en: '[PRE106]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，使用`Mapped[str50]`、`Mapped[intpk]`或`Mapped[user_fk]`映射的列直接从[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")以及`Annotated`构造中绘制，以便重新使用预先建立的类型和列配置。
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选步骤 - 将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)，其中一个关键优势是我们可以构建一个严格类型的`__init__()`方法，具有显式的位置、关键字参数和默认参数，更不用说我们还可以免费获取`__str__()`和`__repr__()`等方法。下一节[作为
    ORM 模型映射的 dataclasses 的本机支持](#whatsnew-20-dataclasses)进一步说明了上述模型的转换。 '
- en: Typing is supported from step 3 onwards
  id: totrans-545
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从第 3 步开始支持键入。
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上面的示例，从“第 3 步”开始的任何示例都将包括模型属性的类型，并将传播到[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象：
- en: '[PRE107]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: See also
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 mapped_column() 的声明性表](../orm/declarative_tables.html#orm-declarative-table)
    - 更新了声明性文档以声明性生成和映射 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    列。'
- en: Overview
  id: totrans-550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概述
- en: The fundamental approach for the new system is that mapped column declarations,
    when using a fully [Declarative](../orm/declarative_tables.html#orm-declarative-table)
    model (that is, not [hybrid declarative](../orm/declarative_tables.html#orm-imperative-table-configuration)
    or [imperative](../orm/mapping_styles.html#orm-imperative-mapping) configurations,
    which are unchanged), are first derived at runtime by inspecting the type annotation
    on the left side of each attribute declaration, if present. Left hand type annotations
    are expected to be contained within the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") generic type, otherwise the attribute is not considered
    to be a mapped attribute. The attribute declaration may then refer to the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct on the right hand side, which is used
    to provide additional Core-level schema information about the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to be produced and mapped. This right hand side declaration
    is optional if a [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    annotation is present on the left side; if no annotation is present on the left
    side, then the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") may be used as an exact replacement for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") directive where it will provide for more accurate
    (but not exact) typing behavior of the attribute, even though no annotation is
    present.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统的基本方法是，当使用完全[声明式](../orm/declarative_tables.html#orm-declarative-table)模型（即不使用[混合声明式](../orm/declarative_tables.html#orm-imperative-table-configuration)或[命令式](../orm/mapping_styles.html#orm-imperative-mapping)配置，这些配置不变）时，映射列声明首先在运行时通过检查每个属性声明左侧的类型注释来推导，如果存在的话。左手类型注释应该包含在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")泛型类型中，否则该属性不被视为映射属性。然后属性声明可以引用右侧的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，用于提供有关要生成和映射的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的附加核心级模式信息。如果左侧存在[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释，则此右侧声明是可选的；如果左侧没有注释，则[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")可以用作[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")指令的精确替代，其中它将提供更准确（但不精确）的属性类型行为，即使没有注释存在。
- en: The approach is inspired by the approach of Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    which starts with an annotation on the left, then allows for an optional `dataclasses.field()`
    specification on the right; the key difference from the dataclasses approach is
    that SQLAlchemy’s approach is strictly **opt-in**, where existing mappings that
    use [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any type annotations continue to work as they always have, and the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct may be used as a direct replacement
    for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    without any explicit type annotations. Only for exact attribute-level Python types
    to be present is the use of explicit annotations with [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") required. These annotations may be used on an as-needed,
    per-attribute basis for those attributes where specific types are helpful; non-annotated
    attributes that use [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be typed as `Any` at the instance level.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法受到了Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)方法的启发，它从左边的注解开始，然后允许在右边进行可选的`dataclasses.field()`规范；与dataclasses方法的主要区别在于SQLAlchemy方法是严格的**选择性**，其中使用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的现有映射不带任何类型注释仍然像以往一样工作，并且[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造可以直接替换[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")而不需要任何显式的类型注释。只有在确切的属性级Python类型存在时，才需要使用具有[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的显式注释。这些注释可以根据需要在每个属性的基础上使用，对于那些特定类型有帮助的属性；使用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")的未注释属性将在实例级别被标记为`Any`。
- en: '#### Migrating an Existing Mapping'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 迁移现有映射'
- en: Transitioning to the new ORM approach begins as more verbose, but becomes more
    succinct than was previously possible as the available new features are used fully.
    The following steps detail a typical transition and then continue on to illustrate
    some more options.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到新的ORM方法开始时可能更加冗长，但随着可用的新功能的充分利用，它变得比以前更加简洁。以下步骤详细说明了一个典型的过渡，然后继续说明了一些更多的选项。
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一步 - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")被[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")所取代。
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python类型中观察到的一个限制是似乎没有能力从一个函数中动态生成一个类，然后让类型工具将其理解为新类的基类。为了解决这个问题而不使用插件，通常对[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")的调用可以被替换为使用[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类，它生成与通常相同的`Base`对象，只是类型工具理解它：
- en: '[PRE108]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二步 - 将[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")的声明性使用替换为[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")是一个
    ORM 类型感知的构造，可以直接替换为 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的使用。给定一个 1.x 风格的映射，如下所示：'
- en: '[PRE109]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")替换了[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")；不需要更改任何参数：
- en: '[PRE110]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 上述各列目前**尚未使用 Python 类型进行类型化**，而是以`Mapped[Any]`类型进行类型化；这是因为我们可以声明任何列是否为`Optional`，而且在明确类型时不可能有“猜测”，否则会在明确类型时导致类型错误。
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这一步骤中，我们上述的映射已经为所有属性设置了适当的[描述符](../glossary.html#term-descriptor)类型，并且可以用于查询以及实例级别的操作，所有这些操作都可以在不使用插件的情况下**通过
    mypy –strict 模式**。
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三步 - 根据需要使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")应用精确的
    Python 类型。
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要精确类型的属性都可以进行此操作；可以略过那些可以保持`Any`的属性。为了上下文，我们还演示了在其中应用精确类型的情况下使用[`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的情况，用于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。在这个临时步骤中的映射会更加冗长，但是熟练掌握后，这一步可以与后续步骤结合起来直接更新映射：
- en: '[PRE111]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的 ORM 映射已经完全类型化，并将生成精确类型的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 构造。现在我们可以继续简化映射声明中的冗余部分。
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第四步 - 移除不再需要的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令。
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`nullable`参数都可以使用`Optional[]`来隐含表示；在没有`Optional[]`的情况下，`nullable`默认为`False`。所有没有参数的SQL类型，如`Integer`和`String`，都可以单独用Python注释来表示。一个不带参数的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令可以完全删除。[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")现在会从左手注释派生其类，支持正向引用（正如[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")已经支持字符串型正向引用十年一样；）：
- en: '[PRE112]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第五步 - 利用pep-593 `Annotated`将常见指令打包成类型
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个激进的新功能，提供了一个替代方案，或者说是补充性方法，用于提供类型定向配置，还可以在大多数情况下替代[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")修饰的函数的需求。
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Declarative映射允许将Python类型映射到SQL类型，例如`str`到[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")的自定义，使用[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")。使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`允许我们创建特定Python类型的变体，以便使用相同的类型，例如`str`，为其提供[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")的变体，如下所示，使用`Annotated` `str`称为`str50`将指示`String(50)`：
- en: '[PRE113]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果使用`Annotated[]`，Declarative将从左侧类型中提取完整的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")定义，通过将[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造传递给`Annotated[]`构造（感谢[@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)说明了这个想法）。此功能可能在将来的版本中扩展到还包括[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")、[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")和其他构造，但目前仅限于[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。下面的示例除了我们的`str50`示例之外，还添加了其他额外的`Annotated`类型，以说明此功能：
- en: '[PRE114]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，使用`Mapped[str50]`、`Mapped[intpk]`或`Mapped[user_fk]`映射的列直接从[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")和`Annotated`构造中汲取，以便重新使用预先建立的类型和列配置。
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选步骤 - 将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将映射类转换为[dataclasses](https://docs.python.org/3/library/dataclasses.html)，其中一个关键优势是我们可以构建一个严格类型化的`__init__()`方法，具有显式位置参数、仅关键字参数和默认参数，更不用说我们免费获取了`__str__()`和`__repr__()`等方法。
    下一节 [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    进一步说明了上述模型的转换。
- en: Typing is supported from step 3 onwards
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从第 3 步开始支持类型注解
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 配上上述示例，从“步骤 3”开始的任何示例都会包括模型的属性类型，并将通过[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象进行填充：
- en: '[PRE115]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: See also
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用mapped_column()声明式表](../orm/declarative_tables.html#orm-declarative-table)
    - 更新了声明式文档以声明式生成和映射[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")列。'
- en: Step one - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") is superseded by [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase").
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一步 - [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")已被[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")取代。
- en: 'One observed limitation in Python typing is that there seems to be no ability
    to have a class dynamically generated from a function which then is understood
    by typing tools as a base for new classes. To solve this problem without plugins,
    the usual call to [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") can be replaced with using the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class, which produces the same `Base` object
    as usual, except that typing tools understand it:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python类型注解中观察到的一个限制是似乎没有能力从函数中动态生成类，然后将其理解为新类的基础的功能。 要解决此问题而不使用插件，通常调用[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")的方法可以替换为使用[`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")类，该类产生与通常相同的`Base`对象，只是类型工具将其理解为：
- en: '[PRE116]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Step two - replace Declarative use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二步 - 将[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")的声明式用法替换为[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")
- en: 'The [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is an ORM-typing aware construct that can be swapped
    directly for the use of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). Given a 1.x style mapping as:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    是一个 ORM 类型感知的构造，可以直接替换为 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的使用。在 1.x 风格的映射中如下所示：'
- en: '[PRE117]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We replace [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"); no arguments need to change:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 替换了 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")；不需要更改任何参数：
- en: '[PRE118]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The individual columns above are **not yet typed with Python types**, and are
    instead typed as `Mapped[Any]`; this is because we can declare any column either
    with `Optional` or not, and there’s no way to have a “guess” in place that won’t
    cause typing errors when we type it explicitly.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 上述各列目前**尚未使用 Python 类型进行类型化**，而是被类型化为 `Mapped[Any]`；这是因为我们可以声明任何列是可选的或不可选的，而且在我们显式类型化时，没有办法有一个“猜测”的方式不会在类型化时导致类型错误。
- en: However, at this step, our above mapping has appropriate [descriptor](../glossary.html#term-descriptor)
    types set up for all attributes and may be used in queries as well as for instance-level
    manipulation, all of which will **pass mypy –strict mode** with no plugins.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此步骤中，我们上述的映射已经为所有属性设置了适当的 [描述符](../glossary.html#term-descriptor) 类型，并且可以在查询中使用以及进行实例级别的操作，所有这些操作都将**在不使用插件的情况下通过
    mypy –strict 模式**。
- en: Step three - apply exact Python types as needed using [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped").
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤三 - 使用 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    需要的精确 Python 类型。
- en: 'This can be done for all attributes for which exact typing is desired; attributes
    that are fine being left as `Any` may be skipped. For context we also illustrate
    [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    being used for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") where we apply an exact type. The mapping within
    this interim step will be more verbose, however with proficiency, this step can
    be combined with subsequent steps to update mappings more directly:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望精确类型化的所有属性，都可以执行此操作；对于希望保留为 `Any` 的属性可以跳过。为了提供背景信息，我们还展示了将 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 用于 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的情况，我们在此应用了精确类型。在此过渡阶段内的映射将更为冗长，但是随着熟练程度的提高，可以将此步骤与后续步骤结合起来更直接地更新映射：
- en: '[PRE119]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: At this point, our ORM mapping is fully typed and will produce exact-typed [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") constructs. We now can proceed to pare down redundancy
    in the mapping declaration.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的 ORM 映射已完全类型化，并将生成精确类型化的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 和 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 构造。现在我们可以开始减少映射声明中的冗余。
- en: Step four - remove [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") directives where no longer needed
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 步骤四 - 移除不再需要的 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 指令。
- en: 'All `nullable` parameters can be implied using `Optional[]`; in the absence
    of `Optional[]`, `nullable` defaults to `False`. All SQL types without arguments
    such as `Integer` and `String` can be expressed as a Python annotation alone.
    A [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with no parameters can be removed entirely. [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") now derives its class from the left hand annotation,
    supporting forward references as well (as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") has supported string-based forward references for
    ten years already ;) ):'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`nullable`参数都可以使用`Optional[]`来隐含；在没有`Optional[]`的情况下，`nullable`默认为`False`。所有没有参数的SQL类型，如`Integer`和`String`，可以仅用Python注释表示。没有参数的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令可以完全删除。[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")现在从左侧注释派生其类，还支持前向引用（就像[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")已经支持基于字符串的前向引用十年一样 ;)）：
- en: '[PRE120]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Step five - make use of pep-593 `Annotated` to package common directives into
    types
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第五步 - 利用pep-593的`Annotated`将常见指令打包成类型
- en: This is a radical new capability that presents an alternative, or complementary
    approach, to [declarative mixins](../orm/declarative_mixins.html) as a means to
    provide type oriented configuration, and also replaces the need for [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") decorated functions in most cases.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全新的功能，提供了一种替代或补充方法，作为提供面向类型的配置的手段，也替代了大多数情况下对[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰函数的需求。
- en: 'First, the Declarative mapping allows the mapping of Python type to SQL type,
    such as `str` to [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String"),
    to be customized using [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` allows us to create variants of a particular Python type so that the
    same type, such as `str`, may be used which each provide variants of [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), as below where use of an `Annotated` `str` called
    `str50` will indicate `String(50)`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Declarative映射允许将Python类型映射到SQL类型，例如将`str`定制为[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，使用[`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")进行自定义。使用[**PEP 593**](https://peps.python.org/pep-0593/)的`Annotated`允许我们创建特定Python类型的变体，以便可以使用相同的类型，例如`str`，每个都提供[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")的变体，如下所示，使用`Annotated` `str`称为`str50`将指示`String(50)`：
- en: '[PRE121]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Second, Declarative will extract full [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") definitions from the left hand type if `Annotated[]`
    is used, by passing a [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct as any argument to the `Annotated[]`
    construct (credit to [@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)
    for illustrating this idea). This capability may be extended in future releases
    to also include [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") and other constructs, but currently is limited to
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
    The example below adds additional `Annotated` types in addition to our `str50`
    example to illustrate this feature:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果使用`Annotated[]`，Declarative将从左侧类型中提取完整的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")定义，方法是将[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造作为任何参数传递给`Annotated[]`构造（感谢[@adriangb01](https://twitter.com/adriangb01/status/1532841383647657988)提出这个想法）。未来的版本可能会扩展此功能，以包括[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")、[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")和其他构造，但目前仅限于[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。下面的示例除了我们的`str50`示例外，还添加了额外的`Annotated`类型，以说明此功能：
- en: '[PRE122]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Above, columns that are mapped with `Mapped[str50]`, `Mapped[intpk]`, or `Mapped[user_fk]`
    draw from both the [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") as well as the `Annotated` construct directly in order
    to re-use pre-established typing and column configurations.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，使用 `Mapped[str50]`、`Mapped[intpk]` 或 `Mapped[user_fk]` 映射的列会直接从 [`registry.type_annotation_map`](../orm/mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 和 `Annotated` 结构中获取，以便重新使用预先建立的类型化和列配置。
- en: Optional step - turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html)
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选步骤 - 将映射类转换为 [数据类](https://docs.python.org/3/library/dataclasses.html)
- en: We can turn mapped classes into [dataclasses](https://docs.python.org/3/library/dataclasses.html),
    where a key advantage is that we can build a strictly-typed `__init__()` method
    with explicit positional, keyword only, and default arguments, not to mention
    we get methods such as `__str__()` and `__repr__()` for free. The next section
    [Native Support for Dataclasses Mapped as ORM Models](#whatsnew-20-dataclasses)
    illustrates further transformation of the above model.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将映射类转换为 [数据类](https://docs.python.org/3/library/dataclasses.html)，其中一个关键优势是，我们可以构建一个严格类型化的
    `__init__()` 方法，具有显式的位置、关键字和默认参数，更不用说我们可以免费获得 `__str__()` 和 `__repr__()` 等方法了。下一节
    [数据类作为 ORM 模型的本地支持](#whatsnew-20-dataclasses) 进一步说明了以上模型的转换。 '
- en: Typing is supported from step 3 onwards
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从第三步开始支持类型化
- en: 'With the above examples, any example from “step 3” on forward will include
    that the attributes of the model are typed and will populate through to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上示例，从“第三步”开始的任何示例都将包括模型属性是经过类型化的，并将通过到 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象：
- en: '[PRE123]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: See also
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)
    - Updated Declarative documentation for Declarative generation and mapping of
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    columns.'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 mapped_column() 的声明式表](../orm/declarative_tables.html#orm-declarative-table)
    - 更新了声明式文档以声明性生成和映射 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    列。'
- en: '### Using Legacy Mypy-Typed Models'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用传统 Mypy 类型化模型'
- en: SQLAlchemy applications that use the [Mypy plugin](../orm/extensions/mypy.html)
    with explicit annotations that don’t use [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") in their annotations are subject to errors under the
    new system, as such annotations are flagged as errors when using constructs such
    as [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Mypy 插件](../orm/extensions/mypy.html) 的 SQLAlchemy 应用，在显式注释中不使用 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 的情况下，会在新系统下产生错误，因为这样的注释在使用 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 等结构时被标记为错误。
- en: The section [Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly
    typed ORM models](migration_20.html#migration-20-step-six) illustrates how to
    temporarily disable these errors from being raised for a legacy ORM model that
    uses explicit annotations.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 章节 [2.0 迁移第六步 - 向显式类型化的 ORM 模型添加 __allow_unmapped__](migration_20.html#migration-20-step-six)
    说明了如何临时禁用对使用显式注释的遗留 ORM 模型引发的错误。
- en: See also
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Migration to 2.0 Step Six - Add __allow_unmapped__ to explicitly typed ORM
    models](migration_20.html#migration-20-step-six)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.0 迁移第六步 - 向显式类型化的 ORM 模型添加 __allow_unmapped__](migration_20.html#migration-20-step-six)'
- en: '### Native Support for Dataclasses Mapped as ORM Models'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '### 数据类作为 ORM 模型的本地支持'
- en: The new ORM Declarative features introduced above at [ORM Declarative Models](#whatsnew-20-orm-declarative-typing)
    introduced the new [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct and illustrated type-centric mapping
    with optional use of [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`.
    We can take the mapping one step further by integrating this with Python [dataclasses](https://docs.python.org/3/library/dataclasses.html).
    This new feature is made possible via [**PEP 681**](https://peps.python.org/pep-0681/)
    which allows for type checkers to recognize classes that are dataclass compatible,
    or are fully dataclasses, but were declared through alternate APIs.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 上面介绍的新的ORM声明性特性在[ORM声明模型](#whatsnew-20-orm-declarative-typing)中引入了新的[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，并且演示了以类型为中心的映射，可选地使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`。我们可以通过将其与Python的[dataclasses](https://docs.python.org/3/library/dataclasses.html)集成，进一步推进映射。这个新特性通过[**PEP
    681**](https://peps.python.org/pep-0681/)实现，允许类型检查器识别符合数据类兼容性的类，或者是完全数据类，但是通过替代API声明的类。
- en: Using the dataclasses feature, mapped classes gain an `__init__()` method that
    supports positional arguments as well as customizable default values for optional
    keyword arguments. As mentioned previously, dataclasses also generate many useful
    methods such as `__str__()`, `__eq__()`. Dataclass serialization methods such
    as [dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)
    and [dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)
    also work, but don’t currently accommodate for self-referential structures, which
    makes them less viable for mappings that have bidirectional relationships.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类特性，映射类获得了一个支持位置参数以及可选关键字参数的可定制默认值的`__init__()`方法。正如之前提到的，数据类还生成许多有用的方法，如`__str__()`，`__eq__()`。数据类序列化方法，如[dataclasses.asdict()](https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict)和[dataclasses.astuple()](https://docs.python.org/3/library/dataclasses.html#dataclasses.astuple)也可以使用，但目前不支持自引用结构，这使得它们对于具有双向关系的映射不太可行。
- en: SQLAlchemy’s current integration approach converts the user-defined class into
    a **real dataclass** to provide runtime functionality; the feature makes use of
    the existing dataclass feature introduced in SQLAlchemy 1.4 at [Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings](migration_14.html#change-5027)
    to produce an equivalent runtime mapping with a fully integrated configuration
    style, which is also more correctly typed than was possible with the previous
    approach.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy当前的集成方法将用户定义的类转换为**真实数据类**以提供运行时功能；该特性利用了SQLAlchemy 1.4中引入的现有数据类功能，在[Python数据类，支持attrs
    w/声明性，命令式映射](migration_14.html#change-5027)中介绍了一个等效的运行时映射，具有完全集成的配置样式，这样做比以前的方法更正确地类型化。
- en: To support dataclasses in compliance with [**PEP 681**](https://peps.python.org/pep-0681/),
    ORM constructs like [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") and [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") accept additional [**PEP 681**](https://peps.python.org/pep-0681/)
    arguments `init`, `default`, and `default_factory` which are passed along to the
    dataclass creation process. These arguments currently must be present in an explicit
    directive on the right side, just as they would be used with `dataclasses.field()`;
    they currently can’t be local to an `Annotated` construct on the left side. To
    support the convenient use of `Annotated` while still supporting dataclass configuration,
    [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    can merge a minimal set of right-hand arguments with that of an existing [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct located on the left side within an `Annotated`
    construct, so that most of the succinctness is maintained, as will be seen below.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持符合[**PEP 681**](https://peps.python.org/pep-0681/)的数据类，ORM构造如[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")和[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")接受额外的[**PEP 681**](https://peps.python.org/pep-0681/)参数`init`、`default`和`default_factory`，这些参数会传递到数据类创建过程中。这些参数目前必须存在于右侧的显式指令中，就像它们将与`dataclasses.field()`一起使用一样；目前它们不能作为左侧`Annotated`构造中的局部变量存在。为了支持方便使用`Annotated`同时仍支持数据类配置，[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")可以将右侧的最小一组参数与左侧`Annotated`构造中的现有[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造合并，以便保持大部分的简洁性，如下所示。
- en: 'To enable dataclasses using class inheritance we make use of the [`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin, either directly on each class, or on
    the `Base` class, as illustrated below where we further modify the example mapping
    from “Step 5” of [ORM Declarative Models](#whatsnew-20-orm-declarative-typing):'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用类继承启用数据类，我们使用[`MappedAsDataclass`](../orm/mapping_api.html#sqlalchemy.orm.MappedAsDataclass
    "sqlalchemy.orm.MappedAsDataclass") mixin，可以直接在每个类上使用，也可以在`Base`类上使用，如下所示，我们进一步修改了来自[ORM声明性模型](#whatsnew-20-orm-declarative-typing)“步骤5”的示例映射：
- en: '[PRE124]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The above mapping has used the `@dataclasses.dataclass` decorator directly
    on each mapped class at the same time that the declarative mapping was set up,
    internally setting up each `dataclasses.field()` directive as indicated. `User`
    / `Address` structures can be created using positional arguments as configured:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射在设置声明性映射的同时直接在每个映射类上使用了`@dataclasses.dataclass`装饰器，内部设置了每个`dataclasses.field()`指令，如所示。使用位置参数可以配置`User`
    / `Address`结构：
- en: '[PRE125]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: See also
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Declarative Dataclass Mapping](../orm/dataclasses.html#orm-declarative-native-dataclasses)'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '[声明式数据类映射](../orm/dataclasses.html#orm-declarative-native-dataclasses)'
- en: '## Optimized ORM bulk insert now implemented for all backends other than MySQL'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '## 优化的ORM批量插入现在已经针对除MySQL之外的所有后端实现了'
- en: 'The dramatic performance improvement introduced in the 1.4 series and described
    at [ORM Batch inserts with psycopg2 now batch statements with RETURNING in most
    cases](migration_14.html#change-5263) has now been generalized to all included
    backends that support RETURNING, which is all backends other than MySQL: SQLite,
    MariaDB, PostgreSQL (all drivers), and Oracle; SQL Server has support but is temporarily
    disabled in version 2.0.9 [[1]](#id2). While the original feature was most critical
    for the psycopg2 driver which otherwise had major performance issues when using
    `cursor.executemany()`, the change is also critical for other PostgreSQL drivers
    such as asyncpg, as when using RETURNING, single-statement INSERT statements are
    still unacceptably slow, as well as when using SQL Server that also seems to have
    very slow executemany speed for INSERT statements regardless of whether or not
    RETURNING is used.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 系列中引入的显著性能改进，如 [ORM Batch inserts with psycopg2 now batch statements with
    RETURNING in most cases](migration_14.html#change-5263) 中所述，现已普遍适用于所有支持 RETURNING
    的后端，除了 MySQL：SQLite、MariaDB、PostgreSQL（所有驱动程序）和 Oracle；SQL Server 有支持，但在版本 2.0.9
    中暂时禁用 [[1]](#id2)。虽然原始功能对于 psycopg2 驱动程序至关重要，否则在使用 `cursor.executemany()` 时存在严重的性能问题，但对于其他
    PostgreSQL 驱动程序，如 asyncpg，此更改也至关重要，因为在使用 RETURNING 时，单语句 INSERT 语句仍然不可接受地缓慢，以及在使用
    SQL Server 时，无论是否使用 RETURNING，插入语句的 executemany 速度也似乎非常缓慢。
- en: The performance of the new feature provides an almost across-the-board order
    of magnitude performance increase for basically every driver when INSERTing ORM
    objects that don’t have a pre-assigned primary key value, as indicated in the
    table below, in most cases specific to the use of RETURNING which is not normally
    supported with executemany().
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能的性能为每个驱动程序的 INSERT ORM 对象的性能提供了几乎横跨所有板块的数量级的性能提升，如下表所示，大多数情况下特定于 RETURNING
    的使用，通常不支持 executemany()。
- en: The psycopg2 “fast execution helper” approach consists of transforming an INSERT..RETURNING
    statement with a single parameter set into a single statement that INSERTs many
    parameter sets, using multiple “VALUES…” clauses so that it can accommodate many
    parameter sets at once. Parameter sets are then typically batched into groups
    of 1000 or similar, so that no single INSERT statement is excessively large, and
    the INSERT statement is then invoked for each batch of parameters, rather than
    for each individual parameter set. Primary key values and server defaults are
    returned by RETURNING, which continues to work as each statement execution is
    invoked using `cursor.execute()`, rather than `cursor.executemany()`.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2 的“快速执行助手”方法包括将具有单个参数集的 INSERT..RETURNING 语句转换为一个插入多个参数集的单个语句，使用多个“VALUES…”子句，以便它可以一次容纳多个参数集。然后，参数集通常被批处理成一组
    1000 或类似的参数集，以便没有单个 INSERT 语句过于大，并且 INSERT 语句然后针对每个参数批次调用，而不是针对每个单独的参数集。通过 RETURNING
    返回主键值和服务器默认值，这仍然会在每个语句执行时使用 `cursor.execute()` 调用，而不是 `cursor.executemany()`。
- en: This allows many rows to be inserted in one statement while also being able
    to return newly-generated primary key values as well as SQL and server defaults.
    SQLAlchemy historically has always needed to invoke one statement per parameter
    set, as it relied upon Python DBAPI Features such as `cursor.lastrowid` which
    do not support multiple rows.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许一次插入许多行，同时还能够返回新生成的主键值以及 SQL 和服务器默认值。历史上，SQLAlchemy 一直需要对每个参数集调用一条语句，因为它依赖于诸如
    `cursor.lastrowid` 等 Python DBAPI 功能，这些功能不支持多行。
- en: With most databases now offering RETURNING (with the conspicuous exception of
    MySQL, given that MariaDB supports it), the new change generalizes the psycopg2
    “fast execution helper” approach to all dialects that support RETURNING, which
    now includes SQlite and MariaDB, and for which no other approach for “executemany
    plus RETURNING” is possible, which includes SQLite, MariaDB, and all PG drivers.
    The cx_Oracle and oracledb drivers used for Oracle support RETURNING with executemany
    natively, and this has also been implemented to provide equivalent performance
    improvements. With SQLite and MariaDB now offering RETURNING support, ORM use
    of `cursor.lastrowid` is nearly a thing of the past, with only MySQL still relying
    upon it.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在大多数数据库都提供了RETURNING（尤其是MySQL是一个明显的例外，因为MariaDB支持它），新的更改将psycopg2的“快速执行助手”方法推广到支持RETURNING的所有方言，现在包括SQlite和MariaDB，并且对于没有其他方法来执行“executemany加RETURNING”的方言，包括SQLite、MariaDB和所有PG驱动程序。用于Oracle支持RETURNING的cx_Oracle和oracledb驱动程序会在本机支持executemany，这也已经实现了相应的性能改进。由于SQLite和MariaDB现在提供RETURNING支持，ORM对`cursor.lastrowid`的使用几乎成为历史，只有MySQL仍然依赖于它。
- en: For INSERT statements that don’t use RETURNING, traditional executemany() behavior
    is used for most backends, with the current exception of psycopg2, which has very
    slow executemany() performance overall and are still improved by the “insertmanyvalues”
    approach.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不使用RETURNING的INSERT语句，对于大多数后端，都使用传统的executemany()行为，当前的例外是psycopg2，它的executemany()性能总体上非常慢，并且仍然受到“insertmanyvalues”方法的改进。
- en: Benchmarks
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: SQLAlchemy includes a [Performance Suite](../orm/examples.html#examples-performance)
    within the `examples/` directory, where we can make use of the `bulk_insert` suite
    to benchmark INSERTs of many rows using both Core and ORM in different ways.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在`examples/`目录中包含一个[性能套件](../orm/examples.html#examples-performance)，在这里我们可以利用`bulk_insert`套件以不同的方式使用Core和ORM来对插入多行的INSERT进行基准测试。
- en: For the tests below, we are inserting **100,000 objects**, and in all cases
    we actually have 100,000 real Python ORM objects in memory, either created up
    front or generated on the fly. All databases other than SQLite are run over a
    local network connection, not localhost; this causes the “slower” results to be
    extremely slow.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的测试，我们插入了**100,000个对象**，在所有情况下，我们实际上都有100,000个真实的Python ORM对象在内存中，无论是预先创建的还是动态生成的。除了SQLite之外的所有数据库都通过本地网络连接运行，而不是本地主机；这导致“较慢”的结果非常慢。
- en: 'Operations that are improved by this feature include:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能改进的操作包括：
- en: unit of work flushes for objects added to the session using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all").
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")和[`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")将对象添加到会话中的工作单元刷新。
- en: The new [ORM Bulk Insert Statement](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    feature, which improves upon the experimental version of this feature first introduced
    in SQLAlchemy 1.4.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的[ORM批量插入语句](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)功能，改进了SQLAlchemy
    1.4中首次引入的此功能的试验版本。
- en: the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    “bulk” operations described at [Bulk Operations](../orm/persistence_techniques.html#bulk-operations),
    which are superseded by the above mentioned ORM Bulk Insert feature.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[批量操作](../orm/persistence_techniques.html#bulk-operations)中描述的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") “批量”操作，这些操作被上述ORM批量插入功能所取代。
- en: 'To get a sense of the scale of the operation, below are performance measurements
    using the `test_flush_no_pk` performance suite, which historically represents
    SQLAlchemy’s worst-case INSERT performance task, where objects that don’t have
    primary key values need to be INSERTed, and then the newly generated primary key
    values must be fetched so that the objects can be used for subsequent flush operations,
    such as establishment within relationships, flushing joined-inheritance models,
    etc:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对操作的规模有所了解，以下是使用`test_flush_no_pk`性能套件的性能测量结果，该套件历史上代表了SQLAlchemy的最坏情况INSERT性能任务，其中需要插入没有主键值的对象，然后必须获取新生成的主键值，以便对象可以用于后续的flush操作，例如在关系中建立关系，刷新连接继承模型等：
- en: '[PRE126]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'This test can be run from any SQLAlchemy source tree as follows:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何SQLAlchemy源代码树中运行此测试，如下所示：
- en: '[PRE127]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The table below summarizes performance measurements with the latest 1.4 series
    of SQLAlchemy compared to 2.0, both running the same test:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了最新的 1.4 系列 SQLAlchemy 与 2.0 的性能测量结果，两者都运行相同的测试：
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| sqlite+pysqlite2 (内存) | 6.204843 | 3.554856 |'
- en: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+asyncpg (网络) | 88.292285 | 4.561492 |'
- en: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg (网络) | N/A (psycopg3) | 4.861368 |'
- en: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| mssql+pyodbc (网络) | 158.396667 | 4.825139 |'
- en: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| oracle+cx_Oracle (网络) | 92.603953 | 4.809520 |'
- en: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| mariadb+mysqldb (网络) | 71.705197 | 4.075377 |'
- en: Note
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Two additional drivers have no change in performance; the psycopg2 drivers,
    for which fast executemany was already implemented in SQLAlchemy 1.4, and MySQL,
    which continues to not offer RETURNING support:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个驱动程序在性能上没有变化；psycopg2 驱动程序，其在 SQLAlchemy 1.4 中已经实现了快速 executemany，以及 MySQL，它仍然不提供
    RETURNING 支持：
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg2 (网络) | 4.704876 | 4.699883 |'
- en: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| mysql+mysqldb (网络) | 77.281997 | 76.132995 |'
- en: Summary of Changes
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更摘要
- en: 'The following bullets list the individual changes made within 2.0 in order
    to get all drivers to this state:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目列出了 2.0 版本中为使所有驱动程序达到这种状态所做的各项更改：
- en: RETURNING implemented for SQLite - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 实现了 RETURNING - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
- en: RETURNING implemented for MariaDB - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB 实现了 RETURNING - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
- en: Fix multi-row RETURNING for Oracle - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复 Oracle 的多行 RETURNING - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
- en: make insert() executemany() support RETURNING for as many dialects as possible,
    usually with VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 insert() executemany() 支持尽可能多的方言的 RETURNING，通常使用 VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
- en: Emit a warning when RETURNING w/ executemany is used for non-supporting backend
    (currently no RETURNING backend has this limitation) - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对不支持的后端使用 RETURNING w/ executemany 时发出警告（当前没有 RETURNING 后端有此限制）- [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
- en: The ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a a new setting `"auto"`, which
    will enable “eager defaults” automatically for INSERT statements, when the backend
    in use supports RETURNING with “insertmanyvalues”. See [Fetching Server-Generated
    Defaults](../orm/persistence_techniques.html#orm-server-defaults) for documentation.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") 参数现在默认为新设置 `"auto"`，当使用的后端支持带有“insertmanyvalues”的 RETURNING
    时，将自动启用“eager defaults”用于 INSERT 语句。请参阅[获取服务器生成的默认值](../orm/persistence_techniques.html#orm-server-defaults)以获取文档。
- en: See also
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - Documentation and background on the new feature as well as how to configure
    it'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT 语句的“Insert Many Values”行为](../core/connections.html#engine-insertmanyvalues)
    - 新功能的文档和背景以及如何配置它'
- en: Benchmarks
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: SQLAlchemy includes a [Performance Suite](../orm/examples.html#examples-performance)
    within the `examples/` directory, where we can make use of the `bulk_insert` suite
    to benchmark INSERTs of many rows using both Core and ORM in different ways.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在 `examples/` 目录中包含一个[性能套件](../orm/examples.html#examples-performance)，在这里我们可以利用
    `bulk_insert` 套件以不同方式使用 Core 和 ORM 来对插入多行的性能进行基准测试。
- en: For the tests below, we are inserting **100,000 objects**, and in all cases
    we actually have 100,000 real Python ORM objects in memory, either created up
    front or generated on the fly. All databases other than SQLite are run over a
    local network connection, not localhost; this causes the “slower” results to be
    extremely slow.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的测试，我们插入了**100,000个对象**，在所有情况下，我们实际上在内存中有 100,000 个真实的 Python ORM 对象，要么事先创建，要么动态生成。除
    SQLite 外的所有数据库都通过本地网络连接运行，而不是 localhost；这导致“较慢”的结果非常慢。
- en: 'Operations that are improved by this feature include:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个功能改进的操作包括：
- en: unit of work flushes for objects added to the session using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all").
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")和[`Session.add_all()`](../orm/session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")向会话添加的对象的工作单元刷新。
- en: The new [ORM Bulk Insert Statement](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)
    feature, which improves upon the experimental version of this feature first introduced
    in SQLAlchemy 1.4.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的[ORM批量插入语句](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)功能，改进了首次在SQLAlchemy
    1.4中引入的此功能的实验版本。
- en: the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    “bulk” operations described at [Bulk Operations](../orm/persistence_techniques.html#bulk-operations),
    which are superseded by the above mentioned ORM Bulk Insert feature.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中描述的“bulk”操作，已被上述ORM批量插入功能取代。'
- en: 'To get a sense of the scale of the operation, below are performance measurements
    using the `test_flush_no_pk` performance suite, which historically represents
    SQLAlchemy’s worst-case INSERT performance task, where objects that don’t have
    primary key values need to be INSERTed, and then the newly generated primary key
    values must be fetched so that the objects can be used for subsequent flush operations,
    such as establishment within relationships, flushing joined-inheritance models,
    etc:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解操作的规模，以下是使用`test_flush_no_pk`性能套件进行的性能测量，这通常代表SQLAlchemy的最坏情况INSERT性能任务，其中需要INSERT没有主键值的对象，然后必须获取新生成的主键值，以便这些对象可以用于后续的flush操作，比如在关系中建立，刷新加入继承模型等：
- en: '[PRE128]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This test can be run from any SQLAlchemy source tree as follows:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何SQLAlchemy源代码树中运行此测试：
- en: '[PRE129]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The table below summarizes performance measurements with the latest 1.4 series
    of SQLAlchemy compared to 2.0, both running the same test:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了最新的SQLAlchemy 1.4系列与2.0之间的性能测量结果，两者都运行相同的测试：
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| sqlite+pysqlite2 (memory) | 6.204843 | 3.554856 |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| sqlite+pysqlite2 (内存) | 6.204843 | 3.554856 |'
- en: '| postgresql+asyncpg (network) | 88.292285 | 4.561492 |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+asyncpg (网络) | 88.292285 | 4.561492 |'
- en: '| postgresql+psycopg (network) | N/A (psycopg3) | 4.861368 |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg (网络) | N/A (psycopg3) | 4.861368 |'
- en: '| mssql+pyodbc (network) | 158.396667 | 4.825139 |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| mssql+pyodbc (网络) | 158.396667 | 4.825139 |'
- en: '| oracle+cx_Oracle (network) | 92.603953 | 4.809520 |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| oracle+cx_Oracle (网络) | 92.603953 | 4.809520 |'
- en: '| mariadb+mysqldb (network) | 71.705197 | 4.075377 |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| mariadb+mysqldb (网络) | 71.705197 | 4.075377 |'
- en: Note
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Two additional drivers have no change in performance; the psycopg2 drivers,
    for which fast executemany was already implemented in SQLAlchemy 1.4, and MySQL,
    which continues to not offer RETURNING support:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个驱动程序在性能上没有变化；对于已在SQLAlchemy 1.4中实现了快速executemany的psycopg2驱动程序以及继续不提供RETURNING支持的MySQL：
- en: '| Driver | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| postgresql+psycopg2 (network) | 4.704876 | 4.699883 |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg2 (网络) | 4.704876 | 4.699883 |'
- en: '| mysql+mysqldb (network) | 77.281997 | 76.132995 |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| mysql+mysqldb (网络) | 77.281997 | 76.132995 |'
- en: Summary of Changes
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更摘要
- en: 'The following bullets list the individual changes made within 2.0 in order
    to get all drivers to this state:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目列出了2.0中进行的各项更改，以使所有驱动程序达到此状态：
- en: RETURNING implemented for SQLite - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为SQLite实现了RETURNING - [#6195](https://www.sqlalchemy.org/trac/ticket/6195)
- en: RETURNING implemented for MariaDB - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为MariaDB实现了RETURNING - [#7011](https://www.sqlalchemy.org/trac/ticket/7011)
- en: Fix multi-row RETURNING for Oracle - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复了Oracle的多行RETURNING - [#6245](https://www.sqlalchemy.org/trac/ticket/6245)
- en: make insert() executemany() support RETURNING for as many dialects as possible,
    usually with VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使insert() executemany()支持尽可能多的方言，通常使用VALUES() - [#6047](https://www.sqlalchemy.org/trac/ticket/6047)
- en: Emit a warning when RETURNING w/ executemany is used for non-supporting backend
    (currently no RETURNING backend has this limitation) - [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用于不支持的后端时发出警告RETURNING w/ executemany（当前没有RETURNING后端具有此限制）- [#7907](https://www.sqlalchemy.org/trac/ticket/7907)
- en: The ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper") parameter now defaults to a a new setting `"auto"`, which
    will enable “eager defaults” automatically for INSERT statements, when the backend
    in use supports RETURNING with “insertmanyvalues”. See [Fetching Server-Generated
    Defaults](../orm/persistence_techniques.html#orm-server-defaults) for documentation.
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM [`Mapper.eager_defaults`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.eager_defaults
    "sqlalchemy.orm.Mapper")参数现在默认为一个新设置 `"auto"`, 当使用的后端支持带有“insertmanyvalues”的RETURNING时，会自动为INSERT语句启用“急切默认”。请参阅[获取服务器生成的默认值](../orm/persistence_techniques.html#orm-server-defaults)了解文档。
- en: See also
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - Documentation and background on the new feature as well as how to configure
    it'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT语句的“Insert Many Values”行为](../core/connections.html#engine-insertmanyvalues)
    - 新功能的文档和背景，以及如何配置它'
- en: '## ORM-enabled Insert, Upsert, Update and Delete Statements, with ORM RETURNING'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '## 启用ORM的插入、更新和删除语句，带有ORM RETURNING'
- en: SQLAlchemy 1.4 ported the features of the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to [2.0 style](../glossary.html#term-2.0-style)
    execution, which meant that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct could be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") to deliver ORM results. Support was also added
    for [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    to be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), to the degree that they could provide implementations
    of [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete").
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4将遗留的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象的特性移植到[2.0样式](../glossary.html#term-2.0-style)执行，这意味着[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造可以传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")以传递ORM结果。还增加了对[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")和[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete")的支持，以便它们可以提供[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")和[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")的实现。
- en: The major missing element has been support for the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct. The 1.4 documentation addressed
    this with some recipes for “inserts” and “upserts” with use of [`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement") to integrate RETURNING into
    an ORM context. 2.0 now fully closes the gap by integrating direct support for
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    as an enhanced version of the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method, along with full ORM RETURNING
    support for all DML structures.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 主要缺失的元素是对[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")构造的支持。1.4文档通过使用[`Select.from_statement()`](../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement
    "sqlalchemy.sql.expression.Select.from_statement")的一些“插入”和“更新”配方来解决这个问题，将RETURNING集成到ORM上下文中。2.0现在通过将[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")的直接支持整合为增强版本的[`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")方法以及对所有DML结构的完整ORM RETURNING支持来完全填补了这一空白。
- en: Bulk Insert with RETURNING
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有RETURNING的批量插入
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    can be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), with or without [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), which when passed with a separate
    parameter list will invoke the same process as was previously implemented by [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings"), with additional enhancements.
    This will optimize the batching of rows making use of the new [fast insertmany](#change-6047)
    feature, while also adding support for heterogeneous parameter sets and multiple-table
    mappings like joined table inheritance:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    可以传递给 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，可以带有或不带有 [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")，当传递给一个单独的参数列表时，将调用与以前由 [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") 实现的相同的过程，同时增强了附加功能。这将优化使用新的[快速插入](#change-6047)功能的行批处理，同时还添加了对异构参数集和多表映射（如联合表继承）的支持：'
- en: '[PRE130]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: RETURNING is supported for all of these use cases, where the ORM will construct
    a full result set from multiple statement invocations.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[RETURNING](https://example.org/returning) 支持所有这些用例，ORM 将从多个语句调用中构造完整的结果集。'
- en: See also
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 大规模插入语句](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
- en: Bulk UPDATE
  id: totrans-717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大规模 UPDATE
- en: 'In a similar manner as that of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), passing the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a parameter list that
    includes primary key values to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will invoke the same process as previously supported
    by the [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This feature does not however
    support RETURNING, as it uses a SQL UPDATE statement that is invoked using DBAPI
    [executemany](../glossary.html#term-executemany):'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    类似，将 [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    构造传递给包含主键值的参数列表的 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 将调用之前由 [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") 方法支持的相同过程。但是，该功能不支持 RETURNING，因为它使用一个
    SQL UPDATE 语句，该语句使用 DBAPI 的 [executemany](../glossary.html#term-executemany) 调用：
- en: '[PRE131]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: See also
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk UPDATE by Primary Key](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '[按主键进行 ORM 大规模 UPDATE](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
- en: INSERT / upsert … VALUES … RETURNING
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入/ upsert … VALUES … RETURNING
- en: 'When using [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    with [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values"), the set of parameters may include
    SQL expressions. Additionally, upsert variants such as those for SQLite, PostgreSQL
    and MariaDB are also supported. These statements may now include [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") clauses with column expressions
    or full ORM entities:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    时，可在 [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 中包含一组参数，其中可能包括 SQL 表达式。此外，还支持 SQLite、PostgreSQL
    和 MariaDB 的 upsert 变体。这些语句现在可以包含 [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 子句，其中包括列表达式或完整的 ORM 实体：
- en: '[PRE132]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: See also
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk Insert with Per Row SQL Expressions](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用每行 SQL 表达式进行 ORM 大规模插入](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
- en: '[ORM “upsert” Statements](../orm/queryguide/dml.html#orm-queryguide-upsert)'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM "upsert" 语句](../orm/queryguide/dml.html#orm-queryguide-upsert)'
- en: ORM UPDATE / DELETE with WHERE … RETURNING
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM UPDATE / DELETE with WHERE … RETURNING
- en: 'SQLAlchemy 1.4 also had some modest support for the RETURNING feature to be
    used with the [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    constructs, when used with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This support has now been upgraded to be fully
    native, including that the `fetch` synchronization strategy may also proceed whether
    or not explicit use of RETURNING is present:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4还对与[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")和[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造一起使用时与[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")一起使用RETURNING功能提供了一些有限的支持。现在，此支持已经升级为完全本地化，包括`fetch`同步策略也可以继续进行，无论是否明确使用RETURNING：
- en: '[PRE133]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: See also
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用自定义WHERE条件的ORM UPDATE和DELETE](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
- en: '[Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用RETURNING进行UPDATE/DELETE和自定义WHERE条件](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
- en: Improved `synchronize_session` behavior for ORM UPDATE / DELETE
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进的ORM UPDATE / DELETE的`synchronize_session`行为
- en: The default strategy for [synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)
    is now a new value `"auto"`. This strategy will attempt to use the `"evaluate"`
    strategy and then automatically fall back to the `"fetch"` strategy. For all backends
    other than MySQL / MariaDB, `"fetch"` uses RETURNING to fetch UPDATE/DELETEd primary
    key identifiers within the same statement, so is generally more efficient than
    previous versions (in 1.4, RETURNING was only available for PostgreSQL, SQL Server).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)的默认策略现在是一个新值`"auto"`。此策略将尝试使用`"evaluate"`策略，然后自动回退到`"fetch"`策略。除了MySQL
    / MariaDB之外的所有后端，`"fetch"`使用RETURNING在同一语句中获取UPDATE/DELETE的主键标识符，因此通常比以前的版本更有效（在1.4中，RETURNING仅适用于PostgreSQL、SQL
    Server）。'
- en: See also
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting a Synchronization Strategy](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择同步策略](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
- en: Summary of Changes
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更摘要
- en: 'Listed tickets for new ORM DML with RETURNING features:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ORM DML带有RETURNING功能的列出的票据：
- en: convert `insert()` at ORM level to interpret `values()` in an ORM context -
    [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ORM级别的`insert()`转换为在ORM上下文中解释`values()` - [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
- en: evaluate feasibility of dml.returning(Entity) to deliver ORM expressions, automatically
    apply select().from_statement equiv - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估`dml.returning(Entity)`的可行性，以提供ORM表达式，自动应用`select().from_statement`等效 - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
- en: 'given ORM insert, try to carry the bulk methods along, re: inheritance - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定ORM插入，尝试沿用批量方法，关于继承 - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)
- en: Bulk Insert with RETURNING
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有RETURNING的批量插入
- en: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    can be passed to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), with or without [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning"), which when passed with a separate
    parameter list will invoke the same process as was previously implemented by [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings"), with additional enhancements.
    This will optimize the batching of rows making use of the new [fast insertmany](#change-6047)
    feature, while also adding support for heterogeneous parameter sets and multiple-table
    mappings like joined table inheritance:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")可以传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，可以带有或不带有[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")，当与单独的参数列表一起传递时，将调用与以前由[`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings")实现的相同过程，同时增加了额外的增强功能。这将优化行的批处理，利用新的[快速插入多行](#change-6047)功能，同时还支持异构参数集和多表映射，如联合表继承：'
- en: '[PRE134]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: RETURNING is supported for all of these use cases, where the ORM will construct
    a full result set from multiple statement invocations.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些用例，都支持 RETURNING，其中 ORM 将从多个语句调用构造完整的结果集。
- en: See also
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk INSERT Statements](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 批量插入语句](../orm/queryguide/dml.html#orm-queryguide-bulk-insert)'
- en: Bulk UPDATE
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量更新
- en: 'In a similar manner as that of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), passing the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct along with a parameter list that
    includes primary key values to [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") will invoke the same process as previously supported
    by the [`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings") method. This feature does not however
    support RETURNING, as it uses a SQL UPDATE statement that is invoked using DBAPI
    [executemany](../glossary.html#term-executemany):'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")类似，将[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")构造与包含主键值的参数列表一起传递给[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")将调用与之前由[`Session.bulk_update_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_update_mappings
    "sqlalchemy.orm.Session.bulk_update_mappings")方法支持的相同过程。但是，此功能不支持 RETURNING，因为它使用了通过
    DBAPI [executemany](../glossary.html#term-executemany) 调用的 SQL UPDATE 语句：
- en: '[PRE135]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: See also
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk UPDATE by Primary Key](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '[按主键批量更新的 ORM UPDATE](../orm/queryguide/dml.html#orm-queryguide-bulk-update)'
- en: INSERT / upsert … VALUES … RETURNING
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INSERT / upsert … VALUES … RETURNING
- en: 'When using [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    with [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values"), the set of parameters may include
    SQL expressions. Additionally, upsert variants such as those for SQLite, PostgreSQL
    and MariaDB are also supported. These statements may now include [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") clauses with column expressions
    or full ORM entities:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")与[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")时，参数集合可以包含 SQL 表达式。此外，还支持 SQLite、PostgreSQL
    和 MariaDB 等数据库的 upsert 变体。这些语句现在可以包括带有列表达式或完整 ORM 实体的[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")子句：
- en: '[PRE136]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: See also
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Bulk Insert with Per Row SQL Expressions](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用每行 SQL 表达式的 ORM 批量插入](../orm/queryguide/dml.html#orm-queryguide-insert-values)'
- en: '[ORM “upsert” Statements](../orm/queryguide/dml.html#orm-queryguide-upsert)'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM “upsert” 语句](../orm/queryguide/dml.html#orm-queryguide-upsert)'
- en: ORM UPDATE / DELETE with WHERE … RETURNING
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带 WHERE … RETURNING 的 ORM UPDATE / DELETE
- en: 'SQLAlchemy 1.4 also had some modest support for the RETURNING feature to be
    used with the [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    constructs, when used with [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). This support has now been upgraded to be fully
    native, including that the `fetch` synchronization strategy may also proceed whether
    or not explicit use of RETURNING is present:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4 也对与[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")和[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造一起使用时与[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")一起使用 RETURNING 功能提供了一些有限支持。此支持现已升级为完全本机，包括`fetch`同步策略也可以继续进行，无论是否存在显式使用
    RETURNING：
- en: '[PRE137]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: See also
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用自定义 WHERE 条件的 ORM UPDATE 和 DELETE](../orm/queryguide/dml.html#orm-queryguide-update-delete-where)'
- en: '[Using RETURNING with UPDATE/DELETE and Custom WHERE Criteria](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 UPDATE/DELETE 和自定义 WHERE 条件的 RETURNING](../orm/queryguide/dml.html#orm-queryguide-update-delete-where-returning)'
- en: Improved `synchronize_session` behavior for ORM UPDATE / DELETE
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM UPDATE / DELETE 的改进`synchronize_session`行为
- en: The default strategy for [synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)
    is now a new value `"auto"`. This strategy will attempt to use the `"evaluate"`
    strategy and then automatically fall back to the `"fetch"` strategy. For all backends
    other than MySQL / MariaDB, `"fetch"` uses RETURNING to fetch UPDATE/DELETEd primary
    key identifiers within the same statement, so is generally more efficient than
    previous versions (in 1.4, RETURNING was only available for PostgreSQL, SQL Server).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '[synchronize_session](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)的默认策略现在是一个新值`"auto"`。此策略将尝试使用`"evaluate"`策略，然后自动回退到`"fetch"`策略。对于除MySQL
    / MariaDB之外的所有后端，`"fetch"`使用RETURNING在同一语句中获取UPDATE/DELETE的主键标识符，因此通常比以前的版本更有效率（在1.4中，RETURNING仅适用于PostgreSQL，SQL
    Server）。'
- en: See also
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Selecting a Synchronization Strategy](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择同步策略](../orm/queryguide/dml.html#orm-queryguide-update-delete-sync)'
- en: Summary of Changes
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更摘要
- en: 'Listed tickets for new ORM DML with RETURNING features:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 新ORM DML的带有RETURNING特性的已列出的票证：
- en: convert `insert()` at ORM level to interpret `values()` in an ORM context -
    [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ORM级别的`insert()`转换为在ORM上下文中解释`values()`- [#7864](https://www.sqlalchemy.org/trac/ticket/7864)
- en: evaluate feasibility of dml.returning(Entity) to deliver ORM expressions, automatically
    apply select().from_statement equiv - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估dml.returning(Entity)提供ORM表达式的可行性，自动应用select().from_statement等效 - [#7865](https://www.sqlalchemy.org/trac/ticket/7865)
- en: 'given ORM insert, try to carry the bulk methods along, re: inheritance - [#8360](https://www.sqlalchemy.org/trac/ticket/8360)'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定ORM插入，尝试沿用批量方法，即继承关系- [#8360](https://www.sqlalchemy.org/trac/ticket/8360)
- en: '## New “Write Only” relationship strategy supersedes “dynamic”'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '## 新的“只写”关系策略取代了“动态”'
- en: The `lazy="dynamic"` loader strategy becomes legacy, in that it is hardcoded
    to make use of legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This loader strategy is both not compatible with asyncio,
    and additionally has many behaviors that implicitly iterate its contents, which
    defeat the original purpose of the “dynamic” relationship as being for very large
    collections that should not be implicitly fully loaded into memory at any time.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy="dynamic"`加载策略已经过时，因为它是硬编码的，使用了遗留的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")。这种加载策略既不兼容asyncio，而且还有许多行为会隐式地迭代其内容，这些行为背离了“动态”关系最初的目的，即针对不应在任何时候隐式完全加载到内存中的非常大的集合。'
- en: 'The “dynamic” strategy is now superseded by a new strategy `lazy="write_only"`.
    Configuration of “write only” may be achieved using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), or when using [type annotated mappings](#whatsnew-20-orm-declarative-typing),
    indicating the [`WriteOnlyMapped`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation as the mapping style:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: “动态”策略现已由新策略`lazy="write_only"`取代。可以使用[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的[`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")参数进行“只写”配置，或者在使用[类型注释映射](#whatsnew-20-orm-declarative-typing)时，将[`WriteOnlyMapped`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped")注释指示为映射样式：
- en: '[PRE138]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The write-only-mapped collection resembles `lazy="dynamic"` in that the collection
    may be assigned up front, and also has methods such as [`WriteOnlyCollection.add()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add") and [`WriteOnlyCollection.remove()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") to modify the collection on an individual
    item basis:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 写入仅映射集合类似于`lazy="dynamic"`，因为集合可以提前分配，并且还具有[`WriteOnlyCollection.add()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add")和[`WriteOnlyCollection.remove()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove")等方法，以逐个项目的方式修改集合：
- en: '[PRE139]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The bigger difference is on the database loading side, where the collection
    has no ability to load objects from the database directly; instead, SQL construction
    methods such as [`WriteOnlyCollection.select()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") are used to produce SQL constructs
    such as [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    which are then executed using [2.0 style](../glossary.html#term-2.0-style) to
    load the desired objects in an explicit way:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库加载方面的主要区别在于，该集合没有直接从数据库加载对象的能力；相反，使用 SQL 构造方法，如 [`WriteOnlyCollection.select()`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") 来生成 SQL 构造，比如 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")，然后使用 [2.0 风格](../glossary.html#term-2.0-style)
    显式加载所需对象：
- en: '[PRE140]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The [`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") also integrates with the new [ORM bulk dml](#change-8360)
    features, including support for bulk INSERT and UPDATE/DELETE with WHERE criteria,
    all including RETURNING support as well. See the complete documentation at [Write
    Only Relationships](../orm/large_collections.html#write-only-relationship).
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '[`WriteOnlyCollection`](../orm/large_collections.html#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") 也与新的 [ORM bulk dml](#change-8360) 功能集成，包括支持带有
    WHERE 条件的批量 INSERT 和 UPDATE/DELETE，所有这些都包括 RETURNING 支持。请参阅完整文档 [Write Only Relationships](../orm/large_collections.html#write-only-relationship)。'
- en: See also
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '[Write Only Relationships](../orm/large_collections.html#write-only-relationship)'
- en: New pep-484 / type annotated mapping support for Dynamic Relationships
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态关系的新 pep-484 / 类型注释映射支持
- en: 'Even though “dynamic” relationships are legacy in 2.0, as these patterns are
    expected to have a long lifespan, [type annotated mapping](#whatsnew-20-orm-declarative-typing)
    support is now added for “dynamic” relationships in the same way that its available
    for the new `lazy="write_only"` approach, using the [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“动态”关系在 2.0 中是遗留的，但由于这些模式预计具有较长的生命周期，[类型注释映射](#whatsnew-20-orm-declarative-typing)
    现在已添加到“动态”关系中，与新的 `lazy="write_only"` 方法可用的方式相同，使用 [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") 注释：
- en: '[PRE141]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The above mapping will provide an `Account.account_transactions` collection
    that is typed as returning the [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") collection type, including its element type, e.g.
    `AppenderQuery[AccountTransaction]`. This then allows iteration and queries to
    yield objects which are typed as `AccountTransaction`.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将提供一个 `Account.account_transactions` 集合，其类型为 [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") 集合类型，包括其元素类型，例如 `AppenderQuery[AccountTransaction]`。然后允许迭代和查询产生类型为
    `AccountTransaction` 的对象。
- en: See also
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dynamic Relationship Loaders](../orm/large_collections.html#dynamic-relationship)'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '[动态关系加载器](../orm/large_collections.html#dynamic-relationship)'
- en: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)'
- en: New pep-484 / type annotated mapping support for Dynamic Relationships
  id: totrans-793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态关系的新 pep-484 / 类型注释映射支持
- en: 'Even though “dynamic” relationships are legacy in 2.0, as these patterns are
    expected to have a long lifespan, [type annotated mapping](#whatsnew-20-orm-declarative-typing)
    support is now added for “dynamic” relationships in the same way that its available
    for the new `lazy="write_only"` approach, using the [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") annotation:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管“动态”关系在 2.0 中是遗留的，但由于这些模式预计具有较长的生命周期，[类型注释映射](#whatsnew-20-orm-declarative-typing)
    现在已添加到“动态”关系中，与新的 `lazy="write_only"` 方法可用的方式相同，使用 [`DynamicMapped`](../orm/large_collections.html#sqlalchemy.orm.DynamicMapped
    "sqlalchemy.orm.DynamicMapped") 注释：
- en: '[PRE142]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The above mapping will provide an `Account.account_transactions` collection
    that is typed as returning the [`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery") collection type, including its element type, e.g.
    `AppenderQuery[AccountTransaction]`. This then allows iteration and queries to
    yield objects which are typed as `AccountTransaction`.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将提供一个类型为返回[`AppenderQuery`](../orm/large_collections.html#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery")集合类型的`Account.account_transactions`集合，包括其元素类型，例如`AppenderQuery[AccountTransaction]`。这样就允许迭代和查询产生类型为`AccountTransaction`的对象。
- en: See also
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dynamic Relationship Loaders](../orm/large_collections.html#dynamic-relationship)'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '[动态关系加载器](../orm/large_collections.html#dynamic-relationship)'
- en: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7123](https://www.sqlalchemy.org/trac/ticket/7123)'
- en: '## Installation is now fully pep-517 enabled'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '## 安装现在完全支持PEP-517'
- en: The source distribution now includes a `pyproject.toml` file to allow for complete
    [**PEP 517**](https://peps.python.org/pep-0517/) support. In particular this allows
    a local source build using `pip` to automatically install the [Cython](https://cython.org/)
    optional dependency.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码分发现在包含一个`pyproject.toml`文件，以允许完全支持[**PEP 517**](https://peps.python.org/pep-0517/)。特别是，这允许使用`pip`进行本地源构建时自动安装可选依赖[Cython](https://cython.org/)。
- en: '[#7311](https://www.sqlalchemy.org/trac/ticket/7311)'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7311](https://www.sqlalchemy.org/trac/ticket/7311)'
- en: '## C Extensions now ported to Cython'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '## C扩展现在转移到了Cython'
- en: The SQLAlchemy C extensions have been replaced with all new extensions written
    in [Cython](https://cython.org/). While Cython was evaluated back in 2010 when
    the C extensions were first created, the nature and focus of the C extensions
    in use today has changed quite a bit from that time. At the same time, Cython
    has apparently evolved significantly, as has the Python build / distribution toolchain
    which made it feasible for us to revisit it.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的C扩展已被全部用[Cython](https://cython.org/)编写的新扩展替换。虽然Cython在2010年评估过，当时创建了C扩展，但今天使用的C扩展的性质和重点与当时相比已经发生了很大变化。同时，Cython显然已经有了很大发展，Python构建/分发工具链也使我们重新审视它成为可能。
- en: 'The move to Cython provides dramatic new advantages with no apparent downsides:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到Cython提供了明显的新优势，而没有明显的缺点：
- en: The Cython extensions that replace specific C extensions have all benchmarked
    as **faster**, often slightly, but sometimes significantly, than virtually all
    the C code that SQLAlchemy previously included. While this seems amazing, it appears
    to be a product of non-obvious optimizations within Cython’s implementation that
    would not be present in a direct Python to C port of a function, as was particularly
    the case for many of the custom collection types added to the C extensions.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Cython替换特定C扩展的Cython扩展都经过了基准测试，通常比SQLAlchemy以前包含的几乎所有C代码都**更快**，有时显着快。虽然这看起来很神奇，但似乎是Cython实现中的一些非明显优化的结果，这些优化在直接将函数从Python转换为C时不会存在，特别是对于添加到C扩展的许多自定义集合类型的情况。
- en: Cython extensions are much easier to write, maintain and debug compared to raw
    C code, and in most cases are line-per-line equivalent to the Python code. It
    is expected that many more elements of SQLAlchemy will be ported to Cython in
    the coming releases which should open many new doors to performance improvements
    that were previously out of reach.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原始C代码相比，Cython扩展更容易编写、维护和调试，在大多数情况下与Python代码是逐行等效的。预计在即将发布的版本中，SQLAlchemy的许多元素都将被转移到Cython中，这将打开许多以前无法实现的性能改进的新门路。
- en: Cython is very mature and widely used, including being the basis of some of
    the prominent database drivers supported by SQLAlchemy including `asyncpg`, `psycopg3`
    and `asyncmy`.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython非常成熟且被广泛使用，包括成为SQLAlchemy支持的一些显著数据库驱动程序的基础，包括`asyncpg`、`psycopg3`和`asyncmy`。
- en: Like the previous C extensions, the Cython extensions are pre-built within SQLAlchemy’s
    wheel distributions which are automatically available to `pip` from PyPi. Manual
    build instructions are also unchanged with the exception of the Cython requirement.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前的C扩展一样，Cython扩展被预先构建在SQLAlchemy的wheel分发中，这些分发可以自动从PyPi中的`pip`获得。手动构建说明也没有变化，除了Cython要求。
- en: See also
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '[构建Cython扩展](../intro.html#c-extensions)'
- en: '[#7256](https://www.sqlalchemy.org/trac/ticket/7256)'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7256](https://www.sqlalchemy.org/trac/ticket/7256)'
- en: '## Major Architectural, Performance and API Enhancements for Database Reflection'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数据库反射的重大架构、性能和API增强'
- en: The internal system by which [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects and their components are [reflected](../core/reflection.html#metadata-reflection)
    has been completely rearchitected to allow high performance bulk reflection of
    thousands of tables at once for participating dialects. Currently, the **PostgreSQL**
    and **Oracle** dialects participate in the new architecture, where the PostgreSQL
    dialect can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects nearly three times faster, and the Oracle dialect
    can now reflect a large series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects ten times faster.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象及其组件被反射的内部系统已经被完全重新架构，以允许参与方言一次性高性能地大量反射数千个表。目前，**PostgreSQL** 和 **Oracle**
    方言参与了新的架构，其中 PostgreSQL 方言现在可以将大量 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象反射得快近三倍，而 Oracle 方言现在可以将大量 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象反射得快十倍。'
- en: The rearchitecture applies most directly to dialects that make use of SELECT
    queries against system catalog tables to reflect tables, and the remaining included
    dialect that can benefit from this approach will be the SQL Server dialect. The
    MySQL/MariaDB and SQLite dialects by contrast make use of non-relational systems
    to reflect database tables, and were not subject to a pre-existing performance
    issue.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 重新架构最直接适用于利用 SELECT 查询系统目录表以反射表的方言，并且剩下的包括可以受益于这种方法的方言将是 SQL Server 方言。相比之下，MySQL/MariaDB
    和 SQLite 方言利用非关系系统反射数据库表，并且没有受到现有性能问题的影响。
- en: The new API is backwards compatible with the previous system, and should require
    no changes to third party dialects to retain compatibility; third party dialects
    can also opt into the new system by implementing batched queries for schema reflection.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 API 与之前的系统向后兼容，并且不需要对第三方方言进行任何更改以保持兼容性；第三方方言也可以通过实现批量查询来选择加入新系统以进行模式反射。
- en: Along with this change, the API and behavior of the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object has been improved and enhanced
    with more consistent cross-dialect behaviors as well as new methods and new performance
    features.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这一变化，[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 对象的 API 和行为已经改进和增强，具有更一致的跨方言行为以及新的方法和性能特性。
- en: Performance Overview
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能概览
- en: 'The source distribution includes a script `test/perf/many_table_reflection.py`
    which benches both existing reflection features as well as new ones. A limited
    set of its tests may be run on older versions of SQLAlchemy, where here we use
    it to illustrate differences in performance to invoke `metadata.reflect()` to
    reflect 250 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects at once over a local network connection:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 源分发包括一个脚本`test/perf/many_table_reflection.py`，它对现有的反射功能和新功能进行基准测试。其中一部分测试可以在较旧版本的
    SQLAlchemy 上运行，在这里我们使用它来说明性能差异，调用`metadata.reflect()`一次性反射 250 个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象在本地网络连接上：
- en: '| Dialect | Operation | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '| 方言 | 操作 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg2 | `metadata.reflect()`，250 个表 | 8.2 | 3.3 |'
- en: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '| oracle+cx_oracle | `metadata.reflect()`，250 个表 | 60.4 | 6.8 |'
- en: Behavioral Changes for `Inspector()`
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Inspector()` 的行为变化'
- en: 'For SQLAlchemy-included dialects for SQLite, PostgreSQL, MySQL/MariaDB, Oracle,
    and SQL Server, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence"), [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index"), [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") now all behave consistently
    in terms of caching: they all fully cache their result after being called the
    first time for a particular [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object. Programs that create or drop
    tables/sequences while calling upon the same [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object will not receive updated status
    after the state of the database has changed. A call to [`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache") or a new [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") should be used when DDL changes are
    to be executed. Previously, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence") methods did not implement
    caching nor did the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") support caching for these methods, while
    the [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") methods were, leading
    to inconsistent results between the two types of method.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含在SQLite、PostgreSQL、MySQL/MariaDB、Oracle和SQL Server中的SQLAlchemy方言，[`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table")、[`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence")、[`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index")、[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names")现在在缓存方面都表现一致：在第一次为特定的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象调用后，它们都完全缓存其结果。当调用相同的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象创建或删除表/序列时，程序将不会在数据库状态发生更改后收到更新的状态。当要执行DDL更改时，应使用调用[`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache")或新的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")。之前，[`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table")、[`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence")方法没有实现缓存，也没有[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")支持这些方法的缓存，而[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names")方法是，导致两种类型的方法之间的结果不一致。
- en: Behavior for third party dialects is dependent on whether or not they implement
    the “reflection cache” decorator for the dialect-level implementation of these
    methods.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三方方言的行为取决于它们是否实现了“反射缓存”装饰器来实现这些方法的方言级实现。
- en: New Methods and Improvements for `Inspector()`
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的方法和改进`Inspector()`的行为
- en: added a method [`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema") that returns if a schema
    is present in the target database
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法[`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema")，用于返回目标数据库中是否存在模式。
- en: added a method [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index") that returns if a table has
    a particular index.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法[`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index")，用于返回表是否具有特定索引。
- en: Inspection methods such as [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") that work on a single table
    at a time should now all consistently raise [`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError") if a table or view is not found; this change
    is specific to individual dialects, so may not be the case for existing third-party
    dialects.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如[`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")之类的检查方法现在在一次只处理一个表时，如果未找到表或视图，将一致引发[`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError")；此更改特定于各个方言，因此对于现有的第三方方言可能不适用。
- en: Separated the handling of “views” and “materialized views”, as in real world
    use cases, these two constructs make use of different DDL for CREATE and DROP;
    this includes that there are now separate [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and [`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“视图”和“物化视图”的处理分开，因为在实际用例中，这两个构造使用不同的DDL来进行CREATE和DROP；现在有单独的[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names")和[`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names")方法。
- en: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)'
- en: Performance Overview
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能概述
- en: 'The source distribution includes a script `test/perf/many_table_reflection.py`
    which benches both existing reflection features as well as new ones. A limited
    set of its tests may be run on older versions of SQLAlchemy, where here we use
    it to illustrate differences in performance to invoke `metadata.reflect()` to
    reflect 250 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects at once over a local network connection:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码分发包括一个脚本`test/perf/many_table_reflection.py`，该脚本对现有的反射功能以及新功能进行基准测试。其一部分测试可以在较旧版本的SQLAlchemy上运行，我们在这里使用它来说明在本地网络连接上一次性反射250个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象时调用`metadata.reflect()`的性能差异：
- en: '| Dialect | Operation | SQLA 1.4 Time (secs) | SQLA 2.0 Time (secs) |'
  id: totrans-834
  prefs: []
  type: TYPE_TB
  zh: '| 方言 | 操作 | SQLA 1.4 时间（秒） | SQLA 2.0 时间（秒） |'
- en: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '| postgresql+psycopg2 | `metadata.reflect()`, 250 tables | 8.2 | 3.3 |'
- en: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '| oracle+cx_oracle | `metadata.reflect()`, 250 tables | 60.4 | 6.8 |'
- en: Behavioral Changes for `Inspector()`
  id: totrans-837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Inspector()`的行为变化'
- en: 'For SQLAlchemy-included dialects for SQLite, PostgreSQL, MySQL/MariaDB, Oracle,
    and SQL Server, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence"), [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index"), [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") now all behave consistently
    in terms of caching: they all fully cache their result after being called the
    first time for a particular [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object. Programs that create or drop
    tables/sequences while calling upon the same [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object will not receive updated status
    after the state of the database has changed. A call to [`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache") or a new [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") should be used when DDL changes are
    to be executed. Previously, the [`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table"), [`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence") methods did not implement
    caching nor did the [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") support caching for these methods, while
    the [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names") methods were, leading
    to inconsistent results between the two types of method.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含在SQLite、PostgreSQL、MySQL/MariaDB、Oracle和SQL Server中的SQLAlchemy内置方言，[`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table")，[`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence")，[`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index")，[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names")现在在缓存方面行为一致：它们在第一次为特定[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象调用后完全缓存其结果。在调用相同的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象时创建或删除表/序列的程序在数据库状态发生变化后将不会接收到更新的状态。当要执行DDL更改时应使用[`Inspector.clear_cache()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.clear_cache
    "sqlalchemy.engine.reflection.Inspector.clear_cache")或一个新的[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")。先前，[`Inspector.has_table()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_table
    "sqlalchemy.engine.reflection.Inspector.has_table")，[`Inspector.has_sequence()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_sequence
    "sqlalchemy.engine.reflection.Inspector.has_sequence")方法未实现缓存，[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")也不支持这些方法的缓存，而[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_sequence_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_sequence_names
    "sqlalchemy.engine.reflection.Inspector.get_sequence_names")方法则是，导致两种方法之间结果不一致。
- en: Behavior for third party dialects is dependent on whether or not they implement
    the “reflection cache” decorator for the dialect-level implementation of these
    methods.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方方言的行为取决于它们是否实现了这些方法的方言级实现的“反射缓存”装饰器。
- en: New Methods and Improvements for `Inspector()`
  id: totrans-840
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的方法和改进对于`Inspector()`而言
- en: added a method [`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema") that returns if a schema
    is present in the target database
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法[`Inspector.has_schema()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_schema
    "sqlalchemy.engine.reflection.Inspector.has_schema")，用于返回目标数据库中是否存在模式
- en: added a method [`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index") that returns if a table has
    a particular index.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个方法[`Inspector.has_index()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.has_index
    "sqlalchemy.engine.reflection.Inspector.has_index")，用于返回表是否具有特定索引。
- en: Inspection methods such as [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") that work on a single table
    at a time should now all consistently raise [`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError") if a table or view is not found; this change
    is specific to individual dialects, so may not be the case for existing third-party
    dialects.
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如[`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")之类的检查方法现在在一次只处理一个表时应一致地引发[`NoSuchTableError`](../core/exceptions.html#sqlalchemy.exc.NoSuchTableError
    "sqlalchemy.exc.NoSuchTableError")，如果未找到表或视图，则此更改特定于各个方言，因此对于现有的第三方方言可能不适用。
- en: Separated the handling of “views” and “materialized views”, as in real world
    use cases, these two constructs make use of different DDL for CREATE and DROP;
    this includes that there are now separate [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") and [`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names") methods.
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“视图”和“物化视图”的处理分开，因为在实际用例中，这两个构造使用不同的DDL来进行CREATE和DROP；现在有单独的[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names")和[`Inspector.get_materialized_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_materialized_view_names
    "sqlalchemy.engine.reflection.Inspector.get_materialized_view_names")方法。
- en: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4379](https://www.sqlalchemy.org/trac/ticket/4379)'
- en: '## Dialect support for psycopg 3 (a.k.a. “psycopg”)'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为psycopg 3（又名“psycopg”）添加方言支持'
- en: Added dialect support for the [psycopg 3](https://pypi.org/project/psycopg/)
    DBAPI, which despite the number “3” now goes by the package name `psycopg`, superseding
    the previous `psycopg2` package that for the time being remains SQLAlchemy’s “default”
    driver for the `postgresql` dialects. `psycopg` is a completely reworked and modernized
    database adapter for PostgreSQL which supports concepts such as prepared statements
    as well as Python asyncio.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 为[psycopg 3](https://pypi.org/project/psycopg/) DBAPI添加了方言支持，尽管现在以包名`psycopg`取代了之前的`psycopg2`包，后者目前仍然是SQLAlchemy“默认”驱动程序的`postgresql`方言。
    `psycopg`是一个完全重做和现代化的用于PostgreSQL的数据库适配器，支持诸如准备语句和Python asyncio等概念。
- en: '`psycopg` is the first DBAPI supported by SQLAlchemy which provides both a
    pep-249 synchronous API as well as an asyncio driver. The same `psycopg` database
    URL may be used with the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") and [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine-creation functions, and the
    corresponding sync or asyncio version of the dialect will be selected automatically.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '`psycopg`是SQLAlchemy支持的第一个DBAPI，它提供了pep-249同步API和一个asyncio驱动程序。 可以使用相同的`psycopg`数据库URL与[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")和[`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine")引擎创建函数，并且相应的同步或asyncio版本的方言将自动选择。'
- en: See also
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[psycopg](../dialects/postgresql.html#postgresql-psycopg)'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '[psycopg](../dialects/postgresql.html#postgresql-psycopg)'
- en: '## Dialect support for oracledb'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为oracledb添加方言支持'
- en: Added dialect support for the [oracledb](https://pypi.org/project/oracledb/)
    DBAPI, which is the renamed, new major release of the popular cx_Oracle driver.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 为[oracledb](https://pypi.org/project/oracledb/) DBAPI添加了方言支持，这是流行的cx_Oracle驱动程序的重命名、新主要版本。
- en: See also
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[python-oracledb](../dialects/oracle.html#oracledb)'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '[python-oracledb](../dialects/oracle.html#oracledb)'
- en: '## New Conditional DDL for Constraints and Indexes'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '## 新的条件DDL用于约束和索引'
- en: 'A new method [`Constraint.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Constraint.ddl_if
    "sqlalchemy.schema.Constraint.ddl_if") and [`Index.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Index.ddl_if
    "sqlalchemy.schema.Index.ddl_if") allows constructs such as [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") and [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") to be rendered conditionally for a given [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), based on the same kinds of criteria that are accepted
    by the `DDLElement.execute_if()` method. In the example below, the CHECK constraint
    and index will only be produced against a PostgreSQL backend:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的方法[`Constraint.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Constraint.ddl_if
    "sqlalchemy.schema.Constraint.ddl_if")和[`Index.ddl_if()`](../core/constraints.html#sqlalchemy.schema.Index.ddl_if
    "sqlalchemy.schema.Index.ddl_if")允许像[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")和[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")这样的构造在给定的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")上有条件地渲染，基于与`DDLElement.execute_if()`方法接受的相同类型的条件。在下面的示例中，CHECK
    约束和索引只会针对 PostgreSQL 后端生成：
- en: '[PRE143]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: See also
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Controlling DDL Generation of Constraints and Indexes](../core/ddl.html#schema-ddl-ddl-if)'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '[控制约束和索引的 DDL 生成](../core/ddl.html#schema-ddl-ddl-if)'
- en: '[#7631](https://www.sqlalchemy.org/trac/ticket/7631)'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7631](https://www.sqlalchemy.org/trac/ticket/7631)'
- en: '## DATE, TIME, DATETIME datatypes now support literal rendering on all backends'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '## DATE、TIME、DATETIME 数据类型现在在所有后端上支持文字渲染'
- en: 'Literal rendering is now implemented for date and time types for backend specific
    compilation, including PostgreSQL and Oracle:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经为后端特定编译实现了日期和时间类型的文字渲染，包括 PostgreSQL 和 Oracle：
- en: '[PRE144]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Previously, such literal rendering only worked when stringifying statements
    without any dialect given; when attempting to render with a dialect-specific type,
    a `NotImplementedError` would be raised, up until SQLAlchemy 1.4.45 where this
    became a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") (part of [#8800](https://www.sqlalchemy.org/trac/ticket/8800)).
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这种文字渲染仅在没有给定方言的情况下将语句字符串化时起作用；当尝试使用特定于方言的类型进行渲染时，会引发`NotImplementedError`，直到
    SQLAlchemy 1.4.45，这变为���[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")（属于[#8800](https://www.sqlalchemy.org/trac/ticket/8800)的一部分）。
- en: The default rendering is modified ISO-8601 rendering (i.e. ISO-8601 with the
    T converted to a space) when using `literal_binds` with the SQL compilers provided
    by the PostgreSQL, MySQL, MariaDB, MSSQL, Oracle dialects. For Oracle, the ISO
    format is wrapped inside of an appropriate TO_DATE() function call. The rendering
    for SQLite is unchanged as this dialect always included string rendering for date
    values.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 PostgreSQL、MySQL、MariaDB、MSSQL、Oracle 方言提供的 SQL 编译器和`literal_binds`时，默认渲染为修改后的
    ISO-8601 渲染（即将 T 转换为空格的 ISO-8601），对于 Oracle，ISO 格式被包装在适当的 TO_DATE() 函数调用中。对于 SQLite，渲染保持不变，因为该方言始终包含日期值的字符串渲染。
- en: '[#5052](https://www.sqlalchemy.org/trac/ticket/5052)'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5052](https://www.sqlalchemy.org/trac/ticket/5052)'
- en: '## Context Manager Support for `Result`, `AsyncResult`'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '## `Result`、`AsyncResult` 的上下文管理器支持'
- en: 'The [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object now supports context manager use, which will ensure the object and its
    underlying cursor is closed at the end of the block. This is useful in particular
    with server side cursors, where it’s important that the open cursor object is
    closed at the end of an operation, even if user-defined exceptions have occurred:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    对象现在支持上下文管理器使用，这将确保对象及其底层游标在块结束时关闭。这在特定于服务器端游标的情况下特别有用，其中重要的是在操作结束时关闭打开的游标对象，即使发生了用户定义的异常：'
- en: '[PRE145]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'With asyncio use, the [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") and [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") have been altered to provide for optional
    async context manager use, as in:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 asyncio 时，[`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") 和 [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 已经修改，以提供可选的异步上下文管理器使用，例如：
- en: '[PRE146]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[#8710](https://www.sqlalchemy.org/trac/ticket/8710)'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8710](https://www.sqlalchemy.org/trac/ticket/8710)'
- en: Behavioral Changes
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变更
- en: This section covers behavioral changes made in SQLAlchemy 2.0 which are not
    otherwise part of the major 1.4->2.0 migration path; changes here are not expected
    to have significant effects on backwards compatibility.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了在SQLAlchemy 2.0中进行的行为更改，这些更改在主要的1.4->2.0迁移路径中不是主要的一部分；这里的更改不应对向后兼容性产生重大影响。
- en: '### New transaction join modes for `Session`'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '### `Session` 的新事务加入模式'
- en: The behavior of “joining an external transaction into a Session” has been revised
    and improved, allowing explicit control over how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will accommodate an incoming [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that already has a transaction and possibly a
    savepoint already established. The new parameter [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") includes a series of option values which can accommodate
    the existing transaction in several ways, most importantly allowing a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to operate in a fully transactional style using savepoints
    exclusively, while leaving the externally initiated transaction non-committed
    and active under all circumstances, allowing test suites to rollback all changes
    that take place within tests.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: “将外部事务加入会话”的行为已经进行了修订和改进，允许显式控制[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将如何适应已经建立了事务和可能已经建立了保存点的传入[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")。新参数[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")包括一系列选项值，可以以多种方式适应现有事务，最重要的是允许[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")仅使用保存点以完全事务化的方式运行，同时在任何情况下都保持外部启动的事务为非提交且处于活动状态，允许测试套件回滚测试中发生的所有更改。
- en: The primary improvement this allows is that the recipe documented at [Joining
    a Session into an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction),
    which also changed from SQLAlchemy 1.3 to 1.4, is now simplified to no longer
    require explicit use of an event handler or any mention of an explicit savepoint;
    by using `join_transaction_mode="create_savepoint"`, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will never affect the state of an incoming transaction,
    and will instead create a savepoint (i.e. “nested transaction”) as its root transaction.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 这一主要改进允许文档中记录的[将会话加入外部事务的方法（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)的步骤，也从SQLAlchemy
    1.3到1.4进行了更改，现在简化为不再需要显式使用事件处理程序或提及显式保存点；通过使用`join_transaction_mode="create_savepoint"`，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")永远不会影响传入事务的状态，而是创建一个保存点（即“嵌套事务”）作为其根事务。
- en: 'The following illustrates part of the example given at [Joining a Session into
    an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction);
    see that section for a full example:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在[将会话加入外部事务的方法（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)给出的示例的部分内容；查看该部分以获取完整示例：
- en: '[PRE147]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The default mode selected for [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") is `"conditional_savepoint"`, which uses `"create_savepoint"`
    behavior if the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is itself already on a savepoint. If the given
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is in a transaction but not a savepoint, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will propagate “rollback” calls but not “commit” calls,
    but will not begin a new savepoint on its own. This behavior is chosen by default
    for its maximum compatibility with older SQLAlchemy versions as well as that it
    does not start a new SAVEPOINT unless the given driver is already making use of
    SAVEPOINT, as support for SAVEPOINT varies not only with specific backend and
    driver but also configurationally.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")的默认模式选择为`"conditional_savepoint"`，如果给定的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")本身已经在保存点上，则使用`"create_savepoint"`行为。如果给定的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")处于事务中但不在保存点上，则[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将传播“rollback”调用但不会传播“commit”调用，但不会自行开始新的保存点。此行为被默认选择，因为它与旧版SQLAlchemy版本的兼容性最大，并且它不会启动新的SAVEPOINT，除非给定的驱动程序已经在使用SAVEPOINT，因为对SAVEPOINT的支持不仅取决于特定的后端和驱动程序，还取决于配置。'
- en: 'The following illustrates a case that worked in SQLAlchemy 1.3, stopped working
    in SQLAlchemy 1.4, and is now restored in SQLAlchemy 2.0:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个案例，该案例在SQLAlchemy 1.3中有效，在SQLAlchemy 1.4中停止工作，现在在SQLAlchemy 2.0中已经恢复：
- en: '[PRE148]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Where above, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is joined to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that has a savepoint started on it; the state
    of these two units remains unchanged after the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has worked with the transaction. In SQLAlchemy 1.3,
    the above case worked because the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would begin a “subtransaction” upon the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which would allow the outer savepoint / transaction
    to remain unaffected for simple cases as above. Since subtransactions were deprecated
    in 1.4 and are now removed in 2.0, this behavior was no longer available. The
    new default behavior improves upon the behavior of “subtransactions” by using
    a real, second SAVEPOINT instead, so that even calls to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") prevent the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from “breaking out” into the externally initiated SAVEPOINT
    or transaction.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")加入到已经启动保存点的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")中；在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")处理事务后，这两个单元的状态保持不变。在SQLAlchemy 1.3中，上述案例有效，因为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上开始一个“子事务”，这将允许外部保存点/事务保持不受影响，就像上面的简单情况一样。由于子事务在1.4中已被弃用并在2.0中已被移除，因此此行为不再可用。新的默认行为通过使用真正的第二个SAVEPOINT来改进“子事务”的行为，因此即使调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")也会阻止[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")“突破”到外部启动的SAVEPOINT或事务。
- en: New code that is joining a transaction-started [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should however select a [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") explicitly, so that the desired behavior is explicitly
    defined.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 将已启动事务的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")加入到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的新代码应明确选择[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")，以便明确定义所��的行为。
- en: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)  ### `str(engine.url)`
    will obfuscate the password by default'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)  ### `str(engine.url)`
    将默认混淆密码'
- en: 'To avoid leakage of database passwords, calling `str()` on a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") will now enable the password obfuscation feature by default.
    Previously, this obfuscation would be in place for `__repr__()` calls but not
    `__str__()`. This change will impact applications and test suites that attempt
    to invoke [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    given the stringified URL from another engine, such as:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据库密码泄露，对 [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    调用 `str()` 现在默认启用密码混淆功能。以前，这种混淆将在 `__repr__()` 调用中生效，但不会在 `__str__()` 中生效。此更改将影响试图从另一个引擎的字符串化
    URL 调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    的应用程序和测试套件，例如：
- en: '[PRE149]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The above engine `e2` will not have the correct password; it will have the obfuscated
    string `"***"`.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎 `e2` 将不会有正确的密码；它将有混淆的字符串 `"***"`。
- en: 'The preferred approach for the above pattern is to pass the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object directly, there’s no need to stringify:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式的首选方法是直接传递 [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    对象，无需进行字符串化：
- en: '[PRE150]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Otherwise, for a stringified URL with cleartext password, use the [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") method, passing the [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") parameter as `False`:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对于具有明文密码的字符串化 URL，请使用 [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") 方法，并将 [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") 参数设置为 `False`：
- en: '[PRE151]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)  ### Stricter rules for
    replacement of Columns in Table objects with same-names, keys'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)  ### 对具有相同名称、键的 Table
    对象中列的替换有更严格的规则'
- en: Stricter rules are in place for appending of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, both moving some previous deprecation warnings
    to exceptions, and preventing some previous scenarios that would cause duplicate
    columns to appear in tables, when [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") were set to `True`, for both programmatic [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construction as well as during reflection operations.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象附加到 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象，现在有更严格的规则，将一些先前的弃用警告移至异常，并阻止一些以前会导致表中出现重复列的情况，当 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") 设置为 `True` 时，无论是在编程时 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 构建还是在反射操作期间。
- en: Under no circumstances should a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object ever have two or more [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with the same name, regardless of what .key
    they have. An edge case where this was still possible was identified and fixed.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论什么情况下，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象都不应该有两个或更多具有相同名称的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，无论它们有什么 .key。识别并修复了仍然可能出现此情况的边缘案例。
- en: Adding a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that has the same name or key as an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will always raise [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError") (a new subclass of [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") in 2.0.0b4) unless additional parameters are present;
    [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") for [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column"), and [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") for construction of a same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as an existing one, with or without reflection being
    used. Previously, there was a deprecation warning in place for this scenario.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向具有与现有 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    相同名称或键的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    添加 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    将始终引发 [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError")（在 2.0.0b4 中是 [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") 的新子类）除非存在其他参数；对于 [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column")，使用 [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column")，以及对于使用反射或不使用反射的构建一个具有相同名称的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table")。此前，该情况已经有了废弃警告。
- en: A warning is now emitted if a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is created, that does include [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table"), where an incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that has no separate [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") would fully replace an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that does have a key, which suggests the operation
    is not what the user intended. This can happen particularly during a secondary
    reflection step, such as `metadata.reflect(extend_existing=True)`. The warning
    suggests that the [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") parameter be set to `False` to prevent this. Previously,
    in 1.4 and earlier, the incoming column would be added **in addition** to the
    existing column. This was a bug and is a behavioral change in 2.0 (as of 2.0.0b4),
    as the previous key will **no longer be present** in the column collection when
    this occurs.
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    时现在会发出警告，如果其中包含 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table")，其中一个没有单独的 [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") 的传入 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 会完全替换具有键的现有 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，这表明操作并非用户意图。这种情况可能特别发生在次要反射步骤期间，例如 `metadata.reflect(extend_existing=True)`。警告建议将
    [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") 参数设置为 `False` 以防止这种情况发生。在之前的版本中（1.4 及更早），传入的列会**额外**添加到现有列中。这是一个错误，并且在
    2.0 中（截至 2.0.0b4）是一种行为变化，因为此时先前的键将**不再存在于**列集合中。
- en: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)  ### ORM Declarative Applies
    Column Orders Differently; Control behavior using `sort_order`'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)  ### ORM 声明式应用列顺序不同；使用
    `sort_order` 控制行为'
- en: 'Declarative has changed the system by which mapped columns that originate from
    mixin or abstract base classes are sorted along with the columns that are on the
    declared class itself to place columns from the declared class first, followed
    by mixin columns. The following mapping:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式已更改了从 mixin 或抽象基类产生的映射列与声明类本身上的列一起排序的系统，以便先将声明类的列放在前面，然后是 mixin 列。以下映射：
- en: '[PRE152]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Produces a CREATE TABLE as follows on 1.4:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4上产生一个CREATE TABLE如下所示：
- en: '[PRE153]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Whereas on 2.0 it produces:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 而在2.0上它产生：
- en: '[PRE154]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'For the specific case above, this can be seen as an improvement, as the primary
    key columns on the `Model` are now where one would typically prefer. However,
    this is no comfort for the application that defined models the other way around,
    as:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述特定情况，这可以被看作是一种改进，因为 `Model` 上的主键列现在位于人们通常更喜欢的位置。然而，对于以其他方式定义模型的应用程序来说，这并不令人感到安慰，因为：
- en: '[PRE155]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'This now produces CREATE TABLE output as:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出为CREATE TABLE如下：
- en: '[PRE156]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'To solve this issue, SQLAlchemy 2.0.4 introduces a new parameter on [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") called [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column"), which is an integer value, defaulting to `0`,
    that can be set to a positive or negative value so that columns are placed before
    or after other columns, as in the example below:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，SQLAlchemy 2.0.4 引入了 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 上的一个新参数 [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column")，它是一个整数值，默认为 `0`，可以设置为正值或负值，以便将列放置在其他列之前或之后，如下例所示：
- en: '[PRE157]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The above model places “id” before all others and “col1” after “id”:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模型将“id”放在所有其他列之前，将“col1”放在“id”之后：
- en: '[PRE158]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Future SQLAlchemy releases may opt to provide an explicit ordering hint for
    the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, as this ordering is ORM specific.  ### The `Sequence` construct reverts
    to not having any explicit default “start” value; impacts MS SQL Server'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的 SQLAlchemy 发布版本可能会选择为 [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造提供一个显式的排序提示，因为这种排序是 ORM 特定的。### `Sequence` 构造恢复为不具有任何显式默认的“start”值；影响
    MS SQL Server
- en: 'Prior to SQLAlchemy 1.4, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct would emit only simple `CREATE SEQUENCE`
    DDL, if no additional arguments were specified:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.4之前，如果未指定任何其他参数，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 构造将只发出简单的 `CREATE SEQUENCE` DDL：
- en: '[PRE159]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'However, as [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    support was added for MS SQL Server, where the default start value is inconveniently
    set to `-2**63`, version 1.4 decided to default the DDL to emit a start value
    of 1, if [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") were not otherwise provided:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于在 MS SQL Server 上添加了 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 的支持，其中默认的起始值不方便设置为 `-2**63`，因此版本 1.4 决定默认情况下发出 DDL
    以发射起始值为1，如果未提供 [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence")：
- en: '[PRE160]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: This change has introduced other complexities, including that when the [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") parameter is included, this default of `1` should
    in fact default to what [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") states, else a min_value that’s below the start_value
    may be seen as contradictory. As looking at this issue started to become a bit
    of a rabbit hole of other various edge cases, we decided to instead revert this
    change and restore the original behavior of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") which is to have no opinion, and just emit CREATE
    SEQUENCE, allowing the database itself to make its decisions on how the various
    parameters of `SEQUENCE` should interact with each other.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改引入了其他复杂性，包括当包括 [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") 参数时，默认值 `1` 实际上应该默认为 [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") 所述的内容，否则，小于 start_value 的 min_value 可能被视为矛盾。由于查看此问题开始变得有点复杂，涉及到其他各种边缘情况，我们决定撤销此更改，并恢复
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    的原始行为，即没有任何意见，只是发出 CREATE SEQUENCE，让数据库本身决定 `SEQUENCE` 的各种参数应如何相互作用。
- en: 'Therefore, to ensure that the start value is 1 on all backends, **the start
    value of 1 may be indicated explicitly**, as below:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保所有后端的起始值都为1，**可以明确指示起始值为1**，如下所示：
- en: '[PRE161]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Beyond all of that, for autogeneration of integer primary keys on modern backends
    including PostgreSQL, Oracle, SQL Server, the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct should be preferred, which also works
    the same way in 1.4 and 2.0 with no changes in behavior.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于现代后端包括PostgreSQL、Oracle、SQL Server上的整数主键的自动生成，应优先使用[`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity")构造，这在1.4和2.0中的行为没有变化。
- en: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)  ### “with_variant()”
    clones the original TypeEngine rather than changing the type'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)  ### “with_variant()”克隆原始TypeEngine而不是更改类型'
- en: The [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method, which is used to apply alternate
    per-database behaviors to a particular type, now returns a copy of the original
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object with the variant information stored internally, rather than wrapping it
    inside the `Variant` class.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")方法，用于将特定数据库的备用行为应用于特定类型，现在返回原始[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象的副本，其中包含内部存储的变体信息，而不是将其包装在`Variant`类中。'
- en: 'While the previous `Variant` approach was able to maintain all the in-Python
    behaviors of the original type using dynamic attribute getters, the improvement
    here is that when calling upon a variant, the returned type remains an instance
    of the original type, which works more smoothly with type checkers such as mypy
    and pylance. Given a program as below:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以前的`Variant`方法能够使用动态属性获取器保持原始类型的所有Python行为，但这里的改进是，调用变体时，返回的类型仍然是原始类型的实例，这更顺畅地与类型检查器如mypy和pylance配合使用。给定以下程序：
- en: '[PRE162]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'A type checker like pyright will now report the type as:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器如pyright现在将报告类型为：
- en: '[PRE163]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: In addition, as illustrated above, multiple dialect names may be passed for
    single type, in particular this is helpful for the pair of `"mysql"` and `"mariadb"`
    dialects which are considered separately as of SQLAlchemy 1.4.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如上所示，可以为单个类型传递多个方言名称，特别是对于被视为分开的"mysql"和"mariadb"方言对，这在SQLAlchemy 1.4中是有帮助的。
- en: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)  ### Python division operator
    performs true division for all backends; added floor division'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)  ### Python除法运算符对所有后端执行真除法；添加了地板除法。'
- en: The Core expression language now supports both “true division” (i.e. the `/`
    Python operator) and “floor division” (i.e. the `//` Python operator) including
    backend-specific behaviors to normalize different databases in this regard.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达式语言现在支持“真除法”（即Python操作符`/`）和“地板除法”（即Python操作符`//`），包括后端特定的行为以规范化这方面不同数据库的行为。
- en: 'Given a “true division” operation against two integer values:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数值进行“真除法”操作：
- en: '[PRE164]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The SQL division operator on PostgreSQL for example normally acts as “floor
    division” when used against integers, meaning the above result would return the
    integer “0”. For this and similar backends, SQLAlchemy now renders the SQL using
    a form which is equivalent towards:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在PostgreSQL上，SQL除法运算符通常在对整数使用时作为“地板除法”运行，这意味着上述结果将返回整数“0”。对于这些和类似的后端，SQLAlchemy现在使用等效于以下形式的SQL来呈现：
- en: '[PRE165]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: With `param_1=5`, `param_2=10`, so that the return expression will be of type
    NUMERIC, typically as the Python value `decimal.Decimal("0.5")`.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 当`param_1=5`，`param_2=10`时，返回表达式将是`NUMERIC`类型，通常作为Python值`decimal.Decimal("0.5")`。
- en: 'Given a “floor division” operation against two integer values:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数值进行“地板除法”操作：
- en: '[PRE166]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The SQL division operator on MySQL and Oracle for example normally acts as
    “true division” when used against integers, meaning the above result would return
    the floating point value “0.5”. For these and similar backends, SQLAlchemy now
    renders the SQL using a form which is equivalent towards:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在MySQL和Oracle上，SQL除法运算符通常在对整数使用时作为“真除法”运行，这意味着上述结果将返回浮点值“0.5”。对于这些和类似的后端，SQLAlchemy现在使用等效于以下形式的SQL来呈现：
- en: '[PRE167]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: With param_1=5, param_2=10, so that the return expression will be of type INTEGER,
    as the Python value `0`.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 当`param_1=5`，`param_2=10`时，返回表达式将是`INTEGER`类型，就像Python值`0`一样。
- en: 'The backwards-incompatible change here would be if an application using PostgreSQL,
    SQL Server, or SQLite which relied on the Python “truediv” operator to return
    an integer value in all cases. Applications which rely upon this behavior should
    instead use the Python “floor division” operator `//` for these operations, or
    for forwards compatibility when using a previous SQLAlchemy version, the floor
    function:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不兼容变化是，如果一个应用程序使用 PostgreSQL、SQL Server 或 SQLite，并依赖于 Python 的“truediv”运算符在所有情况下返回整数值。依赖于这种行为的应用程序应该使用
    Python 的“floor division”运算符 `//` 进行这些操作，或者在使用之前的 SQLAlchemy 版本时，使用 floor 函数以确保向前兼容性。
- en: '[PRE168]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The above form would be needed on any SQLAlchemy version prior to 2.0 in order
    to provide backend-agnostic floor division.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 SQLAlchemy 版本 2.0 之前的版本中，都需要上述形式来提供与后端无关的地板除法。
- en: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)  ### Session raises proactively
    when illegal concurrent or reentrant access is detected'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)  ### 当检测到非法并发或重入访问时，Session
    现在会主动引发异常'
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now trap more errors related to illegal concurrent state changes within multithreaded
    or other concurrent scenarios as well as for event hooks which perform unexpected
    state changes.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")现在可以捕获更多与多线程或其他并发场景中的非法并发状态更改相关的错误，以及执行意外状态更改的事件钩子。'
- en: 'One error that’s been known to occur when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in multiple threads simultaneously is `AttributeError:
    ''NoneType'' object has no attribute ''twophase''`, which is completely cryptic.
    This error occurs when a thread calls [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which internally invokes the `SessionTransaction.close()`
    method to end the transactional context, at the same time that another thread
    is in progress running a query as from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). Within [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), the internal method that acquires a database
    connection for the current transaction first begins by asserting that the session
    is “active”, but after this assertion passes, the concurrent call to [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") interferes with this state which leads to the
    undefined condition above.'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '当一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")在多个线程同时使用时，可能会发生一个错误：`AttributeError:
    ''NoneType'' object has no attribute ''twophase''`，这个错误完全是晦涩的。当一个线程调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时，内部会调用`SessionTransaction.close()`方法来结束事务上下文，与此同时另一个线程正在运行一个查询，如[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")。在[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")中，获取当前事务的数据库连接的内部方法首先会断言会话是“活动的”，但在这个断言通过后，同时调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")会干扰这个状态，导致上述未定义的条件。'
- en: The change applies guards to all state-changing methods surrounding the [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object so that in the above case, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will instead fail as it will seek to change
    the state to one that is disallowed for the duration of the already-in-progress
    method that wants to get the current connection to run a database query.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变对围绕[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象的所有改变状态的方法应用了保护措施，因此在上述情况下，[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法将会失败，因为它试图将状态更改为在已经进行中的方法中不允许的状态，而这个方法想要获取当前连接来运行数据库查询。
- en: 'Using the test script illustrated at [#7433](https://www.sqlalchemy.org/trac/ticket/7433),
    the previous error case looks like:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[#7433](https://www.sqlalchemy.org/trac/ticket/7433)中说明的测试脚本，前面的错误案例看起来像这样：
- en: '[PRE169]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Where the `_connection_for_bind()` method isn’t able to continue since concurrent
    access placed it into an invalid state. Using the new approach, the originator
    of the state change throws the error instead:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 当`_connection_for_bind()`方法由于并发访问而无法继续时。使用新方法，状态更改的发起者会抛出错误：
- en: '[PRE170]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The state transition checks intentionally don’t use explicit locks to detect
    concurrent thread activity, instead relying upon simple attribute set / value
    test operations that inherently fail when unexpected concurrent changes occur.
    The rationale is that the approach can detect illegal state changes that occur
    entirely within a single thread, such as an event handler that runs on session
    transaction events calls a state-changing method that’s not expected, or under
    asyncio if a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were shared among multiple asyncio tasks, as well as
    when using patching-style concurrency approaches such as gevent.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换检查故意不使用显式锁来检测并发线程活动，而是依赖于简单的属性设置/值测试操作，当发生意外的并发更改时会自然失败。其理念是该方法可以检测在单个线程内完全发生的非法状态更改，例如在会话事务事件上运行的事件处理程序调用了不被期望的状态更改方法，或者在asyncio中，如果一个特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")被多个asyncio任务共享，以及在使用诸如gevent之类的补丁样式并发方法时。
- en: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)  ### The SQLite dialect
    uses QueuePool for file-based databases'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)  ### SQLite方言在基于文件的数据库中使用QueuePool'
- en: The SQLite dialect now defaults to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") when a file based database is used. This is set along
    with setting the `check_same_thread` parameter to `False`. It has been observed
    that the previous approach of defaulting to [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool"), which does not hold onto database connections after
    they are released, did in fact have a measurable negative performance impact.
    As always, the pool class is customizable via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于文件的数据库时，SQLite方言现在默认为[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。这是在将`check_same_thread`参数设置为`False`的同时进行的。已经观察到，以前默认为[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")的方法，在释放连接后不会保留数据库连接，实际上确实对性能产生了可测量的负面影响。像往常一样，可以通过[`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine")参数自定义池类。
- en: See also
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '[线程/池行为](../dialects/sqlite.html#pysqlite-threading-pool)'
- en: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)  ### New Oracle FLOAT
    type with binary precision; decimal precision not accepted directly'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)  ### 具有二进制精度的新Oracle FLOAT类型；不能直接接受十进制精度'
- en: 'A new datatype [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") has been added to the Oracle dialect, to accompany
    the addition of [`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    and database-specific [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE"), [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") and [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") datatypes. Oracle’s `FLOAT` accepts a so-called “binary
    precision” parameter that per Oracle documentation is roughly a standard “precision”
    value divided by 0.3103:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle方言添加了新的数据类型[`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT")，以配合[`Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double")和数据库特定的[`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE")、[`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION")和[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL")数据类型的添加。 Oracle的`FLOAT`接受所谓的“二进制精度”参数，根据Oracle文档，这大致是标准“精度”值除以0.3103：
- en: '[PRE171]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: A binary precision value of 126 is synonymous with using the [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") datatype, and a value of 63 is equivalent
    to using the [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    datatype. Other precision values are specific to the [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") type itself.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制精度值 126 等同于使用 [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") 数据类型，而值 63 等效于使用 [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") 数据类型。其他精度值特定于 [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") 类型本身。
- en: 'The SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype also accepts a “precision” parameter, but this is decimal precision which
    is not accepted by Oracle. Rather than attempting to guess the conversion, the
    Oracle dialect will now raise an informative error if [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") is used with a precision value against the Oracle backend.
    To specify a [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype with an explicit precision value for supporting backends, while also
    supporting other backends, use the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method as follows:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    数据类型还接受“精度”参数，但这是十进制精度，Oracle 不接受。Oracle 方言现在将在针对 Oracle 后端使用 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 与精度值时引发信息性错误，而不是尝试猜测转换。要为支持的后端指定具有显式精度值的 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 数据类型，同时还支持其他后端，请使用 [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 方法如下：
- en: '[PRE172]  ### New RANGE / MULTIRANGE support and changes for PostgreSQL backends'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE172]  ### PostgreSQL 后端的新 RANGE / MULTIRANGE 支持和更改'
- en: RANGE / MULTIRANGE support has been fully implemented for psycopg2, psycopg3,
    and asyncpg dialects. The new support uses a new SQLAlchemy-specific [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object that is agnostic of the different
    backends and does not require the use of backend-specific imports or extension
    steps. For multirange support, lists of [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects are used.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 psycopg2、psycopg3 和 asyncpg 方言，已完全实现了 RANGE / MULTIRANGE 支持。新的支持使用一个新的与后端无关的
    SQLAlchemy 特定的 [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象，不需要使用后端特定的导入或扩展步骤。对于多范围支持，使用 [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象的列表。
- en: Code that used the previous psycopg2-specific types should be modified to use
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range"),
    which presents a compatible interface.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 使用先前的 psycopg2 特定类型的代码应修改为使用 [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range")，它提供了兼容的接口。
- en: The [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object also features comparison support
    which mirrors that of PostgreSQL. Implemented so far are [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") and [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") methods which work in the
    same way as the PostgreSQL `@>` and `<@`. Additional operator support may be added
    in future releases.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象还具有与 PostgreSQL 相同的比较支持。到目前为止已经实现了 [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") 和 [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") 方法，它们的工作方式与 PostgreSQL 的
    `@>` 和 `<@` 相同。未来的版本可能会增加其他操作符支持。'
- en: See the documentation at [Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)
    for background on using the new feature.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)文档，了解使用这一新功能的背景。
- en: See also
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '[范围和多范围类型](../dialects/postgresql.html#postgresql-ranges)'
- en: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)  ###
    `match()` operator on PostgreSQL uses `plainto_tsquery()` rather than `to_tsquery()`'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)  ###
    在 PostgreSQL 上，`match()` 运算符使用 `plainto_tsquery()` 而不是 `to_tsquery()`'
- en: The `Operators.match()` function now renders `col @@ plainto_tsquery(expr)`
    on the PostgreSQL backend, rather than `col @@ to_tsquery()`. `plainto_tsquery()`
    accepts plain text whereas `to_tsquery()` accepts specialized query symbols, and
    is therefore less cross-compatible with other backends.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 后端上，`Operators.match()` 函数现在呈现 `col @@ plainto_tsquery(expr)`，而不是
    `col @@ to_tsquery()`。`plainto_tsquery()` 接受纯文本，而 `to_tsquery()` 接受专用查询符号，因此与其他后端的兼容性较差。
- en: All PostgreSQL search functions and operators are available through use of [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to generate PostgreSQL-specific functions and
    [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") (a boolean-typed version of [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")) to generate arbitrary operators, in
    the same manner as they are available in previous versions. See the examples at
    [Full Text Search](../dialects/postgresql.html#postgresql-match).
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    生成 PostgreSQL 特定函数和 [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")（[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 的布尔类型版本）生成任意运算符，可以使用所有 PostgreSQL 搜索函数和操作符，方式与先前版本中提供的方式相同。请参阅
    [全文搜索](../dialects/postgresql.html#postgresql-match) 中的示例。
- en: Existing SQLAlchemy projects that make use of PG-specific directives within
    `Operators.match()` should make use of `func.to_tsquery()` directly. To render
    SQL in exactly the same form as would be present in 1.4, see the version note
    at [Simple plain text matching with match()](../dialects/postgresql.html#postgresql-simple-match).
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Operators.match()` 内的 PG 特定指令的现有 SQLAlchemy 项目应直接使用 `func.to_tsquery()`。要以与
    1.4 中相同的形式呈现 SQL，请参阅 [使用 match() 进行简单的纯文本匹配](../dialects/postgresql.html#postgresql-simple-match)
    的版本说明。
- en: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)  ### New transaction join
    modes for `Session`'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)  ### `Session` 的新事务连接模式'
- en: The behavior of “joining an external transaction into a Session” has been revised
    and improved, allowing explicit control over how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will accommodate an incoming [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that already has a transaction and possibly a
    savepoint already established. The new parameter [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") includes a series of option values which can accommodate
    the existing transaction in several ways, most importantly allowing a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to operate in a fully transactional style using savepoints
    exclusively, while leaving the externally initiated transaction non-committed
    and active under all circumstances, allowing test suites to rollback all changes
    that take place within tests.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: “将外部事务加入到会话中”的行为已经修订和改进，允许对 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 如何适应已经建立了事务和可能已经建立了保存点的传入 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 进行显式控制。新的参数 [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") 包括一系列选项值，可以以几种方式适应现有的事务，最重要的是允许一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 以完全事务性的方式操作，专门使用保存点，同时在所有情况下保持外部启动的事务未提交且处于活动状态，从而允许测试套件回滚在测试中发生的所有更改。
- en: The primary improvement this allows is that the recipe documented at [Joining
    a Session into an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction),
    which also changed from SQLAlchemy 1.3 to 1.4, is now simplified to no longer
    require explicit use of an event handler or any mention of an explicit savepoint;
    by using `join_transaction_mode="create_savepoint"`, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will never affect the state of an incoming transaction,
    and will instead create a savepoint (i.e. “nested transaction”) as its root transaction.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要改进是，文档中记录的 [将会话加入外部事务（例如测试套件）](../orm/session_transaction.html#session-external-transaction)
    的配方，也从 SQLAlchemy 1.3 更改为 1.4，现在简化为不再需要显式使用事件处理程序或任何提及显式保存点；通过使用 `join_transaction_mode="create_savepoint"`，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将永远不会影响传入事务的状态，而是创建一个保存点（即“嵌套事务”）作为其根事务。
- en: 'The following illustrates part of the example given at [Joining a Session into
    an External Transaction (such as for test suites)](../orm/session_transaction.html#session-external-transaction);
    see that section for a full example:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 [将会话加入外部事务（例如测试套件）](../orm/session_transaction.html#session-external-transaction)
    中给出的示例的一部分说明；请参阅该部分以获取完整示例：
- en: '[PRE173]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The default mode selected for [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") is `"conditional_savepoint"`, which uses `"create_savepoint"`
    behavior if the given [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is itself already on a savepoint. If the given
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    is in a transaction but not a savepoint, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will propagate “rollback” calls but not “commit” calls,
    but will not begin a new savepoint on its own. This behavior is chosen by default
    for its maximum compatibility with older SQLAlchemy versions as well as that it
    does not start a new SAVEPOINT unless the given driver is already making use of
    SAVEPOINT, as support for SAVEPOINT varies not only with specific backend and
    driver but also configurationally.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") 的默认模式选择是 `"conditional_savepoint"`，如果给定的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 已经处于保存点上，则使用 `"create_savepoint"` 行为。如果给定的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 处于事务中但不在保存点中，则 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将传播“回滚”调用但不传播“提交”调用，但不会自行开始新的保存点。此行为被默认选择，因为它最大程度地与旧版本的
    SQLAlchemy 兼容，并且它不会启动新的 SAVEPOINT，除非给定的驱动程序已经在使用 SAVEPOINT，因为 SAVEPOINT 的支持不仅与特定的后端和驱动程序有关，还与配置有关。'
- en: 'The following illustrates a case that worked in SQLAlchemy 1.3, stopped working
    in SQLAlchemy 1.4, and is now restored in SQLAlchemy 2.0:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个案例的示例，在 SQLAlchemy 1.3 中有效，在 SQLAlchemy 1.4 中停止工作，并在 SQLAlchemy 2.0 中恢复：
- en: '[PRE174]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Where above, a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is joined to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that has a savepoint started on it; the state
    of these two units remains unchanged after the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has worked with the transaction. In SQLAlchemy 1.3,
    the above case worked because the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would begin a “subtransaction” upon the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), which would allow the outer savepoint / transaction
    to remain unaffected for simple cases as above. Since subtransactions were deprecated
    in 1.4 and are now removed in 2.0, this behavior was no longer available. The
    new default behavior improves upon the behavior of “subtransactions” by using
    a real, second SAVEPOINT instead, so that even calls to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") prevent the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") from “breaking out” into the externally initiated SAVEPOINT
    or transaction.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    加入到具有已启动保存点的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 中后；这两个单元的状态在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 处理事务后保持不变。在 SQLAlchemy 1.3 中，上述情况有效，因为 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将在 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 上开始一个“子事务”，这将允许外部保存点 / 事务保持不受影响，对于上述简单情况而言。由于子事务在
    1.4 中已弃用并在 2.0 中已删除，因此此行为不再可用。新的默认行为通过使用真正的第二个 SAVEPOINT 改进了“子事务”的行为，以便即使调用 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 也会阻止 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") “突破”到外部启动的 SAVEPOINT 或事务。
- en: New code that is joining a transaction-started [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should however select a [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") explicitly, so that the desired behavior is explicitly
    defined.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码将 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    加入到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的事务中时，应明确选择一个 [`Session.join_transaction_mode`](../orm/session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") ，以明确定义所需的行为。
- en: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '[#9015](https://www.sqlalchemy.org/trac/ticket/9015)'
- en: '### `str(engine.url)` will obfuscate the password by default'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '### `str(engine.url)` 将默认混淆密码'
- en: 'To avoid leakage of database passwords, calling `str()` on a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") will now enable the password obfuscation feature by default.
    Previously, this obfuscation would be in place for `__repr__()` calls but not
    `__str__()`. This change will impact applications and test suites that attempt
    to invoke [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    given the stringified URL from another engine, such as:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据库密码泄露，现在在 [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    上调用 `str()` 将默认启用密码混淆功能。之前，此混淆对于 `__repr__()` 调用有效，但对于 `__str__()` 调用无效。此更改将影响尝试使用来自另一个引擎的字符串化
    URL 调用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    的应用程序和测试套件，例如：
- en: '[PRE175]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The above engine `e2` will not have the correct password; it will have the obfuscated
    string `"***"`.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 上述引擎 `e2` 将不会有正确的密码；它将有混淆的字符串 `"***"`。
- en: 'The preferred approach for the above pattern is to pass the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object directly, there’s no need to stringify:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式的首选方法是直接传递 [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    对象，无需转换为字符串：
- en: '[PRE176]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Otherwise, for a stringified URL with cleartext password, use the [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") method, passing the [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") parameter as `False`:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对于具有明文密码的字符串化 URL，请使用 [`URL.render_as_string()`](../core/engines.html#sqlalchemy.engine.URL.render_as_string
    "sqlalchemy.engine.URL.render_as_string") 方法，并将 [`URL.render_as_string.hide_password`](../core/engines.html#sqlalchemy.engine.URL.render_as_string.params.hide_password
    "sqlalchemy.engine.URL.render_as_string") 参数设置为 `False`：
- en: '[PRE177]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8567](https://www.sqlalchemy.org/trac/ticket/8567)'
- en: '### Stricter rules for replacement of Columns in Table objects with same-names,
    keys'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '### 替换具有相同名称和键的 Table 对象中的 Columns 的更严格规则'
- en: Stricter rules are in place for appending of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, both moving some previous deprecation warnings
    to exceptions, and preventing some previous scenarios that would cause duplicate
    columns to appear in tables, when [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") were set to `True`, for both programmatic [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construction as well as during reflection operations.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象附加到 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象，有更严格的规则，将一些先前的弃用警告转移到异常中，并防止一些先前可能导致表中出现重复列的情况，当 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") 设置为 `True` 时，对于编程方式的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 构建以及在反射操作期间。
- en: Under no circumstances should a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object ever have two or more [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects with the same name, regardless of what .key
    they have. An edge case where this was still possible was identified and fixed.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论如何，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象都不应该具有两个或更多具有相同名称的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，无论它们的 .key 如何。已经确定并修复了仍然可能发生此情况的边缘情况。
- en: Adding a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that has the same name or key as an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will always raise [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError") (a new subclass of [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") in 2.0.0b4) unless additional parameters are present;
    [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column") for [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column"), and [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table") for construction of a same-named [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as an existing one, with or without reflection being
    used. Previously, there was a deprecation warning in place for this scenario.
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向具有与现有 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    相同名称或键的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    添加 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    将始终引发 [`DuplicateColumnError`](../core/exceptions.html#sqlalchemy.exc.DuplicateColumnError
    "sqlalchemy.exc.DuplicateColumnError")（在 2.0.0b4 中是 [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") 的新子类），除非存在额外参数；对于 [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column")，使用 [`Table.append_column.replace_existing`](../core/metadata.html#sqlalchemy.schema.Table.append_column.params.replace_existing
    "sqlalchemy.schema.Table.append_column")，以及对于构建具有与现有 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 相同名称的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")（使用或不使用反射）时使用 [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table")。此前，针对此情况已经放置了弃用警告。
- en: A warning is now emitted if a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") is created, that does include [`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing
    "sqlalchemy.schema.Table"), where an incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that has no separate [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") would fully replace an existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that does have a key, which suggests the operation
    is not what the user intended. This can happen particularly during a secondary
    reflection step, such as `metadata.reflect(extend_existing=True)`. The warning
    suggests that the [`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace
    "sqlalchemy.schema.Table") parameter be set to `False` to prevent this. Previously,
    in 1.4 and earlier, the incoming column would be added **in addition** to the
    existing column. This was a bug and is a behavioral change in 2.0 (as of 2.0.0b4),
    as the previous key will **no longer be present** in the column collection when
    this occurs.
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果创建了一个包含[`Table.extend_existing`](../core/metadata.html#sqlalchemy.schema.Table.params.extend_existing)的[`Table`](../core/metadata.html#sqlalchemy.schema.Table)，并且存在一个没有单独的[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key)的传入[`Column`](../core/metadata.html#sqlalchemy.schema.Column)，该传入的[`Column`](../core/metadata.html#sqlalchemy.schema.Column)将完全替换具有键的现有[`Column`](../core/metadata.html#sqlalchemy.schema.Column)，这表明操作不是用户所期望的。这在特别是在次要反射步骤期间可能发生，例如`metadata.reflect(extend_existing=True)`。警告建议将[`Table.autoload_replace`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_replace)参数设置为`False`以防止这种情况发生。在1.4及以前的版本中，传入的列会**额外**添加到现有列中。这是一个错误，在2.0（截至2.0.0b4）中是一种行为变更，因为在这种情况发生时，以前的键将**不再存在**于列集合中。
- en: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[#8925](https://www.sqlalchemy.org/trac/ticket/8925)'
- en: '### ORM Declarative Applies Column Orders Differently; Control behavior using
    `sort_order`'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM 声明式不同的列顺序应用方式；使用`sort_order`控制行为'
- en: 'Declarative has changed the system by which mapped columns that originate from
    mixin or abstract base classes are sorted along with the columns that are on the
    declared class itself to place columns from the declared class first, followed
    by mixin columns. The following mapping:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式已更改了来自混合或抽象基类的映射列与声明类本身上的列一起排序的系统，以便首先放置来自声明类的列，然后是混合列。以下映射：
- en: '[PRE178]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Produces a CREATE TABLE as follows on 1.4:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4上产生的CREATE TABLE如下：
- en: '[PRE179]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Whereas on 2.0 it produces:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 而在2.0上它产生：
- en: '[PRE180]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'For the specific case above, this can be seen as an improvement, as the primary
    key columns on the `Model` are now where one would typically prefer. However,
    this is no comfort for the application that defined models the other way around,
    as:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述特定情况，这可以视为一种改进，因为`Model`上的主键列现在位于人们通常更喜欢的位置。然而，对于以相反方式定义模型的应用程序来说，这并没有什么安慰，因为：
- en: '[PRE181]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'This now produces CREATE TABLE output as:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将产生以下CREATE TABLE输出：
- en: '[PRE182]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'To solve this issue, SQLAlchemy 2.0.4 introduces a new parameter on [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") called [`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order
    "sqlalchemy.orm.mapped_column"), which is an integer value, defaulting to `0`,
    that can be set to a positive or negative value so that columns are placed before
    or after other columns, as in the example below:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 为解决此问题，SQLAlchemy 2.0.4 引入了[`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column)上的一个新参数，称为[`mapped_column.sort_order`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.sort_order)，它是一个整数值，默认为`0`，可以设置为正值或负值，以便将列放置在其他列之前或之后，如下例所示：
- en: '[PRE183]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The above model places “id” before all others and “col1” after “id”:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模型将“id”放置在所有其他列之前，将“col1”放置在“id”之后：
- en: '[PRE184]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Future SQLAlchemy releases may opt to provide an explicit ordering hint for
    the [`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, as this ordering is ORM specific.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的SQLAlchemy版本可能选择为[`mapped_column`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column)构造提供显式排序提示，因为此排序是ORM特定的。
- en: '### The `Sequence` construct reverts to not having any explicit default “start”
    value; impacts MS SQL Server'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '### `Sequence` 构造不再具有任何显式默认的“start”值；影响 MS SQL Server'
- en: 'Prior to SQLAlchemy 1.4, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct would emit only simple `CREATE SEQUENCE`
    DDL, if no additional arguments were specified:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 1.4 之前，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 构造将仅在未指定其他参数时发出简单的 `CREATE SEQUENCE` DDL：
- en: '[PRE185]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'However, as [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    support was added for MS SQL Server, where the default start value is inconveniently
    set to `-2**63`, version 1.4 decided to default the DDL to emit a start value
    of 1, if [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") were not otherwise provided:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于为 MS SQL Server 添加了 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 支持，其中默认起始值不方便地设置为 `-2**63`，版本 1.4 决定将 DDL 默认为发出起始值为
    1，如果未提供 [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence")：
- en: '[PRE186]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This change has introduced other complexities, including that when the [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") parameter is included, this default of `1` should
    in fact default to what [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") states, else a min_value that’s below the start_value
    may be seen as contradictory. As looking at this issue started to become a bit
    of a rabbit hole of other various edge cases, we decided to instead revert this
    change and restore the original behavior of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") which is to have no opinion, and just emit CREATE
    SEQUENCE, allowing the database itself to make its decisions on how the various
    parameters of `SEQUENCE` should interact with each other.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改引入了其他复杂性，包括当包含 [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") 参数时，默认值为 `1` 实际上应默认为 [`Sequence.min_value`](../core/defaults.html#sqlalchemy.schema.Sequence.params.min_value
    "sqlalchemy.schema.Sequence") 所述的内容，否则，将看到低于 start_value 的 min_value 可能被视为矛盾。由于研究此问题开始变得有点复杂，包括各种其他边缘情况，我们决定撤消此更改，并恢复
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    的原始行为，即不表达任何观点，只是发出 CREATE SEQUENCE，允许数据库本身决定如何处理 `SEQUENCE` 的各种参数之间的交互。
- en: 'Therefore, to ensure that the start value is 1 on all backends, **the start
    value of 1 may be indicated explicitly**, as below:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保所有后端的起始值都为 1，**可能需要显式指定起始值为 1**，如下所示：
- en: '[PRE187]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Beyond all of that, for autogeneration of integer primary keys on modern backends
    including PostgreSQL, Oracle, SQL Server, the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct should be preferred, which also works
    the same way in 1.4 and 2.0 with no changes in behavior.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在现代后端（包括 PostgreSQL、Oracle、SQL Server）上自动生成整数主键时，应优先使用 [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") 构造，在 1.4 和 2.0 中也以相同方式工作，行为没有任何更改。
- en: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7211](https://www.sqlalchemy.org/trac/ticket/7211)'
- en: '### “with_variant()” clones the original TypeEngine rather than changing the
    type'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '### “with_variant()” 克隆原始 TypeEngine 而不是更改类型'
- en: The [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method, which is used to apply alternate
    per-database behaviors to a particular type, now returns a copy of the original
    [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object with the variant information stored internally, rather than wrapping it
    inside the `Variant` class.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 方法用于将特定类型应用于数据库的备用行为，现在返回原始 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 对象的副本，并在内部存储变体信息，而不是将其包装在 `Variant` 类中。'
- en: 'While the previous `Variant` approach was able to maintain all the in-Python
    behaviors of the original type using dynamic attribute getters, the improvement
    here is that when calling upon a variant, the returned type remains an instance
    of the original type, which works more smoothly with type checkers such as mypy
    and pylance. Given a program as below:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以前的 `Variant` 方法能够使用动态属性获取器维护原始类型的所有 Python 行为，但这里的改进是，当调用变体时，返回的类型仍然是原始类型的实例，这与诸如
    mypy 和 pylance 的类型检查器更加顺畅地配合。给定以下程序：
- en: '[PRE188]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'A type checker like pyright will now report the type as:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器如 pyright 现在将报告类型为：
- en: '[PRE189]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: In addition, as illustrated above, multiple dialect names may be passed for
    single type, in particular this is helpful for the pair of `"mysql"` and `"mariadb"`
    dialects which are considered separately as of SQLAlchemy 1.4.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如上所示，对于单个类型，可以传递多个方言名称，特别是对于被视为分开的“mysql”和“mariadb”方言的成对，这对于 SQLAlchemy 1.4
    很有帮助。
- en: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '[#6980](https://www.sqlalchemy.org/trac/ticket/6980)'
- en: '### Python division operator performs true division for all backends; added
    floor division'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '### Python 除法运算符对所有后端执行真除法；添加地板除法'
- en: The Core expression language now supports both “true division” (i.e. the `/`
    Python operator) and “floor division” (i.e. the `//` Python operator) including
    backend-specific behaviors to normalize different databases in this regard.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 核心表达式语言现在支持“真除法”（即 `/` Python 运算符）和“地板除法”（即 `//` Python 运算符），包括标准化此方面不同数据库的后端特定行为。
- en: 'Given a “true division” operation against two integer values:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数值进行“真除法”操作：
- en: '[PRE190]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The SQL division operator on PostgreSQL for example normally acts as “floor
    division” when used against integers, meaning the above result would return the
    integer “0”. For this and similar backends, SQLAlchemy now renders the SQL using
    a form which is equivalent towards:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 上的 SQL 除法运算符通常在对整数进行操作时作为“地板除法”（floor division）操作，意味着以上结果将返回整数“0”。对于此类后端，SQLAlchemy
    现在使用等效于以下形式的 SQL 来渲染 SQL：
- en: '[PRE191]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: With `param_1=5`, `param_2=10`, so that the return expression will be of type
    NUMERIC, typically as the Python value `decimal.Decimal("0.5")`.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `param_1=5`，`param_2=10`，以便返回表达式将是 NUMERIC 类型，通常为 Python 值 `decimal.Decimal("0.5")`。
- en: 'Given a “floor division” operation against two integer values:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个整数值进行“地板除法”操作：
- en: '[PRE192]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The SQL division operator on MySQL and Oracle for example normally acts as
    “true division” when used against integers, meaning the above result would return
    the floating point value “0.5”. For these and similar backends, SQLAlchemy now
    renders the SQL using a form which is equivalent towards:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 和 Oracle 上的 SQL 除法运算符通常在对整数进行操作时作为“真除法”（true division）操作，意味着以上结果将返回浮点值“0.5”。对于这些和类似的后端，SQLAlchemy
    现在使用等效于以下形式的 SQL 渲染 SQL：
- en: '[PRE193]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: With param_1=5, param_2=10, so that the return expression will be of type INTEGER,
    as the Python value `0`.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 param_1=5，param_2=10，以便返回表达式将是整数类型，就像 Python 值 `0` 一样。
- en: 'The backwards-incompatible change here would be if an application using PostgreSQL,
    SQL Server, or SQLite which relied on the Python “truediv” operator to return
    an integer value in all cases. Applications which rely upon this behavior should
    instead use the Python “floor division” operator `//` for these operations, or
    for forwards compatibility when using a previous SQLAlchemy version, the floor
    function:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的不兼容变更将是，如果一个应用程序使用 PostgreSQL、SQL Server 或 SQLite，并且依赖于 Python 的“truediv”运算符在所有情况下返回整数值。依赖于此行为的应用程序应该使用
    Python 的“地板除法”运算符 `//` 进行这些操作，或者在使用之前的 SQLAlchemy 版本时进行前向兼容，使用 floor 函数：
- en: '[PRE194]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The above form would be needed on any SQLAlchemy version prior to 2.0 in order
    to provide backend-agnostic floor division.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 版本 2.0 之前的任何版本中，将需要上述形式以提供与后端无关的地板除法。
- en: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4926](https://www.sqlalchemy.org/trac/ticket/4926)'
- en: '### Session raises proactively when illegal concurrent or reentrant access
    is detected'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '### Session 主动提出当检测到非法并发或重入访问时'
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now trap more errors related to illegal concurrent state changes within multithreaded
    or other concurrent scenarios as well as for event hooks which perform unexpected
    state changes.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在可以更全面地捕获与多线程或其他并发场景中的非法并发状态更改相关的错误，以及执行意外状态更改的事件钩子。'
- en: 'One error that’s been known to occur when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is used in multiple threads simultaneously is `AttributeError:
    ''NoneType'' object has no attribute ''twophase''`, which is completely cryptic.
    This error occurs when a thread calls [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which internally invokes the `SessionTransaction.close()`
    method to end the transactional context, at the same time that another thread
    is in progress running a query as from [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). Within [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), the internal method that acquires a database
    connection for the current transaction first begins by asserting that the session
    is “active”, but after this assertion passes, the concurrent call to [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") interferes with this state which leads to the
    undefined condition above.'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '已知的一个错误是当一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")同时在多个线程中使用时会出现`AttributeError:
    ''NoneType'' object has no attribute ''twophase''`，这完全是神秘的。当一个线程调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时，内部调用`SessionTransaction.close()`方法来结束事务上下文，与此同时另一个线程正在运行一个查询，如[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")。在[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")中，获取当前事务的数据库连接的内部方法首先开始断言会话是“活动的”，但在此断言通过后，同时进行的对[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的调用干扰了这种状态，导致上述未定义的条件。'
- en: The change applies guards to all state-changing methods surrounding the [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object so that in the above case, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will instead fail as it will seek to change
    the state to one that is disallowed for the duration of the already-in-progress
    method that wants to get the current connection to run a database query.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 更改将应用到围绕[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象的所有更改状态方法的保护措施，以便在上述情况下，[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法将会失败，因为它将试图将状态更改为在已经进行中的方法期间不允许的状态，而该方法希望获取当前连接以运行数据库查询。
- en: 'Using the test script illustrated at [#7433](https://www.sqlalchemy.org/trac/ticket/7433),
    the previous error case looks like:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[#7433](https://www.sqlalchemy.org/trac/ticket/7433)中展示的测试脚本，先前的错误案例如下：
- en: '[PRE195]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Where the `_connection_for_bind()` method isn’t able to continue since concurrent
    access placed it into an invalid state. Using the new approach, the originator
    of the state change throws the error instead:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 当`_connection_for_bind()`方法无法继续运行时，因为并发访问使其处于无效状态。使用新方法，状态更改的发起者会抛出错误：
- en: '[PRE196]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The state transition checks intentionally don’t use explicit locks to detect
    concurrent thread activity, instead relying upon simple attribute set / value
    test operations that inherently fail when unexpected concurrent changes occur.
    The rationale is that the approach can detect illegal state changes that occur
    entirely within a single thread, such as an event handler that runs on session
    transaction events calls a state-changing method that’s not expected, or under
    asyncio if a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were shared among multiple asyncio tasks, as well as
    when using patching-style concurrency approaches such as gevent.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换检查故意不使用显式锁来检测并发线程活动，而是依赖于简单的属性设置/值测试操作，当发生意外的并发更改时会自然失败。其理念是该方法可以检测到完全发生在单个线程内的非法状态更改，例如运行在会话事务事件上的事件处理程序调用了一个未预期的改变状态的方法，或者在asyncio中，如果一个特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")被多个asyncio任务共享，以及在使用类似gevent的补丁式并发方法时。
- en: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7433](https://www.sqlalchemy.org/trac/ticket/7433)'
- en: '### The SQLite dialect uses QueuePool for file-based databases'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '### SQLite方言使用QueuePool用于基于文件的数据库'
- en: The SQLite dialect now defaults to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") when a file based database is used. This is set along
    with setting the `check_same_thread` parameter to `False`. It has been observed
    that the previous approach of defaulting to [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool"), which does not hold onto database connections after
    they are released, did in fact have a measurable negative performance impact.
    As always, the pool class is customizable via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于文件的数据库时，SQLite 方言现在默认为 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。这与将 `check_same_thread` 参数设置为 `False` 一起设置。已观察到以前默认为
    [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool "sqlalchemy.pool.NullPool")
    的方法，在释放连接后不保留数据库连接，事实上会产生可测量的负面性能影响。与以往一样，池类可通过 [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") 参数进行自定义。
- en: See also
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Threading/Pooling Behavior](../dialects/sqlite.html#pysqlite-threading-pooling)'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '[线程/池行为](../dialects/sqlite.html#pysqlite-threading-pooling)'
- en: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7490](https://www.sqlalchemy.org/trac/ticket/7490)'
- en: '### New Oracle FLOAT type with binary precision; decimal precision not accepted
    directly'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 Oracle FLOAT 类型，带有二进制精度；不直接接受十进制精度'
- en: 'A new datatype [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") has been added to the Oracle dialect, to accompany
    the addition of [`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    and database-specific [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE"), [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") and [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") datatypes. Oracle’s `FLOAT` accepts a so-called “binary
    precision” parameter that per Oracle documentation is roughly a standard “precision”
    value divided by 0.3103:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 方言现已添加了新的数据类型 [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT")，以配合 [`Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double") 和数据库特定的 [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE
    "sqlalchemy.types.DOUBLE")、[`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") 和 [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") 数据类型的添加。Oracle 的 `FLOAT` 接受所谓的“二进制精度”参数，根据 Oracle 文档，这大致是标准“精度”值除以
    0.3103：
- en: '[PRE197]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: A binary precision value of 126 is synonymous with using the [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") datatype, and a value of 63 is equivalent
    to using the [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    datatype. Other precision values are specific to the [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") type itself.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制精度值 126 等同于使用 [`DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") 数据类型，而值 63 相当于使用 [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL") 数据类型。其他精度值是特定于 [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") 类型本身的。
- en: 'The SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype also accepts a “precision” parameter, but this is decimal precision which
    is not accepted by Oracle. Rather than attempting to guess the conversion, the
    Oracle dialect will now raise an informative error if [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") is used with a precision value against the Oracle backend.
    To specify a [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    datatype with an explicit precision value for supporting backends, while also
    supporting other backends, use the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method as follows:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    数据类型也接受“precision”参数，但这是十进制精度，Oracle 不接受。与其试图猜测转换，Oracle 方言现在将在针对 Oracle 后端使用带有精度值的
    [`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    时引发一个信息性错误。要为支持的后端指定带有显式精度值的 [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") 数据类型，同时还支持其他后端，请使用以下方法：[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")。
- en: '[PRE198]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '### New RANGE / MULTIRANGE support and changes for PostgreSQL backends'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '### PostgreSQL 后端的新 RANGE / MULTIRANGE 支持和更改'
- en: RANGE / MULTIRANGE support has been fully implemented for psycopg2, psycopg3,
    and asyncpg dialects. The new support uses a new SQLAlchemy-specific [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object that is agnostic of the different
    backends and does not require the use of backend-specific imports or extension
    steps. For multirange support, lists of [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects are used.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 psycopg2、psycopg3 和 asyncpg 方言，已完全实现了 RANGE / MULTIRANGE 支持。新的支持使用了一个新的 SQLAlchemy
    特定的 [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象，该对象对不同的后端是不可知的，不需要使用特定于后端的导入或扩展步骤。对于多范围支持，使用
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    对象的列表。
- en: Code that used the previous psycopg2-specific types should be modified to use
    [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range"),
    which presents a compatible interface.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的 psycopg2 特定类型的代码应该修改为使用 [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range")，这提供了一个兼容的接口。
- en: The [`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object also features comparison support
    which mirrors that of PostgreSQL. Implemented so far are [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") and [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") methods which work in the
    same way as the PostgreSQL `@>` and `<@`. Additional operator support may be added
    in future releases.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Range`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") 对象还具有与 PostgreSQL 相同的比较支持。目前已实现的是 [`Range.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contains
    "sqlalchemy.dialects.postgresql.Range.contains") 和 [`Range.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.Range.contained_by
    "sqlalchemy.dialects.postgresql.Range.contained_by") 方法，其工作方式与 PostgreSQL 中的 `@>`
    和 `<@` 相同。将来的版本可能会添加更多的运算符支持。'
- en: See the documentation at [Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)
    for background on using the new feature.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[范围和多范围类型](../dialects/postgresql.html#postgresql-ranges)的文档，了解如何使用这个新功能的背景知识。
- en: See also
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Range and Multirange Types](../dialects/postgresql.html#postgresql-ranges)'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '[范围和多范围类型](../dialects/postgresql.html#postgresql-ranges)'
- en: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7156](https://www.sqlalchemy.org/trac/ticket/7156) [#8706](https://www.sqlalchemy.org/trac/ticket/8706)'
- en: '### `match()` operator on PostgreSQL uses `plainto_tsquery()` rather than `to_tsquery()`'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '### PostgreSQL 上的 `match()` 运算符使用 `plainto_tsquery()` 而不是 `to_tsquery()`'
- en: The `Operators.match()` function now renders `col @@ plainto_tsquery(expr)`
    on the PostgreSQL backend, rather than `col @@ to_tsquery()`. `plainto_tsquery()`
    accepts plain text whereas `to_tsquery()` accepts specialized query symbols, and
    is therefore less cross-compatible with other backends.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operators.match()` 函数现在在 PostgreSQL 后端上呈现为 `col @@ plainto_tsquery(expr)`，而不是
    `col @@ to_tsquery()`。`plainto_tsquery()` 接受纯文本，而 `to_tsquery()` 接受专用的查询符号，因此与其他后端的兼容性较差。'
- en: All PostgreSQL search functions and operators are available through use of [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") to generate PostgreSQL-specific functions and
    [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") (a boolean-typed version of [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")) to generate arbitrary operators, in
    the same manner as they are available in previous versions. See the examples at
    [Full Text Search](../dialects/postgresql.html#postgresql-match).
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 PostgreSQL 搜索函数和运算符都可以通过使用 [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") 来生成 PostgreSQL 特定的函数和 [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op")（`Operators.op()` 的布尔类型版本）来生成任意运算符，方式与之前的版本中可用的方式相同。请参阅[全文搜索](../dialects/postgresql.html#postgresql-match)中的示例。
- en: Existing SQLAlchemy projects that make use of PG-specific directives within
    `Operators.match()` should make use of `func.to_tsquery()` directly. To render
    SQL in exactly the same form as would be present in 1.4, see the version note
    at [Simple plain text matching with match()](../dialects/postgresql.html#postgresql-simple-match).
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的使用`Operators.match()`内置 PG 指令的 SQLAlchemy 项目应直接使用`func.to_tsquery()`。要以与
    1.4 中相同的形式呈现 SQL，请参阅[使用 match() 进行简单纯文本匹配](../dialects/postgresql.html#postgresql-simple-match)的版本说明。
- en: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '[#7086](https://www.sqlalchemy.org/trac/ticket/7086)'
