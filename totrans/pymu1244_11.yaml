- en: Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/recipes-text.html](https://pymupdf.readthedocs.io/en/latest/recipes-text.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## How to Extract all Document Text'
  prefs: []
  type: TYPE_NORMAL
- en: This script will take a document filename and generate a text file from all
    of its text.
  prefs: []
  type: TYPE_NORMAL
- en: The document can be any [supported type](how-to-open-a-file.html#supported-file-types).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script works as a command line tool which expects the document filename
    supplied as a parameter. It generates one text file named “filename.txt” in the
    script directory. Text of pages is separated by a form feed character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output will be plain text as it is coded in the document. No effort is made
    to prettify in any way. Specifically for PDF, this may mean output not in usual
    reading order, unexpected line breaks and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have many options to rectify this – see chapter [Appendix 2: Considerations
    on Embedded Files](app2.html#appendix2). Among them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract text in HTML format and store it as a HTML document, so it can be viewed
    in any browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract text as a list of text blocks via *Page.get_text(“blocks”)*. Each item
    of this list contains position information for its text, which can be used to
    establish a convenient reading order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract a list of single words via *Page.get_text(“words”)*. Its items are words
    with position information. Use it to determine text contained in a given rectangle
    – see next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the following two sections for examples and further explanations.  ## How
    to Extract Text as Markdown'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially useful for RAG/LLM environments - please see [Outputting
    as Markdown](rag.html#rag-outputting-as-md).  ## How to Extract Key-Value Pairs
    from a Page'
  prefs: []
  type: TYPE_NORMAL
- en: If the layout of a page is *“predictable”* in some sense, then there is a simple
    way to find the values for a given set of keywords fast and easily – without using
    regular expressions. Please see [this example script](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/text-extraction/lookup-keywords.py).
  prefs: []
  type: TYPE_NORMAL
- en: '“Predictable” in this context means:'
  prefs: []
  type: TYPE_NORMAL
- en: Every keyword is followed by its value – no other text is present in between
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom of the value’s boundary box is **not above** the one of the keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are **no other restrictions**: the page layout may or may not be fixed,
    and the text may also have been stored as one string. Key and value may have any
    distance from each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following five key-value pairs will be correctly identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]  ## How to Extract Text from within a Rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: There is now (v1.18.0) more than one way to achieve this. We therefore have
    created a [folder](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/textbox-extraction)
    in the PyMuPDF-Utilities repository specifically dealing with this topic.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Extract Text in Natural Reading Order'
  prefs: []
  type: TYPE_NORMAL
- en: One of the common issues with PDF text extraction is, that text may not appear
    in any particular reading order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the responsibility of the PDF creator (software or a human). For example,
    page headers may have been inserted in a separate step – after the document had
    been produced. In such a case, the header text will appear at the end of a page
    text extraction (although it will be correctly shown by PDF viewer software).
    For example, the following snippet will add some header and footer lines to an
    existing PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The text sequence extracted from a page modified in this way will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: original text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: header line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: footer line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PyMuPDF has several means to re-establish some reading sequence or even to
    re-generate a layout close to the original:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `sort` parameter of [`Page.get_text()`](page.html#Page.get_text "Page.get_text").
    It will sort the output from top-left to bottom-right (ignored for XHTML, HTML
    and XML output).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `pymupdf` module in CLI: `python -m pymupdf gettext ...`, which produces
    a text file where text has been re-arranged in layout-preserving mode. Many options
    are available to control the output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also use the above mentioned [script](https://github.com/pymupdf/PyMuPDF/wiki/How-to-extract-text-from-a-rectangle)
    with your modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Extract Table Content from Documents'
  prefs: []
  type: TYPE_NORMAL
- en: If you see a table in a document, you are normally not looking at something
    like an embedded Excel or other identifiable object. It usually is just normal,
    standard text, formatted to appear as tabular data.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting tabular data from such a page area therefore means that you must
    find a way to **identify** the table area (i.e. its boundary box), then **(1)**
    graphically indicate table and column borders, and **(2)** then extract text based
    on this information.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a very complex task, depending on details like the presence or absence
    of lines, rectangles or other supporting vector graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Method [`Page.find_tables()`](page.html#Page.find_tables "Page.find_tables")
    does all that for you, with a high table detection precision. Its great advantage
    is that there are no external library dependencies, nor the need to employ artificial
    intelligence or machine learning technologies. It also provides an integrated
    interface to the well-known Python package for data analysis [pandas](https://pypi.org/project/pandas/).
  prefs: []
  type: TYPE_NORMAL
- en: Please have a look at example [Jupyter notebooks](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/table-analysis),
    which cover standard situations like multiple tables on one page or joining table
    fragments across multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Mark Extracted Text'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard search function to search for arbitrary text on a page:
    [`Page.search_for()`](page.html#Page.search_for "Page.search_for"). It returns
    a list of [Rect](rect.html#rect) objects which surround a found occurrence. These
    rectangles can for example be used to automatically insert annotations which visibly
    mark the found text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method has advantages and drawbacks. Pros are:'
  prefs: []
  type: TYPE_NORMAL
- en: The search string can contain blanks and wrap across lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upper or lower case characters are treated equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word hyphenation at line ends is detected and resolved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return may also be a list of [Quad](quad.html#quad) objects to precisely locate
    text that is **not parallel** to either axis – using [Quad](quad.html#quad) output
    is also recommended, when page rotation is not zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But you also have other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This script uses `Page.get_text("words")` to look for a string, handed in via
    cli parameter. This method separates a page’s text into “words” using white spaces
    as delimiters. Further remarks:'
  prefs: []
  type: TYPE_NORMAL
- en: If found, the **complete word containing the string** is marked (underlined)
    – not only the search string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search string may **not contain word delimiters**. By default, word delimiters
    are white spaces and the non-breaking space `chr(0xA0)`. If you use extra delimiting
    characters like `page.get_text("words", delimiters="./,")` then none of these
    characters should be included in your search string either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown here, upper / lower cases are **respected**. But this can be changed
    by using the string method *lower()* (or even regular expressions) in function
    *mark_word*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is **no upper limit**: all occurrences will be detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use **anything** to mark the word: ‘Underline’, ‘Highlight’, ‘StrikeThrough’
    or ‘Square’ annotations, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example snippet of a page of this manual, where “MuPDF” has been
    used as the search string. Note that all strings **containing “MuPDF”** have been
    completely underlined (not just the search string).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![_images/img-markedpdf.jpg](../Images/0448b9e0acc8a3e3d876ad65a6a528d8.png)](_images/img-markedpdf.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Mark Searched Text'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script searches for text and marks it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-textmarker.jpg](../Images/95f5e2d18ebc68755eca6121258dbcd4.png)](_images/img-textmarker.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Mark Non-horizontal Text'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section already shows an example for marking non-horizontal text,
    that was detected by text **searching**.
  prefs: []
  type: TYPE_NORMAL
- en: 'But text **extraction** with the “dict” / “rawdict” options of [`Page.get_text()`](page.html#Page.get_text
    "Page.get_text") may also return text with a non-zero angle to the x-axis. This
    is indicated by the value of the line dictionary’s `"dir"` key: it is the tuple
    `(cosine, sine)` for that angle. If `line["dir"] != (1, 0)`, then the text of
    all its spans is rotated by (the same) angle != 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “bboxes” returned by the method however are rectangles only – not quads.
    So, to mark span text correctly, its quad must be recovered from the data contained
    in the line and span dictionary. Do this with the following utility function (new
    in v1.18.9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to **mark the complete line** or a subset of its spans in one go,
    use the following snippet (works for v1.18.10 or later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-linequad.jpg](../Images/0e11012d738da2691155d336685c97f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The `spans` argument above may specify any sub-list of `line["spans"]`. In the
    example above, the second to second-to-last span are marked. If omitted, the complete
    line is taken.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Analyze Font Characteristics'
  prefs: []
  type: TYPE_NORMAL
- en: 'To analyze the characteristics of text in a PDF use this elementary script
    as a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the PDF page and the script output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-pdftext.jpg](../Images/ea9fe46f4058406ffd5d30e00fc4a158.png)](_images/img-pdftext.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Insert Text'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyMuPDF provides ways to insert text on new or existing PDF pages with the
    following features:'
  prefs: []
  type: TYPE_NORMAL
- en: choose the font, including built-in fonts and fonts that are available as files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: choose text characteristics like bold, italic, font size, font color, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'position the text in multiple ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: either as simple line-oriented output starting at a certain point,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: or fitting text in a box provided as a rectangle, in which case text alignment
    choices are also available,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: choose whether text should be put in foreground (overlay existing content),
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all text can be arbitrarily “morphed”, i.e. its appearance can be changed via
    a [Matrix](matrix.html#matrix), to achieve effects like scaling, shearing or mirroring,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: independently from morphing and in addition to that, text can be rotated by
    integer multiples of 90 degrees.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the above is provided by three basic [Page](page.html#page), resp. [Shape](shape.html#shape)
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Page.insert_font()`](page.html#Page.insert_font "Page.insert_font") – install
    a font for the page for later reference. The result is reflected in the output
    of [`Document.get_page_fonts()`](document.html#Document.get_page_fonts "Document.get_page_fonts").
    The font can be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: provided as a file,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: via [Font](font.html#font) (then use [`Font.buffer`](font.html#Font.buffer "Font.buffer"))
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: already present somewhere in **this or another** PDF, or
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: be a **built-in** font.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Page.insert_text()`](page.html#Page.insert_text "Page.insert_text") – write
    some lines of text. Internally, this uses [`Shape.insert_text()`](shape.html#Shape.insert_text
    "Shape.insert_text").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Page.insert_textbox()`](page.html#Page.insert_textbox "Page.insert_textbox")
    – fit text in a given rectangle. Here you can choose text alignment features (left,
    right, centered, justified) and you keep control as to whether text actually fits.
    Internally, this uses [`Shape.insert_textbox()`](shape.html#Shape.insert_textbox
    "Shape.insert_textbox").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both text insertion methods automatically install the font as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '### How to Write Text Lines'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output some text lines on a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this method, only the **number of lines** will be controlled to not go
    beyond page height. Surplus lines will not be written and the number of actual
    lines will be returned. The calculation uses a line height calculated from the
    [`fontsize`](glossary.html#fontsize "fontsize") and 36 points (0.5 inches) as
    bottom margin.
  prefs: []
  type: TYPE_NORMAL
- en: Line **width is ignored**. The surplus part of a line will simply be invisible.
  prefs: []
  type: TYPE_NORMAL
- en: However, for built-in fonts there are ways to calculate the line width beforehand
    - see [`get_text_length()`](functions.html#get_text_length "get_text_length").
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example. It inserts 4 text strings using the four different
    rotation options, and thereby explains, how the text insertion point must be chosen
    to achieve the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-inserttext.jpg](../Images/d9072bb6d96d3c7d885c9abbc01b8215.png)](_images/img-inserttext.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ### How to Fill a Text Box'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script fills 4 different rectangles with text, each time choosing a different
    rotation value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Some default values were used above: font size 11 and text alignment “left”.
    The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-rotate.png](../Images/50131384349202b34e4bddbe97be8b9e.png)](_images/img-rotate.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ### How to Fill a Box with HTML Text'
  prefs: []
  type: TYPE_NORMAL
- en: Method [`Page.insert_htmlbox()`](page.html#Page.insert_htmlbox "Page.insert_htmlbox")
    offers a **much more powerful** way to insert text in a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simple, plain text, this method accepts HTML source, which may not
    only contain HTML tags but also styling instructions to influence things like
    font, font weight (bold) and style (italic), color and much more.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to mix multiple fonts and languages, to output HTML tables
    and to insert images and URI links.
  prefs: []
  type: TYPE_NORMAL
- en: For even more styling flexibility, an additional CSS source may also be given.
  prefs: []
  type: TYPE_NORMAL
- en: The method is based on the [Story](story-class.html#story) class. Therefore,
    complex script systems like Devanagari, Nepali, Tamil and many are supported and
    written correctly thanks to using the HarfBuzz library - which provides this so-called
    **“text shaping”** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Any required fonts to output characters are automatically pulled in from the
    Google NOTO font library - as a fallback (when the – optionally supplied – user
    font(s) do not contain some glyphs).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a small glimpse into the features offered here, we will output the following
    HTML-enriched text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Please note how the “css” parameter is used to globally select the default “sans-serif”
    font and a font size of 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox1.png](../Images/bcef64ba7d5e99097a0f6a33f9761d15.png)'
  prefs: []
  type: TYPE_IMG
- en: How to output HTML tables and images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is another example that outputs a table with this method. This time, we
    are including all the styling in the HTML source itself. Please also note, how
    it works to include an image - even within a table cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox2.png](../Images/9b0a83fc8dc8d1d74e653eb50bd1c77c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Output Languages of the World
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our third example will demonstrate the automatic multi-language support. It
    includes automatic **text shaping** for complex scripting systems like Devanagari
    and right-to-left languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox3.png](../Images/c791fadfc6af4734847fac7b1a1eaa89.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Specify your Own Fonts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define your font files in CSS syntax using the `@font-face` statement. You need
    a separate `@font-face` for every combination of font weight and font style (e.g.
    bold or italic) you want to be supported. The following example uses the famous
    MS Comic Sans font in its four variants regular, bold, italic and bold-italic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As these four font files are located in the system’s folder `C:/Windows/Fonts`
    the method needs an [Archive](archive-class.html#archive) definition that points
    to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox4.png](../Images/b9d7da6fbd0fc897ce70e3eae0f7bd0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Request Text Alignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example combines multiple requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the text by 90 degrees anti-clockwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a font from package [pymupdf-fonts](https://pypi.org/project/pymupdf-fonts/).
    You will see that the respective CSS definitions are a lot easier in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align the text with the “justify” option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox5.png](../Images/f9acc6e6e085886a6aa315bc922e711c.png)
    ## How to Extract Text with Color'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through your text blocks and find the spans of text you need for this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)
    ## How to Extract all Document Text'
  prefs: []
  type: TYPE_NORMAL
- en: This script will take a document filename and generate a text file from all
    of its text.
  prefs: []
  type: TYPE_NORMAL
- en: The document can be any [supported type](how-to-open-a-file.html#supported-file-types).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script works as a command line tool which expects the document filename
    supplied as a parameter. It generates one text file named “filename.txt” in the
    script directory. Text of pages is separated by a form feed character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output will be plain text as it is coded in the document. No effort is made
    to prettify in any way. Specifically for PDF, this may mean output not in usual
    reading order, unexpected line breaks and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have many options to rectify this – see chapter [Appendix 2: Considerations
    on Embedded Files](app2.html#appendix2). Among them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract text in HTML format and store it as a HTML document, so it can be viewed
    in any browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract text as a list of text blocks via *Page.get_text(“blocks”)*. Each item
    of this list contains position information for its text, which can be used to
    establish a convenient reading order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract a list of single words via *Page.get_text(“words”)*. Its items are words
    with position information. Use it to determine text contained in a given rectangle
    – see next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the following two sections for examples and further explanations.
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Extract Text as Markdown'
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful for RAG/LLM environments - please see [Outputting
    as Markdown](rag.html#rag-outputting-as-md).
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Extract Key-Value Pairs from a Page'
  prefs: []
  type: TYPE_NORMAL
- en: If the layout of a page is *“predictable”* in some sense, then there is a simple
    way to find the values for a given set of keywords fast and easily – without using
    regular expressions. Please see [this example script](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/text-extraction/lookup-keywords.py).
  prefs: []
  type: TYPE_NORMAL
- en: '“Predictable” in this context means:'
  prefs: []
  type: TYPE_NORMAL
- en: Every keyword is followed by its value – no other text is present in between
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom of the value’s boundary box is **not above** the one of the keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are **no other restrictions**: the page layout may or may not be fixed,
    and the text may also have been stored as one string. Key and value may have any
    distance from each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following five key-value pairs will be correctly identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '## How to Extract Text from within a Rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: There is now (v1.18.0) more than one way to achieve this. We therefore have
    created a [folder](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/textbox-extraction)
    in the PyMuPDF-Utilities repository specifically dealing with this topic.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Extract Text in Natural Reading Order'
  prefs: []
  type: TYPE_NORMAL
- en: One of the common issues with PDF text extraction is, that text may not appear
    in any particular reading order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the responsibility of the PDF creator (software or a human). For example,
    page headers may have been inserted in a separate step – after the document had
    been produced. In such a case, the header text will appear at the end of a page
    text extraction (although it will be correctly shown by PDF viewer software).
    For example, the following snippet will add some header and footer lines to an
    existing PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The text sequence extracted from a page modified in this way will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: original text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: header line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: footer line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PyMuPDF has several means to re-establish some reading sequence or even to
    re-generate a layout close to the original:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `sort` parameter of [`Page.get_text()`](page.html#Page.get_text "Page.get_text").
    It will sort the output from top-left to bottom-right (ignored for XHTML, HTML
    and XML output).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `pymupdf` module in CLI: `python -m pymupdf gettext ...`, which produces
    a text file where text has been re-arranged in layout-preserving mode. Many options
    are available to control the output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also use the above mentioned [script](https://github.com/pymupdf/PyMuPDF/wiki/How-to-extract-text-from-a-rectangle)
    with your modifications.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Extract Table Content from Documents'
  prefs: []
  type: TYPE_NORMAL
- en: If you see a table in a document, you are normally not looking at something
    like an embedded Excel or other identifiable object. It usually is just normal,
    standard text, formatted to appear as tabular data.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting tabular data from such a page area therefore means that you must
    find a way to **identify** the table area (i.e. its boundary box), then **(1)**
    graphically indicate table and column borders, and **(2)** then extract text based
    on this information.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a very complex task, depending on details like the presence or absence
    of lines, rectangles or other supporting vector graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Method [`Page.find_tables()`](page.html#Page.find_tables "Page.find_tables")
    does all that for you, with a high table detection precision. Its great advantage
    is that there are no external library dependencies, nor the need to employ artificial
    intelligence or machine learning technologies. It also provides an integrated
    interface to the well-known Python package for data analysis [pandas](https://pypi.org/project/pandas/).
  prefs: []
  type: TYPE_NORMAL
- en: Please have a look at example [Jupyter notebooks](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/table-analysis),
    which cover standard situations like multiple tables on one page or joining table
    fragments across multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Mark Extracted Text'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard search function to search for arbitrary text on a page:
    [`Page.search_for()`](page.html#Page.search_for "Page.search_for"). It returns
    a list of [Rect](rect.html#rect) objects which surround a found occurrence. These
    rectangles can for example be used to automatically insert annotations which visibly
    mark the found text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method has advantages and drawbacks. Pros are:'
  prefs: []
  type: TYPE_NORMAL
- en: The search string can contain blanks and wrap across lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upper or lower case characters are treated equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Word hyphenation at line ends is detected and resolved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return may also be a list of [Quad](quad.html#quad) objects to precisely locate
    text that is **not parallel** to either axis – using [Quad](quad.html#quad) output
    is also recommended, when page rotation is not zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But you also have other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This script uses `Page.get_text("words")` to look for a string, handed in via
    cli parameter. This method separates a page’s text into “words” using white spaces
    as delimiters. Further remarks:'
  prefs: []
  type: TYPE_NORMAL
- en: If found, the **complete word containing the string** is marked (underlined)
    – not only the search string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search string may **not contain word delimiters**. By default, word delimiters
    are white spaces and the non-breaking space `chr(0xA0)`. If you use extra delimiting
    characters like `page.get_text("words", delimiters="./,")` then none of these
    characters should be included in your search string either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown here, upper / lower cases are **respected**. But this can be changed
    by using the string method *lower()* (or even regular expressions) in function
    *mark_word*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is **no upper limit**: all occurrences will be detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use **anything** to mark the word: ‘Underline’, ‘Highlight’, ‘StrikeThrough’
    or ‘Square’ annotations, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is an example snippet of a page of this manual, where “MuPDF” has been
    used as the search string. Note that all strings **containing “MuPDF”** have been
    completely underlined (not just the search string).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![_images/img-markedpdf.jpg](../Images/0448b9e0acc8a3e3d876ad65a6a528d8.png)](_images/img-markedpdf.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Mark Searched Text'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script searches for text and marks it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-textmarker.jpg](../Images/95f5e2d18ebc68755eca6121258dbcd4.png)](_images/img-textmarker.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Mark Non-horizontal Text'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section already shows an example for marking non-horizontal text,
    that was detected by text **searching**.
  prefs: []
  type: TYPE_NORMAL
- en: 'But text **extraction** with the “dict” / “rawdict” options of [`Page.get_text()`](page.html#Page.get_text
    "Page.get_text") may also return text with a non-zero angle to the x-axis. This
    is indicated by the value of the line dictionary’s `"dir"` key: it is the tuple
    `(cosine, sine)` for that angle. If `line["dir"] != (1, 0)`, then the text of
    all its spans is rotated by (the same) angle != 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “bboxes” returned by the method however are rectangles only – not quads.
    So, to mark span text correctly, its quad must be recovered from the data contained
    in the line and span dictionary. Do this with the following utility function (new
    in v1.18.9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to **mark the complete line** or a subset of its spans in one go,
    use the following snippet (works for v1.18.10 or later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-linequad.jpg](../Images/0e11012d738da2691155d336685c97f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The `spans` argument above may specify any sub-list of `line["spans"]`. In the
    example above, the second to second-to-last span are marked. If omitted, the complete
    line is taken.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Analyze Font Characteristics'
  prefs: []
  type: TYPE_NORMAL
- en: 'To analyze the characteristics of text in a PDF use this elementary script
    as a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the PDF page and the script output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-pdftext.jpg](../Images/ea9fe46f4058406ffd5d30e00fc4a158.png)](_images/img-pdftext.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Insert Text'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyMuPDF provides ways to insert text on new or existing PDF pages with the
    following features:'
  prefs: []
  type: TYPE_NORMAL
- en: choose the font, including built-in fonts and fonts that are available as files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: choose text characteristics like bold, italic, font size, font color, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'position the text in multiple ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: either as simple line-oriented output starting at a certain point,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: or fitting text in a box provided as a rectangle, in which case text alignment
    choices are also available,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: choose whether text should be put in foreground (overlay existing content),
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all text can be arbitrarily “morphed”, i.e. its appearance can be changed via
    a [Matrix](matrix.html#matrix), to achieve effects like scaling, shearing or mirroring,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: independently from morphing and in addition to that, text can be rotated by
    integer multiples of 90 degrees.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the above is provided by three basic [Page](page.html#page), resp. [Shape](shape.html#shape)
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Page.insert_font()`](page.html#Page.insert_font "Page.insert_font") – install
    a font for the page for later reference. The result is reflected in the output
    of [`Document.get_page_fonts()`](document.html#Document.get_page_fonts "Document.get_page_fonts").
    The font can be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: provided as a file,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: via [Font](font.html#font) (then use [`Font.buffer`](font.html#Font.buffer "Font.buffer"))
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: already present somewhere in **this or another** PDF, or
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: be a **built-in** font.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Page.insert_text()`](page.html#Page.insert_text "Page.insert_text") – write
    some lines of text. Internally, this uses [`Shape.insert_text()`](shape.html#Shape.insert_text
    "Shape.insert_text").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Page.insert_textbox()`](page.html#Page.insert_textbox "Page.insert_textbox")
    – fit text in a given rectangle. Here you can choose text alignment features (left,
    right, centered, justified) and you keep control as to whether text actually fits.
    Internally, this uses [`Shape.insert_textbox()`](shape.html#Shape.insert_textbox
    "Shape.insert_textbox").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both text insertion methods automatically install the font as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '### How to Write Text Lines'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output some text lines on a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this method, only the **number of lines** will be controlled to not go
    beyond page height. Surplus lines will not be written and the number of actual
    lines will be returned. The calculation uses a line height calculated from the
    [`fontsize`](glossary.html#fontsize "fontsize") and 36 points (0.5 inches) as
    bottom margin.
  prefs: []
  type: TYPE_NORMAL
- en: Line **width is ignored**. The surplus part of a line will simply be invisible.
  prefs: []
  type: TYPE_NORMAL
- en: However, for built-in fonts there are ways to calculate the line width beforehand
    - see [`get_text_length()`](functions.html#get_text_length "get_text_length").
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example. It inserts 4 text strings using the four different
    rotation options, and thereby explains, how the text insertion point must be chosen
    to achieve the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-inserttext.jpg](../Images/d9072bb6d96d3c7d885c9abbc01b8215.png)](_images/img-inserttext.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ### How to Fill a Text Box'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script fills 4 different rectangles with text, each time choosing a different
    rotation value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Some default values were used above: font size 11 and text alignment “left”.
    The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-rotate.png](../Images/50131384349202b34e4bddbe97be8b9e.png)](_images/img-rotate.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ### How to Fill a Box with HTML Text'
  prefs: []
  type: TYPE_NORMAL
- en: Method [`Page.insert_htmlbox()`](page.html#Page.insert_htmlbox "Page.insert_htmlbox")
    offers a **much more powerful** way to insert text in a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simple, plain text, this method accepts HTML source, which may not
    only contain HTML tags but also styling instructions to influence things like
    font, font weight (bold) and style (italic), color and much more.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to mix multiple fonts and languages, to output HTML tables
    and to insert images and URI links.
  prefs: []
  type: TYPE_NORMAL
- en: For even more styling flexibility, an additional CSS source may also be given.
  prefs: []
  type: TYPE_NORMAL
- en: The method is based on the [Story](story-class.html#story) class. Therefore,
    complex script systems like Devanagari, Nepali, Tamil and many are supported and
    written correctly thanks to using the HarfBuzz library - which provides this so-called
    **“text shaping”** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Any required fonts to output characters are automatically pulled in from the
    Google NOTO font library - as a fallback (when the – optionally supplied – user
    font(s) do not contain some glyphs).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a small glimpse into the features offered here, we will output the following
    HTML-enriched text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Please note how the “css” parameter is used to globally select the default “sans-serif”
    font and a font size of 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox1.png](../Images/bcef64ba7d5e99097a0f6a33f9761d15.png)'
  prefs: []
  type: TYPE_IMG
- en: How to output HTML tables and images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is another example that outputs a table with this method. This time, we
    are including all the styling in the HTML source itself. Please also note, how
    it works to include an image - even within a table cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox2.png](../Images/9b0a83fc8dc8d1d74e653eb50bd1c77c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Output Languages of the World
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our third example will demonstrate the automatic multi-language support. It
    includes automatic **text shaping** for complex scripting systems like Devanagari
    and right-to-left languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox3.png](../Images/c791fadfc6af4734847fac7b1a1eaa89.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Specify your Own Fonts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define your font files in CSS syntax using the `@font-face` statement. You need
    a separate `@font-face` for every combination of font weight and font style (e.g.
    bold or italic) you want to be supported. The following example uses the famous
    MS Comic Sans font in its four variants regular, bold, italic and bold-italic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As these four font files are located in the system’s folder `C:/Windows/Fonts`
    the method needs an [Archive](archive-class.html#archive) definition that points
    to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox4.png](../Images/b9d7da6fbd0fc897ce70e3eae0f7bd0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Request Text Alignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example combines multiple requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the text by 90 degrees anti-clockwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a font from package [pymupdf-fonts](https://pypi.org/project/pymupdf-fonts/).
    You will see that the respective CSS definitions are a lot easier in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align the text with the “justify” option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox5.png](../Images/f9acc6e6e085886a6aa315bc922e711c.png)
    ### How to Write Text Lines'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output some text lines on a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this method, only the **number of lines** will be controlled to not go
    beyond page height. Surplus lines will not be written and the number of actual
    lines will be returned. The calculation uses a line height calculated from the
    [`fontsize`](glossary.html#fontsize "fontsize") and 36 points (0.5 inches) as
    bottom margin.
  prefs: []
  type: TYPE_NORMAL
- en: Line **width is ignored**. The surplus part of a line will simply be invisible.
  prefs: []
  type: TYPE_NORMAL
- en: However, for built-in fonts there are ways to calculate the line width beforehand
    - see [`get_text_length()`](functions.html#get_text_length "get_text_length").
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example. It inserts 4 text strings using the four different
    rotation options, and thereby explains, how the text insertion point must be chosen
    to achieve the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-inserttext.jpg](../Images/d9072bb6d96d3c7d885c9abbc01b8215.png)](_images/img-inserttext.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '### How to Fill a Text Box'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script fills 4 different rectangles with text, each time choosing a different
    rotation value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Some default values were used above: font size 11 and text alignment “left”.
    The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-rotate.png](../Images/50131384349202b34e4bddbe97be8b9e.png)](_images/img-rotate.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '### How to Fill a Box with HTML Text'
  prefs: []
  type: TYPE_NORMAL
- en: Method [`Page.insert_htmlbox()`](page.html#Page.insert_htmlbox "Page.insert_htmlbox")
    offers a **much more powerful** way to insert text in a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simple, plain text, this method accepts HTML source, which may not
    only contain HTML tags but also styling instructions to influence things like
    font, font weight (bold) and style (italic), color and much more.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to mix multiple fonts and languages, to output HTML tables
    and to insert images and URI links.
  prefs: []
  type: TYPE_NORMAL
- en: For even more styling flexibility, an additional CSS source may also be given.
  prefs: []
  type: TYPE_NORMAL
- en: The method is based on the [Story](story-class.html#story) class. Therefore,
    complex script systems like Devanagari, Nepali, Tamil and many are supported and
    written correctly thanks to using the HarfBuzz library - which provides this so-called
    **“text shaping”** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Any required fonts to output characters are automatically pulled in from the
    Google NOTO font library - as a fallback (when the – optionally supplied – user
    font(s) do not contain some glyphs).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a small glimpse into the features offered here, we will output the following
    HTML-enriched text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Please note how the “css” parameter is used to globally select the default “sans-serif”
    font and a font size of 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox1.png](../Images/bcef64ba7d5e99097a0f6a33f9761d15.png)'
  prefs: []
  type: TYPE_IMG
- en: How to output HTML tables and images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is another example that outputs a table with this method. This time, we
    are including all the styling in the HTML source itself. Please also note, how
    it works to include an image - even within a table cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox2.png](../Images/9b0a83fc8dc8d1d74e653eb50bd1c77c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Output Languages of the World
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our third example will demonstrate the automatic multi-language support. It
    includes automatic **text shaping** for complex scripting systems like Devanagari
    and right-to-left languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox3.png](../Images/c791fadfc6af4734847fac7b1a1eaa89.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Specify your Own Fonts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define your font files in CSS syntax using the `@font-face` statement. You need
    a separate `@font-face` for every combination of font weight and font style (e.g.
    bold or italic) you want to be supported. The following example uses the famous
    MS Comic Sans font in its four variants regular, bold, italic and bold-italic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As these four font files are located in the system’s folder `C:/Windows/Fonts`
    the method needs an [Archive](archive-class.html#archive) definition that points
    to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox4.png](../Images/b9d7da6fbd0fc897ce70e3eae0f7bd0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Request Text Alignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example combines multiple requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the text by 90 degrees anti-clockwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a font from package [pymupdf-fonts](https://pypi.org/project/pymupdf-fonts/).
    You will see that the respective CSS definitions are a lot easier in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align the text with the “justify” option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox5.png](../Images/f9acc6e6e085886a6aa315bc922e711c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to output HTML tables and images
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is another example that outputs a table with this method. This time, we
    are including all the styling in the HTML source itself. Please also note, how
    it works to include an image - even within a table cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox2.png](../Images/9b0a83fc8dc8d1d74e653eb50bd1c77c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Output Languages of the World
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our third example will demonstrate the automatic multi-language support. It
    includes automatic **text shaping** for complex scripting systems like Devanagari
    and right-to-left languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-htmlbox3.png](../Images/c791fadfc6af4734847fac7b1a1eaa89.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Specify your Own Fonts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define your font files in CSS syntax using the `@font-face` statement. You need
    a separate `@font-face` for every combination of font weight and font style (e.g.
    bold or italic) you want to be supported. The following example uses the famous
    MS Comic Sans font in its four variants regular, bold, italic and bold-italic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As these four font files are located in the system’s folder `C:/Windows/Fonts`
    the method needs an [Archive](archive-class.html#archive) definition that points
    to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox4.png](../Images/b9d7da6fbd0fc897ce70e3eae0f7bd0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to Request Text Alignment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This example combines multiple requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotate the text by 90 degrees anti-clockwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a font from package [pymupdf-fonts](https://pypi.org/project/pymupdf-fonts/).
    You will see that the respective CSS definitions are a lot easier in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align the text with the “justify” option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/img-htmlbox5.png](../Images/f9acc6e6e085886a6aa315bc922e711c.png)
    ## How to Extract Text with Color'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through your text blocks and find the spans of text you need for this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
