# å³æ—¶ç¼–è¯‘

> åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/jit-compilation.html`](https://jax.readthedocs.io/en/latest/jit-compilation.html)

åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†è¿›ä¸€æ­¥æ¢è®¨ JAX çš„å·¥ä½œåŸç†ï¼Œä»¥åŠå¦‚ä½•ä½¿å…¶æ€§èƒ½å“è¶Šã€‚æˆ‘ä»¬å°†è®¨è®º `jax.jit()` å˜æ¢ï¼Œå®ƒå°† JAX Python å‡½æ•°è¿›è¡Œå³æ—¶ç¼–è¯‘ï¼Œä»¥ä¾¿åœ¨ XLA ä¸­é«˜æ•ˆæ‰§è¡Œã€‚

## å¦‚ä½•å·¥ä½œ JAX å˜æ¢

åœ¨å‰ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº† JAX å…è®¸æˆ‘ä»¬è½¬æ¢ Python å‡½æ•°çš„èƒ½åŠ›ã€‚JAX é€šè¿‡å°†æ¯ä¸ªå‡½æ•°å‡å°‘ä¸ºä¸€ç³»åˆ—åŸå§‹æ“ä½œæ¥å®ç°è¿™ä¸€ç‚¹ï¼Œæ¯ä¸ªåŸå§‹æ“ä½œä»£è¡¨ä¸€ç§åŸºæœ¬çš„è®¡ç®—å•ä½ã€‚

æŸ¥çœ‹å‡½æ•°èƒŒååŸå§‹æ“ä½œåºåˆ—çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `jax.make_jaxpr()`ï¼š

```py
import jax
import jax.numpy as jnp

global_list = []

def log2(x):
  global_list.append(x)
  ln_x = jnp.log(x)
  ln_2 = jnp.log(2.0)
  return ln_x / ln_2

print(jax.make_jaxpr(log2)(3.0)) 
```

```py
{ lambda ; a:f32[]. let
    b:f32[] = log a
    c:f32[] = log 2.0
    d:f32[] = div b c
  in (d,) } 
```

æ–‡æ¡£çš„ç†è§£ Jaxprs éƒ¨åˆ†æä¾›äº†æœ‰å…³ä¸Šè¿°è¾“å‡ºå«ä¹‰çš„æ›´å¤šä¿¡æ¯ã€‚

é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œjaxpr ä¸æ•è·å‡½æ•°ä¸­å­˜åœ¨çš„å‰¯ä½œç”¨ï¼šå…¶ä¸­æ²¡æœ‰å¯¹ `global_list.append(x)` çš„ä»»ä½•å†…å®¹ã€‚è¿™æ˜¯ä¸€ä¸ªç‰¹æ€§ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªé”™è¯¯ï¼šJAX å˜æ¢æ—¨åœ¨ç†è§£æ— å‰¯ä½œç”¨ï¼ˆä¹Ÿç§°ä¸ºå‡½æ•°çº¯ç²¹ï¼‰çš„ä»£ç ã€‚å¦‚æœ *çº¯å‡½æ•°* å’Œ *å‰¯ä½œç”¨* æ˜¯é™Œç”Ÿçš„æœ¯è¯­ï¼Œè¿™åœ¨ [ğŸ”ª JAX - The Sharp Bits ğŸ”ª: Pure Functions](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions) ä¸­æœ‰ç¨å¾®è¯¦ç»†çš„è§£é‡Šã€‚

éçº¯å‡½æ•°å¾ˆå±é™©ï¼Œå› ä¸ºåœ¨ JAX å˜æ¢ä¸‹å®ƒä»¬å¯èƒ½æ— æ³•æŒ‰é¢„æœŸè¿è¡Œï¼›å®ƒä»¬å¯èƒ½ä¼šæ‚„æ— å£°æ¯åœ°å¤±è´¥ï¼Œæˆ–è€…äº§ç”Ÿæ„å¤–çš„ä¸‹æ¸¸é”™è¯¯ï¼Œå¦‚æ³„æ¼çš„è·Ÿè¸ªå™¨ã€‚æ­¤å¤–ï¼ŒJAX é€šå¸¸æ— æ³•æ£€æµ‹åˆ°æ˜¯å¦å­˜åœ¨å‰¯ä½œç”¨ã€‚ï¼ˆå¦‚æœéœ€è¦è°ƒè¯•æ‰“å°ï¼Œè¯·ä½¿ç”¨ `jax.debug.print()`ã€‚è¦è¡¨è¾¾ä¸€èˆ¬æ€§å‰¯ä½œç”¨è€Œç‰ºç‰²æ€§èƒ½ï¼Œè¯·å‚é˜… `jax.experimental.io_callback()`ã€‚è¦æ£€æŸ¥è·Ÿè¸ªå™¨æ³„æ¼è€Œç‰ºç‰²æ€§èƒ½ï¼Œè¯·ä½¿ç”¨ `jax.check_tracer_leaks()`ï¼‰ã€‚

åœ¨è·Ÿè¸ªæ—¶ï¼ŒJAX é€šè¿‡ *è·Ÿè¸ªå™¨* å¯¹è±¡åŒ…è£…æ¯ä¸ªå‚æ•°ã€‚è¿™äº›è·Ÿè¸ªå™¨è®°å½•äº†åœ¨å‡½æ•°è°ƒç”¨æœŸé—´ï¼ˆå³åœ¨å¸¸è§„ Python ä¸­å‘ç”Ÿï¼‰å¯¹å®ƒä»¬æ‰§è¡Œçš„æ‰€æœ‰ JAX æ“ä½œã€‚ç„¶åï¼ŒJAX ä½¿ç”¨è·Ÿè¸ªå™¨è®°å½•é‡æ„æ•´ä¸ªå‡½æ•°ã€‚é‡æ„çš„è¾“å‡ºæ˜¯ jaxprã€‚ç”±äºè·Ÿè¸ªå™¨ä¸è®°å½• Python çš„å‰¯ä½œç”¨ï¼Œå®ƒä»¬ä¸ä¼šå‡ºç°åœ¨ jaxpr ä¸­ã€‚ä½†æ˜¯ï¼Œå‰¯ä½œç”¨ä»ä¼šåœ¨è·Ÿè¸ªè¿‡ç¨‹ä¸­å‘ç”Ÿã€‚

æ³¨æ„ï¼šPython çš„ `print()` å‡½æ•°ä¸æ˜¯çº¯å‡½æ•°ï¼šæ–‡æœ¬è¾“å‡ºæ˜¯å‡½æ•°çš„å‰¯ä½œç”¨ã€‚å› æ­¤ï¼Œåœ¨è·Ÿè¸ªæœŸé—´ï¼Œä»»ä½• `print()` è°ƒç”¨éƒ½å°†åªå‘ç”Ÿä¸€æ¬¡ï¼Œå¹¶ä¸”ä¸ä¼šå‡ºç°åœ¨ jaxpr ä¸­ï¼š

```py
def log2_with_print(x):
  print("printed x:", x)
  ln_x = jnp.log(x)
  ln_2 = jnp.log(2.0)
  return ln_x / ln_2

print(jax.make_jaxpr(log2_with_print)(3.)) 
```

```py
printed x: Traced<ShapedArray(float32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)>
{ lambda ; a:f32[]. let
    b:f32[] = log a
    c:f32[] = log 2.0
    d:f32[] = div b c
  in (d,) } 
```

çœ‹çœ‹æ‰“å°å‡ºæ¥çš„ `x` æ˜¯ä¸€ä¸ª `Traced` å¯¹è±¡ï¼Ÿè¿™å°±æ˜¯ JAX å†…éƒ¨çš„å·¥ä½œåŸç†ã€‚

Python ä»£ç è‡³å°‘è¿è¡Œä¸€æ¬¡çš„äº‹å®ä¸¥æ ¼æ¥è¯´æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚ï¼Œå› æ­¤ä¸åº”ä¾èµ–å®ƒã€‚ç„¶è€Œï¼Œåœ¨è°ƒè¯•æ—¶ç†è§£å®ƒæ˜¯æœ‰ç”¨çš„ï¼Œå› ä¸ºæ‚¨å¯ä»¥åœ¨è®¡ç®—çš„ä¸­é—´å€¼æ‰“å°å‡ºæ¥ã€‚

ä¸€ä¸ªå…³é”®çš„ç†è§£ç‚¹æ˜¯ï¼Œjaxpr æ•æ‰å‡½æ•°åœ¨ç»™å®šå‚æ•°ä¸Šæ‰§è¡Œçš„æ–¹å¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ª Python æ¡ä»¶è¯­å¥ï¼Œjaxpr åªä¼šäº†è§£æˆ‘ä»¬é€‰æ‹©çš„åˆ†æ”¯ï¼š

```py
def log2_if_rank_2(x):
  if x.ndim == 2:
    ln_x = jnp.log(x)
    ln_2 = jnp.log(2.0)
    return ln_x / ln_2
  else:
    return x

print(jax.make_jaxpr(log2_if_rank_2)(jax.numpy.array([1, 2, 3]))) 
```

```py
{ lambda ; a:i32[3]. let  in (a,) } 
```

## JIT ç¼–è¯‘å‡½æ•°

æ­£å¦‚ä¹‹å‰æ‰€è§£é‡Šçš„ï¼ŒJAX ä½¿å¾—æ“ä½œèƒ½å¤Ÿä½¿ç”¨ç›¸åŒçš„ä»£ç åœ¨ CPU/GPU/TPU ä¸Šæ‰§è¡Œã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªè®¡ç®—*ç¼©æ”¾æŒ‡æ•°çº¿æ€§å•å…ƒ*ï¼ˆ[SELU](https://proceedings.neurips.cc/paper/6698-self-normalizing-neural-networks.pdf)ï¼‰çš„ä¾‹å­ï¼Œè¿™æ˜¯æ·±åº¦å­¦ä¹ ä¸­å¸¸ç”¨çš„æ“ä½œï¼š

```py
import jax
import jax.numpy as jnp

def selu(x, alpha=1.67, lambda_=1.05):
  return lambda_ * jnp.where(x > 0, x, alpha * jnp.exp(x) - alpha)

x = jnp.arange(1000000)
%timeit selu(x).block_until_ready() 
```

```py
2.81 ms Â± 27 Î¼s per loop (mean Â± std. dev. of 7 runs, 100 loops each) 
```

ä¸Šè¿°ä»£ç ä¸€æ¬¡åªå‘é€ä¸€ä¸ªæ“ä½œåˆ°åŠ é€Ÿå™¨ã€‚è¿™é™åˆ¶äº† XLA ç¼–è¯‘å™¨ä¼˜åŒ–æˆ‘ä»¬å‡½æ•°çš„èƒ½åŠ›ã€‚

è‡ªç„¶åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›å°½å¯èƒ½å¤šåœ°å‘ XLA ç¼–è¯‘å™¨æä¾›ä»£ç ï¼Œä»¥ä¾¿å®ƒèƒ½å¤Ÿå®Œå…¨ä¼˜åŒ–å®ƒã€‚ä¸ºæ­¤ï¼ŒJAX æä¾›äº†`jax.jit()`è½¬æ¢ï¼Œå®ƒå°†å³æ—¶ç¼–è¯‘ä¸€ä¸ªä¸ JAX å…¼å®¹çš„å‡½æ•°ã€‚ä¸‹é¢çš„ç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ JIT åŠ é€Ÿå‰è¿°å‡½æ•°ã€‚

```py
selu_jit = jax.jit(selu)

# Pre-compile the function before timing...
selu_jit(x).block_until_ready()

%timeit selu_jit(x).block_until_ready() 
```

```py
1.01 ms Â± 2.6 Î¼s per loop (mean Â± std. dev. of 7 runs, 1,000 loops each) 
```

åˆšåˆšå‘ç”Ÿäº†ä»€ä¹ˆäº‹ï¼š

1.  æˆ‘ä»¬å®šä¹‰äº†`selu_jit`ä½œä¸º`selu`çš„ç¼–è¯‘ç‰ˆæœ¬ã€‚

1.  æˆ‘ä»¬åœ¨`x`ä¸Šè°ƒç”¨äº†`selu_jit`ä¸€æ¬¡ã€‚è¿™æ˜¯ JAX è¿›è¡Œå…¶è¿½è¸ªçš„åœ°æ–¹ - å®ƒéœ€è¦ä¸€äº›è¾“å…¥æ¥åŒ…è£…æˆè¿½è¸ªå™¨ã€‚ç„¶åï¼Œjaxpr ä½¿ç”¨ XLA ç¼–è¯‘æˆéå¸¸é«˜æ•ˆçš„ä»£ç ï¼Œé’ˆå¯¹æ‚¨çš„ GPU æˆ– TPU è¿›è¡Œä¼˜åŒ–ã€‚æœ€åï¼Œç¼–è¯‘çš„ä»£ç è¢«æ‰§è¡Œä»¥æ»¡è¶³è°ƒç”¨ã€‚åç»­å¯¹`selu_jit`çš„è°ƒç”¨å°†ç›´æ¥ä½¿ç”¨ç¼–è¯‘åçš„ä»£ç ï¼Œè·³è¿‡ Python å®ç°ã€‚ï¼ˆå¦‚æœæˆ‘ä»¬æ²¡æœ‰å•ç‹¬åŒ…æ‹¬é¢„çƒ­è°ƒç”¨ï¼Œä¸€åˆ‡ä»å°†æ­£å¸¸è¿è¡Œï¼Œä½†ç¼–è¯‘æ—¶é—´å°†åŒ…å«åœ¨åŸºå‡†æµ‹è¯•ä¸­ã€‚å› ä¸ºæˆ‘ä»¬åœ¨åŸºå‡†æµ‹è¯•ä¸­è¿è¡Œå¤šä¸ªå¾ªç¯ï¼Œæ‰€ä»¥ä»ä¼šæ›´å¿«ï¼Œä½†è¿™ä¸æ˜¯å…¬å¹³çš„æ¯”è¾ƒã€‚ï¼‰

1.  æˆ‘ä»¬è®¡æ—¶äº†ç¼–è¯‘ç‰ˆæœ¬çš„æ‰§è¡Œé€Ÿåº¦ã€‚ï¼ˆæ³¨æ„ä½¿ç”¨`block_until_ready()`ï¼Œè¿™æ˜¯ç”±äº JAX çš„å¼‚æ­¥è°ƒåº¦æ‰€éœ€ã€‚ï¼‰

## ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸èƒ½æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½å³æ—¶ç¼–è¯‘ï¼ˆJITï¼‰å‘¢ï¼Ÿ

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œä½ å¯èƒ½ä¼šæƒ³çŸ¥é“æˆ‘ä»¬æ˜¯å¦åº”è¯¥ç®€å•åœ°å¯¹æ¯ä¸ªå‡½æ•°åº”ç”¨`jax.jit()`ã€‚è¦ç†è§£ä¸ºä»€ä¹ˆä¸æ˜¯è¿™æ ·ï¼Œå¹¶ä¸”ä½•æ—¶éœ€è¦/ä¸éœ€è¦åº”ç”¨`jit`ï¼Œè®©æˆ‘ä»¬é¦–å…ˆæ£€æŸ¥ä¸€äº›`jit`ä¸é€‚ç”¨çš„æƒ…å†µã€‚

```py
# Condition on value of x.

def f(x):
  if x > 0:
    return x
  else:
    return 2 * x

jax.jit(f)(10)  # Raises an error 
```

```py
TracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..
The error occurred while tracing the function f at /tmp/ipykernel_1169/2956679937.py:3 for jit. This concrete value was not available in Python because it depends on the value of the argument x.
See https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError 
```

```py
# While loop conditioned on x and n.

def g(x, n):
  i = 0
  while i < n:
    i += 1
  return x + i

jax.jit(g)(10, 20)  # Raises an error 
```

```py
TracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..
The error occurred while tracing the function g at /tmp/ipykernel_1169/722961019.py:3 for jit. This concrete value was not available in Python because it depends on the value of the argument n.
See https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError 
```

åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å°è¯•ä½¿ç”¨è¿è¡Œæ—¶å€¼æ¥æ¡ä»¶è¿½è¸ªæ—¶é—´æµç¨‹ã€‚åœ¨ JIT ä¸­è¿½è¸ªçš„å€¼ï¼Œä¾‹å¦‚è¿™é‡Œçš„`x`å’Œ`n`ï¼Œåªèƒ½é€šè¿‡å®ƒä»¬çš„é™æ€å±æ€§ï¼ˆå¦‚`shape`æˆ–`dtype`ï¼‰å½±å“æ§åˆ¶æµï¼Œè€Œä¸èƒ½é€šè¿‡å®ƒä»¬çš„å€¼ã€‚æœ‰å…³ Python æ§åˆ¶æµä¸ JAX äº¤äº’çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§[ğŸ”ª JAX - The Sharp Bits ğŸ”ª: Control Flow](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#control-flow)ã€‚

å¤„ç†è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯é‡å†™ä»£ç ï¼Œé¿å…åœ¨å€¼æ¡ä»¶ä¸Šä½¿ç”¨æ¡ä»¶è¯­å¥ã€‚å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ç‰¹æ®Šçš„æ§åˆ¶æµæ“ä½œç¬¦ï¼Œä¾‹å¦‚`jax.lax.cond()`ã€‚ç„¶è€Œï¼Œæœ‰æ—¶è¿™å¹¶ä¸å¯è¡Œæˆ–å®é™…ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥è€ƒè™‘åªå¯¹å‡½æ•°çš„éƒ¨åˆ†è¿›è¡Œ JIT ç¼–è¯‘ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå‡½æ•°ä¸­æœ€æ¶ˆè€—è®¡ç®—èµ„æºçš„éƒ¨åˆ†åœ¨å¾ªç¯å†…éƒ¨ï¼Œæˆ‘ä»¬å¯ä»¥åªå¯¹å†…éƒ¨çš„é‚£éƒ¨åˆ†è¿›è¡Œ JIT ç¼–è¯‘ï¼ˆä½†åŠ¡å¿…æŸ¥çœ‹å…³äºç¼“å­˜çš„ä¸‹ä¸€èŠ‚ï¼Œä»¥é¿å…å‡ºç°é—®é¢˜ï¼‰ï¼š

```py
# While loop conditioned on x and n with a jitted body.

@jax.jit
def loop_body(prev_i):
  return prev_i + 1

def g_inner_jitted(x, n):
  i = 0
  while i < n:
    i = loop_body(i)
  return x + i

g_inner_jitted(10, 20) 
```

```py
Array(30, dtype=int32, weak_type=True) 
```

## å°†å‚æ•°æ ‡è®°ä¸ºé™æ€çš„

å¦‚æœæˆ‘ä»¬ç¡®å®éœ€è¦å¯¹å…·æœ‰è¾“å…¥å€¼æ¡ä»¶çš„å‡½æ•°è¿›è¡Œ JIT ç¼–è¯‘ï¼Œæˆ‘ä»¬å¯ä»¥å‘Šè¯‰ JAX é€šè¿‡æŒ‡å®š`static_argnums`æˆ–`static_argnames`æ¥å¸®åŠ©è‡ªå·±è·å–ç‰¹å®šè¾“å…¥çš„è¾ƒå°‘æŠ½è±¡çš„è¿½è¸ªå™¨ã€‚è¿™æ ·åšçš„æˆæœ¬æ˜¯ç”Ÿæˆçš„ jaxpr å’Œç¼–è¯‘çš„å·¥ä»¶ä¾èµ–äºä¼ é€’çš„ç‰¹å®šå€¼ï¼Œå› æ­¤ JAX å°†ä¸å¾—ä¸é’ˆå¯¹æŒ‡å®šé™æ€è¾“å…¥çš„æ¯ä¸ªæ–°å€¼é‡æ–°ç¼–è¯‘å‡½æ•°ã€‚åªæœ‰åœ¨å‡½æ•°ä¿è¯çœ‹åˆ°æœ‰é™çš„é™æ€å€¼é›†æ—¶ï¼Œè¿™æ‰æ˜¯ä¸€ä¸ªå¥½ç­–ç•¥ã€‚

```py
f_jit_correct = jax.jit(f, static_argnums=0)
print(f_jit_correct(10)) 
```

```py
10 
```

```py
g_jit_correct = jax.jit(g, static_argnames=['n'])
print(g_jit_correct(10, 20)) 
```

```py
30 
```

å½“ä½¿ç”¨`jit`ä½œä¸ºè£…é¥°å™¨æ—¶ï¼Œè¦æŒ‡å®šè¿™äº›å‚æ•°çš„ä¸€ç§å¸¸è§æ¨¡å¼æ˜¯ä½¿ç”¨ Python çš„[`functools.partial()`](https://docs.python.org/3/library/functools.html#functools.partial "(åœ¨ Python v3.12 ä¸­)")ï¼š

```py
from functools import partial

@partial(jax.jit, static_argnames=['n'])
def g_jit_decorated(x, n):
  i = 0
  while i < n:
    i += 1
  return x + i

print(g_jit_decorated(10, 20)) 
```

```py
30 
```

## JIT å’Œç¼“å­˜

é€šè¿‡ç¬¬ä¸€æ¬¡ JIT è°ƒç”¨çš„ç¼–è¯‘å¼€é”€ï¼Œäº†è§£`jax.jit()`å¦‚ä½•ä»¥åŠä½•æ—¶ç¼“å­˜å…ˆå‰çš„ç¼–è¯‘æ˜¯æœ‰æ•ˆä½¿ç”¨å®ƒçš„å…³é”®ã€‚

å‡è®¾æˆ‘ä»¬å®šä¹‰`f = jax.jit(g)`ã€‚å½“æˆ‘ä»¬é¦–æ¬¡è°ƒç”¨`f`æ—¶ï¼Œå®ƒä¼šè¢«ç¼–è¯‘ï¼Œå¹¶ä¸”ç”Ÿæˆçš„ XLA ä»£ç å°†è¢«ç¼“å­˜ã€‚åç»­è°ƒç”¨`f`å°†é‡ç”¨ç¼“å­˜çš„ä»£ç ã€‚è¿™å°±æ˜¯`jax.jit`å¦‚ä½•å¼¥è¡¥ç¼–è¯‘çš„å‰æœŸæˆæœ¬ã€‚

å¦‚æœæˆ‘ä»¬æŒ‡å®šäº†`static_argnums`ï¼Œé‚£ä¹ˆç¼“å­˜çš„ä»£ç å°†ä»…åœ¨æ ‡è®°ä¸ºé™æ€çš„å‚æ•°å€¼ç›¸åŒæ—¶ä½¿ç”¨ã€‚å¦‚æœå®ƒä»¬ä¸­ä»»ä½•ä¸€ä¸ªå‘ç”Ÿæ›´æ”¹ï¼Œå°†é‡æ–°ç¼–è¯‘ã€‚å¦‚æœå­˜åœ¨è®¸å¤šå€¼ï¼Œåˆ™æ‚¨çš„ç¨‹åºå¯èƒ½ä¼šèŠ±è´¹æ›´å¤šæ—¶é—´è¿›è¡Œç¼–è¯‘ï¼Œè€Œä¸æ˜¯é€ä¸ªæ‰§è¡Œæ“ä½œã€‚

é¿å…åœ¨å¾ªç¯æˆ–å…¶ä»– Python ä½œç”¨åŸŸå†…å®šä¹‰çš„ä¸´æ—¶å‡½æ•°ä¸Šè°ƒç”¨`jax.jit()`ã€‚å¯¹äºå¤§å¤šæ•°æƒ…å†µï¼ŒJAX èƒ½å¤Ÿåœ¨åç»­è°ƒç”¨`jax.jit()`æ—¶ä½¿ç”¨ç¼–è¯‘å’Œç¼“å­˜çš„å‡½æ•°ã€‚ç„¶è€Œï¼Œç”±äºç¼“å­˜ä¾èµ–äºå‡½æ•°çš„å“ˆå¸Œå€¼ï¼Œåœ¨é‡æ–°å®šä¹‰ç­‰ä»·å‡½æ•°æ—¶ä¼šå¼•å‘é—®é¢˜ã€‚è¿™å°†å¯¼è‡´æ¯æ¬¡åœ¨å¾ªç¯ä¸­ä¸å¿…è¦åœ°é‡æ–°ç¼–è¯‘ï¼š

```py
from functools import partial

def unjitted_loop_body(prev_i):
  return prev_i + 1

def g_inner_jitted_partial(x, n):
  i = 0
  while i < n:
    # Don't do this! each time the partial returns
    # a function with different hash
    i = jax.jit(partial(unjitted_loop_body))(i)
  return x + i

def g_inner_jitted_lambda(x, n):
  i = 0
  while i < n:
    # Don't do this!, lambda will also return
    # a function with a different hash
    i = jax.jit(lambda x: unjitted_loop_body(x))(i)
  return x + i

def g_inner_jitted_normal(x, n):
  i = 0
  while i < n:
    # this is OK, since JAX can find the
    # cached, compiled function
    i = jax.jit(unjitted_loop_body)(i)
  return x + i

print("jit called in a loop with partials:")
%timeit g_inner_jitted_partial(10, 20).block_until_ready()

print("jit called in a loop with lambdas:")
%timeit g_inner_jitted_lambda(10, 20).block_until_ready()

print("jit called in a loop with caching:")
%timeit g_inner_jitted_normal(10, 20).block_until_ready() 
```

```py
jit called in a loop with partials:
217 ms Â± 2.03 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
jit called in a loop with lambdas:
219 ms Â± 5.44 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
jit called in a loop with caching:
2.33 ms Â± 29.5 Î¼s per loop (mean Â± std. dev. of 7 runs, 100 loops each) 
```
