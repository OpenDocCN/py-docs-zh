# å¿«é€Ÿå…¥é—¨

> åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/quickstart.html`](https://jax.readthedocs.io/en/latest/quickstart.html)

**JAX æ˜¯ä¸€ä¸ªé¢å‘æ•°ç»„çš„æ•°å€¼è®¡ç®—åº“ï¼ˆ*Ã  la* [NumPy](https://numpy.org/)ï¼‰ï¼Œå…·æœ‰è‡ªåŠ¨å¾®åˆ†å’Œ JIT ç¼–è¯‘åŠŸèƒ½ï¼Œä»¥æ”¯æŒé«˜æ€§èƒ½çš„æœºå™¨å­¦ä¹ ç ”ç©¶**ã€‚

æœ¬æ–‡æ¡£æä¾›äº† JAX ä¸»è¦åŠŸèƒ½çš„å¿«é€Ÿæ¦‚è¿°ï¼Œè®©æ‚¨å¯ä»¥å¿«é€Ÿå¼€å§‹ä½¿ç”¨ JAXï¼š

+   JAX æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„ç±»ä¼¼äº NumPy çš„æ¥å£ï¼Œç”¨äºåœ¨ CPUã€GPU æˆ– TPU ä¸Šè¿è¡Œçš„è®¡ç®—ï¼Œåœ¨æœ¬åœ°æˆ–åˆ†å¸ƒå¼è®¾ç½®ä¸­ã€‚

+   JAX é€šè¿‡ [Open XLA](https://github.com/openxla) å†…ç½®äº†å³æ—¶ç¼–è¯‘ï¼ˆJITï¼‰åŠŸèƒ½ï¼Œè¿™æ˜¯ä¸€ä¸ªå¼€æºçš„æœºå™¨å­¦ä¹ ç¼–è¯‘å™¨ç”Ÿæ€ç³»ç»Ÿã€‚

+   JAX å‡½æ•°æ”¯æŒé€šè¿‡å…¶è‡ªåŠ¨å¾®åˆ†è½¬æ¢æœ‰æ•ˆåœ°è¯„ä¼°æ¢¯åº¦ã€‚

+   JAX å‡½æ•°å¯ä»¥è‡ªåŠ¨å‘é‡åŒ–ï¼Œä»¥æœ‰æ•ˆåœ°å°†å®ƒä»¬æ˜ å°„åˆ°è¡¨ç¤ºè¾“å…¥æ‰¹æ¬¡çš„æ•°ç»„ä¸Šã€‚

## å®‰è£…

å¯ä»¥ç›´æ¥ä» [Python Package Index](https://pypi.org/project/jax/) å®‰è£… JAX ç”¨äº Linuxã€Windows å’Œ macOS ä¸Šçš„ CPUï¼š

```py
pip install jax 
```

æˆ–è€…ï¼Œå¯¹äº NVIDIA GPUï¼š

```py
pip install -U "jax[cuda12]" 
```

å¦‚éœ€æ›´è¯¦ç»†çš„ç‰¹å®šå¹³å°å®‰è£…ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹å®‰è£… JAXã€‚

## JAX å°±åƒ NumPy ä¸€æ ·

å¤§å¤šæ•° JAX çš„ä½¿ç”¨æ˜¯é€šè¿‡ç†Ÿæ‚‰çš„ `jax.numpy` API è¿›è¡Œçš„ï¼Œé€šå¸¸åœ¨ `jnp` åˆ«åä¸‹å¯¼å…¥ï¼š

```py
import jax.numpy as jnp 
```

é€šè¿‡è¿™ä¸ªå¯¼å…¥ï¼Œæ‚¨å¯ä»¥ç«‹å³åƒä½¿ç”¨å…¸å‹çš„ NumPy ç¨‹åºä¸€æ ·ä½¿ç”¨ JAXï¼ŒåŒ…æ‹¬ä½¿ç”¨ NumPy é£æ ¼çš„æ•°ç»„åˆ›å»ºå‡½æ•°ã€Python å‡½æ•°å’Œæ“ä½œç¬¦ï¼Œä»¥åŠæ•°ç»„å±æ€§å’Œæ–¹æ³•ï¼š

```py
def selu(x, alpha=1.67, lmbda=1.05):
  return lmbda * jnp.where(x > 0, x, alpha * jnp.exp(x) - alpha)

x = jnp.arange(5.0)
print(selu(x)) 
```

```py
[0\.        1.05      2.1       3.1499999 4.2      ] 
```

ä¸€æ—¦æ‚¨å¼€å§‹æ·±å…¥ç ”ç©¶ï¼Œæ‚¨ä¼šå‘ç° JAX æ•°ç»„å’Œ NumPy æ•°ç»„ä¹‹é—´å­˜åœ¨ä¸€äº›å·®å¼‚ï¼›è¿™äº›å·®å¼‚åœ¨ [ğŸ”ª JAX - The Sharp Bits ğŸ”ª](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html) ä¸­è¿›è¡Œäº†æ¢è®¨ã€‚

## ä½¿ç”¨`jax.jit()`è¿›è¡Œå³æ—¶ç¼–è¯‘

JAX å¯ä»¥åœ¨ GPU æˆ– TPU ä¸Šé€æ˜è¿è¡Œï¼ˆå¦‚æœæ²¡æœ‰ï¼Œåˆ™é€€å›åˆ° CPUï¼‰ã€‚ç„¶è€Œï¼Œåœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼ŒJAX æ˜¯ä¸€æ¬¡å°†æ ¸å¿ƒåˆ†æ´¾åˆ°èŠ¯ç‰‡ä¸Šçš„æ“ä½œã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ç³»åˆ—æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `jax.jit()` å‡½æ•°å°†è¿™äº›æ“ä½œä¸€èµ·ç¼–è¯‘ä¸º XLAã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ IPython çš„ `%timeit` å¿«é€Ÿæµ‹è¯•æˆ‘ä»¬çš„ `selu` å‡½æ•°ï¼Œä½¿ç”¨ `block_until_ready()` æ¥è€ƒè™‘ JAX çš„åŠ¨æ€åˆ†æ´¾ï¼ˆè¯·å‚é˜…å¼‚æ­¥åˆ†æ´¾ï¼‰ï¼š

```py
from jax import random

key = random.key(1701)
x = random.normal(key, (1_000_000,))
%timeit selu(x).block_until_ready() 
```

```py
2.84 ms Â± 9.23 Î¼s per loop (mean Â± std. dev. of 7 runs, 100 loops each) 
```

ï¼ˆè¯·æ³¨æ„ï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨ `jax.random` ç”Ÿæˆäº†ä¸€äº›éšæœºæ•°ï¼›æœ‰å…³å¦‚ä½•åœ¨ JAX ä¸­ç”Ÿæˆéšæœºæ•°çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹ä¼ªéšæœºæ•°ï¼‰ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `jax.jit()` è½¬æ¢æ¥åŠ é€Ÿæ­¤å‡½æ•°çš„æ‰§è¡Œï¼Œè¯¥è½¬æ¢å°†åœ¨é¦–æ¬¡è°ƒç”¨ `selu` æ—¶è¿›è¡Œ JIT ç¼–è¯‘ï¼Œå¹¶åœ¨æ­¤åè¿›è¡Œç¼“å­˜ã€‚

```py
from jax import jit

selu_jit = jit(selu)
_ = selu_jit(x)  # compiles on first call
%timeit selu_jit(x).block_until_ready() 
```

```py
844 Î¼s Â± 2.73 Î¼s per loop (mean Â± std. dev. of 7 runs, 1,000 loops each) 
```

ä¸Šè¿°æ—¶é—´è¡¨ç¤ºåœ¨ CPU ä¸Šæ‰§è¡Œï¼Œä½†åŒæ ·çš„ä»£ç å¯ä»¥åœ¨ GPU æˆ– TPU ä¸Šè¿è¡Œï¼Œé€šå¸¸ä¼šæœ‰æ›´å¤§çš„åŠ é€Ÿæ•ˆæœã€‚

æ¬²äº†è§£æ›´å¤šå…³äº JAX ä¸­ JIT ç¼–è¯‘çš„ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹å³æ—¶ç¼–è¯‘ã€‚

## ä½¿ç”¨ `jax.grad()` è®¡ç®—å¯¼æ•°

é™¤äº†é€šè¿‡ JIT ç¼–è¯‘è½¬æ¢å‡½æ•°å¤–ï¼ŒJAX è¿˜æä¾›å…¶ä»–è½¬æ¢åŠŸèƒ½ã€‚å…¶ä¸­ä¸€ç§è½¬æ¢æ˜¯ `jax.grad()`ï¼Œå®ƒæ‰§è¡Œ[è‡ªåŠ¨å¾®åˆ† (autodiff)](https://en.wikipedia.org/wiki/Automatic_differentiation)ï¼š

```py
from jax import grad

def sum_logistic(x):
  return jnp.sum(1.0 / (1.0 + jnp.exp(-x)))

x_small = jnp.arange(3.)
derivative_fn = grad(sum_logistic)
print(derivative_fn(x_small)) 
```

```py
[0.25       0.19661197 0.10499357] 
```

è®©æˆ‘ä»¬ç”¨æœ‰é™å·®åˆ†æ¥éªŒè¯æˆ‘ä»¬çš„ç»“æœæ˜¯å¦æ­£ç¡®ã€‚

```py
def first_finite_differences(f, x, eps=1E-3):
  return jnp.array([(f(x + eps * v) - f(x - eps * v)) / (2 * eps)
                   for v in jnp.eye(len(x))])

print(first_finite_differences(sum_logistic, x_small)) 
```

```py
[0.24998187 0.1965761  0.10502338] 
```

`grad()` å’Œ `jit()` è½¬æ¢å¯ä»¥ä»»æ„ç»„åˆå¹¶æ··åˆä½¿ç”¨ã€‚åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¯¹ `sum_logistic` è¿›è¡Œäº† JIT ç¼–è¯‘ï¼Œç„¶åå–äº†å®ƒçš„å¯¼æ•°ã€‚æˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥è¿›è¡Œï¼š

```py
print(grad(jit(grad(jit(grad(sum_logistic)))))(1.0)) 
```

```py
-0.0353256 
```

é™¤äº†æ ‡é‡å€¼å‡½æ•°å¤–ï¼Œ`jax.jacobian()` è½¬æ¢è¿˜å¯ç”¨äºè®¡ç®—å‘é‡å€¼å‡½æ•°çš„å®Œæ•´é›…å¯æ¯”çŸ©é˜µï¼š

```py
from jax import jacobian
print(jacobian(jnp.exp)(x_small)) 
```

```py
[[1\.        0\.        0\.       ]
 [0\.        2.7182817 0\.       ]
 [0\.        0\.        7.389056 ]] 
```

å¯¹äºæ›´é«˜çº§çš„è‡ªåŠ¨å¾®åˆ†æ“ä½œï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `jax.vjp()` æ¥è¿›è¡Œåå‘æ¨¡å¼å‘é‡-é›…å¯æ¯”ç§¯åˆ†ï¼Œä»¥åŠä½¿ç”¨ `jax.jvp()` å’Œ `jax.linearize()` è¿›è¡Œæ­£å‘æ¨¡å¼é›…å¯æ¯”-å‘é‡ç§¯åˆ†ã€‚è¿™ä¸¤è€…å¯ä»¥ä»»æ„ç»„åˆï¼Œä¹Ÿå¯ä»¥ä¸å…¶ä»– JAX è½¬æ¢ç»„åˆä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œ`jax.jvp()` å’Œ `jax.vjp()` ç”¨äºå®šä¹‰æ­£å‘æ¨¡å¼ `jax.jacfwd()` å’Œåå‘æ¨¡å¼ `jax.jacrev()`ï¼Œç”¨äºè®¡ç®—æ­£å‘å’Œåå‘æ¨¡å¼ä¸‹çš„é›…å¯æ¯”çŸ©é˜µã€‚ä»¥ä¸‹æ˜¯ç»„åˆå®ƒä»¬ä»¥æœ‰æ•ˆè®¡ç®—å®Œæ•´ Hessian çŸ©é˜µçš„ä¸€ç§æ–¹æ³•ï¼š

```py
from jax import jacfwd, jacrev
def hessian(fun):
  return jit(jacfwd(jacrev(fun)))
print(hessian(sum_logistic)(x_small)) 
```

```py
[[-0\.         -0\.         -0\.        ]
 [-0\.         -0.09085776 -0\.        ]
 [-0\.         -0\.         -0.07996249]] 
```

è¿™ç§ç»„åˆåœ¨å®è·µä¸­äº§ç”Ÿäº†é«˜æ•ˆçš„ä»£ç ï¼›è¿™åŸºæœ¬ä¸Šæ˜¯ JAX å†…ç½®çš„ `jax.hessian()` å‡½æ•°çš„å®ç°æ–¹å¼ã€‚

æƒ³äº†è§£æ›´å¤šå…³äº JAX ä¸­çš„è‡ªåŠ¨å¾®åˆ†ï¼Œè¯·æŸ¥çœ‹è‡ªåŠ¨å¾®åˆ†ã€‚

## ä½¿ç”¨ `jax.vmap()` è¿›è¡Œè‡ªåŠ¨å‘é‡åŒ–

å¦ä¸€ä¸ªæœ‰ç”¨çš„è½¬æ¢æ˜¯ `vmap()`ï¼Œå³å‘é‡åŒ–æ˜ å°„ã€‚å®ƒå…·æœ‰æ²¿æ•°ç»„è½´æ˜ å°„å‡½æ•°çš„ç†Ÿæ‚‰è¯­ä¹‰ï¼Œä½†ä¸æ˜¾å¼å¾ªç¯å‡½æ•°è°ƒç”¨ä¸åŒï¼Œå®ƒå°†å‡½æ•°è½¬æ¢ä¸ºæœ¬åœ°å‘é‡åŒ–ç‰ˆæœ¬ï¼Œä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚ä¸ `jit()` ç»„åˆæ—¶ï¼Œå®ƒå¯ä»¥ä¸æ‰‹åŠ¨é‡å†™å‡½æ•°ä»¥å¤„ç†é¢å¤–æ‰¹å¤„ç†ç»´åº¦çš„æ€§èƒ½ç›¸åª²ç¾ã€‚

æˆ‘ä»¬å°†å¤„ç†ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œå¹¶ä½¿ç”¨ `vmap()` å°†çŸ©é˜µ-å‘é‡ä¹˜æ³•æå‡ä¸ºçŸ©é˜µ-çŸ©é˜µä¹˜æ³•ã€‚è™½ç„¶åœ¨è¿™ç§ç‰¹å®šæƒ…å†µä¸‹æ‰‹åŠ¨å®Œæˆè¿™ä¸€ç‚¹å¾ˆå®¹æ˜“ï¼Œä½†ç›¸åŒçš„æŠ€æœ¯ä¹Ÿé€‚ç”¨äºæ›´å¤æ‚çš„å‡½æ•°ã€‚

```py
key1, key2 = random.split(key)
mat = random.normal(key1, (150, 100))
batched_x = random.normal(key2, (10, 100))

def apply_matrix(x):
  return jnp.dot(mat, x) 
```

`apply_matrix` å‡½æ•°å°†ä¸€ä¸ªå‘é‡æ˜ å°„åˆ°å¦ä¸€ä¸ªå‘é‡ï¼Œä½†æˆ‘ä»¬å¯èƒ½å¸Œæœ›å°†å…¶é€è¡Œåº”ç”¨äºçŸ©é˜µã€‚åœ¨ Python ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¾ªç¯éå†æ‰¹å¤„ç†ç»´åº¦æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œä½†é€šå¸¸å¯¼è‡´æ€§èƒ½ä¸ä½³ã€‚

```py
def naively_batched_apply_matrix(v_batched):
  return jnp.stack([apply_matrix(v) for v in v_batched])

print('Naively batched')
%timeit naively_batched_apply_matrix(batched_x).block_until_ready() 
```

```py
Naively batched
962 Î¼s Â± 1.54 Î¼s per loop (mean Â± std. dev. of 7 runs, 1,000 loops each) 
```

ç†Ÿæ‚‰ `jnp.dot` å‡½æ•°çš„ç¨‹åºå‘˜å¯èƒ½ä¼šæ„è¯†åˆ°ï¼Œå¯ä»¥é‡å†™ `apply_matrix` æ¥é¿å…æ˜¾å¼å¾ªç¯ï¼Œåˆ©ç”¨ `jnp.dot` çš„å†…ç½®æ‰¹å¤„ç†è¯­ä¹‰ï¼š

```py
import numpy as np

@jit
def batched_apply_matrix(batched_x):
  return jnp.dot(batched_x, mat.T)

np.testing.assert_allclose(naively_batched_apply_matrix(batched_x),
                           batched_apply_matrix(batched_x), atol=1E-4, rtol=1E-4)
print('Manually batched')
%timeit batched_apply_matrix(batched_x).block_until_ready() 
```

```py
Manually batched
14.3 Î¼s Â± 28.6 ns per loop (mean Â± std. dev. of 7 runs, 100,000 loops each) 
```

ç„¶è€Œï¼Œéšç€å‡½æ•°å˜å¾—æ›´åŠ å¤æ‚ï¼Œè¿™ç§æ‰‹åŠ¨æ‰¹å¤„ç†å˜å¾—æ›´åŠ å›°éš¾ä¸”å®¹æ˜“å‡ºé”™ã€‚`vmap()` è½¬æ¢æ—¨åœ¨è‡ªåŠ¨å°†å‡½æ•°è½¬æ¢ä¸ºæ”¯æŒæ‰¹å¤„ç†çš„ç‰ˆæœ¬ï¼š

```py
from jax import vmap

@jit
def vmap_batched_apply_matrix(batched_x):
  return vmap(apply_matrix)(batched_x)

np.testing.assert_allclose(naively_batched_apply_matrix(batched_x),
                           vmap_batched_apply_matrix(batched_x), atol=1E-4, rtol=1E-4)
print('Auto-vectorized with vmap')
%timeit vmap_batched_apply_matrix(batched_x).block_until_ready() 
```

```py
Auto-vectorized with vmap
21.7 Î¼s Â± 98.7 ns per loop (mean Â± std. dev. of 7 runs, 10,000 loops each) 
```

æ­£å¦‚æ‚¨æ‰€é¢„æœŸçš„é‚£æ ·ï¼Œ`vmap()` å¯ä»¥ä¸ `jit()`ã€`grad()` å’Œä»»ä½•å…¶ä»– JAX è½¬æ¢ä»»æ„ç»„åˆã€‚

æƒ³äº†è§£æ›´å¤šå…³äº JAX ä¸­çš„è‡ªåŠ¨å‘é‡åŒ–ï¼Œè¯·æŸ¥çœ‹è‡ªåŠ¨å‘é‡åŒ–ã€‚

è¿™åªæ˜¯ JAX èƒ½åšçš„ä¸€å°éƒ¨åˆ†ã€‚æˆ‘ä»¬éå¸¸æœŸå¾…çœ‹åˆ°ä½ ç”¨å®ƒåšäº›ä»€ä¹ˆï¼
