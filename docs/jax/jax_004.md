# ğŸ”ª JAX - é”‹åˆ©çš„éƒ¨åˆ† ğŸ”ª

> åŸæ–‡ï¼š[`jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html`](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html)

![åœ¨ Colab ä¸­æ‰“å¼€](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb) ![åœ¨ Kaggle ä¸­æ‰“å¼€](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)

*levskaya@ mattjj@*

åœ¨æ„å¤§åˆ©ä¹¡é—´æ¼«æ­¥æ—¶ï¼Œäººä»¬ä¼šæ¯«ä¸çŠ¹è±«åœ°å‘Šè¯‰æ‚¨ï¼Œ**JAX** å…·æœ‰ [*â€œuna anima di pura programmazione funzionaleâ€*](https://www.sscardapane.it/iaml-backup/jax-intro/)ã€‚

**JAX** æ˜¯ä¸€ç§ç”¨äºè¡¨è¾¾å’Œç»„åˆæ•°å€¼ç¨‹åºè½¬æ¢çš„è¯­è¨€ã€‚**JAX** è¿˜èƒ½å¤Ÿä¸º CPU æˆ–åŠ é€Ÿå™¨ï¼ˆGPU/TPUï¼‰**ç¼–è¯‘**æ•°å€¼ç¨‹åºã€‚å¯¹äºè®¸å¤šæ•°å€¼å’Œç§‘å­¦ç¨‹åºï¼ŒJAX è¡¨ç°å‡ºè‰²ï¼Œä½†å‰ææ˜¯å®ƒä»¬å¿…é¡»æŒ‰ç…§æˆ‘ä»¬ä¸‹é¢æè¿°çš„æŸäº›çº¦æŸæ¡ä»¶ç¼–å†™ã€‚

```py
import numpy as np
from jax import grad, jit
from jax import lax
from jax import random
import jax
import jax.numpy as jnp 
```

## ğŸ”ª çº¯å‡½æ•°

JAX çš„è½¬æ¢å’Œç¼–è¯‘è®¾è®¡ä»…é€‚ç”¨äºå‡½æ•°å¼çº¯çš„ Python å‡½æ•°ï¼šæ‰€æœ‰è¾“å…¥æ•°æ®é€šè¿‡å‡½æ•°å‚æ•°ä¼ é€’ï¼Œæ‰€æœ‰ç»“æœé€šè¿‡å‡½æ•°ç»“æœè¾“å‡ºã€‚çº¯å‡½æ•°å¦‚æœä»¥ç›¸åŒçš„è¾“å…¥è°ƒç”¨ï¼Œå°†å§‹ç»ˆè¿”å›ç›¸åŒçš„ç»“æœã€‚

ä¸‹é¢æ˜¯ä¸€äº›å‡½æ•°ç¤ºä¾‹ï¼Œè¿™äº›å‡½æ•°ä¸æ˜¯å‡½æ•°å¼çº¯çš„ï¼Œå› æ­¤ JAX çš„è¡Œä¸ºä¸ Python è§£é‡Šå™¨ä¸åŒã€‚è¯·æ³¨æ„ï¼Œè¿™äº›è¡Œä¸ºå¹¶ä¸ç”± JAX ç³»ç»Ÿä¿è¯ï¼›æ­£ç¡®ä½¿ç”¨ JAX çš„æ–¹æ³•æ˜¯ä»…åœ¨å‡½æ•°å¼çº¯ Python å‡½æ•°ä¸Šä½¿ç”¨å®ƒã€‚

```py
def impure_print_side_effect(x):
  print("Executing function")  # This is a side-effect
  return x

# The side-effects appear during the first run
print ("First call: ", jit(impure_print_side_effect)(4.))

# Subsequent runs with parameters of same type and shape may not show the side-effect
# This is because JAX now invokes a cached compilation of the function
print ("Second call: ", jit(impure_print_side_effect)(5.))

# JAX re-runs the Python function when the type or shape of the argument changes
print ("Third call, different type: ", jit(impure_print_side_effect)(jnp.array([5.]))) 
```

```py
Executing function
First call:  4.0
Second call:  5.0
Executing function
Third call, different type:  [5.] 
```

```py
g = 0.
def impure_uses_globals(x):
  return x + g

# JAX captures the value of the global during the first run
print ("First call: ", jit(impure_uses_globals)(4.))
g = 10.  # Update the global

# Subsequent runs may silently use the cached value of the globals
print ("Second call: ", jit(impure_uses_globals)(5.))

# JAX re-runs the Python function when the type or shape of the argument changes
# This will end up reading the latest value of the global
print ("Third call, different type: ", jit(impure_uses_globals)(jnp.array([4.]))) 
```

```py
First call:  4.0
Second call:  5.0
Third call, different type:  [14.] 
```

```py
g = 0.
def impure_saves_global(x):
  global g
  g = x
  return x

# JAX runs once the transformed function with special Traced values for arguments
print ("First call: ", jit(impure_saves_global)(4.))
print ("Saved global: ", g)  # Saved global has an internal JAX value 
```

```py
First call:  4.0
Saved global:  Traced<ShapedArray(float32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)> 
```

å³ä½¿ä¸€ä¸ª Python å‡½æ•°åœ¨å†…éƒ¨å®é™…ä¸Šä½¿ç”¨äº†æœ‰çŠ¶æ€çš„å¯¹è±¡ï¼Œåªè¦å®ƒä¸è¯»å–æˆ–å†™å…¥å¤–éƒ¨çŠ¶æ€ï¼Œå®ƒå°±å¯ä»¥æ˜¯å‡½æ•°å¼çº¯çš„ï¼š

```py
def pure_uses_internal_state(x):
  state = dict(even=0, odd=0)
  for i in range(10):
    state['even' if i % 2 == 0 else 'odd'] += x
  return state['even'] + state['odd']

print(jit(pure_uses_internal_state)(5.)) 
```

```py
50.0 
```

ä¸å»ºè®®åœ¨å¸Œæœ›`jit`çš„ä»»ä½• JAX å‡½æ•°ä¸­ä½¿ç”¨è¿­ä»£å™¨æˆ–ä»»ä½•æ§åˆ¶æµåŸè¯­ã€‚åŸå› æ˜¯è¿­ä»£å™¨æ˜¯ä¸€ä¸ªå¼•å…¥çŠ¶æ€ä»¥æ£€ç´¢ä¸‹ä¸€ä¸ªå…ƒç´ çš„ Python å¯¹è±¡ã€‚å› æ­¤ï¼Œå®ƒä¸ JAX çš„å‡½æ•°å¼ç¼–ç¨‹æ¨¡å‹ä¸å…¼å®¹ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼Œæœ‰ä¸€äº›å°è¯•åœ¨ JAX ä¸­ä½¿ç”¨è¿­ä»£å™¨çš„é”™è¯¯ç¤ºä¾‹ã€‚å…¶ä¸­å¤§å¤šæ•°ä¼šè¿”å›é”™è¯¯ï¼Œä½†æœ‰äº›ä¼šç»™å‡ºæ„å¤–çš„ç»“æœã€‚

```py
import jax.numpy as jnp
import jax.lax as lax
from jax import make_jaxpr

# lax.fori_loop
array = jnp.arange(10)
print(lax.fori_loop(0, 10, lambda i,x: x+array[i], 0)) # expected result 45
iterator = iter(range(10))
print(lax.fori_loop(0, 10, lambda i,x: x+next(iterator), 0)) # unexpected result 0

# lax.scan
def func11(arr, extra):
    ones = jnp.ones(arr.shape)
    def body(carry, aelems):
        ae1, ae2 = aelems
        return (carry + ae1 * ae2 + extra, carry)
    return lax.scan(body, 0., (arr, ones))
make_jaxpr(func11)(jnp.arange(16), 5.)
# make_jaxpr(func11)(iter(range(16)), 5.) # throws error

# lax.cond
array_operand = jnp.array([0.])
lax.cond(True, lambda x: x+1, lambda x: x-1, array_operand)
iter_operand = iter(range(10))
# lax.cond(True, lambda x: next(x)+1, lambda x: next(x)-1, iter_operand) # throws error 
```

```py
45
0 
```

## ğŸ”ª åŸåœ°æ›´æ–°

åœ¨ Numpy ä¸­ï¼Œæ‚¨ä¹ æƒ¯äºæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

```py
numpy_array = np.zeros((3,3), dtype=np.float32)
print("original array:")
print(numpy_array)

# In place, mutating update
numpy_array[1, :] = 1.0
print("updated array:")
print(numpy_array) 
```

```py
original array:
[[0\. 0\. 0.]
 [0\. 0\. 0.]
 [0\. 0\. 0.]]
updated array:
[[0\. 0\. 0.]
 [1\. 1\. 1.]
 [0\. 0\. 0.]] 
```

ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬å°è¯•åœ¨ JAX è®¾å¤‡æ•°ç»„ä¸Šå°±åœ°æ›´æ–°ï¼Œæˆ‘ä»¬ä¼šæ”¶åˆ°**é”™è¯¯**ï¼(â˜‰_â˜‰)

```py
%xmode Minimal 
```

```py
Exception reporting mode: Minimal 
```

```py
jax_array = jnp.zeros((3,3), dtype=jnp.float32)

# In place update of JAX's array will yield an error!
jax_array[1, :] = 1.0 
```

```py
TypeError: '<class 'jaxlib.xla_extension.ArrayImpl'>' object does not support item assignment. JAX arrays are immutable. Instead of ``x[idx] = y``, use ``x = x.at[idx].set(y)`` or another .at[] method: https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html 
```

å…è®¸å˜é‡åœ¨åŸåœ°å˜å¼‚ä¼šä½¿ç¨‹åºåˆ†æå’Œè½¬æ¢å˜å¾—å›°éš¾ã€‚JAX è¦æ±‚ç¨‹åºæ˜¯çº¯å‡½æ•°ã€‚

ç›¸åï¼ŒJAX æä¾›äº†å¯¹ JAX æ•°ç»„ä¸Šçš„ [`.at` å±æ€§è¿›è¡Œå‡½æ•°å¼æ•°ç»„æ›´æ–°](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at)ã€‚

ï¸âš ï¸ åœ¨ `jit` çš„ä»£ç ä¸­å’Œ `lax.while_loop` æˆ– `lax.fori_loop` ä¸­ï¼Œ**åˆ‡ç‰‡çš„å¤§å°**ä¸èƒ½æ˜¯å‚æ•° *å€¼* çš„å‡½æ•°ï¼Œè€Œåªèƒ½æ˜¯å‚æ•° *å½¢çŠ¶* çš„å‡½æ•° â€” åˆ‡ç‰‡çš„èµ·å§‹ç´¢å¼•æ²¡æœ‰æ­¤ç±»é™åˆ¶ã€‚æœ‰å…³æ­¤é™åˆ¶çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸‹é¢çš„ **æ§åˆ¶æµ** éƒ¨åˆ†ã€‚

### æ•°ç»„æ›´æ–°ï¼š`x.at[idx].set(y)`

ä¾‹å¦‚ï¼Œä¸Šè¿°æ›´æ–°å¯ä»¥å†™æˆï¼š

```py
updated_array = jax_array.at[1, :].set(1.0)
print("updated array:\n", updated_array) 
```

```py
updated array:
 [[0\. 0\. 0.]
 [1\. 1\. 1.]
 [0\. 0\. 0.]] 
```

JAX çš„æ•°ç»„æ›´æ–°å‡½æ•°ä¸å…¶ NumPy ç‰ˆæœ¬ä¸åŒï¼Œæ˜¯åœ¨**åŸåœ°**å¤–æ‰§è¡Œçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ›´æ–°åçš„æ•°ç»„ä½œä¸ºæ–°æ•°ç»„è¿”å›ï¼ŒåŸå§‹æ•°ç»„ä¸ä¼šè¢«æ›´æ–°ä¿®æ”¹ã€‚

```py
print("original array unchanged:\n", jax_array) 
```

```py
original array unchanged:
 [[0\. 0\. 0.]
 [0\. 0\. 0.]
 [0\. 0\. 0.]] 
```

ç„¶è€Œï¼Œåœ¨**jit**ç¼–è¯‘çš„ä»£ç å†…éƒ¨ï¼Œå¦‚æœ`x.at[idx].set(y)`çš„**è¾“å…¥å€¼** `x` æ²¡æœ‰è¢«é‡ç”¨ï¼Œç¼–è¯‘å™¨ä¼šä¼˜åŒ–æ•°ç»„æ›´æ–°ä»¥è¿›è¡Œ*åŸåœ°*æ“ä½œã€‚

### ä½¿ç”¨å…¶ä»–æ“ä½œçš„æ•°ç»„æ›´æ–°

ç´¢å¼•æ•°ç»„æ›´æ–°ä¸ä»…é™äºè¦†ç›–å€¼ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œç´¢å¼•åŠ æ³•å¦‚ä¸‹ï¼š

```py
print("original array:")
jax_array = jnp.ones((5, 6))
print(jax_array)

new_jax_array = jax_array.at[::2, 3:].add(7.)
print("new array post-addition:")
print(new_jax_array) 
```

```py
original array:
[[1\. 1\. 1\. 1\. 1\. 1.]
 [1\. 1\. 1\. 1\. 1\. 1.]
 [1\. 1\. 1\. 1\. 1\. 1.]
 [1\. 1\. 1\. 1\. 1\. 1.]
 [1\. 1\. 1\. 1\. 1\. 1.]]
new array post-addition:
[[1\. 1\. 1\. 8\. 8\. 8.]
 [1\. 1\. 1\. 1\. 1\. 1.]
 [1\. 1\. 1\. 8\. 8\. 8.]
 [1\. 1\. 1\. 1\. 1\. 1.]
 [1\. 1\. 1\. 8\. 8\. 8.]] 
```

æœ‰å…³ç´¢å¼•æ•°ç»„æ›´æ–°çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[`.at`å±æ€§çš„æ–‡æ¡£](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at)ã€‚

## ğŸ”ª è¶…å‡ºè¾¹ç•Œç´¢å¼•

åœ¨ NumPy ä¸­ï¼Œå½“æ‚¨ç´¢å¼•æ•°ç»„è¶…å‡ºå…¶è¾¹ç•Œæ—¶ï¼Œé€šå¸¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œä¾‹å¦‚ï¼š

```py
np.arange(10)[11] 
```

```py
IndexError: index 11 is out of bounds for axis 0 with size 10 
```

ç„¶è€Œï¼Œåœ¨åŠ é€Ÿå™¨ä¸Šè¿è¡Œçš„ä»£ç ä¸­å¼•å‘é”™è¯¯å¯èƒ½ä¼šå¾ˆå›°éš¾æˆ–ä¸å¯èƒ½ã€‚å› æ­¤ï¼ŒJAX å¿…é¡»ä¸ºè¶…å‡ºè¾¹ç•Œçš„ç´¢å¼•é€‰æ‹©ä¸€äº›éé”™è¯¯è¡Œä¸ºï¼ˆç±»ä¼¼äºæ— æ•ˆçš„æµ®ç‚¹ç®—æœ¯ç»“æœä¸º`NaN`çš„æƒ…å†µï¼‰ã€‚å½“ç´¢å¼•æ“ä½œæ˜¯æ•°ç»„ç´¢å¼•æ›´æ–°æ—¶ï¼ˆä¾‹å¦‚`index_add`æˆ–ç±»ä¼¼çš„åŸè¯­ï¼‰ï¼Œå°†è·³è¿‡è¶…å‡ºè¾¹ç•Œçš„ç´¢å¼•ï¼›å½“æ“ä½œæ˜¯æ•°ç»„ç´¢å¼•æ£€ç´¢æ—¶ï¼ˆä¾‹å¦‚ NumPy ç´¢å¼•æˆ–ç±»ä¼¼çš„åŸè¯­ï¼‰ï¼Œç´¢å¼•å°†å¤¹ç´§åˆ°æ•°ç»„çš„è¾¹ç•Œï¼Œå› ä¸ºå¿…é¡»è¿”å›**æŸäº›å†…å®¹**ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„çš„æœ€åä¸€ä¸ªå€¼å°†ä»æ­¤ç´¢å¼•æ“ä½œä¸­è¿”å›ï¼š

```py
jnp.arange(10)[11] 
```

```py
Array(9, dtype=int32) 
```

å¦‚æœæ‚¨å¸Œæœ›å¯¹è¶…å‡ºè¾¹ç•Œç´¢å¼•çš„è¡Œä¸ºæœ‰æ›´ç²¾ç»†çš„æ§åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨[`ndarray.at`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html)çš„å¯é€‰å‚æ•°ï¼›ä¾‹å¦‚ï¼š

```py
jnp.arange(10.0).at[11].get() 
```

```py
Array(9., dtype=float32) 
```

```py
jnp.arange(10.0).at[11].get(mode='fill', fill_value=jnp.nan) 
```

```py
Array(nan, dtype=float32) 
```

æ³¨æ„ç”±äºè¿™ç§ç´¢å¼•æ£€ç´¢è¡Œä¸ºï¼Œåƒ`jnp.nanargmin`å’Œ`jnp.nanargmax`è¿™æ ·çš„å‡½æ•°åœ¨ç”± NaN ç»„æˆçš„åˆ‡ç‰‡ä¸­è¿”å›-1ï¼Œè€Œ NumPy ä¼šæŠ›å‡ºé”™è¯¯ã€‚

è¿˜è¯·æ³¨æ„ï¼Œç”±äºä¸Šè¿°ä¸¤ç§è¡Œä¸ºä¸æ˜¯äº’ä¸ºåæ“ä½œï¼Œåå‘æ¨¡å¼è‡ªåŠ¨å¾®åˆ†ï¼ˆå°†ç´¢å¼•æ›´æ–°è½¬æ¢ä¸ºç´¢å¼•æ£€ç´¢åŠå…¶åä¹‹ï¼‰[å°†ä¸ä¼šä¿ç•™è¶…å‡ºè¾¹ç•Œç´¢å¼•çš„è¯­ä¹‰](https://github.com/google/jax/issues/5760)ã€‚å› æ­¤ï¼Œå°† JAX ä¸­çš„è¶…å‡ºè¾¹ç•Œç´¢å¼•è§†ä¸º[æœªå®šä¹‰è¡Œä¸º](https://en.wikipedia.org/wiki/Undefined_behavior)å¯èƒ½æ˜¯ä¸ªå¥½ä¸»æ„ã€‚

## ğŸ”ª éæ•°ç»„è¾“å…¥ï¼šNumPy vs. JAX

NumPy é€šå¸¸å¯ä»¥æ¥å— Python åˆ—è¡¨æˆ–å…ƒç»„ä½œä¸ºå…¶ API å‡½æ•°çš„è¾“å…¥ï¼š

```py
np.sum([1, 2, 3]) 
```

```py
np.int64(6) 
```

JAX åœ¨è¿™æ–¹é¢æœ‰æ‰€ä¸åŒï¼Œé€šå¸¸ä¼šè¿”å›æœ‰ç”¨çš„é”™è¯¯ï¼š

```py
jnp.sum([1, 2, 3]) 
```

```py
TypeError: sum requires ndarray or scalar arguments, got <class 'list'> at position 0. 
```

è¿™æ˜¯ä¸€ä¸ªæœ‰æ„çš„è®¾è®¡é€‰æ‹©ï¼Œå› ä¸ºå‘è¿½è¸ªå‡½æ•°ä¼ é€’åˆ—è¡¨æˆ–å…ƒç»„å¯èƒ½å¯¼è‡´æ€§èƒ½ä¸‹é™ï¼Œè€Œè¿™ç§æ€§èƒ½ä¸‹é™å¯èƒ½å¾ˆéš¾æ£€æµ‹åˆ°ã€‚

ä¾‹å¦‚ï¼Œè¯·è€ƒè™‘å…è®¸åˆ—è¡¨è¾“å…¥çš„`jnp.sum`çš„ä»¥ä¸‹å®½æ¾ç‰ˆæœ¬ï¼š

```py
def permissive_sum(x):
  return jnp.sum(jnp.array(x))

x = list(range(10))
permissive_sum(x) 
```

```py
Array(45, dtype=int32) 
```

è¾“å‡ºä¸é¢„æœŸç›¸ç¬¦ï¼Œä½†è¿™éšè—äº†åº•å±‚çš„æ½œåœ¨æ€§èƒ½é—®é¢˜ã€‚åœ¨ JAX çš„è¿½è¸ªå’Œ JIT ç¼–è¯‘æ¨¡å‹ä¸­ï¼ŒPython åˆ—è¡¨æˆ–å…ƒç»„ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è¢«è§†ä¸ºå•ç‹¬çš„ JAX å˜é‡ï¼Œå¹¶åˆ†åˆ«å¤„ç†å’Œæ¨é€åˆ°è®¾å¤‡ã€‚è¿™å¯ä»¥åœ¨ä¸Šé¢çš„`permissive_sum`å‡½æ•°çš„ jaxpr ä¸­çœ‹åˆ°ï¼š

```py
make_jaxpr(permissive_sum)(x) 
```

```py
{ lambda ; a:i32[] b:i32[] c:i32[] d:i32[] e:i32[] f:i32[] g:i32[] h:i32[] i:i32[]
    j:i32[]. let
    k:i32[] = convert_element_type[new_dtype=int32 weak_type=False] a
    l:i32[] = convert_element_type[new_dtype=int32 weak_type=False] b
    m:i32[] = convert_element_type[new_dtype=int32 weak_type=False] c
    n:i32[] = convert_element_type[new_dtype=int32 weak_type=False] d
    o:i32[] = convert_element_type[new_dtype=int32 weak_type=False] e
    p:i32[] = convert_element_type[new_dtype=int32 weak_type=False] f
    q:i32[] = convert_element_type[new_dtype=int32 weak_type=False] g
    r:i32[] = convert_element_type[new_dtype=int32 weak_type=False] h
    s:i32[] = convert_element_type[new_dtype=int32 weak_type=False] i
    t:i32[] = convert_element_type[new_dtype=int32 weak_type=False] j
    u:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] k
    v:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] l
    w:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] m
    x:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] n
    y:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] o
    z:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] p
    ba:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] q
    bb:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] r
    bc:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] s
    bd:i32[1] = broadcast_in_dim[broadcast_dimensions=() shape=(1,)] t
    be:i32[10] = concatenate[dimension=0] u v w x y z ba bb bc bd
    bf:i32[] = reduce_sum[axes=(0,)] be
  in (bf,) } 
```

åˆ—è¡¨çš„æ¯ä¸ªæ¡ç›®éƒ½ä½œä¸ºå•ç‹¬çš„è¾“å…¥å¤„ç†ï¼Œå¯¼è‡´è¿½è¸ªå’Œç¼–è¯‘å¼€é”€éšåˆ—è¡¨å¤§å°çº¿æ€§å¢é•¿ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„æ„å¤–ï¼ŒJAX é¿å…å°†åˆ—è¡¨å’Œå…ƒç»„éšå¼è½¬æ¢ä¸ºæ•°ç»„ã€‚

å¦‚æœæ‚¨å¸Œæœ›å°†å…ƒç»„æˆ–åˆ—è¡¨ä¼ é€’ç»™ JAX å‡½æ•°ï¼Œå¯ä»¥é¦–å…ˆæ˜¾å¼åœ°å°†å…¶è½¬æ¢ä¸ºæ•°ç»„ï¼š

```py
jnp.sum(jnp.array(x)) 
```

```py
Array(45, dtype=int32) 
```

## ğŸ”ª éšæœºæ•°

> *å¦‚æœæ‰€æœ‰å› ç³Ÿç³•çš„`rand()`è€Œå­˜ç–‘çš„ç§‘å­¦è®ºæ–‡éƒ½ä»å›¾ä¹¦é¦†ä¹¦æ¶ä¸Šæ¶ˆå¤±ï¼Œæ¯ä¸ªä¹¦æ¶ä¸Šä¼šæœ‰ä¸€ä¸ªæ‹³å¤´å¤§å°çš„ç©ºç™½ã€‚* - Numerical Recipes

### RNG å’ŒçŠ¶æ€

æ‚¨ä¹ æƒ¯äºä» numpy å’Œå…¶ä»–åº“ä¸­ä½¿ç”¨*æœ‰çŠ¶æ€çš„*ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ï¼ˆPRNGï¼‰ï¼Œè¿™äº›åº“åœ¨å¹•åå·§å¦™åœ°éšè—äº†è®¸å¤šç»†èŠ‚ï¼Œä¸ºæ‚¨æä¾›äº†ä¼ªéšæœºæ€§çš„ä¸°å¯Œæºæ³‰ï¼š

```py
print(np.random.random())
print(np.random.random())
print(np.random.random()) 
```

```py
0.9818293835329528
0.06574727326903418
0.3930007618911092 
```

åœ¨åº•å±‚ï¼Œnumpy ä½¿ç”¨[Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) PRNG æ¥é©±åŠ¨å…¶ä¼ªéšæœºå‡½æ•°ã€‚è¯¥ PRNG å…·æœ‰\(2^{19937}-1\)çš„å‘¨æœŸï¼Œå¹¶ä¸”åœ¨ä»»ä½•æ—¶å€™å¯ä»¥ç”±**624 ä¸ª 32 ä½æ— ç¬¦å·æ•´æ•°**å’Œä¸€ä¸ªè¡¨ç¤ºå·²ä½¿ç”¨çš„â€œç†µâ€é‡çš„**ä½ç½®**æ¥æè¿°ã€‚

```py
np.random.seed(0)
rng_state = np.random.get_state()
# print(rng_state)
# --> ('MT19937', array([0, 1, 1812433255, 1900727105, 1208447044,
#       2481403966, 4042607538,  337614300, ... 614 more numbers...,
#       3048484911, 1796872496], dtype=uint32), 624, 0, 0.0) 
```

è¿™ä¸ªä¼ªéšæœºçŠ¶æ€å‘é‡åœ¨æ¯æ¬¡éœ€è¦éšæœºæ•°æ—¶éƒ½ä¼šåœ¨å¹•åè‡ªåŠ¨æ›´æ–°ï¼Œâ€œæ¶ˆè€—â€Mersenne Twister çŠ¶æ€å‘é‡ä¸­çš„ 2 ä¸ª uint32ï¼š

```py
_ = np.random.uniform()
rng_state = np.random.get_state()
#print(rng_state)
# --> ('MT19937', array([2443250962, 1093594115, 1878467924,
#       ..., 2648828502, 1678096082], dtype=uint32), 2, 0, 0.0)

# Let's exhaust the entropy in this PRNG statevector
for i in range(311):
  _ = np.random.uniform()
rng_state = np.random.get_state()
#print(rng_state)
# --> ('MT19937', array([2443250962, 1093594115, 1878467924,
#       ..., 2648828502, 1678096082], dtype=uint32), 624, 0, 0.0)

# Next call iterates the RNG state for a new batch of fake "entropy".
_ = np.random.uniform()
rng_state = np.random.get_state()
# print(rng_state)
# --> ('MT19937', array([1499117434, 2949980591, 2242547484,
#      4162027047, 3277342478], dtype=uint32), 2, 0, 0.0) 
```

é­”æ³• PRNG çŠ¶æ€çš„é—®é¢˜åœ¨äºå¾ˆéš¾æ¨æ–­å®ƒåœ¨ä¸åŒçº¿ç¨‹ã€è¿›ç¨‹å’Œè®¾å¤‡ä¸­çš„ä½¿ç”¨å’Œæ›´æ–°æ–¹å¼ï¼Œå¹¶ä¸”åœ¨ç†µçš„ç”Ÿæˆå’Œæ¶ˆè€—ç»†èŠ‚å¯¹æœ€ç»ˆç”¨æˆ·éšè—æ—¶ï¼Œ*éå¸¸å®¹æ˜“*å‡ºé”™ã€‚

Mersenne Twister PRNG ä¹Ÿè¢«è®¤ä¸ºå­˜åœ¨[ä¸€äº›é—®é¢˜](https://cs.stackexchange.com/a/53475)ï¼Œå®ƒå…·æœ‰è¾ƒå¤§çš„ 2.5kB çŠ¶æ€å¤§å°ï¼Œå¯¼è‡´åˆå§‹åŒ–é—®é¢˜[å¾ˆå¤š](https://dl.acm.org/citation.cfm?id=1276928)ã€‚å®ƒåœ¨ç°ä»£çš„ BigCrush æµ‹è¯•ä¸­[å¤±è´¥](http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf)ï¼Œå¹¶ä¸”é€šå¸¸é€Ÿåº¦è¾ƒæ…¢ã€‚

### JAX PRNG

ç›¸åï¼ŒJAX å®ç°äº†ä¸€ä¸ª*æ˜¾å¼çš„*PRNGï¼Œå…¶ä¸­ç†µçš„ç”Ÿæˆå’Œæ¶ˆè€—é€šè¿‡æ˜¾å¼ä¼ é€’å’Œè¿­ä»£ PRNG çŠ¶æ€æ¥å¤„ç†ã€‚JAX ä½¿ç”¨ä¸€ç§ç°ä»£åŒ–çš„[Threefry åŸºäºè®¡æ•°å™¨çš„ PRNG](https://github.com/google/jax/blob/main/docs/jep/263-prng.md)ï¼Œå®ƒæ˜¯**å¯åˆ†è£‚**çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå…¶è®¾è®¡å…è®¸æˆ‘ä»¬å°† PRNG çŠ¶æ€åˆ†å‰æˆæ–°çš„ PRNGï¼Œä»¥ç”¨äºå¹¶è¡Œéšæœºç”Ÿæˆã€‚

éšæœºçŠ¶æ€ç”±ä¸€ä¸ªæˆ‘ä»¬ç§°ä¹‹ä¸º**å¯†é’¥**çš„ç‰¹æ®Šæ•°ç»„å…ƒç´ æè¿°ï¼š

```py
from jax import random
key = random.key(0)
key 
```

```py
Array((), dtype=key<fry>) overlaying:
[0 0] 
```

JAX çš„éšæœºå‡½æ•°ä» PRNG çŠ¶æ€ç”Ÿæˆä¼ªéšæœºæ•°ï¼Œä½†**ä¸ä¼š**æ”¹å˜çŠ¶æ€ï¼

å¤ç”¨ç›¸åŒçš„çŠ¶æ€ä¼šå¯¼è‡´**æ‚²ä¼¤**å’Œ**å•è°ƒ**ï¼Œå‰¥å¤ºæœ€ç»ˆç”¨æˆ·**ç”Ÿå‘½åŠ›çš„æ··ä¹±**ï¼š

```py
print(random.normal(key, shape=(1,)))
print(key)
# No no no!
print(random.normal(key, shape=(1,)))
print(key) 
```

```py
[-0.20584226]
Array((), dtype=key<fry>) overlaying:
[0 0]
[-0.20584226]
Array((), dtype=key<fry>) overlaying:
[0 0] 
```

ç›¸åï¼Œæˆ‘ä»¬**åˆ†å‰²**PRNG ä»¥åœ¨æ¯æ¬¡éœ€è¦æ–°çš„ä¼ªéšæœºæ•°æ—¶è·å¾—å¯ç”¨çš„**å­å¯†é’¥**ï¼š

```py
print("old key", key)
key, subkey = random.split(key)
normal_pseudorandom = random.normal(subkey, shape=(1,))
print("    \---SPLIT --> new key   ", key)
print("             \--> new subkey", subkey, "--> normal", normal_pseudorandom) 
```

```py
old key Array((), dtype=key<fry>) overlaying:
[0 0]
    \---SPLIT --> new key    Array((), dtype=key<fry>) overlaying:
[4146024105  967050713]
             \--> new subkey Array((), dtype=key<fry>) overlaying:
[2718843009 1272950319] --> normal [-1.2515389] 
```

æˆ‘ä»¬ä¼ æ’­**å¯†é’¥**å¹¶åœ¨éœ€è¦æ–°çš„éšæœºæ•°æ—¶ç”Ÿæˆæ–°çš„**å­å¯†é’¥**ï¼š

```py
print("old key", key)
key, subkey = random.split(key)
normal_pseudorandom = random.normal(subkey, shape=(1,))
print("    \---SPLIT --> new key   ", key)
print("             \--> new subkey", subkey, "--> normal", normal_pseudorandom) 
```

```py
old key Array((), dtype=key<fry>) overlaying:
[4146024105  967050713]
    \---SPLIT --> new key    Array((), dtype=key<fry>) overlaying:
[2384771982 3928867769]
             \--> new subkey Array((), dtype=key<fry>) overlaying:
[1278412471 2182328957] --> normal [-0.58665055] 
```

æˆ‘ä»¬å¯ä»¥åŒæ—¶ç”Ÿæˆå¤šä¸ª**å­å¯†é’¥**ï¼š

```py
key, *subkeys = random.split(key, 4)
for subkey in subkeys:
  print(random.normal(subkey, shape=(1,))) 
```

```py
[-0.37533438]
[0.98645043]
[0.14553197] 
```

## ğŸ”ª æ§åˆ¶æµ

### âœ” python æ§åˆ¶æµ + è‡ªåŠ¨å¾®åˆ† âœ”

å¦‚æœæ‚¨åªæƒ³å°†`grad`åº”ç”¨äºæ‚¨çš„ Python å‡½æ•°ï¼Œå¯ä»¥ä½¿ç”¨å¸¸è§„çš„ Python æ§åˆ¶æµç»“æ„ï¼Œæ²¡æœ‰é—®é¢˜ï¼Œå°±åƒä½¿ç”¨[Autograd](https://github.com/hips/autograd)ï¼ˆæˆ– Pytorch æˆ– TF Eagerï¼‰ä¸€æ ·ã€‚

```py
def f(x):
  if x < 3:
    return 3. * x ** 2
  else:
    return -4 * x

print(grad(f)(2.))  # ok!
print(grad(f)(4.))  # ok! 
```

```py
12.0
-4.0 
```

### python æ§åˆ¶æµ + JIT

ä½¿ç”¨`jit`è¿›è¡Œæ§åˆ¶æµæ›´ä¸ºå¤æ‚ï¼Œé»˜è®¤æƒ…å†µä¸‹å…·æœ‰æ›´å¤šçº¦æŸã€‚

è¿™ä¸ªå¯ä»¥å·¥ä½œï¼š

```py
@jit
def f(x):
  for i in range(3):
    x = 2 * x
  return x

print(f(3)) 
```

```py
24 
```

è¿™æ ·ä¹Ÿå¯ä»¥ï¼š

```py
@jit
def g(x):
  y = 0.
  for i in range(x.shape[0]):
    y = y + x[i]
  return y

print(g(jnp.array([1., 2., 3.]))) 
```

```py
6.0 
```

ä½†é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™æ ·ä¸è¡Œï¼š

```py
@jit
def f(x):
  if x < 3:
    return 3. * x ** 2
  else:
    return -4 * x

# This will fail!
f(2) 
```

```py
TracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..
The error occurred while tracing the function f at /tmp/ipykernel_1227/3402096563.py:1 for jit. This concrete value was not available in Python because it depends on the value of the argument x.
See https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError 
```

**æ€ä¹ˆå›äº‹ï¼ï¼Ÿ**

å½“æˆ‘ä»¬`jit`ç¼–è¯‘ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œé€šå¸¸å¸Œæœ›ç¼–è¯‘ä¸€ä¸ªé€‚ç”¨äºè®¸å¤šä¸åŒå‚æ•°å€¼çš„å‡½æ•°ç‰ˆæœ¬ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ç¼“å­˜å’Œé‡å¤ä½¿ç”¨ç¼–è¯‘ä»£ç ã€‚è¿™æ ·æˆ‘ä»¬å°±ä¸å¿…åœ¨æ¯æ¬¡å‡½æ•°è¯„ä¼°æ—¶é‡æ–°ç¼–è¯‘ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åœ¨æ•°ç»„`jnp.array([1., 2., 3.], jnp.float32)`ä¸Šè¯„ä¼°`@jit`å‡½æ•°ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›ç¼–è¯‘ä»£ç ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥é‡å¤ä½¿ç”¨å®ƒæ¥åœ¨`jnp.array([4., 5., 6.], jnp.float32)`ä¸Šè¯„ä¼°å‡½æ•°ï¼Œä»è€ŒèŠ‚çœç¼–è¯‘æ—¶é—´ã€‚

è¦æŸ¥çœ‹é€‚ç”¨äºè®¸å¤šä¸åŒå‚æ•°å€¼çš„ Python ä»£ç è§†å›¾ï¼ŒJAX ä¼šè·Ÿè¸ª*æŠ½è±¡å€¼*ï¼Œè¿™äº›æŠ½è±¡å€¼è¡¨ç¤ºå¯èƒ½è¾“å…¥é›†åˆçš„é›†åˆã€‚æœ‰å…³ä¸åŒçš„è½¬æ¢ä½¿ç”¨ä¸åŒçš„æŠ½è±¡çº§åˆ«ï¼Œè¯¦è§[å¤šä¸ªä¸åŒçš„æŠ½è±¡çº§åˆ«](https://github.com/google/jax/blob/main/jax/_src/abstract_arrays.py)ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`jit`ä¼šåœ¨`ShapedArray`æŠ½è±¡çº§åˆ«ä¸Šè·Ÿè¸ªæ‚¨çš„ä»£ç ï¼Œå…¶ä¸­æ¯ä¸ªæŠ½è±¡å€¼è¡¨ç¤ºå…·æœ‰å›ºå®šå½¢çŠ¶å’Œ dtype çš„æ‰€æœ‰æ•°ç»„å€¼çš„é›†åˆã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨æŠ½è±¡å€¼`ShapedArray((3,), jnp.float32)`è¿›è¡Œè·Ÿè¸ªï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°å¯ä»¥é‡å¤ä½¿ç”¨äºç›¸åº”æ•°ç»„é›†åˆä¸­çš„ä»»ä½•å…·ä½“å€¼çš„å‡½æ•°è§†å›¾ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥èŠ‚çœç¼–è¯‘æ—¶é—´ã€‚

ä½†è¿™é‡Œæœ‰ä¸€ä¸ªæƒè¡¡ï¼šå¦‚æœæˆ‘ä»¬åœ¨`ShapedArray((), jnp.float32)`ä¸Šè·Ÿè¸ª Python å‡½æ•°ï¼Œå®ƒä¸ä¸“æ³¨äºå…·ä½“å€¼ï¼Œå½“æˆ‘ä»¬é‡åˆ°åƒ`if x < 3`è¿™æ ·çš„è¡Œæ—¶ï¼Œè¡¨è¾¾å¼`x < 3`ä¼šè¯„ä¼°ä¸ºè¡¨ç¤ºé›†åˆ`{True, False}`çš„æŠ½è±¡`ShapedArray((), jnp.bool_)`ã€‚å½“ Python å°è¯•å°†å…¶å¼ºåˆ¶è½¬æ¢ä¸ºå…·ä½“çš„`True`æˆ–`False`æ—¶ï¼Œæˆ‘ä»¬ä¼šæ”¶åˆ°é”™è¯¯ï¼šæˆ‘ä»¬ä¸çŸ¥é“åº”è¯¥é€‰æ‹©å“ªä¸ªåˆ†æ”¯ï¼Œæ— æ³•ç»§ç»­è·Ÿè¸ªï¼æƒè¡¡æ˜¯ï¼Œä½¿ç”¨æ›´é«˜çº§åˆ«çš„æŠ½è±¡ï¼Œæˆ‘ä»¬è·å¾— Python ä»£ç çš„æ›´ä¸€èˆ¬è§†å›¾ï¼ˆå› æ­¤èŠ‚çœé‡æ–°ç¼–è¯‘çš„æ—¶é—´ï¼‰ï¼Œä½†æˆ‘ä»¬éœ€è¦æ›´å¤šçº¦æŸæ¥å®Œæˆè·Ÿè¸ªã€‚

å¥½æ¶ˆæ¯æ˜¯ï¼Œæ‚¨å¯ä»¥è‡ªè¡Œæ§åˆ¶è¿™ç§æƒè¡¡ã€‚é€šè¿‡å¯ç”¨`jit`å¯¹æ›´ç²¾ç»†çš„æŠ½è±¡å€¼è¿›è¡Œè·Ÿè¸ªï¼Œæ‚¨å¯ä»¥æ”¾å®½è·Ÿè¸ªçº¦æŸã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨`jit`çš„`static_argnums`å‚æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‡å®šåœ¨æŸäº›å‚æ•°çš„å…·ä½“å€¼ä¸Šè¿›è¡Œè·Ÿè¸ªã€‚ä¸‹é¢æ˜¯è¿™ä¸ªä¾‹å­å‡½æ•°ï¼š

```py
def f(x):
  if x < 3:
    return 3. * x ** 2
  else:
    return -4 * x

f = jit(f, static_argnums=(0,))

print(f(2.)) 
```

```py
12.0 
```

ä¸‹é¢æ˜¯å¦ä¸€ä¸ªä¾‹å­ï¼Œè¿™æ¬¡æ¶‰åŠå¾ªç¯ï¼š

```py
def f(x, n):
  y = 0.
  for i in range(n):
    y = y + x[i]
  return y

f = jit(f, static_argnums=(1,))

f(jnp.array([2., 3., 4.]), 2) 
```

```py
Array(5., dtype=float32) 
```

å®é™…ä¸Šï¼Œå¾ªç¯è¢«é™æ€å±•å¼€ã€‚JAX ä¹Ÿå¯ä»¥åœ¨æ›´é«˜çš„æŠ½è±¡çº§åˆ«è¿›è¡Œè¿½è¸ªï¼Œæ¯”å¦‚ `Unshaped`ï¼Œä½†ç›®å‰å¯¹äºä»»ä½•å˜æ¢æ¥è¯´è¿™éƒ½ä¸æ˜¯é»˜è®¤çš„ã€‚

ï¸âš ï¸ **å…·æœ‰å‚æ•°-å€¼ç›¸å…³å½¢çŠ¶çš„å‡½æ•°**

è¿™äº›æ§åˆ¶æµé—®é¢˜ä¹Ÿä»¥æ›´å¾®å¦™çš„æ–¹å¼å‡ºç°ï¼šæˆ‘ä»¬å¸Œæœ› **jit** çš„æ•°å€¼å‡½æ•°ä¸èƒ½æ ¹æ®å‚æ•° *å€¼* æ¥ç‰¹åŒ–å†…éƒ¨æ•°ç»„çš„å½¢çŠ¶ï¼ˆåœ¨å‚æ•° **å½¢çŠ¶** ä¸Šç‰¹åŒ–æ˜¯å¯ä»¥çš„ï¼‰ã€‚ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå‡½æ•°ï¼Œå…¶è¾“å‡ºæ°å¥½ä¾èµ–äºè¾“å…¥å˜é‡ `length`ã€‚

```py
def example_fun(length, val):
  return jnp.ones((length,)) * val
# un-jit'd works fine
print(example_fun(5, 4)) 
```

```py
[4\. 4\. 4\. 4\. 4.] 
```

```py
bad_example_jit = jit(example_fun)
# this will fail:
bad_example_jit(10, 4) 
```

```py
TypeError: Shapes must be 1D sequences of concrete values of integer type, got (Traced<ShapedArray(int32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)>,).
If using `jit`, try using `static_argnums` or applying `jit` to smaller subfunctions.
The error occurred while tracing the function example_fun at /tmp/ipykernel_1227/1210496444.py:1 for jit. This concrete value was not available in Python because it depends on the value of the argument length. 
```

```py
# static_argnums tells JAX to recompile on changes at these argument positions:
good_example_jit = jit(example_fun, static_argnums=(0,))
# first compile
print(good_example_jit(10, 4))
# recompiles
print(good_example_jit(5, 4)) 
```

```py
[4\. 4\. 4\. 4\. 4\. 4\. 4\. 4\. 4\. 4.]
[4\. 4\. 4\. 4\. 4.] 
```

å¦‚æœåœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­ `length` å¾ˆå°‘æ›´æ”¹ï¼Œé‚£ä¹ˆ `static_argnums` å°±ä¼šå¾ˆæ–¹ä¾¿ï¼Œä½†å¦‚æœå®ƒç»å¸¸æ›´æ”¹ï¼Œé‚£å°†æ˜¯ç¾éš¾æ€§çš„ï¼

æœ€åï¼Œå¦‚æœæ‚¨çš„å‡½æ•°å…·æœ‰å…¨å±€å‰¯ä½œç”¨ï¼ŒJAX çš„è¿½è¸ªå™¨å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›å¥‡æ€ªçš„äº‹æƒ…å‘ç”Ÿã€‚ä¸€ä¸ªå¸¸è§çš„å‘æ˜¯å°è¯•åœ¨ **jit** å‡½æ•°ä¸­æ‰“å°æ•°ç»„ï¼š

```py
@jit
def f(x):
  print(x)
  y = 2 * x
  print(y)
  return y
f(2) 
```

```py
Traced<ShapedArray(int32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)>
Traced<ShapedArray(int32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)> 
```

```py
Array(4, dtype=int32, weak_type=True) 
```

### ç»“æ„åŒ–æ§åˆ¶æµåŸè¯­

JAX ä¸­æœ‰æ›´å¤šæ§åˆ¶æµé€‰é¡¹ã€‚å‡è®¾æ‚¨æƒ³é¿å…é‡æ–°ç¼–è¯‘ä½†ä»æƒ³ä½¿ç”¨å¯è¿½è¸ªçš„æ§åˆ¶æµï¼Œå¹¶é¿å…å±•å¼€å¤§å¾ªç¯ã€‚é‚£ä¹ˆæ‚¨å¯ä»¥ä½¿ç”¨è¿™å››ä¸ªç»“æ„åŒ–çš„æ§åˆ¶æµåŸè¯­ï¼š

+   `lax.cond` *å¯å¾®åˆ†*

+   `lax.while_loop` **å‰å‘æ¨¡å¼å¯å¾®åˆ†**

+   `lax.fori_loop` **å‰å‘æ¨¡å¼å¯å¾®åˆ†**ï¼›å¦‚æœç«¯ç‚¹æ˜¯é™æ€çš„ï¼Œåˆ™**å‰å‘å’Œåå‘æ¨¡å¼å‡å¯å¾®åˆ†**ã€‚

+   `lax.scan` *å¯å¾®åˆ†*

#### `cond`

python ç­‰æ•ˆï¼š

```py
def cond(pred, true_fun, false_fun, operand):
  if pred:
    return true_fun(operand)
  else:
    return false_fun(operand) 
```

```py
from jax import lax

operand = jnp.array([0.])
lax.cond(True, lambda x: x+1, lambda x: x-1, operand)
# --> array([1.], dtype=float32)
lax.cond(False, lambda x: x+1, lambda x: x-1, operand)
# --> array([-1.], dtype=float32) 
```

```py
Array([-1.], dtype=float32) 
```

`jax.lax` è¿˜æä¾›äº†å¦å¤–ä¸¤ä¸ªå‡½æ•°ï¼Œå…è®¸æ ¹æ®åŠ¨æ€è°“è¯è¿›è¡Œåˆ†æ”¯ï¼š

+   [`lax.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.select.html) ç±»ä¼¼äº `lax.cond` çš„æ‰¹å¤„ç†ç‰ˆæœ¬ï¼Œé€‰æ‹©é¡¹è¡¨è¾¾ä¸ºé¢„å…ˆè®¡ç®—çš„æ•°ç»„è€Œä¸æ˜¯å‡½æ•°ã€‚

+   [`lax.switch`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.switch.html) ç±»ä¼¼äº `lax.cond`ï¼Œä½†å…è®¸åœ¨ä»»æ„æ•°é‡çš„å¯è°ƒç”¨é€‰é¡¹ä¹‹é—´è¿›è¡Œåˆ‡æ¢ã€‚

å¦å¤–ï¼Œ`jax.numpy` æä¾›äº†å‡ ä¸ª numpy é£æ ¼çš„æ¥å£ï¼š

+   [`jnp.where`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.where.html) çš„ä¸‰ä¸ªå‚æ•°æ˜¯ `lax.select` çš„ numpy é£æ ¼å°è£…ã€‚

+   [`jnp.piecewise`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.piecewise.html) æ˜¯ `lax.switch` çš„ numpy é£æ ¼å°è£…ï¼Œä½†æ˜¯æ ¹æ®ä¸€ç³»åˆ—å¸ƒå°”æ¡ä»¶è€Œä¸æ˜¯å•ä¸ªæ ‡é‡ç´¢å¼•è¿›è¡Œåˆ‡æ¢ã€‚

+   [`jnp.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.select.html) çš„ API ç±»ä¼¼äº `jnp.piecewise`ï¼Œä½†é€‰æ‹©é¡¹æ˜¯ä½œä¸ºé¢„å…ˆè®¡ç®—çš„æ•°ç»„è€Œä¸æ˜¯å‡½æ•°ç»™å‡ºçš„ã€‚å®ƒæ˜¯åŸºäºå¤šæ¬¡è°ƒç”¨ `lax.select` å®ç°çš„ã€‚

#### `while_loop`

python ç­‰æ•ˆï¼š

```py
def while_loop(cond_fun, body_fun, init_val):
  val = init_val
  while cond_fun(val):
    val = body_fun(val)
  return val 
```

```py
init_val = 0
cond_fun = lambda x: x<10
body_fun = lambda x: x+1
lax.while_loop(cond_fun, body_fun, init_val)
# --> array(10, dtype=int32) 
```

```py
Array(10, dtype=int32, weak_type=True) 
```

#### `fori_loop`

python ç­‰æ•ˆï¼š

```py
def fori_loop(start, stop, body_fun, init_val):
  val = init_val
  for i in range(start, stop):
    val = body_fun(i, val)
  return val 
```

```py
init_val = 0
start = 0
stop = 10
body_fun = lambda i,x: x+i
lax.fori_loop(start, stop, body_fun, init_val)
# --> array(45, dtype=int32) 
```

```py
Array(45, dtype=int32, weak_type=True) 
```

#### æ€»ç»“

\[\begin{split} \begin{array} {r|rr} \hline \ \textrm{æ„é€ } & \textrm{jit} & \textrm{grad} \\ \hline \ \textrm{if} & âŒ & âœ” \\ \textrm{for} & âœ”* & âœ”\\ \textrm{while} & âœ”* & âœ”\\ \textrm{lax.cond} & âœ” & âœ”\\ \textrm{lax.while_loop} & âœ” & \textrm{å‰å‘}\\ \textrm{lax.fori_loop} & âœ” & \textrm{å‰å‘}\\ \textrm{lax.scan} & âœ” & âœ”\\ \hline \end{array} \end{split}\]

\(\ast\) = å‚æ•°-**å€¼**-ç‹¬ç«‹å¾ªç¯æ¡ä»¶ - å±•å¼€å¾ªç¯

## ğŸ”ª åŠ¨æ€å½¢çŠ¶

åœ¨åƒ`jax.jit`ã€`jax.vmap`ã€`jax.grad`ç­‰å˜æ¢ä¸­ä½¿ç”¨çš„ JAX ä»£ç è¦æ±‚æ‰€æœ‰è¾“å‡ºæ•°ç»„å’Œä¸­é—´æ•°ç»„å…·æœ‰é™æ€å½¢çŠ¶ï¼šå³å½¢çŠ¶ä¸èƒ½ä¾èµ–äºå…¶ä»–æ•°ç»„ä¸­çš„å€¼ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æ­£åœ¨å®ç°è‡ªå·±çš„ç‰ˆæœ¬`jnp.nansum`ï¼Œæ‚¨å¯èƒ½ä¼šä»ä»¥ä¸‹å†…å®¹å¼€å§‹ï¼š

```py
def nansum(x):
  mask = ~jnp.isnan(x)  # boolean mask selecting non-nan values
  x_without_nans = x[mask]
  return x_without_nans.sum() 
```

åœ¨ JIT å’Œå…¶ä»–è½¬æ¢ä¹‹å¤–ï¼Œè¿™å¯ä»¥æ­£å¸¸å·¥ä½œï¼š

```py
x = jnp.array([1, 2, jnp.nan, 3, 4])
print(nansum(x)) 
```

```py
10.0 
```

å¦‚æœå°è¯•å°†`jax.jit`æˆ–å¦ä¸€ä¸ªè½¬æ¢åº”ç”¨äºæ­¤å‡½æ•°ï¼Œåˆ™ä¼šæŠ¥é”™ï¼š

```py
jax.jit(nansum)(x) 
```

```py
NonConcreteBooleanIndexError: Array boolean indices must be concrete; got ShapedArray(bool[5])

See https://jax.readthedocs.io/en/latest/errors.html#jax.errors.NonConcreteBooleanIndexError 
```

é—®é¢˜åœ¨äº`x_without_nans`çš„å¤§å°å–å†³äº`x`ä¸­çš„å€¼ï¼Œè¿™å¦ä¸€ç§æ–¹å¼è¯´å®ƒçš„å¤§å°æ˜¯*åŠ¨æ€*çš„ã€‚é€šå¸¸åœ¨ JAX ä¸­ï¼Œå¯ä»¥é€šè¿‡å…¶ä»–æ–¹å¼ç»•è¿‡å¯¹åŠ¨æ€å¤§å°æ•°ç»„çš„éœ€æ±‚ã€‚ä¾‹å¦‚ï¼Œåœ¨è¿™é‡Œå¯ä»¥ä½¿ç”¨`jnp.where`çš„ä¸‰å‚æ•°å½¢å¼ï¼Œå°† NaN å€¼æ›¿æ¢ä¸ºé›¶ï¼Œä»è€Œè®¡ç®—å‡ºç›¸åŒçš„ç»“æœï¼ŒåŒæ—¶é¿å…åŠ¨æ€å½¢çŠ¶ï¼š

```py
@jax.jit
def nansum_2(x):
  mask = ~jnp.isnan(x)  # boolean mask selecting non-nan values
  return jnp.where(mask, x, 0).sum()

print(nansum_2(x)) 
```

```py
10.0 
```

åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œç±»ä¼¼çš„æŠ€å·§å¯ä»¥å‘æŒ¥ä½œç”¨ï¼Œå…¶ä¸­åŠ¨æ€å½¢çŠ¶æ•°ç»„å‡ºç°ã€‚

## ğŸ”ª NaNs

### è°ƒè¯• NaNs

å¦‚æœè¦è¿½è¸ªä½ çš„å‡½æ•°æˆ–æ¢¯åº¦ä¸­å‡ºç° NaN çš„ä½ç½®ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ‰“å¼€ NaN æ£€æŸ¥å™¨ï¼š

+   è®¾ç½®`JAX_DEBUG_NANS=True`ç¯å¢ƒå˜é‡ï¼›

+   åœ¨ä½ çš„ä¸»æ–‡ä»¶é¡¶éƒ¨æ·»åŠ `jax.config.update("jax_debug_nans", True)`ï¼›

+   åœ¨ä½ çš„ä¸»æ–‡ä»¶ä¸­æ·»åŠ `jax.config.parse_flags_with_absl()`ï¼Œç„¶åä½¿ç”¨å‘½ä»¤è¡Œæ ‡å¿—è®¾ç½®é€‰é¡¹ï¼Œå¦‚`--jax_debug_nans=True`ï¼›

è¿™å°†å¯¼è‡´ NaN äº§ç”Ÿæ—¶ç«‹å³ç»ˆæ­¢è®¡ç®—ã€‚æ‰“å¼€æ­¤é€‰é¡¹ä¼šåœ¨ç”± XLA äº§ç”Ÿçš„æ¯ä¸ªæµ®ç‚¹ç±»å‹å€¼ä¸Šæ·»åŠ  NaN æ£€æŸ¥ã€‚è¿™æ„å‘³ç€å¯¹äºä¸åœ¨`@jit`ä¸‹çš„æ¯ä¸ªåŸºå…ƒæ“ä½œï¼Œå€¼å°†è¢«æ‹‰å›ä¸»æœºå¹¶ä½œä¸º ndarrays è¿›è¡Œæ£€æŸ¥ã€‚å¯¹äºåœ¨`@jit`ä¸‹çš„ä»£ç ï¼Œå°†æ£€æŸ¥æ¯ä¸ª`@jit`å‡½æ•°çš„è¾“å‡ºï¼Œå¦‚æœå­˜åœ¨ NaNï¼Œåˆ™å°†ä»¥é€ä¸ªæ“ä½œçš„å»ä¼˜åŒ–æ¨¡å¼é‡æ–°è¿è¡Œå‡½æ•°ï¼Œæœ‰æ•ˆåœ°ä¸€æ¬¡ç§»é™¤ä¸€ä¸ª`@jit`çº§åˆ«ã€‚

å¯èƒ½ä¼šå‡ºç°æ£˜æ‰‹çš„æƒ…å†µï¼Œæ¯”å¦‚åªåœ¨`@jit`ä¸‹å‡ºç°çš„ NaNï¼Œä½†åœ¨å»ä¼˜åŒ–æ¨¡å¼ä¸‹å´ä¸ä¼šäº§ç”Ÿã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ ä¼šçœ‹åˆ°è­¦å‘Šæ¶ˆæ¯æ‰“å°å‡ºæ¥ï¼Œä½†ä½ çš„ä»£ç å°†ç»§ç»­æ‰§è¡Œã€‚

å¦‚æœåœ¨æ¢¯åº¦è¯„ä¼°çš„åå‘ä¼ é€’ä¸­äº§ç”Ÿ NaNsï¼Œå½“åœ¨å †æ ˆè·Ÿè¸ªä¸­å¼•å‘å¼‚å¸¸æ—¶ï¼Œæ‚¨å°†ä½äº backward_pass å‡½æ•°ä¸­ï¼Œè¿™æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç®€å•çš„ jaxpr è§£é‡Šå™¨ï¼Œä»¥åå‘éå†åŸå§‹æ“ä½œåºåˆ—ã€‚åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å‘½ä»¤è¡Œ`env JAX_DEBUG_NANS=True ipython`å¯åŠ¨äº†ä¸€ä¸ª ipython replï¼Œç„¶åè¿è¡Œäº†ä»¥ä¸‹å‘½ä»¤ï¼š

```py
In [1]: import jax.numpy as jnp

In [2]: jnp.divide(0., 0.)
---------------------------------------------------------------------------
FloatingPointError                        Traceback (most recent call last)
<ipython-input-2-f2e2c413b437> in <module>()
----> 1 jnp.divide(0., 0.)

.../jax/jax/numpy/lax_numpy.pyc in divide(x1, x2)
    343     return floor_divide(x1, x2)
    344   else:
--> 345     return true_divide(x1, x2)
    346
    347

.../jax/jax/numpy/lax_numpy.pyc in true_divide(x1, x2)
    332   x1, x2 = _promote_shapes(x1, x2)
    333   return lax.div(lax.convert_element_type(x1, result_dtype),
--> 334                  lax.convert_element_type(x2, result_dtype))
    335
    336

.../jax/jax/lax.pyc in div(x, y)
    244 def div(x, y):
    245   r"""Elementwise division: :math:`x \over y`."""
--> 246   return div_p.bind(x, y)
    247
    248 def rem(x, y):

... stack trace ...

.../jax/jax/interpreters/xla.pyc in handle_result(device_buffer)
    103         py_val = device_buffer.to_py()
    104         if np.any(np.isnan(py_val)):
--> 105           raise FloatingPointError("invalid value")
    106         else:
    107           return Array(device_buffer, *result_shape)

FloatingPointError: invalid value 
```

æ•è·åˆ°ç”Ÿæˆçš„ NaNã€‚é€šè¿‡è¿è¡Œ`%debug`ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—åæœŸè°ƒè¯•å™¨ã€‚æ­£å¦‚ä¸‹é¢çš„ç¤ºä¾‹æ‰€ç¤ºï¼Œè¿™ä¹Ÿé€‚ç”¨äºåœ¨`@jit`ä¸‹çš„å‡½æ•°ã€‚

```py
In [4]: from jax import jit

In [5]: @jit
   ...: def f(x, y):
   ...:     a = x * y
   ...:     b = (x + y) / (x - y)
   ...:     c = a + 2
   ...:     return a + b * c
   ...:

In [6]: x = jnp.array([2., 0.])

In [7]: y = jnp.array([3., 0.])

In [8]: f(x, y)
Invalid value encountered in the output of a jit function. Calling the de-optimized version.
---------------------------------------------------------------------------
FloatingPointError                        Traceback (most recent call last)
<ipython-input-8-811b7ddb3300> in <module>()
----> 1 f(x, y)

 ... stack trace ...

<ipython-input-5-619b39acbaac> in f(x, y)
      2 def f(x, y):
      3     a = x * y
----> 4     b = (x + y) / (x - y)
      5     c = a + 2
      6     return a + b * c

.../jax/jax/numpy/lax_numpy.pyc in divide(x1, x2)
    343     return floor_divide(x1, x2)
    344   else:
--> 345     return true_divide(x1, x2)
    346
    347

.../jax/jax/numpy/lax_numpy.pyc in true_divide(x1, x2)
    332   x1, x2 = _promote_shapes(x1, x2)
    333   return lax.div(lax.convert_element_type(x1, result_dtype),
--> 334                  lax.convert_element_type(x2, result_dtype))
    335
    336

.../jax/jax/lax.pyc in div(x, y)
    244 def div(x, y):
    245   r"""Elementwise division: :math:`x \over y`."""
--> 246   return div_p.bind(x, y)
    247
    248 def rem(x, y):

 ... stack trace ... 
```

å½“æ­¤ä»£ç åœ¨ `@jit` å‡½æ•°çš„è¾“å‡ºä¸­çœ‹åˆ° NaN æ—¶ï¼Œå®ƒè°ƒç”¨å»ä¼˜åŒ–çš„ä»£ç ï¼Œå› æ­¤æˆ‘ä»¬ä»ç„¶å¯ä»¥è·å¾—æ¸…æ™°çš„å †æ ˆè·Ÿè¸ªã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `%debug` è¿è¡Œäº‹åè°ƒè¯•å™¨æ¥æ£€æŸ¥æ‰€æœ‰å€¼ï¼Œä»¥æ‰¾å‡ºé”™è¯¯ã€‚

âš ï¸ å¦‚æœæ‚¨ä¸æ˜¯åœ¨è°ƒè¯•ï¼Œå°±ä¸åº”è¯¥å¼€å¯ NaN æ£€æŸ¥å™¨ï¼Œå› ä¸ºå®ƒå¯èƒ½ä¼šå¯¼è‡´å¤§é‡è®¾å¤‡ä¸»æœºå¾€è¿”å’Œæ€§èƒ½å›å½’ï¼

âš ï¸ NaN æ£€æŸ¥å™¨åœ¨ `pmap` ä¸­ä¸èµ·ä½œç”¨ã€‚è¦è°ƒè¯• `pmap` ä»£ç ä¸­çš„ NaNï¼Œå¯ä»¥å°è¯•ç”¨ `vmap` æ›¿æ¢ `pmap`ã€‚

## ğŸ”ª åŒç²¾åº¦ï¼ˆ64 ä½ï¼‰

ç›®å‰ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼ŒJAX å¼ºåˆ¶ä½¿ç”¨å•ç²¾åº¦æ•°å­—ï¼Œä»¥å‡å°‘ Numpy API å°†æ“ä½œæ•°è¿‡åº¦æå‡ä¸º `double` çš„å€¾å‘ã€‚è¿™æ˜¯è®¸å¤šæœºå™¨å­¦ä¹ åº”ç”¨ç¨‹åºçš„æœŸæœ›è¡Œä¸ºï¼Œä½†å¯èƒ½ä¼šè®©æ‚¨æ„Ÿåˆ°æ„å¤–ï¼

```py
x = random.uniform(random.key(0), (1000,), dtype=jnp.float64)
x.dtype 
```

```py
/tmp/ipykernel_1227/1258726447.py:1: UserWarning: Explicitly requested dtype <class 'jax.numpy.float64'>  is not available, and will be truncated to dtype float32\. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/google/jax#current-gotchas for more.
  x = random.uniform(random.key(0), (1000,), dtype=jnp.float64) 
```

```py
dtype('float32') 
```

è¦ä½¿ç”¨åŒç²¾åº¦æ•°ï¼Œæ‚¨éœ€è¦åœ¨å¯åŠ¨æ—¶è®¾ç½® `jax_enable_x64` é…ç½®å˜é‡**ã€‚

æœ‰å‡ ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š

1.  æ‚¨å¯ä»¥é€šè¿‡è®¾ç½®ç¯å¢ƒå˜é‡ `JAX_ENABLE_X64=True` æ¥å¯ç”¨ 64 ä½æ¨¡å¼ã€‚

1.  æ‚¨å¯ä»¥åœ¨å¯åŠ¨æ—¶æ‰‹åŠ¨è®¾ç½® `jax_enable_x64` é…ç½®æ ‡å¿—ï¼š

    ```py
    # again, this only works on startup!
    import jax
    jax.config.update("jax_enable_x64", True) 
    ```

1.  æ‚¨å¯ä»¥ä½¿ç”¨ `absl.app.run(main)` è§£æå‘½ä»¤è¡Œæ ‡å¿—

    ```py
    import jax
    jax.config.config_with_absl() 
    ```

1.  å¦‚æœæ‚¨å¸Œæœ› JAX ä¸ºæ‚¨è¿è¡Œ absl è§£æï¼Œå³æ‚¨ä¸æƒ³æ‰§è¡Œ `absl.app.run(main)`ï¼Œæ‚¨å¯ä»¥æ”¹ç”¨

    ```py
    import jax
    if __name__ == '__main__':
      # calls jax.config.config_with_absl() *and* runs absl parsing
      jax.config.parse_flags_with_absl() 
    ```

è¯·æ³¨æ„ï¼Œ#2-#4 é€‚ç”¨äº*ä»»ä½•* JAX çš„é…ç½®é€‰é¡¹ã€‚

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ç¡®è®¤å·²å¯ç”¨ `x64` æ¨¡å¼ï¼š

```py
import jax.numpy as jnp
from jax import random
x = random.uniform(random.key(0), (1000,), dtype=jnp.float64)
x.dtype # --> dtype('float64') 
```

```py
/tmp/ipykernel_1227/2819792939.py:3: UserWarning: Explicitly requested dtype <class 'jax.numpy.float64'>  is not available, and will be truncated to dtype float32\. To enable more dtypes, set the jax_enable_x64 configuration option or the JAX_ENABLE_X64 shell environment variable. See https://github.com/google/jax#current-gotchas for more.
  x = random.uniform(random.key(0), (1000,), dtype=jnp.float64) 
```

```py
dtype('float32') 
```

### æ³¨æ„äº‹é¡¹

âš ï¸ XLA ä¸æ”¯æŒæ‰€æœ‰åç«¯çš„ 64 ä½å·ç§¯ï¼

## ğŸ”ª NumPy ä¸­çš„å„ç§åˆ†æ­§

è™½ç„¶ `jax.numpy` å°½åŠ›å¤åˆ¶ numpy API çš„è¡Œä¸ºï¼Œä½†ç¡®å®å­˜åœ¨ä¸€äº›è¾¹ç•Œæƒ…å†µï¼Œå…¶è¡Œä¸ºæœ‰æ‰€ä¸åŒã€‚è®¸å¤šè¿™æ ·çš„æƒ…å†µåœ¨å‰é¢çš„éƒ¨åˆ†ä¸­æœ‰è¯¦ç»†è®¨è®ºï¼›è¿™é‡Œæˆ‘ä»¬åˆ—å‡ºäº†å‡ ä¸ªå·²çŸ¥çš„å…¶ä»– API åˆ†æ­§å¤„ã€‚

+   å¯¹äºäºŒè¿›åˆ¶æ“ä½œï¼ŒJAX çš„ç±»å‹æå‡è§„åˆ™ä¸ NumPy ç•¥æœ‰ä¸åŒã€‚æœ‰å…³æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…[ç±»å‹æå‡è¯­ä¹‰](https://jax.readthedocs.io/en/latest/type_promotion.html)ã€‚

+   åœ¨æ‰§è¡Œä¸å®‰å…¨ç±»å‹è½¬æ¢ï¼ˆå³ç›®æ ‡ dtype ä¸èƒ½è¡¨ç¤ºè¾“å…¥å€¼çš„è½¬æ¢ï¼‰æ—¶ï¼ŒJAX çš„è¡Œä¸ºå¯èƒ½ä¾èµ–äºåç«¯ï¼Œå¹¶ä¸”é€šå¸¸å¯èƒ½ä¸ NumPy çš„è¡Œä¸ºä¸åŒã€‚NumPy å…è®¸é€šè¿‡ `casting` å‚æ•°ï¼ˆå‚è§[`np.ndarray.astype`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html)ï¼‰æ§åˆ¶è¿™äº›æƒ…å†µä¸‹çš„ç»“æœï¼›JAX ä¸æä¾›ä»»ä½•æ­¤ç±»é…ç½®ï¼Œè€Œæ˜¯ç›´æ¥ç»§æ‰¿[XLA:ConvertElementType](https://www.tensorflow.org/xla/operation_semantics#convertelementtype)çš„è¡Œä¸ºã€‚

    è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼Œæ˜¾ç¤ºäº†åœ¨ NumPy å’Œ JAX ä¹‹é—´å­˜åœ¨ä¸åŒç»“æœçš„ä¸å®‰å…¨è½¬æ¢ï¼š

    ```py
    >>> np.arange(254.0, 258.0).astype('uint8')
    array([254, 255,   0,   1], dtype=uint8)

    >>> jnp.arange(254.0, 258.0).astype('uint8')
    Array([254, 255, 255, 255], dtype=uint8) 
    ```

    è¿™ç§ä¸åŒ¹é…é€šå¸¸åœ¨å°†æµ®ç‚¹å€¼è½¬æ¢ä¸ºæ•´æ•°ç±»å‹æˆ–åä¹‹æ—¶å‡ºç°æç«¯æƒ…å†µã€‚

## ç»“æŸã€‚

å¦‚æœè¿™é‡Œæ²¡æœ‰æ¶‰åŠåˆ°æ‚¨æ›¾ç»å› ä¹‹è€Œå“­æ³£å’Œå’¬ç‰™åˆ‡é½¿çš„é—®é¢˜ï¼Œè¯·å‘ŠçŸ¥æˆ‘ä»¬ï¼Œæˆ‘ä»¬å°†æ‰©å±•è¿™äº›ä»‹ç»æ€§*å»ºè®®*ï¼
